
// BUN EXECUTABLE FETCH INTERCEPTOR
// Intercept fetch requests for fonts and serve from extracted location
(function() {
  if (typeof process !== 'undefined' && process.argv && process.argv.some(a => a && a.includes && a.includes('auditaria'))) {
    const originalFetch = globalThis.fetch;
    const path = require('path');
    const fs = require('fs');
    const os = require('os');

    globalThis.fetch = async function(input, init) {
      const url = typeof input === 'string' ? input : (input && input.url ? input.url : String(input));

      // Check if this is a font request from Bun virtual path
      if (url && (url.includes('~BUN') || url.includes('fonts/'))) {
        // Extract font filename
        const fontMatch = url.match(/fonts\/(all|latin)\/([^?\/]+)/);
        if (fontMatch) {
          const fontDir = fontMatch[1];
          const fontFile = fontMatch[2];
          const scribeDir = path.join(os.homedir(), '.auditaria', 'scribe');
          const localFontPath = path.join(scribeDir, 'fonts', fontDir, fontFile);

          if (fs.existsSync(localFontPath)) {
            const data = fs.readFileSync(localFontPath);
            return new Response(data, {
              status: 200,
              headers: { 'Content-Type': 'font/woff' }
            });
          }
        }
      }

      // Check if this is a local file path
      const isWindowsPath = url && url.length > 2 && url.charAt(1) === ':';
      const isFileUrl = url && url.indexOf('file://') === 0;

      if (isWindowsPath || isFileUrl) {
        let localPath = url;
        if (isFileUrl) {
          localPath = url.substring(7);
          if (localPath.charAt(0) === '/' && localPath.charAt(2) === ':') {
            localPath = localPath.substring(1);
          }
        }

        if (fs.existsSync(localPath)) {
          const data = fs.readFileSync(localPath);
          const ext = path.extname(localPath).toLowerCase();
          const mimeTypes = {
            '.woff': 'font/woff',
            '.ttf': 'font/ttf',
            '.wasm': 'application/wasm',
            '.json': 'application/json',
          };
          return new Response(data, {
            status: 200,
            headers: { 'Content-Type': mimeTypes[ext] || 'application/octet-stream' }
          });
        }
      }

      return originalFetch.apply(this, arguments);
    };
  }
})();
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a2, b2) => (typeof require !== "undefined" ? require : a2)[b2]
}) : x2)(function(x2) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/canvaskit-wasm/bin/canvaskit.js
var require_canvaskit = __commonJS({
  "node_modules/canvaskit-wasm/bin/canvaskit.js"(exports2, module) {
    var CanvasKitInit = (() => {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined") _scriptDir = _scriptDir || __filename;
      return function(moduleArg = {}) {
        var w2 = moduleArg, ba, fa;
        w2.ready = new Promise((a2, b2) => {
          ba = a2;
          fa = b2;
        });
        (function(a2) {
          a2.Td = a2.Td || [];
          a2.Td.push(function() {
            a2.MakeSWCanvasSurface = function(b2) {
              var c2 = b2, f2 = "undefined" !== typeof OffscreenCanvas && c2 instanceof OffscreenCanvas;
              if (!("undefined" !== typeof HTMLCanvasElement && c2 instanceof HTMLCanvasElement || f2 || (c2 = document.getElementById(b2), c2))) throw "Canvas with id " + b2 + " was not found";
              if (b2 = a2.MakeSurface(c2.width, c2.height)) b2.Ld = c2;
              return b2;
            };
            a2.MakeCanvasSurface || (a2.MakeCanvasSurface = a2.MakeSWCanvasSurface);
            a2.MakeSurface = function(b2, c2) {
              var f2 = {
                width: b2,
                height: c2,
                colorType: a2.ColorType.RGBA_8888,
                alphaType: a2.AlphaType.Unpremul,
                colorSpace: a2.ColorSpace.SRGB
              }, h2 = b2 * c2 * 4, m2 = a2._malloc(h2);
              if (f2 = a2.Surface._makeRasterDirect(f2, m2, 4 * b2)) f2.Ld = null, f2.Hf = b2, f2.Df = c2, f2.Ff = h2, f2.bf = m2, f2.getCanvas().clear(a2.TRANSPARENT);
              return f2;
            };
            a2.MakeRasterDirectSurface = function(b2, c2, f2) {
              return a2.Surface._makeRasterDirect(b2, c2.byteOffset, f2);
            };
            a2.Surface.prototype.flush = function(b2) {
              a2.Md(this.Kd);
              this._flush();
              if (this.Ld) {
                var c2 = new Uint8ClampedArray(a2.HEAPU8.buffer, this.bf, this.Ff);
                c2 = new ImageData(c2, this.Hf, this.Df);
                b2 ? this.Ld.getContext("2d").putImageData(
                  c2,
                  0,
                  0,
                  b2[0],
                  b2[1],
                  b2[2] - b2[0],
                  b2[3] - b2[1]
                ) : this.Ld.getContext("2d").putImageData(c2, 0, 0);
              }
            };
            a2.Surface.prototype.dispose = function() {
              this.bf && a2._free(this.bf);
              this.delete();
            };
            a2.Md = a2.Md || function() {
            };
            a2.Te = a2.Te || function() {
              return null;
            };
          });
        })(w2);
        (function(a2) {
          a2.Td = a2.Td || [];
          a2.Td.push(function() {
            function b2(n2, p2, v2) {
              return n2 && n2.hasOwnProperty(p2) ? n2[p2] : v2;
            }
            function c2(n2) {
              var p2 = ha(ia);
              ia[p2] = n2;
              return p2;
            }
            function f2(n2) {
              return n2.naturalHeight || n2.videoHeight || n2.displayHeight || n2.height;
            }
            function h2(n2) {
              return n2.naturalWidth || n2.videoWidth || n2.displayWidth || n2.width;
            }
            function m2(n2, p2, v2, E2) {
              n2.bindTexture(n2.TEXTURE_2D, p2);
              E2 || v2.alphaType !== a2.AlphaType.Premul || n2.pixelStorei(n2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
              return p2;
            }
            function u2(n2, p2, v2) {
              v2 || p2.alphaType !== a2.AlphaType.Premul || n2.pixelStorei(n2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
              n2.bindTexture(n2.TEXTURE_2D, null);
            }
            a2.GetWebGLContext = function(n2, p2) {
              if (!n2) throw "null canvas passed into makeWebGLContext";
              var v2 = { alpha: b2(p2, "alpha", 1), depth: b2(p2, "depth", 1), stencil: b2(p2, "stencil", 8), antialias: b2(p2, "antialias", 0), premultipliedAlpha: b2(p2, "premultipliedAlpha", 1), preserveDrawingBuffer: b2(p2, "preserveDrawingBuffer", 0), preferLowPowerToHighPerformance: b2(p2, "preferLowPowerToHighPerformance", 0), failIfMajorPerformanceCaveat: b2(
                p2,
                "failIfMajorPerformanceCaveat",
                0
              ), enableExtensionsByDefault: b2(p2, "enableExtensionsByDefault", 1), explicitSwapControl: b2(p2, "explicitSwapControl", 0), renderViaOffscreenBackBuffer: b2(p2, "renderViaOffscreenBackBuffer", 0) };
              v2.majorVersion = p2 && p2.majorVersion ? p2.majorVersion : "undefined" !== typeof WebGL2RenderingContext ? 2 : 1;
              if (v2.explicitSwapControl) throw "explicitSwapControl is not supported";
              n2 = la(n2, v2);
              if (!n2) return 0;
              oa(n2);
              A2.fe.getExtension("WEBGL_debug_renderer_info");
              return n2;
            };
            a2.deleteContext = function(n2) {
              A2 === pa[n2] && (A2 = null);
              "object" == typeof JSEvents && JSEvents.ug(pa[n2].fe.canvas);
              pa[n2] && pa[n2].fe.canvas && (pa[n2].fe.canvas.zf = void 0);
              pa[n2] = null;
            };
            a2._setTextureCleanup({ deleteTexture: function(n2, p2) {
              var v2 = ia[p2];
              v2 && pa[n2].fe.deleteTexture(v2);
              ia[p2] = null;
            } });
            a2.MakeWebGLContext = function(n2) {
              if (!this.Md(n2)) return null;
              var p2 = this._MakeGrContext();
              if (!p2) return null;
              p2.Kd = n2;
              var v2 = p2.delete.bind(p2);
              p2["delete"] = function() {
                a2.Md(this.Kd);
                v2();
              }.bind(p2);
              return A2.ff = p2;
            };
            a2.MakeGrContext = a2.MakeWebGLContext;
            a2.GrDirectContext.prototype.getResourceCacheLimitBytes = function() {
              a2.Md(this.Kd);
              this._getResourceCacheLimitBytes();
            };
            a2.GrDirectContext.prototype.getResourceCacheUsageBytes = function() {
              a2.Md(this.Kd);
              this._getResourceCacheUsageBytes();
            };
            a2.GrDirectContext.prototype.releaseResourcesAndAbandonContext = function() {
              a2.Md(this.Kd);
              this._releaseResourcesAndAbandonContext();
            };
            a2.GrDirectContext.prototype.setResourceCacheLimitBytes = function(n2) {
              a2.Md(this.Kd);
              this._setResourceCacheLimitBytes(n2);
            };
            a2.MakeOnScreenGLSurface = function(n2, p2, v2, E2, H2, L2) {
              if (!this.Md(n2.Kd)) return null;
              p2 = void 0 === H2 || void 0 === L2 ? this._MakeOnScreenGLSurface(n2, p2, v2, E2) : this._MakeOnScreenGLSurface(n2, p2, v2, E2, H2, L2);
              if (!p2) return null;
              p2.Kd = n2.Kd;
              return p2;
            };
            a2.MakeRenderTarget = function() {
              var n2 = arguments[0];
              if (!this.Md(n2.Kd)) return null;
              if (3 === arguments.length) {
                var p2 = this._MakeRenderTargetWH(n2, arguments[1], arguments[2]);
                if (!p2) return null;
              } else if (2 === arguments.length) {
                if (p2 = this._MakeRenderTargetII(n2, arguments[1]), !p2) return null;
              } else return null;
              p2.Kd = n2.Kd;
              return p2;
            };
            a2.MakeWebGLCanvasSurface = function(n2, p2, v2) {
              p2 = p2 || null;
              var E2 = n2, H2 = "undefined" !== typeof OffscreenCanvas && E2 instanceof OffscreenCanvas;
              if (!("undefined" !== typeof HTMLCanvasElement && E2 instanceof HTMLCanvasElement || H2 || (E2 = document.getElementById(n2), E2))) throw "Canvas with id " + n2 + " was not found";
              n2 = this.GetWebGLContext(E2, v2);
              if (!n2 || 0 > n2) throw "failed to create webgl context: err " + n2;
              n2 = this.MakeWebGLContext(n2);
              p2 = this.MakeOnScreenGLSurface(n2, E2.width, E2.height, p2);
              return p2 ? p2 : (p2 = E2.cloneNode(true), E2.parentNode.replaceChild(p2, E2), p2.classList.add("ck-replaced"), a2.MakeSWCanvasSurface(p2));
            };
            a2.MakeCanvasSurface = a2.MakeWebGLCanvasSurface;
            a2.Surface.prototype.makeImageFromTexture = function(n2, p2) {
              a2.Md(this.Kd);
              n2 = c2(n2);
              if (p2 = this._makeImageFromTexture(this.Kd, n2, p2)) p2.Le = n2;
              return p2;
            };
            a2.Surface.prototype.makeImageFromTextureSource = function(n2, p2, v2) {
              p2 || (p2 = { height: f2(n2), width: h2(n2), colorType: a2.ColorType.RGBA_8888, alphaType: v2 ? a2.AlphaType.Premul : a2.AlphaType.Unpremul });
              p2.colorSpace || (p2.colorSpace = a2.ColorSpace.SRGB);
              a2.Md(this.Kd);
              var E2 = A2.fe;
              v2 = m2(E2, E2.createTexture(), p2, v2);
              2 === A2.version ? E2.texImage2D(
                E2.TEXTURE_2D,
                0,
                E2.RGBA,
                p2.width,
                p2.height,
                0,
                E2.RGBA,
                E2.UNSIGNED_BYTE,
                n2
              ) : E2.texImage2D(E2.TEXTURE_2D, 0, E2.RGBA, E2.RGBA, E2.UNSIGNED_BYTE, n2);
              u2(E2, p2);
              this._resetContext();
              return this.makeImageFromTexture(v2, p2);
            };
            a2.Surface.prototype.updateTextureFromSource = function(n2, p2, v2) {
              if (n2.Le) {
                a2.Md(this.Kd);
                var E2 = n2.getImageInfo(), H2 = A2.fe, L2 = m2(H2, ia[n2.Le], E2, v2);
                2 === A2.version ? H2.texImage2D(H2.TEXTURE_2D, 0, H2.RGBA, h2(p2), f2(p2), 0, H2.RGBA, H2.UNSIGNED_BYTE, p2) : H2.texImage2D(H2.TEXTURE_2D, 0, H2.RGBA, H2.RGBA, H2.UNSIGNED_BYTE, p2);
                u2(H2, E2, v2);
                this._resetContext();
                ia[n2.Le] = null;
                n2.Le = c2(L2);
                E2.colorSpace = n2.getColorSpace();
                p2 = this._makeImageFromTexture(this.Kd, n2.Le, E2);
                v2 = n2.Jd.Rd;
                H2 = n2.Jd.Yd;
                n2.Jd.Rd = p2.Jd.Rd;
                n2.Jd.Yd = p2.Jd.Yd;
                p2.Jd.Rd = v2;
                p2.Jd.Yd = H2;
                p2.delete();
                E2.colorSpace.delete();
              }
            };
            a2.MakeLazyImageFromTextureSource = function(n2, p2, v2) {
              p2 || (p2 = { height: f2(n2), width: h2(n2), colorType: a2.ColorType.RGBA_8888, alphaType: v2 ? a2.AlphaType.Premul : a2.AlphaType.Unpremul });
              p2.colorSpace || (p2.colorSpace = a2.ColorSpace.SRGB);
              var E2 = { makeTexture: function() {
                var H2 = A2, L2 = H2.fe, y2 = m2(L2, L2.createTexture(), p2, v2);
                2 === H2.version ? L2.texImage2D(
                  L2.TEXTURE_2D,
                  0,
                  L2.RGBA,
                  p2.width,
                  p2.height,
                  0,
                  L2.RGBA,
                  L2.UNSIGNED_BYTE,
                  n2
                ) : L2.texImage2D(L2.TEXTURE_2D, 0, L2.RGBA, L2.RGBA, L2.UNSIGNED_BYTE, n2);
                u2(L2, p2, v2);
                return c2(y2);
              }, freeSrc: function() {
              } };
              "VideoFrame" === n2.constructor.name && (E2.freeSrc = function() {
                n2.close();
              });
              return a2.Image._makeFromGenerator(p2, E2);
            };
            a2.Md = function(n2) {
              return n2 ? oa(n2) : false;
            };
            a2.Te = function() {
              return A2 && A2.ff && !A2.ff.isDeleted() ? A2.ff : null;
            };
          });
        })(w2);
        (function(a2) {
          function b2(e2, d2, g2, l2, t2) {
            for (var x2 = 0; x2 < e2.length; x2++) d2[x2 * g2 + (x2 * t2 + l2 + g2) % g2] = e2[x2];
            return d2;
          }
          function c2(e2) {
            for (var d2 = e2 * e2, g2 = Array(d2); d2--; ) g2[d2] = 0 === d2 % (e2 + 1) ? 1 : 0;
            return g2;
          }
          function f2(e2) {
            return e2 ? e2.constructor === Float32Array && 4 === e2.length : false;
          }
          function h2(e2) {
            return (n2(255 * e2[3]) << 24 | n2(255 * e2[0]) << 16 | n2(255 * e2[1]) << 8 | n2(255 * e2[2]) << 0) >>> 0;
          }
          function m2(e2) {
            if (e2 && e2._ck) return e2;
            if (e2 instanceof Float32Array) {
              for (var d2 = Math.floor(e2.length / 4), g2 = new Uint32Array(d2), l2 = 0; l2 < d2; l2++) g2[l2] = h2(e2.slice(4 * l2, 4 * (l2 + 1)));
              return g2;
            }
            if (e2 instanceof Uint32Array) return e2;
            if (e2 instanceof Array && e2[0] instanceof Float32Array) return e2.map(h2);
          }
          function u2(e2) {
            if (void 0 === e2) return 1;
            var d2 = parseFloat(e2);
            return e2 && -1 !== e2.indexOf("%") ? d2 / 100 : d2;
          }
          function n2(e2) {
            return Math.round(Math.max(0, Math.min(e2 || 0, 255)));
          }
          function p2(e2, d2) {
            d2 && d2._ck || a2._free(e2);
          }
          function v2(e2, d2, g2) {
            if (!e2 || !e2.length) return W2;
            if (e2 && e2._ck) return e2.byteOffset;
            var l2 = a2[d2].BYTES_PER_ELEMENT;
            g2 || (g2 = a2._malloc(e2.length * l2));
            a2[d2].set(e2, g2 / l2);
            return g2;
          }
          function E2(e2) {
            var d2 = { be: W2, count: e2.length, colorType: a2.ColorType.RGBA_F32 };
            if (e2 instanceof Float32Array) d2.be = v2(e2, "HEAPF32"), d2.count = e2.length / 4;
            else if (e2 instanceof Uint32Array) d2.be = v2(e2, "HEAPU32"), d2.colorType = a2.ColorType.RGBA_8888;
            else if (e2 instanceof Array) {
              if (e2 && e2.length) {
                for (var g2 = a2._malloc(16 * e2.length), l2 = 0, t2 = g2 / 4, x2 = 0; x2 < e2.length; x2++) for (var C2 = 0; 4 > C2; C2++) a2.HEAPF32[t2 + l2] = e2[x2][C2], l2++;
                e2 = g2;
              } else e2 = W2;
              d2.be = e2;
            } else throw "Invalid argument to copyFlexibleColorArray, Not a color array " + typeof e2;
            return d2;
          }
          function H2(e2) {
            if (!e2) return W2;
            var d2 = Vb.toTypedArray();
            if (e2.length) {
              if (6 === e2.length || 9 === e2.length) return v2(e2, "HEAPF32", Na), 6 === e2.length && a2.HEAPF32.set(wd, 6 + Na / 4), Na;
              if (16 === e2.length) return d2[0] = e2[0], d2[1] = e2[1], d2[2] = e2[3], d2[3] = e2[4], d2[4] = e2[5], d2[5] = e2[7], d2[6] = e2[12], d2[7] = e2[13], d2[8] = e2[15], Na;
              throw "invalid matrix size";
            }
            if (void 0 === e2.m11) throw "invalid matrix argument";
            d2[0] = e2.m11;
            d2[1] = e2.m21;
            d2[2] = e2.m41;
            d2[3] = e2.m12;
            d2[4] = e2.m22;
            d2[5] = e2.m42;
            d2[6] = e2.m14;
            d2[7] = e2.m24;
            d2[8] = e2.m44;
            return Na;
          }
          function L2(e2) {
            if (!e2) return W2;
            var d2 = Wb.toTypedArray();
            if (e2.length) {
              if (16 !== e2.length && 6 !== e2.length && 9 !== e2.length) throw "invalid matrix size";
              if (16 === e2.length) return v2(e2, "HEAPF32", $a);
              d2.fill(0);
              d2[0] = e2[0];
              d2[1] = e2[1];
              d2[3] = e2[2];
              d2[4] = e2[3];
              d2[5] = e2[4];
              d2[7] = e2[5];
              d2[10] = 1;
              d2[12] = e2[6];
              d2[13] = e2[7];
              d2[15] = e2[8];
              6 === e2.length && (d2[12] = 0, d2[13] = 0, d2[15] = 1);
              return $a;
            }
            if (void 0 === e2.m11) throw "invalid matrix argument";
            d2[0] = e2.m11;
            d2[1] = e2.m21;
            d2[2] = e2.m31;
            d2[3] = e2.m41;
            d2[4] = e2.m12;
            d2[5] = e2.m22;
            d2[6] = e2.m32;
            d2[7] = e2.m42;
            d2[8] = e2.m13;
            d2[9] = e2.m23;
            d2[10] = e2.m33;
            d2[11] = e2.m43;
            d2[12] = e2.m14;
            d2[13] = e2.m24;
            d2[14] = e2.m34;
            d2[15] = e2.m44;
            return $a;
          }
          function y2(e2, d2) {
            return v2(e2, "HEAPF32", d2 || Ta);
          }
          function N2(e2, d2, g2, l2) {
            var t2 = Xb.toTypedArray();
            t2[0] = e2;
            t2[1] = d2;
            t2[2] = g2;
            t2[3] = l2;
            return Ta;
          }
          function T2(e2) {
            for (var d2 = new Float32Array(4), g2 = 0; 4 > g2; g2++) d2[g2] = a2.HEAPF32[e2 / 4 + g2];
            return d2;
          }
          function S2(e2, d2) {
            return v2(e2, "HEAPF32", d2 || ja);
          }
          function sa(e2, d2) {
            return v2(e2, "HEAPF32", d2 || Yb);
          }
          function ma() {
            for (var e2 = 0, d2 = 0; d2 < arguments.length - 1; d2 += 2) e2 += arguments[d2] * arguments[d2 + 1];
            return e2;
          }
          function gb(e2, d2, g2) {
            for (var l2 = Array(e2.length), t2 = 0; t2 < g2; t2++) for (var x2 = 0; x2 < g2; x2++) {
              for (var C2 = 0, J2 = 0; J2 < g2; J2++) C2 += e2[g2 * t2 + J2] * d2[g2 * J2 + x2];
              l2[t2 * g2 + x2] = C2;
            }
            return l2;
          }
          function hb(e2, d2) {
            for (var g2 = gb(d2[0], d2[1], e2), l2 = 2; l2 < d2.length; ) g2 = gb(g2, d2[l2], e2), l2++;
            return g2;
          }
          a2.Color = function(e2, d2, g2, l2) {
            void 0 === l2 && (l2 = 1);
            return a2.Color4f(n2(e2) / 255, n2(d2) / 255, n2(g2) / 255, l2);
          };
          a2.ColorAsInt = function(e2, d2, g2, l2) {
            void 0 === l2 && (l2 = 255);
            return (n2(l2) << 24 | n2(e2) << 16 | n2(d2) << 8 | n2(g2) << 0 & 268435455) >>> 0;
          };
          a2.Color4f = function(e2, d2, g2, l2) {
            void 0 === l2 && (l2 = 1);
            return Float32Array.of(e2, d2, g2, l2);
          };
          Object.defineProperty(a2, "TRANSPARENT", { get: function() {
            return a2.Color4f(0, 0, 0, 0);
          } });
          Object.defineProperty(a2, "BLACK", { get: function() {
            return a2.Color4f(0, 0, 0, 1);
          } });
          Object.defineProperty(
            a2,
            "WHITE",
            { get: function() {
              return a2.Color4f(1, 1, 1, 1);
            } }
          );
          Object.defineProperty(a2, "RED", { get: function() {
            return a2.Color4f(1, 0, 0, 1);
          } });
          Object.defineProperty(a2, "GREEN", { get: function() {
            return a2.Color4f(0, 1, 0, 1);
          } });
          Object.defineProperty(a2, "BLUE", { get: function() {
            return a2.Color4f(0, 0, 1, 1);
          } });
          Object.defineProperty(a2, "YELLOW", { get: function() {
            return a2.Color4f(1, 1, 0, 1);
          } });
          Object.defineProperty(a2, "CYAN", { get: function() {
            return a2.Color4f(0, 1, 1, 1);
          } });
          Object.defineProperty(a2, "MAGENTA", { get: function() {
            return a2.Color4f(
              1,
              0,
              1,
              1
            );
          } });
          a2.getColorComponents = function(e2) {
            return [Math.floor(255 * e2[0]), Math.floor(255 * e2[1]), Math.floor(255 * e2[2]), e2[3]];
          };
          a2.parseColorString = function(e2, d2) {
            e2 = e2.toLowerCase();
            if (e2.startsWith("#")) {
              d2 = 255;
              switch (e2.length) {
                case 9:
                  d2 = parseInt(e2.slice(7, 9), 16);
                case 7:
                  var g2 = parseInt(e2.slice(1, 3), 16);
                  var l2 = parseInt(e2.slice(3, 5), 16);
                  var t2 = parseInt(e2.slice(5, 7), 16);
                  break;
                case 5:
                  d2 = 17 * parseInt(e2.slice(4, 5), 16);
                case 4:
                  g2 = 17 * parseInt(e2.slice(1, 2), 16), l2 = 17 * parseInt(e2.slice(2, 3), 16), t2 = 17 * parseInt(e2.slice(3, 4), 16);
              }
              return a2.Color(
                g2,
                l2,
                t2,
                d2 / 255
              );
            }
            return e2.startsWith("rgba") ? (e2 = e2.slice(5, -1), e2 = e2.split(","), a2.Color(+e2[0], +e2[1], +e2[2], u2(e2[3]))) : e2.startsWith("rgb") ? (e2 = e2.slice(4, -1), e2 = e2.split(","), a2.Color(+e2[0], +e2[1], +e2[2], u2(e2[3]))) : e2.startsWith("gray(") || e2.startsWith("hsl") || !d2 || (e2 = d2[e2], void 0 === e2) ? a2.BLACK : e2;
          };
          a2.multiplyByAlpha = function(e2, d2) {
            e2 = e2.slice();
            e2[3] = Math.max(0, Math.min(e2[3] * d2, 1));
            return e2;
          };
          a2.Malloc = function(e2, d2) {
            var g2 = a2._malloc(d2 * e2.BYTES_PER_ELEMENT);
            return { _ck: true, length: d2, byteOffset: g2, qe: null, subarray: function(l2, t2) {
              l2 = this.toTypedArray().subarray(
                l2,
                t2
              );
              l2._ck = true;
              return l2;
            }, toTypedArray: function() {
              if (this.qe && this.qe.length) return this.qe;
              this.qe = new e2(a2.HEAPU8.buffer, g2, d2);
              this.qe._ck = true;
              return this.qe;
            } };
          };
          a2.Free = function(e2) {
            a2._free(e2.byteOffset);
            e2.byteOffset = W2;
            e2.toTypedArray = null;
            e2.qe = null;
          };
          var Na = W2, Vb, $a = W2, Wb, Ta = W2, Xb, Ba, ja = W2, xc, Oa = W2, yc, Zb = W2, zc, $b = W2, yb, ib = W2, Ac, Yb = W2, Bc, Cc = W2, wd = Float32Array.of(0, 0, 1), W2 = 0;
          a2.onRuntimeInitialized = function() {
            function e2(d2, g2, l2, t2, x2, C2, J2) {
              C2 || (C2 = 4 * t2.width, t2.colorType === a2.ColorType.RGBA_F16 ? C2 *= 2 : t2.colorType === a2.ColorType.RGBA_F32 && (C2 *= 4));
              var P2 = C2 * t2.height;
              var O2 = x2 ? x2.byteOffset : a2._malloc(P2);
              if (J2 ? !d2._readPixels(t2, O2, C2, g2, l2, J2) : !d2._readPixels(t2, O2, C2, g2, l2)) return x2 || a2._free(O2), null;
              if (x2) return x2.toTypedArray();
              switch (t2.colorType) {
                case a2.ColorType.RGBA_8888:
                case a2.ColorType.RGBA_F16:
                  d2 = new Uint8Array(a2.HEAPU8.buffer, O2, P2).slice();
                  break;
                case a2.ColorType.RGBA_F32:
                  d2 = new Float32Array(a2.HEAPU8.buffer, O2, P2).slice();
                  break;
                default:
                  return null;
              }
              a2._free(O2);
              return d2;
            }
            Xb = a2.Malloc(Float32Array, 4);
            Ta = Xb.byteOffset;
            Wb = a2.Malloc(Float32Array, 16);
            $a = Wb.byteOffset;
            Vb = a2.Malloc(Float32Array, 9);
            Na = Vb.byteOffset;
            Ac = a2.Malloc(Float32Array, 12);
            Yb = Ac.byteOffset;
            Bc = a2.Malloc(Float32Array, 12);
            Cc = Bc.byteOffset;
            Ba = a2.Malloc(Float32Array, 4);
            ja = Ba.byteOffset;
            xc = a2.Malloc(Float32Array, 4);
            Oa = xc.byteOffset;
            yc = a2.Malloc(Float32Array, 3);
            Zb = yc.byteOffset;
            zc = a2.Malloc(Float32Array, 3);
            $b = zc.byteOffset;
            yb = a2.Malloc(Int32Array, 4);
            ib = yb.byteOffset;
            a2.ColorSpace.SRGB = a2.ColorSpace._MakeSRGB();
            a2.ColorSpace.DISPLAY_P3 = a2.ColorSpace._MakeDisplayP3();
            a2.ColorSpace.ADOBE_RGB = a2.ColorSpace._MakeAdobeRGB();
            a2.GlyphRunFlags = { IsWhiteSpace: a2._GlyphRunFlags_isWhiteSpace };
            a2.Path.MakeFromCmds = function(d2) {
              var g2 = v2(d2, "HEAPF32"), l2 = a2.Path._MakeFromCmds(g2, d2.length);
              p2(g2, d2);
              return l2;
            };
            a2.Path.MakeFromVerbsPointsWeights = function(d2, g2, l2) {
              var t2 = v2(d2, "HEAPU8"), x2 = v2(g2, "HEAPF32"), C2 = v2(l2, "HEAPF32"), J2 = a2.Path._MakeFromVerbsPointsWeights(t2, d2.length, x2, g2.length, C2, l2 && l2.length || 0);
              p2(t2, d2);
              p2(x2, g2);
              p2(C2, l2);
              return J2;
            };
            a2.Path.prototype.addArc = function(d2, g2, l2) {
              d2 = S2(d2);
              this._addArc(d2, g2, l2);
              return this;
            };
            a2.Path.prototype.addCircle = function(d2, g2, l2, t2) {
              this._addCircle(
                d2,
                g2,
                l2,
                !!t2
              );
              return this;
            };
            a2.Path.prototype.addOval = function(d2, g2, l2) {
              void 0 === l2 && (l2 = 1);
              d2 = S2(d2);
              this._addOval(d2, !!g2, l2);
              return this;
            };
            a2.Path.prototype.addPath = function() {
              var d2 = Array.prototype.slice.call(arguments), g2 = d2[0], l2 = false;
              "boolean" === typeof d2[d2.length - 1] && (l2 = d2.pop());
              if (1 === d2.length) this._addPath(g2, 1, 0, 0, 0, 1, 0, 0, 0, 1, l2);
              else if (2 === d2.length) d2 = d2[1], this._addPath(g2, d2[0], d2[1], d2[2], d2[3], d2[4], d2[5], d2[6] || 0, d2[7] || 0, d2[8] || 1, l2);
              else if (7 === d2.length || 10 === d2.length) this._addPath(g2, d2[1], d2[2], d2[3], d2[4], d2[5], d2[6], d2[7] || 0, d2[8] || 0, d2[9] || 1, l2);
              else return null;
              return this;
            };
            a2.Path.prototype.addPoly = function(d2, g2) {
              var l2 = v2(d2, "HEAPF32");
              this._addPoly(l2, d2.length / 2, g2);
              p2(l2, d2);
              return this;
            };
            a2.Path.prototype.addRect = function(d2, g2) {
              d2 = S2(d2);
              this._addRect(d2, !!g2);
              return this;
            };
            a2.Path.prototype.addRRect = function(d2, g2) {
              d2 = sa(d2);
              this._addRRect(d2, !!g2);
              return this;
            };
            a2.Path.prototype.addVerbsPointsWeights = function(d2, g2, l2) {
              var t2 = v2(d2, "HEAPU8"), x2 = v2(g2, "HEAPF32"), C2 = v2(l2, "HEAPF32");
              this._addVerbsPointsWeights(t2, d2.length, x2, g2.length, C2, l2 && l2.length || 0);
              p2(t2, d2);
              p2(x2, g2);
              p2(C2, l2);
            };
            a2.Path.prototype.arc = function(d2, g2, l2, t2, x2, C2) {
              d2 = a2.LTRBRect(d2 - l2, g2 - l2, d2 + l2, g2 + l2);
              x2 = (x2 - t2) / Math.PI * 180 - 360 * !!C2;
              C2 = new a2.Path();
              C2.addArc(d2, t2 / Math.PI * 180, x2);
              this.addPath(C2, true);
              C2.delete();
              return this;
            };
            a2.Path.prototype.arcToOval = function(d2, g2, l2, t2) {
              d2 = S2(d2);
              this._arcToOval(d2, g2, l2, t2);
              return this;
            };
            a2.Path.prototype.arcToRotated = function(d2, g2, l2, t2, x2, C2, J2) {
              this._arcToRotated(d2, g2, l2, !!t2, !!x2, C2, J2);
              return this;
            };
            a2.Path.prototype.arcToTangent = function(d2, g2, l2, t2, x2) {
              this._arcToTangent(d2, g2, l2, t2, x2);
              return this;
            };
            a2.Path.prototype.close = function() {
              this._close();
              return this;
            };
            a2.Path.prototype.conicTo = function(d2, g2, l2, t2, x2) {
              this._conicTo(d2, g2, l2, t2, x2);
              return this;
            };
            a2.Path.prototype.computeTightBounds = function(d2) {
              this._computeTightBounds(ja);
              var g2 = Ba.toTypedArray();
              return d2 ? (d2.set(g2), d2) : g2.slice();
            };
            a2.Path.prototype.cubicTo = function(d2, g2, l2, t2, x2, C2) {
              this._cubicTo(d2, g2, l2, t2, x2, C2);
              return this;
            };
            a2.Path.prototype.dash = function(d2, g2, l2) {
              return this._dash(d2, g2, l2) ? this : null;
            };
            a2.Path.prototype.getBounds = function(d2) {
              this._getBounds(ja);
              var g2 = Ba.toTypedArray();
              return d2 ? (d2.set(g2), d2) : g2.slice();
            };
            a2.Path.prototype.lineTo = function(d2, g2) {
              this._lineTo(d2, g2);
              return this;
            };
            a2.Path.prototype.moveTo = function(d2, g2) {
              this._moveTo(d2, g2);
              return this;
            };
            a2.Path.prototype.offset = function(d2, g2) {
              this._transform(1, 0, d2, 0, 1, g2, 0, 0, 1);
              return this;
            };
            a2.Path.prototype.quadTo = function(d2, g2, l2, t2) {
              this._quadTo(d2, g2, l2, t2);
              return this;
            };
            a2.Path.prototype.rArcTo = function(d2, g2, l2, t2, x2, C2, J2) {
              this._rArcTo(d2, g2, l2, t2, x2, C2, J2);
              return this;
            };
            a2.Path.prototype.rConicTo = function(d2, g2, l2, t2, x2) {
              this._rConicTo(d2, g2, l2, t2, x2);
              return this;
            };
            a2.Path.prototype.rCubicTo = function(d2, g2, l2, t2, x2, C2) {
              this._rCubicTo(d2, g2, l2, t2, x2, C2);
              return this;
            };
            a2.Path.prototype.rLineTo = function(d2, g2) {
              this._rLineTo(d2, g2);
              return this;
            };
            a2.Path.prototype.rMoveTo = function(d2, g2) {
              this._rMoveTo(d2, g2);
              return this;
            };
            a2.Path.prototype.rQuadTo = function(d2, g2, l2, t2) {
              this._rQuadTo(d2, g2, l2, t2);
              return this;
            };
            a2.Path.prototype.stroke = function(d2) {
              d2 = d2 || {};
              d2.width = d2.width || 1;
              d2.miter_limit = d2.miter_limit || 4;
              d2.cap = d2.cap || a2.StrokeCap.Butt;
              d2.join = d2.join || a2.StrokeJoin.Miter;
              d2.precision = d2.precision || 1;
              return this._stroke(d2) ? this : null;
            };
            a2.Path.prototype.transform = function() {
              if (1 === arguments.length) {
                var d2 = arguments[0];
                this._transform(d2[0], d2[1], d2[2], d2[3], d2[4], d2[5], d2[6] || 0, d2[7] || 0, d2[8] || 1);
              } else if (6 === arguments.length || 9 === arguments.length) d2 = arguments, this._transform(d2[0], d2[1], d2[2], d2[3], d2[4], d2[5], d2[6] || 0, d2[7] || 0, d2[8] || 1);
              else throw "transform expected to take 1 or 9 arguments. Got " + arguments.length;
              return this;
            };
            a2.Path.prototype.trim = function(d2, g2, l2) {
              return this._trim(d2, g2, !!l2) ? this : null;
            };
            a2.Image.prototype.encodeToBytes = function(d2, g2) {
              var l2 = a2.Te();
              d2 = d2 || a2.ImageFormat.PNG;
              g2 = g2 || 100;
              return l2 ? this._encodeToBytes(d2, g2, l2) : this._encodeToBytes(d2, g2);
            };
            a2.Image.prototype.makeShaderCubic = function(d2, g2, l2, t2, x2) {
              x2 = H2(x2);
              return this._makeShaderCubic(d2, g2, l2, t2, x2);
            };
            a2.Image.prototype.makeShaderOptions = function(d2, g2, l2, t2, x2) {
              x2 = H2(x2);
              return this._makeShaderOptions(d2, g2, l2, t2, x2);
            };
            a2.Image.prototype.readPixels = function(d2, g2, l2, t2, x2) {
              var C2 = a2.Te();
              return e2(this, d2, g2, l2, t2, x2, C2);
            };
            a2.Canvas.prototype.clear = function(d2) {
              a2.Md(this.Kd);
              d2 = y2(d2);
              this._clear(d2);
            };
            a2.Canvas.prototype.clipRRect = function(d2, g2, l2) {
              a2.Md(this.Kd);
              d2 = sa(d2);
              this._clipRRect(d2, g2, l2);
            };
            a2.Canvas.prototype.clipRect = function(d2, g2, l2) {
              a2.Md(this.Kd);
              d2 = S2(d2);
              this._clipRect(d2, g2, l2);
            };
            a2.Canvas.prototype.concat = function(d2) {
              a2.Md(this.Kd);
              d2 = L2(d2);
              this._concat(d2);
            };
            a2.Canvas.prototype.drawArc = function(d2, g2, l2, t2, x2) {
              a2.Md(this.Kd);
              d2 = S2(d2);
              this._drawArc(d2, g2, l2, t2, x2);
            };
            a2.Canvas.prototype.drawAtlas = function(d2, g2, l2, t2, x2, C2, J2) {
              if (d2 && t2 && g2 && l2 && g2.length === l2.length) {
                a2.Md(this.Kd);
                x2 || (x2 = a2.BlendMode.SrcOver);
                var P2 = v2(g2, "HEAPF32"), O2 = v2(l2, "HEAPF32"), Y2 = l2.length / 4, aa = v2(m2(C2), "HEAPU32");
                if (J2 && "B" in J2 && "C" in J2) this._drawAtlasCubic(d2, O2, P2, aa, Y2, x2, J2.B, J2.C, t2);
                else {
                  let r2 = a2.FilterMode.Linear, D2 = a2.MipmapMode.None;
                  J2 && (r2 = J2.filter, "mipmap" in J2 && (D2 = J2.mipmap));
                  this._drawAtlasOptions(d2, O2, P2, aa, Y2, x2, r2, D2, t2);
                }
                p2(P2, g2);
                p2(O2, l2);
                p2(aa, C2);
              }
            };
            a2.Canvas.prototype.drawCircle = function(d2, g2, l2, t2) {
              a2.Md(this.Kd);
              this._drawCircle(d2, g2, l2, t2);
            };
            a2.Canvas.prototype.drawColor = function(d2, g2) {
              a2.Md(this.Kd);
              d2 = y2(d2);
              void 0 !== g2 ? this._drawColor(d2, g2) : this._drawColor(d2);
            };
            a2.Canvas.prototype.drawColorInt = function(d2, g2) {
              a2.Md(this.Kd);
              this._drawColorInt(d2, g2 || a2.BlendMode.SrcOver);
            };
            a2.Canvas.prototype.drawColorComponents = function(d2, g2, l2, t2, x2) {
              a2.Md(this.Kd);
              d2 = N2(d2, g2, l2, t2);
              void 0 !== x2 ? this._drawColor(d2, x2) : this._drawColor(d2);
            };
            a2.Canvas.prototype.drawDRRect = function(d2, g2, l2) {
              a2.Md(this.Kd);
              d2 = sa(d2, Yb);
              g2 = sa(g2, Cc);
              this._drawDRRect(d2, g2, l2);
            };
            a2.Canvas.prototype.drawImage = function(d2, g2, l2, t2) {
              a2.Md(this.Kd);
              this._drawImage(d2, g2, l2, t2 || null);
            };
            a2.Canvas.prototype.drawImageCubic = function(d2, g2, l2, t2, x2, C2) {
              a2.Md(this.Kd);
              this._drawImageCubic(d2, g2, l2, t2, x2, C2 || null);
            };
            a2.Canvas.prototype.drawImageOptions = function(d2, g2, l2, t2, x2, C2) {
              a2.Md(this.Kd);
              this._drawImageOptions(d2, g2, l2, t2, x2, C2 || null);
            };
            a2.Canvas.prototype.drawImageNine = function(d2, g2, l2, t2, x2) {
              a2.Md(this.Kd);
              g2 = v2(g2, "HEAP32", ib);
              l2 = S2(l2);
              this._drawImageNine(d2, g2, l2, t2, x2 || null);
            };
            a2.Canvas.prototype.drawImageRect = function(d2, g2, l2, t2, x2) {
              a2.Md(this.Kd);
              S2(g2, ja);
              S2(l2, Oa);
              this._drawImageRect(d2, ja, Oa, t2, !!x2);
            };
            a2.Canvas.prototype.drawImageRectCubic = function(d2, g2, l2, t2, x2, C2) {
              a2.Md(this.Kd);
              S2(g2, ja);
              S2(l2, Oa);
              this._drawImageRectCubic(d2, ja, Oa, t2, x2, C2 || null);
            };
            a2.Canvas.prototype.drawImageRectOptions = function(d2, g2, l2, t2, x2, C2) {
              a2.Md(this.Kd);
              S2(g2, ja);
              S2(l2, Oa);
              this._drawImageRectOptions(d2, ja, Oa, t2, x2, C2 || null);
            };
            a2.Canvas.prototype.drawLine = function(d2, g2, l2, t2, x2) {
              a2.Md(this.Kd);
              this._drawLine(d2, g2, l2, t2, x2);
            };
            a2.Canvas.prototype.drawOval = function(d2, g2) {
              a2.Md(this.Kd);
              d2 = S2(d2);
              this._drawOval(d2, g2);
            };
            a2.Canvas.prototype.drawPaint = function(d2) {
              a2.Md(this.Kd);
              this._drawPaint(d2);
            };
            a2.Canvas.prototype.drawParagraph = function(d2, g2, l2) {
              a2.Md(this.Kd);
              this._drawParagraph(d2, g2, l2);
            };
            a2.Canvas.prototype.drawPatch = function(d2, g2, l2, t2, x2) {
              if (24 > d2.length) throw "Need 12 cubic points";
              if (g2 && 4 > g2.length) throw "Need 4 colors";
              if (l2 && 8 > l2.length) throw "Need 4 shader coordinates";
              a2.Md(this.Kd);
              const C2 = v2(d2, "HEAPF32"), J2 = g2 ? v2(m2(g2), "HEAPU32") : W2, P2 = l2 ? v2(l2, "HEAPF32") : W2;
              t2 || (t2 = a2.BlendMode.Modulate);
              this._drawPatch(C2, J2, P2, t2, x2);
              p2(P2, l2);
              p2(J2, g2);
              p2(C2, d2);
            };
            a2.Canvas.prototype.drawPath = function(d2, g2) {
              a2.Md(this.Kd);
              this._drawPath(d2, g2);
            };
            a2.Canvas.prototype.drawPicture = function(d2) {
              a2.Md(this.Kd);
              this._drawPicture(d2);
            };
            a2.Canvas.prototype.drawPoints = function(d2, g2, l2) {
              a2.Md(this.Kd);
              var t2 = v2(g2, "HEAPF32");
              this._drawPoints(
                d2,
                t2,
                g2.length / 2,
                l2
              );
              p2(t2, g2);
            };
            a2.Canvas.prototype.drawRRect = function(d2, g2) {
              a2.Md(this.Kd);
              d2 = sa(d2);
              this._drawRRect(d2, g2);
            };
            a2.Canvas.prototype.drawRect = function(d2, g2) {
              a2.Md(this.Kd);
              d2 = S2(d2);
              this._drawRect(d2, g2);
            };
            a2.Canvas.prototype.drawRect4f = function(d2, g2, l2, t2, x2) {
              a2.Md(this.Kd);
              this._drawRect4f(d2, g2, l2, t2, x2);
            };
            a2.Canvas.prototype.drawShadow = function(d2, g2, l2, t2, x2, C2, J2) {
              a2.Md(this.Kd);
              var P2 = v2(x2, "HEAPF32"), O2 = v2(C2, "HEAPF32");
              g2 = v2(g2, "HEAPF32", Zb);
              l2 = v2(l2, "HEAPF32", $b);
              this._drawShadow(d2, g2, l2, t2, P2, O2, J2);
              p2(P2, x2);
              p2(O2, C2);
            };
            a2.getShadowLocalBounds = function(d2, g2, l2, t2, x2, C2, J2) {
              d2 = H2(d2);
              l2 = v2(l2, "HEAPF32", Zb);
              t2 = v2(t2, "HEAPF32", $b);
              if (!this._getShadowLocalBounds(d2, g2, l2, t2, x2, C2, ja)) return null;
              g2 = Ba.toTypedArray();
              return J2 ? (J2.set(g2), J2) : g2.slice();
            };
            a2.Canvas.prototype.drawTextBlob = function(d2, g2, l2, t2) {
              a2.Md(this.Kd);
              this._drawTextBlob(d2, g2, l2, t2);
            };
            a2.Canvas.prototype.drawVertices = function(d2, g2, l2) {
              a2.Md(this.Kd);
              this._drawVertices(d2, g2, l2);
            };
            a2.Canvas.prototype.getDeviceClipBounds = function(d2) {
              this._getDeviceClipBounds(ib);
              var g2 = yb.toTypedArray();
              d2 ? d2.set(g2) : d2 = g2.slice();
              return d2;
            };
            a2.Canvas.prototype.getLocalToDevice = function() {
              this._getLocalToDevice($a);
              for (var d2 = $a, g2 = Array(16), l2 = 0; 16 > l2; l2++) g2[l2] = a2.HEAPF32[d2 / 4 + l2];
              return g2;
            };
            a2.Canvas.prototype.getTotalMatrix = function() {
              this._getTotalMatrix(Na);
              for (var d2 = Array(9), g2 = 0; 9 > g2; g2++) d2[g2] = a2.HEAPF32[Na / 4 + g2];
              return d2;
            };
            a2.Canvas.prototype.makeSurface = function(d2) {
              d2 = this._makeSurface(d2);
              d2.Kd = this.Kd;
              return d2;
            };
            a2.Canvas.prototype.readPixels = function(d2, g2, l2, t2, x2) {
              a2.Md(this.Kd);
              return e2(this, d2, g2, l2, t2, x2);
            };
            a2.Canvas.prototype.saveLayer = function(d2, g2, l2, t2) {
              g2 = S2(g2);
              return this._saveLayer(d2 || null, g2, l2 || null, t2 || 0);
            };
            a2.Canvas.prototype.writePixels = function(d2, g2, l2, t2, x2, C2, J2, P2) {
              if (d2.byteLength % (g2 * l2)) throw "pixels length must be a multiple of the srcWidth * srcHeight";
              a2.Md(this.Kd);
              var O2 = d2.byteLength / (g2 * l2);
              C2 = C2 || a2.AlphaType.Unpremul;
              J2 = J2 || a2.ColorType.RGBA_8888;
              P2 = P2 || a2.ColorSpace.SRGB;
              var Y2 = O2 * g2;
              O2 = v2(d2, "HEAPU8");
              g2 = this._writePixels({ width: g2, height: l2, colorType: J2, alphaType: C2, colorSpace: P2 }, O2, Y2, t2, x2);
              p2(O2, d2);
              return g2;
            };
            a2.ColorFilter.MakeBlend = function(d2, g2, l2) {
              d2 = y2(d2);
              l2 = l2 || a2.ColorSpace.SRGB;
              return a2.ColorFilter._MakeBlend(d2, g2, l2);
            };
            a2.ColorFilter.MakeMatrix = function(d2) {
              if (!d2 || 20 !== d2.length) throw "invalid color matrix";
              var g2 = v2(d2, "HEAPF32"), l2 = a2.ColorFilter._makeMatrix(g2);
              p2(g2, d2);
              return l2;
            };
            a2.ContourMeasure.prototype.getPosTan = function(d2, g2) {
              this._getPosTan(d2, ja);
              d2 = Ba.toTypedArray();
              return g2 ? (g2.set(d2), g2) : d2.slice();
            };
            a2.ImageFilter.prototype.getOutputBounds = function(d2, g2, l2) {
              d2 = S2(d2, ja);
              g2 = H2(g2);
              this._getOutputBounds(d2, g2, ib);
              g2 = yb.toTypedArray();
              return l2 ? (l2.set(g2), l2) : g2.slice();
            };
            a2.ImageFilter.MakeDropShadow = function(d2, g2, l2, t2, x2, C2) {
              x2 = y2(x2, Ta);
              return a2.ImageFilter._MakeDropShadow(d2, g2, l2, t2, x2, C2);
            };
            a2.ImageFilter.MakeDropShadowOnly = function(d2, g2, l2, t2, x2, C2) {
              x2 = y2(x2, Ta);
              return a2.ImageFilter._MakeDropShadowOnly(d2, g2, l2, t2, x2, C2);
            };
            a2.ImageFilter.MakeImage = function(d2, g2, l2, t2) {
              l2 = S2(l2, ja);
              t2 = S2(t2, Oa);
              if ("B" in g2 && "C" in g2) return a2.ImageFilter._MakeImageCubic(d2, g2.B, g2.C, l2, t2);
              const x2 = g2.filter;
              let C2 = a2.MipmapMode.None;
              "mipmap" in g2 && (C2 = g2.mipmap);
              return a2.ImageFilter._MakeImageOptions(d2, x2, C2, l2, t2);
            };
            a2.ImageFilter.MakeMatrixTransform = function(d2, g2, l2) {
              d2 = H2(d2);
              if ("B" in g2 && "C" in g2) return a2.ImageFilter._MakeMatrixTransformCubic(d2, g2.B, g2.C, l2);
              const t2 = g2.filter;
              let x2 = a2.MipmapMode.None;
              "mipmap" in g2 && (x2 = g2.mipmap);
              return a2.ImageFilter._MakeMatrixTransformOptions(d2, t2, x2, l2);
            };
            a2.Paint.prototype.getColor = function() {
              this._getColor(Ta);
              return T2(Ta);
            };
            a2.Paint.prototype.setColor = function(d2, g2) {
              g2 = g2 || null;
              d2 = y2(d2);
              this._setColor(d2, g2);
            };
            a2.Paint.prototype.setColorComponents = function(d2, g2, l2, t2, x2) {
              x2 = x2 || null;
              d2 = N2(d2, g2, l2, t2);
              this._setColor(d2, x2);
            };
            a2.Path.prototype.getPoint = function(d2, g2) {
              this._getPoint(d2, ja);
              d2 = Ba.toTypedArray();
              return g2 ? (g2[0] = d2[0], g2[1] = d2[1], g2) : d2.slice(0, 2);
            };
            a2.Picture.prototype.makeShader = function(d2, g2, l2, t2, x2) {
              t2 = H2(t2);
              x2 = S2(x2);
              return this._makeShader(d2, g2, l2, t2, x2);
            };
            a2.Picture.prototype.cullRect = function(d2) {
              this._cullRect(ja);
              var g2 = Ba.toTypedArray();
              return d2 ? (d2.set(g2), d2) : g2.slice();
            };
            a2.PictureRecorder.prototype.beginRecording = function(d2, g2) {
              d2 = S2(d2);
              return this._beginRecording(d2, !!g2);
            };
            a2.Surface.prototype.getCanvas = function() {
              var d2 = this._getCanvas();
              d2.Kd = this.Kd;
              return d2;
            };
            a2.Surface.prototype.makeImageSnapshot = function(d2) {
              a2.Md(this.Kd);
              d2 = v2(d2, "HEAP32", ib);
              return this._makeImageSnapshot(d2);
            };
            a2.Surface.prototype.makeSurface = function(d2) {
              a2.Md(this.Kd);
              d2 = this._makeSurface(d2);
              d2.Kd = this.Kd;
              return d2;
            };
            a2.Surface.prototype.Gf = function(d2, g2) {
              this.He || (this.He = this.getCanvas());
              return requestAnimationFrame(function() {
                a2.Md(this.Kd);
                d2(this.He);
                this.flush(g2);
              }.bind(this));
            };
            a2.Surface.prototype.requestAnimationFrame || (a2.Surface.prototype.requestAnimationFrame = a2.Surface.prototype.Gf);
            a2.Surface.prototype.Cf = function(d2, g2) {
              this.He || (this.He = this.getCanvas());
              requestAnimationFrame(function() {
                a2.Md(this.Kd);
                d2(this.He);
                this.flush(g2);
                this.dispose();
              }.bind(this));
            };
            a2.Surface.prototype.drawOnce || (a2.Surface.prototype.drawOnce = a2.Surface.prototype.Cf);
            a2.PathEffect.MakeDash = function(d2, g2) {
              g2 || (g2 = 0);
              if (!d2.length || 1 === d2.length % 2) throw "Intervals array must have even length";
              var l2 = v2(d2, "HEAPF32");
              g2 = a2.PathEffect._MakeDash(l2, d2.length, g2);
              p2(l2, d2);
              return g2;
            };
            a2.PathEffect.MakeLine2D = function(d2, g2) {
              g2 = H2(g2);
              return a2.PathEffect._MakeLine2D(d2, g2);
            };
            a2.PathEffect.MakePath2D = function(d2, g2) {
              d2 = H2(d2);
              return a2.PathEffect._MakePath2D(d2, g2);
            };
            a2.Shader.MakeColor = function(d2, g2) {
              g2 = g2 || null;
              d2 = y2(d2);
              return a2.Shader._MakeColor(d2, g2);
            };
            a2.Shader.Blend = a2.Shader.MakeBlend;
            a2.Shader.Color = a2.Shader.MakeColor;
            a2.Shader.MakeLinearGradient = function(d2, g2, l2, t2, x2, C2, J2, P2) {
              P2 = P2 || null;
              var O2 = E2(l2), Y2 = v2(t2, "HEAPF32");
              J2 = J2 || 0;
              C2 = H2(C2);
              var aa = Ba.toTypedArray();
              aa.set(d2);
              aa.set(g2, 2);
              d2 = a2.Shader._MakeLinearGradient(ja, O2.be, O2.colorType, Y2, O2.count, x2, J2, C2, P2);
              p2(O2.be, l2);
              t2 && p2(Y2, t2);
              return d2;
            };
            a2.Shader.MakeRadialGradient = function(d2, g2, l2, t2, x2, C2, J2, P2) {
              P2 = P2 || null;
              var O2 = E2(l2), Y2 = v2(t2, "HEAPF32");
              J2 = J2 || 0;
              C2 = H2(C2);
              d2 = a2.Shader._MakeRadialGradient(d2[0], d2[1], g2, O2.be, O2.colorType, Y2, O2.count, x2, J2, C2, P2);
              p2(O2.be, l2);
              t2 && p2(Y2, t2);
              return d2;
            };
            a2.Shader.MakeSweepGradient = function(d2, g2, l2, t2, x2, C2, J2, P2, O2, Y2) {
              Y2 = Y2 || null;
              var aa = E2(l2), r2 = v2(t2, "HEAPF32");
              J2 = J2 || 0;
              P2 = P2 || 0;
              O2 = O2 || 360;
              C2 = H2(C2);
              d2 = a2.Shader._MakeSweepGradient(d2, g2, aa.be, aa.colorType, r2, aa.count, x2, P2, O2, J2, C2, Y2);
              p2(aa.be, l2);
              t2 && p2(r2, t2);
              return d2;
            };
            a2.Shader.MakeTwoPointConicalGradient = function(d2, g2, l2, t2, x2, C2, J2, P2, O2, Y2) {
              Y2 = Y2 || null;
              var aa = E2(x2), r2 = v2(C2, "HEAPF32");
              O2 = O2 || 0;
              P2 = H2(P2);
              var D2 = Ba.toTypedArray();
              D2.set(d2);
              D2.set(l2, 2);
              d2 = a2.Shader._MakeTwoPointConicalGradient(ja, g2, t2, aa.be, aa.colorType, r2, aa.count, J2, O2, P2, Y2);
              p2(aa.be, x2);
              C2 && p2(r2, C2);
              return d2;
            };
            a2.Vertices.prototype.bounds = function(d2) {
              this._bounds(ja);
              var g2 = Ba.toTypedArray();
              return d2 ? (d2.set(g2), d2) : g2.slice();
            };
            a2.Td && a2.Td.forEach(function(d2) {
              d2();
            });
          };
          a2.computeTonalColors = function(e2) {
            var d2 = v2(e2.ambient, "HEAPF32"), g2 = v2(e2.spot, "HEAPF32");
            this._computeTonalColors(d2, g2);
            var l2 = { ambient: T2(d2), spot: T2(g2) };
            p2(d2, e2.ambient);
            p2(g2, e2.spot);
            return l2;
          };
          a2.LTRBRect = function(e2, d2, g2, l2) {
            return Float32Array.of(e2, d2, g2, l2);
          };
          a2.XYWHRect = function(e2, d2, g2, l2) {
            return Float32Array.of(e2, d2, e2 + g2, d2 + l2);
          };
          a2.LTRBiRect = function(e2, d2, g2, l2) {
            return Int32Array.of(e2, d2, g2, l2);
          };
          a2.XYWHiRect = function(e2, d2, g2, l2) {
            return Int32Array.of(e2, d2, e2 + g2, d2 + l2);
          };
          a2.RRectXY = function(e2, d2, g2) {
            return Float32Array.of(e2[0], e2[1], e2[2], e2[3], d2, g2, d2, g2, d2, g2, d2, g2);
          };
          a2.MakeAnimatedImageFromEncoded = function(e2) {
            e2 = new Uint8Array(e2);
            var d2 = a2._malloc(e2.byteLength);
            a2.HEAPU8.set(e2, d2);
            return (e2 = a2._decodeAnimatedImage(
              d2,
              e2.byteLength
            )) ? e2 : null;
          };
          a2.MakeImageFromEncoded = function(e2) {
            e2 = new Uint8Array(e2);
            var d2 = a2._malloc(e2.byteLength);
            a2.HEAPU8.set(e2, d2);
            return (e2 = a2._decodeImage(d2, e2.byteLength)) ? e2 : null;
          };
          var jb = null;
          a2.MakeImageFromCanvasImageSource = function(e2) {
            var d2 = e2.width, g2 = e2.height;
            jb || (jb = document.createElement("canvas"));
            jb.width = d2;
            jb.height = g2;
            var l2 = jb.getContext("2d", { willReadFrequently: true });
            l2.drawImage(e2, 0, 0);
            e2 = l2.getImageData(0, 0, d2, g2);
            return a2.MakeImage({
              width: d2,
              height: g2,
              alphaType: a2.AlphaType.Unpremul,
              colorType: a2.ColorType.RGBA_8888,
              colorSpace: a2.ColorSpace.SRGB
            }, e2.data, 4 * d2);
          };
          a2.MakeImage = function(e2, d2, g2) {
            var l2 = a2._malloc(d2.length);
            a2.HEAPU8.set(d2, l2);
            return a2._MakeImage(e2, l2, d2.length, g2);
          };
          a2.MakeVertices = function(e2, d2, g2, l2, t2, x2) {
            var C2 = t2 && t2.length || 0, J2 = 0;
            g2 && g2.length && (J2 |= 1);
            l2 && l2.length && (J2 |= 2);
            void 0 === x2 || x2 || (J2 |= 4);
            e2 = new a2._VerticesBuilder(e2, d2.length / 2, C2, J2);
            v2(d2, "HEAPF32", e2.positions());
            e2.texCoords() && v2(g2, "HEAPF32", e2.texCoords());
            e2.colors() && v2(m2(l2), "HEAPU32", e2.colors());
            e2.indices() && v2(t2, "HEAPU16", e2.indices());
            return e2.detach();
          };
          a2.Matrix = {};
          a2.Matrix.identity = function() {
            return c2(3);
          };
          a2.Matrix.invert = function(e2) {
            var d2 = e2[0] * e2[4] * e2[8] + e2[1] * e2[5] * e2[6] + e2[2] * e2[3] * e2[7] - e2[2] * e2[4] * e2[6] - e2[1] * e2[3] * e2[8] - e2[0] * e2[5] * e2[7];
            return d2 ? [(e2[4] * e2[8] - e2[5] * e2[7]) / d2, (e2[2] * e2[7] - e2[1] * e2[8]) / d2, (e2[1] * e2[5] - e2[2] * e2[4]) / d2, (e2[5] * e2[6] - e2[3] * e2[8]) / d2, (e2[0] * e2[8] - e2[2] * e2[6]) / d2, (e2[2] * e2[3] - e2[0] * e2[5]) / d2, (e2[3] * e2[7] - e2[4] * e2[6]) / d2, (e2[1] * e2[6] - e2[0] * e2[7]) / d2, (e2[0] * e2[4] - e2[1] * e2[3]) / d2] : null;
          };
          a2.Matrix.mapPoints = function(e2, d2) {
            for (var g2 = 0; g2 < d2.length; g2 += 2) {
              var l2 = d2[g2], t2 = d2[g2 + 1], x2 = e2[6] * l2 + e2[7] * t2 + e2[8], C2 = e2[3] * l2 + e2[4] * t2 + e2[5];
              d2[g2] = (e2[0] * l2 + e2[1] * t2 + e2[2]) / x2;
              d2[g2 + 1] = C2 / x2;
            }
            return d2;
          };
          a2.Matrix.multiply = function() {
            return hb(3, arguments);
          };
          a2.Matrix.rotated = function(e2, d2, g2) {
            d2 = d2 || 0;
            g2 = g2 || 0;
            var l2 = Math.sin(e2);
            e2 = Math.cos(e2);
            return [e2, -l2, ma(l2, g2, 1 - e2, d2), l2, e2, ma(-l2, d2, 1 - e2, g2), 0, 0, 1];
          };
          a2.Matrix.scaled = function(e2, d2, g2, l2) {
            g2 = g2 || 0;
            l2 = l2 || 0;
            var t2 = b2([e2, d2], c2(3), 3, 0, 1);
            return b2([g2 - e2 * g2, l2 - d2 * l2], t2, 3, 2, 0);
          };
          a2.Matrix.skewed = function(e2, d2, g2, l2) {
            g2 = g2 || 0;
            l2 = l2 || 0;
            var t2 = b2([e2, d2], c2(3), 3, 1, -1);
            return b2([-e2 * g2, -d2 * l2], t2, 3, 2, 0);
          };
          a2.Matrix.translated = function(e2, d2) {
            return b2(
              arguments,
              c2(3),
              3,
              2,
              0
            );
          };
          a2.Vector = {};
          a2.Vector.dot = function(e2, d2) {
            return e2.map(function(g2, l2) {
              return g2 * d2[l2];
            }).reduce(function(g2, l2) {
              return g2 + l2;
            });
          };
          a2.Vector.lengthSquared = function(e2) {
            return a2.Vector.dot(e2, e2);
          };
          a2.Vector.length = function(e2) {
            return Math.sqrt(a2.Vector.lengthSquared(e2));
          };
          a2.Vector.mulScalar = function(e2, d2) {
            return e2.map(function(g2) {
              return g2 * d2;
            });
          };
          a2.Vector.add = function(e2, d2) {
            return e2.map(function(g2, l2) {
              return g2 + d2[l2];
            });
          };
          a2.Vector.sub = function(e2, d2) {
            return e2.map(function(g2, l2) {
              return g2 - d2[l2];
            });
          };
          a2.Vector.dist = function(e2, d2) {
            return a2.Vector.length(a2.Vector.sub(e2, d2));
          };
          a2.Vector.normalize = function(e2) {
            return a2.Vector.mulScalar(e2, 1 / a2.Vector.length(e2));
          };
          a2.Vector.cross = function(e2, d2) {
            return [e2[1] * d2[2] - e2[2] * d2[1], e2[2] * d2[0] - e2[0] * d2[2], e2[0] * d2[1] - e2[1] * d2[0]];
          };
          a2.M44 = {};
          a2.M44.identity = function() {
            return c2(4);
          };
          a2.M44.translated = function(e2) {
            return b2(e2, c2(4), 4, 3, 0);
          };
          a2.M44.scaled = function(e2) {
            return b2(e2, c2(4), 4, 0, 1);
          };
          a2.M44.rotated = function(e2, d2) {
            return a2.M44.rotatedUnitSinCos(a2.Vector.normalize(e2), Math.sin(d2), Math.cos(d2));
          };
          a2.M44.rotatedUnitSinCos = function(e2, d2, g2) {
            var l2 = e2[0], t2 = e2[1];
            e2 = e2[2];
            var x2 = 1 - g2;
            return [x2 * l2 * l2 + g2, x2 * l2 * t2 - d2 * e2, x2 * l2 * e2 + d2 * t2, 0, x2 * l2 * t2 + d2 * e2, x2 * t2 * t2 + g2, x2 * t2 * e2 - d2 * l2, 0, x2 * l2 * e2 - d2 * t2, x2 * t2 * e2 + d2 * l2, x2 * e2 * e2 + g2, 0, 0, 0, 0, 1];
          };
          a2.M44.lookat = function(e2, d2, g2) {
            d2 = a2.Vector.normalize(a2.Vector.sub(d2, e2));
            g2 = a2.Vector.normalize(g2);
            g2 = a2.Vector.normalize(a2.Vector.cross(d2, g2));
            var l2 = a2.M44.identity();
            b2(g2, l2, 4, 0, 0);
            b2(a2.Vector.cross(g2, d2), l2, 4, 1, 0);
            b2(a2.Vector.mulScalar(d2, -1), l2, 4, 2, 0);
            b2(e2, l2, 4, 3, 0);
            e2 = a2.M44.invert(l2);
            return null === e2 ? a2.M44.identity() : e2;
          };
          a2.M44.perspective = function(e2, d2, g2) {
            var l2 = 1 / (d2 - e2);
            g2 /= 2;
            g2 = Math.cos(g2) / Math.sin(g2);
            return [g2, 0, 0, 0, 0, g2, 0, 0, 0, 0, (d2 + e2) * l2, 2 * d2 * e2 * l2, 0, 0, -1, 1];
          };
          a2.M44.rc = function(e2, d2, g2) {
            return e2[4 * d2 + g2];
          };
          a2.M44.multiply = function() {
            return hb(4, arguments);
          };
          a2.M44.invert = function(e2) {
            var d2 = e2[0], g2 = e2[4], l2 = e2[8], t2 = e2[12], x2 = e2[1], C2 = e2[5], J2 = e2[9], P2 = e2[13], O2 = e2[2], Y2 = e2[6], aa = e2[10], r2 = e2[14], D2 = e2[3], U2 = e2[7], ca2 = e2[11];
            e2 = e2[15];
            var ka = d2 * C2 - g2 * x2, va = d2 * J2 - l2 * x2, wa = d2 * P2 - t2 * x2, na = g2 * J2 - l2 * C2, G2 = g2 * P2 - t2 * C2, k2 = l2 * P2 - t2 * J2, q2 = O2 * U2 - Y2 * D2, z2 = O2 * ca2 - aa * D2, B2 = O2 * e2 - r2 * D2, F2 = Y2 * ca2 - aa * U2, I2 = Y2 * e2 - r2 * U2, M2 = aa * e2 - r2 * ca2, da = ka * M2 - va * I2 + wa * F2 + na * B2 - G2 * z2 + k2 * q2, ea = 1 / da;
            if (0 === da || Infinity === ea) return null;
            ka *= ea;
            va *= ea;
            wa *= ea;
            na *= ea;
            G2 *= ea;
            k2 *= ea;
            q2 *= ea;
            z2 *= ea;
            B2 *= ea;
            F2 *= ea;
            I2 *= ea;
            M2 *= ea;
            d2 = [C2 * M2 - J2 * I2 + P2 * F2, J2 * B2 - x2 * M2 - P2 * z2, x2 * I2 - C2 * B2 + P2 * q2, C2 * z2 - x2 * F2 - J2 * q2, l2 * I2 - g2 * M2 - t2 * F2, d2 * M2 - l2 * B2 + t2 * z2, g2 * B2 - d2 * I2 - t2 * q2, d2 * F2 - g2 * z2 + l2 * q2, U2 * k2 - ca2 * G2 + e2 * na, ca2 * wa - D2 * k2 - e2 * va, D2 * G2 - U2 * wa + e2 * ka, U2 * va - D2 * na - ca2 * ka, aa * G2 - Y2 * k2 - r2 * na, O2 * k2 - aa * wa + r2 * va, Y2 * wa - O2 * G2 - r2 * ka, O2 * na - Y2 * va + aa * ka];
            return d2.every(function(Ia) {
              return !isNaN(Ia) && Infinity !== Ia && -Infinity !== Ia;
            }) ? d2 : null;
          };
          a2.M44.transpose = function(e2) {
            return [
              e2[0],
              e2[4],
              e2[8],
              e2[12],
              e2[1],
              e2[5],
              e2[9],
              e2[13],
              e2[2],
              e2[6],
              e2[10],
              e2[14],
              e2[3],
              e2[7],
              e2[11],
              e2[15]
            ];
          };
          a2.M44.mustInvert = function(e2) {
            e2 = a2.M44.invert(e2);
            if (null === e2) throw "Matrix not invertible";
            return e2;
          };
          a2.M44.setupCamera = function(e2, d2, g2) {
            var l2 = a2.M44.lookat(g2.eye, g2.coa, g2.up);
            g2 = a2.M44.perspective(g2.near, g2.far, g2.angle);
            d2 = [(e2[2] - e2[0]) / 2, (e2[3] - e2[1]) / 2, d2];
            e2 = a2.M44.multiply(a2.M44.translated([(e2[0] + e2[2]) / 2, (e2[1] + e2[3]) / 2, 0]), a2.M44.scaled(d2));
            return a2.M44.multiply(e2, g2, l2, a2.M44.mustInvert(e2));
          };
          a2.ColorMatrix = {};
          a2.ColorMatrix.identity = function() {
            var e2 = new Float32Array(20);
            e2[0] = 1;
            e2[6] = 1;
            e2[12] = 1;
            e2[18] = 1;
            return e2;
          };
          a2.ColorMatrix.scaled = function(e2, d2, g2, l2) {
            var t2 = new Float32Array(20);
            t2[0] = e2;
            t2[6] = d2;
            t2[12] = g2;
            t2[18] = l2;
            return t2;
          };
          var xd = [[6, 7, 11, 12], [0, 10, 2, 12], [0, 1, 5, 6]];
          a2.ColorMatrix.rotated = function(e2, d2, g2) {
            var l2 = a2.ColorMatrix.identity();
            e2 = xd[e2];
            l2[e2[0]] = g2;
            l2[e2[1]] = d2;
            l2[e2[2]] = -d2;
            l2[e2[3]] = g2;
            return l2;
          };
          a2.ColorMatrix.postTranslate = function(e2, d2, g2, l2, t2) {
            e2[4] += d2;
            e2[9] += g2;
            e2[14] += l2;
            e2[19] += t2;
            return e2;
          };
          a2.ColorMatrix.concat = function(e2, d2) {
            for (var g2 = new Float32Array(20), l2 = 0, t2 = 0; 20 > t2; t2 += 5) {
              for (var x2 = 0; 4 > x2; x2++) g2[l2++] = e2[t2] * d2[x2] + e2[t2 + 1] * d2[x2 + 5] + e2[t2 + 2] * d2[x2 + 10] + e2[t2 + 3] * d2[x2 + 15];
              g2[l2++] = e2[t2] * d2[4] + e2[t2 + 1] * d2[9] + e2[t2 + 2] * d2[14] + e2[t2 + 3] * d2[19] + e2[t2 + 4];
            }
            return g2;
          };
          (function(e2) {
            e2.Td = e2.Td || [];
            e2.Td.push(function() {
              function d2(r2) {
                r2 && (r2.dir = 0 === r2.dir ? e2.TextDirection.RTL : e2.TextDirection.LTR);
                return r2;
              }
              function g2(r2) {
                if (!r2 || !r2.length) return [];
                for (var D2 = [], U2 = 0; U2 < r2.length; U2 += 5) {
                  var ca2 = e2.LTRBRect(r2[U2], r2[U2 + 1], r2[U2 + 2], r2[U2 + 3]), ka = e2.TextDirection.LTR;
                  0 === r2[U2 + 4] && (ka = e2.TextDirection.RTL);
                  D2.push({ rect: ca2, dir: ka });
                }
                e2._free(r2.byteOffset);
                return D2;
              }
              function l2(r2) {
                r2 = r2 || {};
                void 0 === r2.weight && (r2.weight = e2.FontWeight.Normal);
                r2.width = r2.width || e2.FontWidth.Normal;
                r2.slant = r2.slant || e2.FontSlant.Upright;
                return r2;
              }
              function t2(r2) {
                if (!r2 || !r2.length) return W2;
                for (var D2 = [], U2 = 0; U2 < r2.length; U2++) {
                  var ca2 = x2(r2[U2]);
                  D2.push(ca2);
                }
                return v2(D2, "HEAPU32");
              }
              function x2(r2) {
                if (P2[r2]) return P2[r2];
                var D2 = qa(r2) + 1, U2 = e2._malloc(D2);
                ra(r2, K2, U2, D2);
                return P2[r2] = U2;
              }
              function C2(r2) {
                r2._colorPtr = y2(r2.color);
                r2._foregroundColorPtr = W2;
                r2._backgroundColorPtr = W2;
                r2._decorationColorPtr = W2;
                r2.foregroundColor && (r2._foregroundColorPtr = y2(r2.foregroundColor, O2));
                r2.backgroundColor && (r2._backgroundColorPtr = y2(r2.backgroundColor, Y2));
                r2.decorationColor && (r2._decorationColorPtr = y2(r2.decorationColor, aa));
                Array.isArray(r2.fontFamilies) && r2.fontFamilies.length ? (r2._fontFamiliesPtr = t2(r2.fontFamilies), r2._fontFamiliesLen = r2.fontFamilies.length) : (r2._fontFamiliesPtr = W2, r2._fontFamiliesLen = 0);
                if (r2.locale) {
                  var D2 = r2.locale;
                  r2._localePtr = x2(D2);
                  r2._localeLen = qa(D2) + 1;
                } else r2._localePtr = W2, r2._localeLen = 0;
                if (Array.isArray(r2.shadows) && r2.shadows.length) {
                  D2 = r2.shadows;
                  var U2 = D2.map(function(G2) {
                    return G2.color || e2.BLACK;
                  }), ca2 = D2.map(function(G2) {
                    return G2.blurRadius || 0;
                  });
                  r2._shadowLen = D2.length;
                  for (var ka = e2._malloc(8 * D2.length), va = ka / 4, wa = 0; wa < D2.length; wa++) {
                    var na = D2[wa].offset || [0, 0];
                    e2.HEAPF32[va] = na[0];
                    e2.HEAPF32[va + 1] = na[1];
                    va += 2;
                  }
                  r2._shadowColorsPtr = E2(U2).be;
                  r2._shadowOffsetsPtr = ka;
                  r2._shadowBlurRadiiPtr = v2(ca2, "HEAPF32");
                } else r2._shadowLen = 0, r2._shadowColorsPtr = W2, r2._shadowOffsetsPtr = W2, r2._shadowBlurRadiiPtr = W2;
                Array.isArray(r2.fontFeatures) && r2.fontFeatures.length ? (D2 = r2.fontFeatures, U2 = D2.map(function(G2) {
                  return G2.name;
                }), ca2 = D2.map(function(G2) {
                  return G2.value;
                }), r2._fontFeatureLen = D2.length, r2._fontFeatureNamesPtr = t2(U2), r2._fontFeatureValuesPtr = v2(ca2, "HEAPU32")) : (r2._fontFeatureLen = 0, r2._fontFeatureNamesPtr = W2, r2._fontFeatureValuesPtr = W2);
                Array.isArray(r2.fontVariations) && r2.fontVariations.length ? (D2 = r2.fontVariations, U2 = D2.map(function(G2) {
                  return G2.axis;
                }), ca2 = D2.map(function(G2) {
                  return G2.value;
                }), r2._fontVariationLen = D2.length, r2._fontVariationAxesPtr = t2(U2), r2._fontVariationValuesPtr = v2(ca2, "HEAPF32")) : (r2._fontVariationLen = 0, r2._fontVariationAxesPtr = W2, r2._fontVariationValuesPtr = W2);
              }
              function J2(r2) {
                e2._free(r2._fontFamiliesPtr);
                e2._free(r2._shadowColorsPtr);
                e2._free(r2._shadowOffsetsPtr);
                e2._free(r2._shadowBlurRadiiPtr);
                e2._free(r2._fontFeatureNamesPtr);
                e2._free(r2._fontFeatureValuesPtr);
                e2._free(r2._fontVariationAxesPtr);
                e2._free(r2._fontVariationValuesPtr);
              }
              e2.Paragraph.prototype.getRectsForRange = function(r2, D2, U2, ca2) {
                r2 = this._getRectsForRange(r2, D2, U2, ca2);
                return g2(r2);
              };
              e2.Paragraph.prototype.getRectsForPlaceholders = function() {
                var r2 = this._getRectsForPlaceholders();
                return g2(r2);
              };
              e2.Paragraph.prototype.getGlyphInfoAt = function(r2) {
                return d2(this._getGlyphInfoAt(r2));
              };
              e2.Paragraph.prototype.getClosestGlyphInfoAtCoordinate = function(r2, D2) {
                return d2(this._getClosestGlyphInfoAtCoordinate(r2, D2));
              };
              e2.TypefaceFontProvider.prototype.registerFont = function(r2, D2) {
                r2 = e2.Typeface.MakeFreeTypeFaceFromData(r2);
                if (!r2) return null;
                D2 = x2(D2);
                this._registerFont(r2, D2);
              };
              e2.ParagraphStyle = function(r2) {
                r2.disableHinting = r2.disableHinting || false;
                if (r2.ellipsis) {
                  var D2 = r2.ellipsis;
                  r2._ellipsisPtr = x2(D2);
                  r2._ellipsisLen = qa(D2) + 1;
                } else r2._ellipsisPtr = W2, r2._ellipsisLen = 0;
                null == r2.heightMultiplier && (r2.heightMultiplier = -1);
                r2.maxLines = r2.maxLines || 0;
                r2.replaceTabCharacters = r2.replaceTabCharacters || false;
                D2 = (D2 = r2.strutStyle) || {};
                D2.strutEnabled = D2.strutEnabled || false;
                D2.strutEnabled && Array.isArray(D2.fontFamilies) && D2.fontFamilies.length ? (D2._fontFamiliesPtr = t2(D2.fontFamilies), D2._fontFamiliesLen = D2.fontFamilies.length) : (D2._fontFamiliesPtr = W2, D2._fontFamiliesLen = 0);
                D2.fontStyle = l2(D2.fontStyle);
                null == D2.fontSize && (D2.fontSize = -1);
                null == D2.heightMultiplier && (D2.heightMultiplier = -1);
                D2.halfLeading = D2.halfLeading || false;
                D2.leading = D2.leading || 0;
                D2.forceStrutHeight = D2.forceStrutHeight || false;
                r2.strutStyle = D2;
                r2.textAlign = r2.textAlign || e2.TextAlign.Start;
                r2.textDirection = r2.textDirection || e2.TextDirection.LTR;
                r2.textHeightBehavior = r2.textHeightBehavior || e2.TextHeightBehavior.All;
                r2.textStyle = e2.TextStyle(r2.textStyle);
                r2.applyRoundingHack = false !== r2.applyRoundingHack;
                return r2;
              };
              e2.TextStyle = function(r2) {
                r2.color || (r2.color = e2.BLACK);
                r2.decoration = r2.decoration || 0;
                r2.decorationThickness = r2.decorationThickness || 0;
                r2.decorationStyle = r2.decorationStyle || e2.DecorationStyle.Solid;
                r2.textBaseline = r2.textBaseline || e2.TextBaseline.Alphabetic;
                null == r2.fontSize && (r2.fontSize = -1);
                r2.letterSpacing = r2.letterSpacing || 0;
                r2.wordSpacing = r2.wordSpacing || 0;
                null == r2.heightMultiplier && (r2.heightMultiplier = -1);
                r2.halfLeading = r2.halfLeading || false;
                r2.fontStyle = l2(r2.fontStyle);
                return r2;
              };
              var P2 = {}, O2 = e2._malloc(16), Y2 = e2._malloc(16), aa = e2._malloc(16);
              e2.ParagraphBuilder.Make = function(r2, D2) {
                C2(r2.textStyle);
                D2 = e2.ParagraphBuilder._Make(r2, D2);
                J2(r2.textStyle);
                return D2;
              };
              e2.ParagraphBuilder.MakeFromFontProvider = function(r2, D2) {
                C2(r2.textStyle);
                D2 = e2.ParagraphBuilder._MakeFromFontProvider(r2, D2);
                J2(r2.textStyle);
                return D2;
              };
              e2.ParagraphBuilder.MakeFromFontCollection = function(r2, D2) {
                C2(r2.textStyle);
                D2 = e2.ParagraphBuilder._MakeFromFontCollection(r2, D2);
                J2(r2.textStyle);
                return D2;
              };
              e2.ParagraphBuilder.ShapeText = function(r2, D2, U2) {
                let ca2 = 0;
                for (const ka of D2) ca2 += ka.length;
                if (ca2 !== r2.length) throw "Accumulated block lengths must equal text.length";
                return e2.ParagraphBuilder._ShapeText(r2, D2, U2);
              };
              e2.ParagraphBuilder.prototype.pushStyle = function(r2) {
                C2(r2);
                this._pushStyle(r2);
                J2(r2);
              };
              e2.ParagraphBuilder.prototype.pushPaintStyle = function(r2, D2, U2) {
                C2(r2);
                this._pushPaintStyle(r2, D2, U2);
                J2(r2);
              };
              e2.ParagraphBuilder.prototype.addPlaceholder = function(r2, D2, U2, ca2, ka) {
                U2 = U2 || e2.PlaceholderAlignment.Baseline;
                ca2 = ca2 || e2.TextBaseline.Alphabetic;
                this._addPlaceholder(r2 || 0, D2 || 0, U2, ca2, ka || 0);
              };
              e2.ParagraphBuilder.prototype.setWordsUtf8 = function(r2) {
                var D2 = v2(r2, "HEAPU32");
                this._setWordsUtf8(D2, r2 && r2.length || 0);
                p2(D2, r2);
              };
              e2.ParagraphBuilder.prototype.setWordsUtf16 = function(r2) {
                var D2 = v2(r2, "HEAPU32");
                this._setWordsUtf16(
                  D2,
                  r2 && r2.length || 0
                );
                p2(D2, r2);
              };
              e2.ParagraphBuilder.prototype.setGraphemeBreaksUtf8 = function(r2) {
                var D2 = v2(r2, "HEAPU32");
                this._setGraphemeBreaksUtf8(D2, r2 && r2.length || 0);
                p2(D2, r2);
              };
              e2.ParagraphBuilder.prototype.setGraphemeBreaksUtf16 = function(r2) {
                var D2 = v2(r2, "HEAPU32");
                this._setGraphemeBreaksUtf16(D2, r2 && r2.length || 0);
                p2(D2, r2);
              };
              e2.ParagraphBuilder.prototype.setLineBreaksUtf8 = function(r2) {
                var D2 = v2(r2, "HEAPU32");
                this._setLineBreaksUtf8(D2, r2 && r2.length || 0);
                p2(D2, r2);
              };
              e2.ParagraphBuilder.prototype.setLineBreaksUtf16 = function(r2) {
                var D2 = v2(
                  r2,
                  "HEAPU32"
                );
                this._setLineBreaksUtf16(D2, r2 && r2.length || 0);
                p2(D2, r2);
              };
            });
          })(w2);
          a2.Td = a2.Td || [];
          a2.Td.push(function() {
            a2.Path.prototype.op = function(e2, d2) {
              return this._op(e2, d2) ? this : null;
            };
            a2.Path.prototype.simplify = function() {
              return this._simplify() ? this : null;
            };
          });
          a2.Td = a2.Td || [];
          a2.Td.push(function() {
            a2.Canvas.prototype.drawText = function(e2, d2, g2, l2, t2) {
              var x2 = qa(e2), C2 = a2._malloc(x2 + 1);
              ra(e2, K2, C2, x2 + 1);
              this._drawSimpleText(C2, x2, d2, g2, t2, l2);
              a2._free(C2);
            };
            a2.Canvas.prototype.drawGlyphs = function(e2, d2, g2, l2, t2, x2) {
              if (!(2 * e2.length <= d2.length)) throw "Not enough positions for the array of gyphs";
              a2.Md(this.Kd);
              const C2 = v2(e2, "HEAPU16"), J2 = v2(d2, "HEAPF32");
              this._drawGlyphs(e2.length, C2, J2, g2, l2, t2, x2);
              p2(J2, d2);
              p2(C2, e2);
            };
            a2.Font.prototype.getGlyphBounds = function(e2, d2, g2) {
              var l2 = v2(e2, "HEAPU16"), t2 = a2._malloc(16 * e2.length);
              this._getGlyphWidthBounds(l2, e2.length, W2, t2, d2 || null);
              d2 = new Float32Array(a2.HEAPU8.buffer, t2, 4 * e2.length);
              p2(l2, e2);
              if (g2) return g2.set(d2), a2._free(t2), g2;
              e2 = Float32Array.from(d2);
              a2._free(t2);
              return e2;
            };
            a2.Font.prototype.getGlyphIDs = function(e2, d2, g2) {
              d2 || (d2 = e2.length);
              var l2 = qa(e2) + 1, t2 = a2._malloc(l2);
              ra(e2, K2, t2, l2);
              e2 = a2._malloc(2 * d2);
              d2 = this._getGlyphIDs(t2, l2 - 1, d2, e2);
              a2._free(t2);
              if (0 > d2) return a2._free(e2), null;
              t2 = new Uint16Array(a2.HEAPU8.buffer, e2, d2);
              if (g2) return g2.set(t2), a2._free(e2), g2;
              g2 = Uint16Array.from(t2);
              a2._free(e2);
              return g2;
            };
            a2.Font.prototype.getGlyphIntercepts = function(e2, d2, g2, l2) {
              var t2 = v2(e2, "HEAPU16"), x2 = v2(d2, "HEAPF32");
              return this._getGlyphIntercepts(t2, e2.length, !(e2 && e2._ck), x2, d2.length, !(d2 && d2._ck), g2, l2);
            };
            a2.Font.prototype.getGlyphWidths = function(e2, d2, g2) {
              var l2 = v2(e2, "HEAPU16"), t2 = a2._malloc(4 * e2.length);
              this._getGlyphWidthBounds(
                l2,
                e2.length,
                t2,
                W2,
                d2 || null
              );
              d2 = new Float32Array(a2.HEAPU8.buffer, t2, e2.length);
              p2(l2, e2);
              if (g2) return g2.set(d2), a2._free(t2), g2;
              e2 = Float32Array.from(d2);
              a2._free(t2);
              return e2;
            };
            a2.FontMgr.FromData = function() {
              if (!arguments.length) return null;
              var e2 = arguments;
              1 === e2.length && Array.isArray(e2[0]) && (e2 = arguments[0]);
              if (!e2.length) return null;
              for (var d2 = [], g2 = [], l2 = 0; l2 < e2.length; l2++) {
                var t2 = new Uint8Array(e2[l2]), x2 = v2(t2, "HEAPU8");
                d2.push(x2);
                g2.push(t2.byteLength);
              }
              d2 = v2(d2, "HEAPU32");
              g2 = v2(g2, "HEAPU32");
              e2 = a2.FontMgr._fromData(d2, g2, e2.length);
              a2._free(d2);
              a2._free(g2);
              return e2;
            };
            a2.Typeface.MakeFreeTypeFaceFromData = function(e2) {
              e2 = new Uint8Array(e2);
              var d2 = v2(e2, "HEAPU8");
              return (e2 = a2.Typeface._MakeFreeTypeFaceFromData(d2, e2.byteLength)) ? e2 : null;
            };
            a2.Typeface.prototype.getGlyphIDs = function(e2, d2, g2) {
              d2 || (d2 = e2.length);
              var l2 = qa(e2) + 1, t2 = a2._malloc(l2);
              ra(e2, K2, t2, l2);
              e2 = a2._malloc(2 * d2);
              d2 = this._getGlyphIDs(t2, l2 - 1, d2, e2);
              a2._free(t2);
              if (0 > d2) return a2._free(e2), null;
              t2 = new Uint16Array(a2.HEAPU8.buffer, e2, d2);
              if (g2) return g2.set(t2), a2._free(e2), g2;
              g2 = Uint16Array.from(t2);
              a2._free(e2);
              return g2;
            };
            a2.TextBlob.MakeOnPath = function(e2, d2, g2, l2) {
              if (e2 && e2.length && d2 && d2.countPoints()) {
                if (1 === d2.countPoints()) return this.MakeFromText(e2, g2);
                l2 || (l2 = 0);
                var t2 = g2.getGlyphIDs(e2);
                t2 = g2.getGlyphWidths(t2);
                var x2 = [];
                d2 = new a2.ContourMeasureIter(d2, false, 1);
                for (var C2 = d2.next(), J2 = new Float32Array(4), P2 = 0; P2 < e2.length && C2; P2++) {
                  var O2 = t2[P2];
                  l2 += O2 / 2;
                  if (l2 > C2.length()) {
                    C2.delete();
                    C2 = d2.next();
                    if (!C2) {
                      e2 = e2.substring(0, P2);
                      break;
                    }
                    l2 = O2 / 2;
                  }
                  C2.getPosTan(l2, J2);
                  var Y2 = J2[2], aa = J2[3];
                  x2.push(Y2, aa, J2[0] - O2 / 2 * Y2, J2[1] - O2 / 2 * aa);
                  l2 += O2 / 2;
                }
                e2 = this.MakeFromRSXform(e2, x2, g2);
                C2 && C2.delete();
                d2.delete();
                return e2;
              }
            };
            a2.TextBlob.MakeFromRSXform = function(e2, d2, g2) {
              var l2 = qa(e2) + 1, t2 = a2._malloc(l2);
              ra(e2, K2, t2, l2);
              e2 = v2(d2, "HEAPF32");
              g2 = a2.TextBlob._MakeFromRSXform(t2, l2 - 1, e2, g2);
              a2._free(t2);
              return g2 ? g2 : null;
            };
            a2.TextBlob.MakeFromRSXformGlyphs = function(e2, d2, g2) {
              var l2 = v2(e2, "HEAPU16");
              d2 = v2(d2, "HEAPF32");
              g2 = a2.TextBlob._MakeFromRSXformGlyphs(l2, 2 * e2.length, d2, g2);
              p2(l2, e2);
              return g2 ? g2 : null;
            };
            a2.TextBlob.MakeFromGlyphs = function(e2, d2) {
              var g2 = v2(e2, "HEAPU16");
              d2 = a2.TextBlob._MakeFromGlyphs(g2, 2 * e2.length, d2);
              p2(g2, e2);
              return d2 ? d2 : null;
            };
            a2.TextBlob.MakeFromText = function(e2, d2) {
              var g2 = qa(e2) + 1, l2 = a2._malloc(g2);
              ra(e2, K2, l2, g2);
              e2 = a2.TextBlob._MakeFromText(l2, g2 - 1, d2);
              a2._free(l2);
              return e2 ? e2 : null;
            };
            a2.MallocGlyphIDs = function(e2) {
              return a2.Malloc(Uint16Array, e2);
            };
          });
          a2.Td = a2.Td || [];
          a2.Td.push(function() {
            a2.MakePicture = function(e2) {
              e2 = new Uint8Array(e2);
              var d2 = a2._malloc(e2.byteLength);
              a2.HEAPU8.set(e2, d2);
              return (e2 = a2._MakePicture(d2, e2.byteLength)) ? e2 : null;
            };
          });
          a2.Td = a2.Td || [];
          a2.Td.push(function() {
            a2.RuntimeEffect.Make = function(e2, d2) {
              return a2.RuntimeEffect._Make(e2, { onError: d2 || function(g2) {
                console.log(
                  "RuntimeEffect error",
                  g2
                );
              } });
            };
            a2.RuntimeEffect.MakeForBlender = function(e2, d2) {
              return a2.RuntimeEffect._MakeForBlender(e2, { onError: d2 || function(g2) {
                console.log("RuntimeEffect error", g2);
              } });
            };
            a2.RuntimeEffect.prototype.makeShader = function(e2, d2) {
              var g2 = !e2._ck, l2 = v2(e2, "HEAPF32");
              d2 = H2(d2);
              return this._makeShader(l2, 4 * e2.length, g2, d2);
            };
            a2.RuntimeEffect.prototype.makeShaderWithChildren = function(e2, d2, g2) {
              var l2 = !e2._ck, t2 = v2(e2, "HEAPF32");
              g2 = H2(g2);
              for (var x2 = [], C2 = 0; C2 < d2.length; C2++) x2.push(d2[C2].Jd.Rd);
              d2 = v2(x2, "HEAPU32");
              return this._makeShaderWithChildren(
                t2,
                4 * e2.length,
                l2,
                d2,
                x2.length,
                g2
              );
            };
            a2.RuntimeEffect.prototype.makeBlender = function(e2) {
              var d2 = !e2._ck, g2 = v2(e2, "HEAPF32");
              return this._makeBlender(g2, 4 * e2.length, d2);
            };
          });
          (function() {
            function e2(G2) {
              for (var k2 = 0; k2 < G2.length; k2++) if (void 0 !== G2[k2] && !Number.isFinite(G2[k2])) return false;
              return true;
            }
            function d2(G2) {
              var k2 = a2.getColorComponents(G2);
              G2 = k2[0];
              var q2 = k2[1], z2 = k2[2];
              k2 = k2[3];
              if (1 === k2) return G2 = G2.toString(16).toLowerCase(), q2 = q2.toString(16).toLowerCase(), z2 = z2.toString(16).toLowerCase(), G2 = 1 === G2.length ? "0" + G2 : G2, q2 = 1 === q2.length ? "0" + q2 : q2, z2 = 1 === z2.length ? "0" + z2 : z2, "#" + G2 + q2 + z2;
              k2 = 0 === k2 || 1 === k2 ? k2 : k2.toFixed(8);
              return "rgba(" + G2 + ", " + q2 + ", " + z2 + ", " + k2 + ")";
            }
            function g2(G2) {
              return a2.parseColorString(G2, va);
            }
            function l2(G2) {
              G2 = wa.exec(G2);
              if (!G2) return null;
              var k2 = parseFloat(G2[4]), q2 = 16;
              switch (G2[5]) {
                case "em":
                case "rem":
                  q2 = 16 * k2;
                  break;
                case "pt":
                  q2 = 4 * k2 / 3;
                  break;
                case "px":
                  q2 = k2;
                  break;
                case "pc":
                  q2 = 16 * k2;
                  break;
                case "in":
                  q2 = 96 * k2;
                  break;
                case "cm":
                  q2 = 96 * k2 / 2.54;
                  break;
                case "mm":
                  q2 = 96 / 25.4 * k2;
                  break;
                case "q":
                  q2 = 96 / 25.4 / 4 * k2;
                  break;
                case "%":
                  q2 = 16 / 75 * k2;
              }
              return { style: G2[1], variant: G2[2], weight: G2[3], sizePx: q2, family: G2[6].trim() };
            }
            function t2(G2) {
              this.Ld = G2;
              this.Od = new a2.Paint();
              this.Od.setAntiAlias(true);
              this.Od.setStrokeMiter(10);
              this.Od.setStrokeCap(a2.StrokeCap.Butt);
              this.Od.setStrokeJoin(a2.StrokeJoin.Miter);
              this.Re = "10px monospace";
              this.me = new a2.Font(null, 10);
              this.me.setSubpixel(true);
              this.ae = this.ge = a2.BLACK;
              this.ve = 0;
              this.Je = a2.TRANSPARENT;
              this.xe = this.we = 0;
              this.Ke = this.ie = 1;
              this.Ie = 0;
              this.ue = [];
              this.Nd = a2.BlendMode.SrcOver;
              this.Od.setStrokeWidth(this.Ke);
              this.Od.setBlendMode(this.Nd);
              this.Qd = new a2.Path();
              this.Sd = a2.Matrix.identity();
              this.lf = [];
              this.Be = [];
              this.le = function() {
                this.Qd.delete();
                this.Od.delete();
                this.me.delete();
                this.Be.forEach(function(k2) {
                  k2.le();
                });
              };
              Object.defineProperty(this, "currentTransform", { enumerable: true, get: function() {
                return { a: this.Sd[0], c: this.Sd[1], e: this.Sd[2], b: this.Sd[3], d: this.Sd[4], f: this.Sd[5] };
              }, set: function(k2) {
                k2.a && this.setTransform(k2.a, k2.b, k2.c, k2.d, k2.e, k2.f);
              } });
              Object.defineProperty(this, "fillStyle", { enumerable: true, get: function() {
                return f2(this.ae) ? d2(this.ae) : this.ae;
              }, set: function(k2) {
                "string" === typeof k2 ? this.ae = g2(k2) : k2.te && (this.ae = k2);
              } });
              Object.defineProperty(this, "font", { enumerable: true, get: function() {
                return this.Re;
              }, set: function(k2) {
                var q2 = l2(k2), z2 = q2.family;
                q2.typeface = na[z2] ? na[z2][(q2.style || "normal") + "|" + (q2.variant || "normal") + "|" + (q2.weight || "normal")] || na[z2]["*"] : null;
                q2 && (this.me.setSize(q2.sizePx), this.me.setTypeface(q2.typeface), this.Re = k2);
              } });
              Object.defineProperty(this, "globalAlpha", { enumerable: true, get: function() {
                return this.ie;
              }, set: function(k2) {
                !isFinite(k2) || 0 > k2 || 1 < k2 || (this.ie = k2);
              } });
              Object.defineProperty(
                this,
                "globalCompositeOperation",
                { enumerable: true, get: function() {
                  switch (this.Nd) {
                    case a2.BlendMode.SrcOver:
                      return "source-over";
                    case a2.BlendMode.DstOver:
                      return "destination-over";
                    case a2.BlendMode.Src:
                      return "copy";
                    case a2.BlendMode.Dst:
                      return "destination";
                    case a2.BlendMode.Clear:
                      return "clear";
                    case a2.BlendMode.SrcIn:
                      return "source-in";
                    case a2.BlendMode.DstIn:
                      return "destination-in";
                    case a2.BlendMode.SrcOut:
                      return "source-out";
                    case a2.BlendMode.DstOut:
                      return "destination-out";
                    case a2.BlendMode.SrcATop:
                      return "source-atop";
                    case a2.BlendMode.DstATop:
                      return "destination-atop";
                    case a2.BlendMode.Xor:
                      return "xor";
                    case a2.BlendMode.Plus:
                      return "lighter";
                    case a2.BlendMode.Multiply:
                      return "multiply";
                    case a2.BlendMode.Screen:
                      return "screen";
                    case a2.BlendMode.Overlay:
                      return "overlay";
                    case a2.BlendMode.Darken:
                      return "darken";
                    case a2.BlendMode.Lighten:
                      return "lighten";
                    case a2.BlendMode.ColorDodge:
                      return "color-dodge";
                    case a2.BlendMode.ColorBurn:
                      return "color-burn";
                    case a2.BlendMode.HardLight:
                      return "hard-light";
                    case a2.BlendMode.SoftLight:
                      return "soft-light";
                    case a2.BlendMode.Difference:
                      return "difference";
                    case a2.BlendMode.Exclusion:
                      return "exclusion";
                    case a2.BlendMode.Hue:
                      return "hue";
                    case a2.BlendMode.Saturation:
                      return "saturation";
                    case a2.BlendMode.Color:
                      return "color";
                    case a2.BlendMode.Luminosity:
                      return "luminosity";
                  }
                }, set: function(k2) {
                  switch (k2) {
                    case "source-over":
                      this.Nd = a2.BlendMode.SrcOver;
                      break;
                    case "destination-over":
                      this.Nd = a2.BlendMode.DstOver;
                      break;
                    case "copy":
                      this.Nd = a2.BlendMode.Src;
                      break;
                    case "destination":
                      this.Nd = a2.BlendMode.Dst;
                      break;
                    case "clear":
                      this.Nd = a2.BlendMode.Clear;
                      break;
                    case "source-in":
                      this.Nd = a2.BlendMode.SrcIn;
                      break;
                    case "destination-in":
                      this.Nd = a2.BlendMode.DstIn;
                      break;
                    case "source-out":
                      this.Nd = a2.BlendMode.SrcOut;
                      break;
                    case "destination-out":
                      this.Nd = a2.BlendMode.DstOut;
                      break;
                    case "source-atop":
                      this.Nd = a2.BlendMode.SrcATop;
                      break;
                    case "destination-atop":
                      this.Nd = a2.BlendMode.DstATop;
                      break;
                    case "xor":
                      this.Nd = a2.BlendMode.Xor;
                      break;
                    case "lighter":
                      this.Nd = a2.BlendMode.Plus;
                      break;
                    case "plus-lighter":
                      this.Nd = a2.BlendMode.Plus;
                      break;
                    case "plus-darker":
                      throw "plus-darker is not supported";
                    case "multiply":
                      this.Nd = a2.BlendMode.Multiply;
                      break;
                    case "screen":
                      this.Nd = a2.BlendMode.Screen;
                      break;
                    case "overlay":
                      this.Nd = a2.BlendMode.Overlay;
                      break;
                    case "darken":
                      this.Nd = a2.BlendMode.Darken;
                      break;
                    case "lighten":
                      this.Nd = a2.BlendMode.Lighten;
                      break;
                    case "color-dodge":
                      this.Nd = a2.BlendMode.ColorDodge;
                      break;
                    case "color-burn":
                      this.Nd = a2.BlendMode.ColorBurn;
                      break;
                    case "hard-light":
                      this.Nd = a2.BlendMode.HardLight;
                      break;
                    case "soft-light":
                      this.Nd = a2.BlendMode.SoftLight;
                      break;
                    case "difference":
                      this.Nd = a2.BlendMode.Difference;
                      break;
                    case "exclusion":
                      this.Nd = a2.BlendMode.Exclusion;
                      break;
                    case "hue":
                      this.Nd = a2.BlendMode.Hue;
                      break;
                    case "saturation":
                      this.Nd = a2.BlendMode.Saturation;
                      break;
                    case "color":
                      this.Nd = a2.BlendMode.Color;
                      break;
                    case "luminosity":
                      this.Nd = a2.BlendMode.Luminosity;
                      break;
                    default:
                      return;
                  }
                  this.Od.setBlendMode(this.Nd);
                } }
              );
              Object.defineProperty(this, "imageSmoothingEnabled", { enumerable: true, get: function() {
                return true;
              }, set: function() {
              } });
              Object.defineProperty(this, "imageSmoothingQuality", {
                enumerable: true,
                get: function() {
                  return "high";
                },
                set: function() {
                }
              });
              Object.defineProperty(this, "lineCap", { enumerable: true, get: function() {
                switch (this.Od.getStrokeCap()) {
                  case a2.StrokeCap.Butt:
                    return "butt";
                  case a2.StrokeCap.Round:
                    return "round";
                  case a2.StrokeCap.Square:
                    return "square";
                }
              }, set: function(k2) {
                switch (k2) {
                  case "butt":
                    this.Od.setStrokeCap(a2.StrokeCap.Butt);
                    break;
                  case "round":
                    this.Od.setStrokeCap(a2.StrokeCap.Round);
                    break;
                  case "square":
                    this.Od.setStrokeCap(a2.StrokeCap.Square);
                }
              } });
              Object.defineProperty(this, "lineDashOffset", {
                enumerable: true,
                get: function() {
                  return this.Ie;
                },
                set: function(k2) {
                  isFinite(k2) && (this.Ie = k2);
                }
              });
              Object.defineProperty(this, "lineJoin", { enumerable: true, get: function() {
                switch (this.Od.getStrokeJoin()) {
                  case a2.StrokeJoin.Miter:
                    return "miter";
                  case a2.StrokeJoin.Round:
                    return "round";
                  case a2.StrokeJoin.Bevel:
                    return "bevel";
                }
              }, set: function(k2) {
                switch (k2) {
                  case "miter":
                    this.Od.setStrokeJoin(a2.StrokeJoin.Miter);
                    break;
                  case "round":
                    this.Od.setStrokeJoin(a2.StrokeJoin.Round);
                    break;
                  case "bevel":
                    this.Od.setStrokeJoin(a2.StrokeJoin.Bevel);
                }
              } });
              Object.defineProperty(
                this,
                "lineWidth",
                { enumerable: true, get: function() {
                  return this.Od.getStrokeWidth();
                }, set: function(k2) {
                  0 >= k2 || !k2 || (this.Ke = k2, this.Od.setStrokeWidth(k2));
                } }
              );
              Object.defineProperty(this, "miterLimit", { enumerable: true, get: function() {
                return this.Od.getStrokeMiter();
              }, set: function(k2) {
                0 >= k2 || !k2 || this.Od.setStrokeMiter(k2);
              } });
              Object.defineProperty(this, "shadowBlur", { enumerable: true, get: function() {
                return this.ve;
              }, set: function(k2) {
                0 > k2 || !isFinite(k2) || (this.ve = k2);
              } });
              Object.defineProperty(this, "shadowColor", {
                enumerable: true,
                get: function() {
                  return d2(this.Je);
                },
                set: function(k2) {
                  this.Je = g2(k2);
                }
              });
              Object.defineProperty(this, "shadowOffsetX", { enumerable: true, get: function() {
                return this.we;
              }, set: function(k2) {
                isFinite(k2) && (this.we = k2);
              } });
              Object.defineProperty(this, "shadowOffsetY", { enumerable: true, get: function() {
                return this.xe;
              }, set: function(k2) {
                isFinite(k2) && (this.xe = k2);
              } });
              Object.defineProperty(this, "strokeStyle", { enumerable: true, get: function() {
                return d2(this.ge);
              }, set: function(k2) {
                "string" === typeof k2 ? this.ge = g2(k2) : k2.te && (this.ge = k2);
              } });
              this.arc = function(k2, q2, z2, B2, F2, I2) {
                r2(
                  this.Qd,
                  k2,
                  q2,
                  z2,
                  z2,
                  0,
                  B2,
                  F2,
                  I2
                );
              };
              this.arcTo = function(k2, q2, z2, B2, F2) {
                O2(this.Qd, k2, q2, z2, B2, F2);
              };
              this.beginPath = function() {
                this.Qd.delete();
                this.Qd = new a2.Path();
              };
              this.bezierCurveTo = function(k2, q2, z2, B2, F2, I2) {
                var M2 = this.Qd;
                e2([k2, q2, z2, B2, F2, I2]) && (M2.isEmpty() && M2.moveTo(k2, q2), M2.cubicTo(k2, q2, z2, B2, F2, I2));
              };
              this.clearRect = function(k2, q2, z2, B2) {
                this.Od.setStyle(a2.PaintStyle.Fill);
                this.Od.setBlendMode(a2.BlendMode.Clear);
                this.Ld.drawRect(a2.XYWHRect(k2, q2, z2, B2), this.Od);
                this.Od.setBlendMode(this.Nd);
              };
              this.clip = function(k2, q2) {
                "string" === typeof k2 ? (q2 = k2, k2 = this.Qd) : k2 && k2.af && (k2 = k2.Ud);
                k2 || (k2 = this.Qd);
                k2 = k2.copy();
                q2 && "evenodd" === q2.toLowerCase() ? k2.setFillType(a2.FillType.EvenOdd) : k2.setFillType(a2.FillType.Winding);
                this.Ld.clipPath(k2, a2.ClipOp.Intersect, true);
                k2.delete();
              };
              this.closePath = function() {
                Y2(this.Qd);
              };
              this.createImageData = function() {
                if (1 === arguments.length) {
                  var k2 = arguments[0];
                  return new J2(new Uint8ClampedArray(4 * k2.width * k2.height), k2.width, k2.height);
                }
                if (2 === arguments.length) {
                  k2 = arguments[0];
                  var q2 = arguments[1];
                  return new J2(new Uint8ClampedArray(4 * k2 * q2), k2, q2);
                }
                throw "createImageData expects 1 or 2 arguments, got " + arguments.length;
              };
              this.createLinearGradient = function(k2, q2, z2, B2) {
                if (e2(arguments)) {
                  var F2 = new P2(k2, q2, z2, B2);
                  this.Be.push(F2);
                  return F2;
                }
              };
              this.createPattern = function(k2, q2) {
                k2 = new ca2(k2, q2);
                this.Be.push(k2);
                return k2;
              };
              this.createRadialGradient = function(k2, q2, z2, B2, F2, I2) {
                if (e2(arguments)) {
                  var M2 = new ka(k2, q2, z2, B2, F2, I2);
                  this.Be.push(M2);
                  return M2;
                }
              };
              this.drawImage = function(k2) {
                k2 instanceof C2 && (k2 = k2.tf());
                var q2 = this.Qe();
                if (3 === arguments.length || 5 === arguments.length) var z2 = a2.XYWHRect(
                  arguments[1],
                  arguments[2],
                  arguments[3] || k2.width(),
                  arguments[4] || k2.height()
                ), B2 = a2.XYWHRect(0, 0, k2.width(), k2.height());
                else if (9 === arguments.length) z2 = a2.XYWHRect(arguments[5], arguments[6], arguments[7], arguments[8]), B2 = a2.XYWHRect(arguments[1], arguments[2], arguments[3], arguments[4]);
                else throw "invalid number of args for drawImage, need 3, 5, or 9; got " + arguments.length;
                this.Ld.drawImageRect(k2, B2, z2, q2, false);
                q2.dispose();
              };
              this.ellipse = function(k2, q2, z2, B2, F2, I2, M2, da) {
                r2(this.Qd, k2, q2, z2, B2, F2, I2, M2, da);
              };
              this.Qe = function() {
                var k2 = this.Od.copy();
                k2.setStyle(a2.PaintStyle.Fill);
                if (f2(this.ae)) {
                  var q2 = a2.multiplyByAlpha(this.ae, this.ie);
                  k2.setColor(q2);
                } else q2 = this.ae.te(this.Sd), k2.setColor(a2.Color(0, 0, 0, this.ie)), k2.setShader(q2);
                k2.dispose = function() {
                  this.delete();
                };
                return k2;
              };
              this.fill = function(k2, q2) {
                "string" === typeof k2 ? (q2 = k2, k2 = this.Qd) : k2 && k2.af && (k2 = k2.Ud);
                if ("evenodd" === q2) this.Qd.setFillType(a2.FillType.EvenOdd);
                else {
                  if ("nonzero" !== q2 && q2) throw "invalid fill rule";
                  this.Qd.setFillType(a2.FillType.Winding);
                }
                k2 || (k2 = this.Qd);
                q2 = this.Qe();
                var z2 = this.ye(q2);
                z2 && (this.Ld.save(), this.re(), this.Ld.drawPath(
                  k2,
                  z2
                ), this.Ld.restore(), z2.dispose());
                this.Ld.drawPath(k2, q2);
                q2.dispose();
              };
              this.fillRect = function(k2, q2, z2, B2) {
                var F2 = this.Qe(), I2 = this.ye(F2);
                I2 && (this.Ld.save(), this.re(), this.Ld.drawRect(a2.XYWHRect(k2, q2, z2, B2), I2), this.Ld.restore(), I2.dispose());
                this.Ld.drawRect(a2.XYWHRect(k2, q2, z2, B2), F2);
                F2.dispose();
              };
              this.fillText = function(k2, q2, z2) {
                var B2 = this.Qe();
                k2 = a2.TextBlob.MakeFromText(k2, this.me);
                var F2 = this.ye(B2);
                F2 && (this.Ld.save(), this.re(), this.Ld.drawTextBlob(k2, q2, z2, F2), this.Ld.restore(), F2.dispose());
                this.Ld.drawTextBlob(k2, q2, z2, B2);
                k2.delete();
                B2.dispose();
              };
              this.getImageData = function(k2, q2, z2, B2) {
                return (k2 = this.Ld.readPixels(k2, q2, { width: z2, height: B2, colorType: a2.ColorType.RGBA_8888, alphaType: a2.AlphaType.Unpremul, colorSpace: a2.ColorSpace.SRGB })) ? new J2(new Uint8ClampedArray(k2.buffer), z2, B2) : null;
              };
              this.getLineDash = function() {
                return this.ue.slice();
              };
              this.mf = function(k2) {
                var q2 = a2.Matrix.invert(this.Sd);
                a2.Matrix.mapPoints(q2, k2);
                return k2;
              };
              this.isPointInPath = function(k2, q2, z2) {
                var B2 = arguments;
                if (3 === B2.length) var F2 = this.Qd;
                else if (4 === B2.length) F2 = B2[0], k2 = B2[1], q2 = B2[2], z2 = B2[3];
                else throw "invalid arg count, need 3 or 4, got " + B2.length;
                if (!isFinite(k2) || !isFinite(q2)) return false;
                z2 = z2 || "nonzero";
                if ("nonzero" !== z2 && "evenodd" !== z2) return false;
                B2 = this.mf([k2, q2]);
                k2 = B2[0];
                q2 = B2[1];
                F2.setFillType("nonzero" === z2 ? a2.FillType.Winding : a2.FillType.EvenOdd);
                return F2.contains(k2, q2);
              };
              this.isPointInStroke = function(k2, q2) {
                var z2 = arguments;
                if (2 === z2.length) var B2 = this.Qd;
                else if (3 === z2.length) B2 = z2[0], k2 = z2[1], q2 = z2[2];
                else throw "invalid arg count, need 2 or 3, got " + z2.length;
                if (!isFinite(k2) || !isFinite(q2)) return false;
                z2 = this.mf([k2, q2]);
                k2 = z2[0];
                q2 = z2[1];
                B2 = B2.copy();
                B2.setFillType(a2.FillType.Winding);
                B2.stroke({ width: this.lineWidth, miter_limit: this.miterLimit, cap: this.Od.getStrokeCap(), join: this.Od.getStrokeJoin(), precision: 0.3 });
                z2 = B2.contains(k2, q2);
                B2.delete();
                return z2;
              };
              this.lineTo = function(k2, q2) {
                D2(this.Qd, k2, q2);
              };
              this.measureText = function(k2) {
                k2 = this.me.getGlyphIDs(k2);
                k2 = this.me.getGlyphWidths(k2);
                let q2 = 0;
                for (const z2 of k2) q2 += z2;
                return { width: q2 };
              };
              this.moveTo = function(k2, q2) {
                var z2 = this.Qd;
                e2([k2, q2]) && z2.moveTo(k2, q2);
              };
              this.putImageData = function(k2, q2, z2, B2, F2, I2, M2) {
                if (e2([q2, z2, B2, F2, I2, M2])) {
                  if (void 0 === B2) this.Ld.writePixels(k2.data, k2.width, k2.height, q2, z2);
                  else if (B2 = B2 || 0, F2 = F2 || 0, I2 = I2 || k2.width, M2 = M2 || k2.height, 0 > I2 && (B2 += I2, I2 = Math.abs(I2)), 0 > M2 && (F2 += M2, M2 = Math.abs(M2)), 0 > B2 && (I2 += B2, B2 = 0), 0 > F2 && (M2 += F2, F2 = 0), !(0 >= I2 || 0 >= M2)) {
                    k2 = a2.MakeImage({ width: k2.width, height: k2.height, alphaType: a2.AlphaType.Unpremul, colorType: a2.ColorType.RGBA_8888, colorSpace: a2.ColorSpace.SRGB }, k2.data, 4 * k2.width);
                    var da = a2.XYWHRect(B2, F2, I2, M2);
                    q2 = a2.XYWHRect(q2 + B2, z2 + F2, I2, M2);
                    z2 = a2.Matrix.invert(this.Sd);
                    this.Ld.save();
                    this.Ld.concat(z2);
                    this.Ld.drawImageRect(k2, da, q2, null, false);
                    this.Ld.restore();
                    k2.delete();
                  }
                }
              };
              this.quadraticCurveTo = function(k2, q2, z2, B2) {
                var F2 = this.Qd;
                e2([k2, q2, z2, B2]) && (F2.isEmpty() && F2.moveTo(k2, q2), F2.quadTo(k2, q2, z2, B2));
              };
              this.rect = function(k2, q2, z2, B2) {
                var F2 = this.Qd;
                k2 = a2.XYWHRect(k2, q2, z2, B2);
                e2(k2) && F2.addRect(k2);
              };
              this.resetTransform = function() {
                this.Qd.transform(this.Sd);
                var k2 = a2.Matrix.invert(this.Sd);
                this.Ld.concat(k2);
                this.Sd = this.Ld.getTotalMatrix();
              };
              this.restore = function() {
                var k2 = this.lf.pop();
                if (k2) {
                  var q2 = a2.Matrix.multiply(this.Sd, a2.Matrix.invert(k2.Jf));
                  this.Qd.transform(q2);
                  this.Od.delete();
                  this.Od = k2.ag;
                  this.ue = k2.Zf;
                  this.Ke = k2.mg;
                  this.ge = k2.lg;
                  this.ae = k2.fs;
                  this.we = k2.jg;
                  this.xe = k2.kg;
                  this.ve = k2.sb;
                  this.Je = k2.ig;
                  this.ie = k2.ga;
                  this.Nd = k2.Qf;
                  this.Ie = k2.$f;
                  this.Re = k2.Pf;
                  this.Ld.restore();
                  this.Sd = this.Ld.getTotalMatrix();
                }
              };
              this.rotate = function(k2) {
                if (isFinite(k2)) {
                  var q2 = a2.Matrix.rotated(-k2);
                  this.Qd.transform(q2);
                  this.Ld.rotate(k2 / Math.PI * 180, 0, 0);
                  this.Sd = this.Ld.getTotalMatrix();
                }
              };
              this.save = function() {
                if (this.ae.se) {
                  var k2 = this.ae.se();
                  this.Be.push(k2);
                } else k2 = this.ae;
                if (this.ge.se) {
                  var q2 = this.ge.se();
                  this.Be.push(q2);
                } else q2 = this.ge;
                this.lf.push({ Jf: this.Sd.slice(), Zf: this.ue.slice(), mg: this.Ke, lg: q2, fs: k2, jg: this.we, kg: this.xe, sb: this.ve, ig: this.Je, ga: this.ie, $f: this.Ie, Qf: this.Nd, ag: this.Od.copy(), Pf: this.Re });
                this.Ld.save();
              };
              this.scale = function(k2, q2) {
                if (e2(arguments)) {
                  var z2 = a2.Matrix.scaled(1 / k2, 1 / q2);
                  this.Qd.transform(z2);
                  this.Ld.scale(k2, q2);
                  this.Sd = this.Ld.getTotalMatrix();
                }
              };
              this.setLineDash = function(k2) {
                for (var q2 = 0; q2 < k2.length; q2++) if (!isFinite(k2[q2]) || 0 > k2[q2]) return;
                1 === k2.length % 2 && Array.prototype.push.apply(k2, k2);
                this.ue = k2;
              };
              this.setTransform = function(k2, q2, z2, B2, F2, I2) {
                e2(arguments) && (this.resetTransform(), this.transform(k2, q2, z2, B2, F2, I2));
              };
              this.re = function() {
                var k2 = a2.Matrix.invert(this.Sd);
                this.Ld.concat(k2);
                this.Ld.concat(a2.Matrix.translated(this.we, this.xe));
                this.Ld.concat(this.Sd);
              };
              this.ye = function(k2) {
                var q2 = a2.multiplyByAlpha(this.Je, this.ie);
                if (!a2.getColorComponents(q2)[3] || !(this.ve || this.xe || this.we)) return null;
                k2 = k2.copy();
                k2.setColor(q2);
                var z2 = a2.MaskFilter.MakeBlur(
                  a2.BlurStyle.Normal,
                  this.ve / 2,
                  false
                );
                k2.setMaskFilter(z2);
                k2.dispose = function() {
                  z2.delete();
                  this.delete();
                };
                return k2;
              };
              this.cf = function() {
                var k2 = this.Od.copy();
                k2.setStyle(a2.PaintStyle.Stroke);
                if (f2(this.ge)) {
                  var q2 = a2.multiplyByAlpha(this.ge, this.ie);
                  k2.setColor(q2);
                } else q2 = this.ge.te(this.Sd), k2.setColor(a2.Color(0, 0, 0, this.ie)), k2.setShader(q2);
                k2.setStrokeWidth(this.Ke);
                if (this.ue.length) {
                  var z2 = a2.PathEffect.MakeDash(this.ue, this.Ie);
                  k2.setPathEffect(z2);
                }
                k2.dispose = function() {
                  z2 && z2.delete();
                  this.delete();
                };
                return k2;
              };
              this.stroke = function(k2) {
                k2 = k2 ? k2.Ud : this.Qd;
                var q2 = this.cf(), z2 = this.ye(q2);
                z2 && (this.Ld.save(), this.re(), this.Ld.drawPath(k2, z2), this.Ld.restore(), z2.dispose());
                this.Ld.drawPath(k2, q2);
                q2.dispose();
              };
              this.strokeRect = function(k2, q2, z2, B2) {
                var F2 = this.cf(), I2 = this.ye(F2);
                I2 && (this.Ld.save(), this.re(), this.Ld.drawRect(a2.XYWHRect(k2, q2, z2, B2), I2), this.Ld.restore(), I2.dispose());
                this.Ld.drawRect(a2.XYWHRect(k2, q2, z2, B2), F2);
                F2.dispose();
              };
              this.strokeText = function(k2, q2, z2) {
                var B2 = this.cf();
                k2 = a2.TextBlob.MakeFromText(k2, this.me);
                var F2 = this.ye(B2);
                F2 && (this.Ld.save(), this.re(), this.Ld.drawTextBlob(k2, q2, z2, F2), this.Ld.restore(), F2.dispose());
                this.Ld.drawTextBlob(k2, q2, z2, B2);
                k2.delete();
                B2.dispose();
              };
              this.translate = function(k2, q2) {
                if (e2(arguments)) {
                  var z2 = a2.Matrix.translated(-k2, -q2);
                  this.Qd.transform(z2);
                  this.Ld.translate(k2, q2);
                  this.Sd = this.Ld.getTotalMatrix();
                }
              };
              this.transform = function(k2, q2, z2, B2, F2, I2) {
                k2 = [k2, z2, F2, q2, B2, I2, 0, 0, 1];
                q2 = a2.Matrix.invert(k2);
                this.Qd.transform(q2);
                this.Ld.concat(k2);
                this.Sd = this.Ld.getTotalMatrix();
              };
              this.addHitRegion = function() {
              };
              this.clearHitRegions = function() {
              };
              this.drawFocusIfNeeded = function() {
              };
              this.removeHitRegion = function() {
              };
              this.scrollPathIntoView = function() {
              };
              Object.defineProperty(this, "canvas", { value: null, writable: false });
            }
            function x2(G2) {
              this.df = G2;
              this.Kd = new t2(G2.getCanvas());
              this.Se = [];
              this.decodeImage = function(k2) {
                k2 = a2.MakeImageFromEncoded(k2);
                if (!k2) throw "Invalid input";
                this.Se.push(k2);
                return new C2(k2);
              };
              this.loadFont = function(k2, q2) {
                k2 = a2.Typeface.MakeFreeTypeFaceFromData(k2);
                if (!k2) return null;
                this.Se.push(k2);
                var z2 = (q2.style || "normal") + "|" + (q2.variant || "normal") + "|" + (q2.weight || "normal");
                q2 = q2.family;
                na[q2] || (na[q2] = { "*": k2 });
                na[q2][z2] = k2;
              };
              this.makePath2D = function(k2) {
                k2 = new U2(k2);
                this.Se.push(k2.Ud);
                return k2;
              };
              this.getContext = function(k2) {
                return "2d" === k2 ? this.Kd : null;
              };
              this.toDataURL = function(k2, q2) {
                this.df.flush();
                var z2 = this.df.makeImageSnapshot();
                if (z2) {
                  k2 = k2 || "image/png";
                  var B2 = a2.ImageFormat.PNG;
                  "image/jpeg" === k2 && (B2 = a2.ImageFormat.JPEG);
                  if (q2 = z2.encodeToBytes(B2, q2 || 0.92)) {
                    z2.delete();
                    k2 = "data:" + k2 + ";base64,";
                    if ("undefined" !== typeof Buffer) q2 = Buffer.from(q2).toString("base64");
                    else {
                      z2 = 0;
                      B2 = q2.length;
                      for (var F2 = "", I2; z2 < B2; ) I2 = q2.slice(z2, Math.min(z2 + 32768, B2)), F2 += String.fromCharCode.apply(null, I2), z2 += 32768;
                      q2 = btoa(F2);
                    }
                    return k2 + q2;
                  }
                }
              };
              this.dispose = function() {
                this.Kd.le();
                this.Se.forEach(function(k2) {
                  k2.delete();
                });
                this.df.dispose();
              };
            }
            function C2(G2) {
              this.width = G2.width();
              this.height = G2.height();
              this.naturalWidth = this.width;
              this.naturalHeight = this.height;
              this.tf = function() {
                return G2;
              };
            }
            function J2(G2, k2, q2) {
              if (!k2 || 0 === q2) throw "invalid dimensions, width and height must be non-zero";
              if (G2.length % 4) throw "arr must be a multiple of 4";
              q2 = q2 || G2.length / (4 * k2);
              Object.defineProperty(this, "data", { value: G2, writable: false });
              Object.defineProperty(this, "height", { value: q2, writable: false });
              Object.defineProperty(this, "width", { value: k2, writable: false });
            }
            function P2(G2, k2, q2, z2) {
              this.Wd = null;
              this.ce = [];
              this.Zd = [];
              this.addColorStop = function(B2, F2) {
                if (0 > B2 || 1 < B2 || !isFinite(B2)) throw "offset must be between 0 and 1 inclusively";
                F2 = g2(F2);
                var I2 = this.Zd.indexOf(B2);
                if (-1 !== I2) this.ce[I2] = F2;
                else {
                  for (I2 = 0; I2 < this.Zd.length && !(this.Zd[I2] > B2); I2++) ;
                  this.Zd.splice(I2, 0, B2);
                  this.ce.splice(I2, 0, F2);
                }
              };
              this.se = function() {
                var B2 = new P2(G2, k2, q2, z2);
                B2.ce = this.ce.slice();
                B2.Zd = this.Zd.slice();
                return B2;
              };
              this.le = function() {
                this.Wd && (this.Wd.delete(), this.Wd = null);
              };
              this.te = function(B2) {
                var F2 = [G2, k2, q2, z2];
                a2.Matrix.mapPoints(B2, F2);
                B2 = F2[0];
                var I2 = F2[1], M2 = F2[2];
                F2 = F2[3];
                this.le();
                return this.Wd = a2.Shader.MakeLinearGradient([B2, I2], [M2, F2], this.ce, this.Zd, a2.TileMode.Clamp);
              };
            }
            function O2(G2, k2, q2, z2, B2, F2) {
              if (e2([k2, q2, z2, B2, F2])) {
                if (0 > F2) throw "radii cannot be negative";
                G2.isEmpty() && G2.moveTo(k2, q2);
                G2.arcToTangent(k2, q2, z2, B2, F2);
              }
            }
            function Y2(G2) {
              if (!G2.isEmpty()) {
                var k2 = G2.getBounds();
                (k2[3] - k2[1] || k2[2] - k2[0]) && G2.close();
              }
            }
            function aa(G2, k2, q2, z2, B2, F2, I2) {
              I2 = (I2 - F2) / Math.PI * 180;
              F2 = F2 / Math.PI * 180;
              k2 = a2.LTRBRect(k2 - z2, q2 - B2, k2 + z2, q2 + B2);
              1e-5 > Math.abs(Math.abs(I2) - 360) ? (q2 = I2 / 2, G2.arcToOval(k2, F2, q2, false), G2.arcToOval(k2, F2 + q2, q2, false)) : G2.arcToOval(k2, F2, I2, false);
            }
            function r2(G2, k2, q2, z2, B2, F2, I2, M2, da) {
              if (e2([k2, q2, z2, B2, F2, I2, M2])) {
                if (0 > z2 || 0 > B2) throw "radii cannot be negative";
                var ea = 2 * Math.PI, Ia = I2 % ea;
                0 > Ia && (Ia += ea);
                var ab = Ia - I2;
                I2 = Ia;
                M2 += ab;
                !da && M2 - I2 >= ea ? M2 = I2 + ea : da && I2 - M2 >= ea ? M2 = I2 - ea : !da && I2 > M2 ? M2 = I2 + (ea - (I2 - M2) % ea) : da && I2 < M2 && (M2 = I2 - (ea - (M2 - I2) % ea));
                F2 ? (da = a2.Matrix.rotated(F2, k2, q2), F2 = a2.Matrix.rotated(-F2, k2, q2), G2.transform(F2), aa(G2, k2, q2, z2, B2, I2, M2), G2.transform(da)) : aa(G2, k2, q2, z2, B2, I2, M2);
              }
            }
            function D2(G2, k2, q2) {
              e2([k2, q2]) && (G2.isEmpty() && G2.moveTo(k2, q2), G2.lineTo(k2, q2));
            }
            function U2(G2) {
              this.Ud = null;
              this.Ud = "string" === typeof G2 ? a2.Path.MakeFromSVGString(G2) : G2 && G2.af ? G2.Ud.copy() : new a2.Path();
              this.af = function() {
                return this.Ud;
              };
              this.addPath = function(k2, q2) {
                q2 || (q2 = { a: 1, c: 0, e: 0, b: 0, d: 1, f: 0 });
                this.Ud.addPath(k2.Ud, [q2.a, q2.c, q2.e, q2.b, q2.d, q2.f]);
              };
              this.arc = function(k2, q2, z2, B2, F2, I2) {
                r2(
                  this.Ud,
                  k2,
                  q2,
                  z2,
                  z2,
                  0,
                  B2,
                  F2,
                  I2
                );
              };
              this.arcTo = function(k2, q2, z2, B2, F2) {
                O2(this.Ud, k2, q2, z2, B2, F2);
              };
              this.bezierCurveTo = function(k2, q2, z2, B2, F2, I2) {
                var M2 = this.Ud;
                e2([k2, q2, z2, B2, F2, I2]) && (M2.isEmpty() && M2.moveTo(k2, q2), M2.cubicTo(k2, q2, z2, B2, F2, I2));
              };
              this.closePath = function() {
                Y2(this.Ud);
              };
              this.ellipse = function(k2, q2, z2, B2, F2, I2, M2, da) {
                r2(this.Ud, k2, q2, z2, B2, F2, I2, M2, da);
              };
              this.lineTo = function(k2, q2) {
                D2(this.Ud, k2, q2);
              };
              this.moveTo = function(k2, q2) {
                var z2 = this.Ud;
                e2([k2, q2]) && z2.moveTo(k2, q2);
              };
              this.quadraticCurveTo = function(k2, q2, z2, B2) {
                var F2 = this.Ud;
                e2([k2, q2, z2, B2]) && (F2.isEmpty() && F2.moveTo(k2, q2), F2.quadTo(k2, q2, z2, B2));
              };
              this.rect = function(k2, q2, z2, B2) {
                var F2 = this.Ud;
                k2 = a2.XYWHRect(k2, q2, z2, B2);
                e2(k2) && F2.addRect(k2);
              };
            }
            function ca2(G2, k2) {
              this.Wd = null;
              G2 instanceof C2 && (G2 = G2.tf());
              this.Ef = G2;
              this._transform = a2.Matrix.identity();
              "" === k2 && (k2 = "repeat");
              switch (k2) {
                case "repeat-x":
                  this.ze = a2.TileMode.Repeat;
                  this.Ae = a2.TileMode.Decal;
                  break;
                case "repeat-y":
                  this.ze = a2.TileMode.Decal;
                  this.Ae = a2.TileMode.Repeat;
                  break;
                case "repeat":
                  this.Ae = this.ze = a2.TileMode.Repeat;
                  break;
                case "no-repeat":
                  this.Ae = this.ze = a2.TileMode.Decal;
                  break;
                default:
                  throw "invalid repetition mode " + k2;
              }
              this.setTransform = function(q2) {
                q2 = [q2.a, q2.c, q2.e, q2.b, q2.d, q2.f, 0, 0, 1];
                e2(q2) && (this._transform = q2);
              };
              this.se = function() {
                var q2 = new ca2();
                q2.ze = this.ze;
                q2.Ae = this.Ae;
                return q2;
              };
              this.le = function() {
                this.Wd && (this.Wd.delete(), this.Wd = null);
              };
              this.te = function() {
                this.le();
                return this.Wd = this.Ef.makeShaderCubic(this.ze, this.Ae, 1 / 3, 1 / 3, this._transform);
              };
            }
            function ka(G2, k2, q2, z2, B2, F2) {
              this.Wd = null;
              this.ce = [];
              this.Zd = [];
              this.addColorStop = function(I2, M2) {
                if (0 > I2 || 1 < I2 || !isFinite(I2)) throw "offset must be between 0 and 1 inclusively";
                M2 = g2(M2);
                var da = this.Zd.indexOf(I2);
                if (-1 !== da) this.ce[da] = M2;
                else {
                  for (da = 0; da < this.Zd.length && !(this.Zd[da] > I2); da++) ;
                  this.Zd.splice(da, 0, I2);
                  this.ce.splice(da, 0, M2);
                }
              };
              this.se = function() {
                var I2 = new ka(G2, k2, q2, z2, B2, F2);
                I2.ce = this.ce.slice();
                I2.Zd = this.Zd.slice();
                return I2;
              };
              this.le = function() {
                this.Wd && (this.Wd.delete(), this.Wd = null);
              };
              this.te = function(I2) {
                var M2 = [G2, k2, z2, B2];
                a2.Matrix.mapPoints(I2, M2);
                var da = M2[0], ea = M2[1], Ia = M2[2];
                M2 = M2[3];
                var ab = (Math.abs(I2[0]) + Math.abs(I2[4])) / 2;
                I2 = q2 * ab;
                ab *= F2;
                this.le();
                return this.Wd = a2.Shader.MakeTwoPointConicalGradient([
                  da,
                  ea
                ], I2, [Ia, M2], ab, this.ce, this.Zd, a2.TileMode.Clamp);
              };
            }
            a2._testing = {};
            var va = {
              aliceblue: Float32Array.of(0.941, 0.973, 1, 1),
              antiquewhite: Float32Array.of(0.98, 0.922, 0.843, 1),
              aqua: Float32Array.of(0, 1, 1, 1),
              aquamarine: Float32Array.of(0.498, 1, 0.831, 1),
              azure: Float32Array.of(0.941, 1, 1, 1),
              beige: Float32Array.of(0.961, 0.961, 0.863, 1),
              bisque: Float32Array.of(1, 0.894, 0.769, 1),
              black: Float32Array.of(0, 0, 0, 1),
              blanchedalmond: Float32Array.of(1, 0.922, 0.804, 1),
              blue: Float32Array.of(0, 0, 1, 1),
              blueviolet: Float32Array.of(0.541, 0.169, 0.886, 1),
              brown: Float32Array.of(
                0.647,
                0.165,
                0.165,
                1
              ),
              burlywood: Float32Array.of(0.871, 0.722, 0.529, 1),
              cadetblue: Float32Array.of(0.373, 0.62, 0.627, 1),
              chartreuse: Float32Array.of(0.498, 1, 0, 1),
              chocolate: Float32Array.of(0.824, 0.412, 0.118, 1),
              coral: Float32Array.of(1, 0.498, 0.314, 1),
              cornflowerblue: Float32Array.of(0.392, 0.584, 0.929, 1),
              cornsilk: Float32Array.of(1, 0.973, 0.863, 1),
              crimson: Float32Array.of(0.863, 0.078, 0.235, 1),
              cyan: Float32Array.of(0, 1, 1, 1),
              darkblue: Float32Array.of(0, 0, 0.545, 1),
              darkcyan: Float32Array.of(0, 0.545, 0.545, 1),
              darkgoldenrod: Float32Array.of(
                0.722,
                0.525,
                0.043,
                1
              ),
              darkgray: Float32Array.of(0.663, 0.663, 0.663, 1),
              darkgreen: Float32Array.of(0, 0.392, 0, 1),
              darkgrey: Float32Array.of(0.663, 0.663, 0.663, 1),
              darkkhaki: Float32Array.of(0.741, 0.718, 0.42, 1),
              darkmagenta: Float32Array.of(0.545, 0, 0.545, 1),
              darkolivegreen: Float32Array.of(0.333, 0.42, 0.184, 1),
              darkorange: Float32Array.of(1, 0.549, 0, 1),
              darkorchid: Float32Array.of(0.6, 0.196, 0.8, 1),
              darkred: Float32Array.of(0.545, 0, 0, 1),
              darksalmon: Float32Array.of(0.914, 0.588, 0.478, 1),
              darkseagreen: Float32Array.of(0.561, 0.737, 0.561, 1),
              darkslateblue: Float32Array.of(
                0.282,
                0.239,
                0.545,
                1
              ),
              darkslategray: Float32Array.of(0.184, 0.31, 0.31, 1),
              darkslategrey: Float32Array.of(0.184, 0.31, 0.31, 1),
              darkturquoise: Float32Array.of(0, 0.808, 0.82, 1),
              darkviolet: Float32Array.of(0.58, 0, 0.827, 1),
              deeppink: Float32Array.of(1, 0.078, 0.576, 1),
              deepskyblue: Float32Array.of(0, 0.749, 1, 1),
              dimgray: Float32Array.of(0.412, 0.412, 0.412, 1),
              dimgrey: Float32Array.of(0.412, 0.412, 0.412, 1),
              dodgerblue: Float32Array.of(0.118, 0.565, 1, 1),
              firebrick: Float32Array.of(0.698, 0.133, 0.133, 1),
              floralwhite: Float32Array.of(1, 0.98, 0.941, 1),
              forestgreen: Float32Array.of(
                0.133,
                0.545,
                0.133,
                1
              ),
              fuchsia: Float32Array.of(1, 0, 1, 1),
              gainsboro: Float32Array.of(0.863, 0.863, 0.863, 1),
              ghostwhite: Float32Array.of(0.973, 0.973, 1, 1),
              gold: Float32Array.of(1, 0.843, 0, 1),
              goldenrod: Float32Array.of(0.855, 0.647, 0.125, 1),
              gray: Float32Array.of(0.502, 0.502, 0.502, 1),
              green: Float32Array.of(0, 0.502, 0, 1),
              greenyellow: Float32Array.of(0.678, 1, 0.184, 1),
              grey: Float32Array.of(0.502, 0.502, 0.502, 1),
              honeydew: Float32Array.of(0.941, 1, 0.941, 1),
              hotpink: Float32Array.of(1, 0.412, 0.706, 1),
              indianred: Float32Array.of(0.804, 0.361, 0.361, 1),
              indigo: Float32Array.of(
                0.294,
                0,
                0.51,
                1
              ),
              ivory: Float32Array.of(1, 1, 0.941, 1),
              khaki: Float32Array.of(0.941, 0.902, 0.549, 1),
              lavender: Float32Array.of(0.902, 0.902, 0.98, 1),
              lavenderblush: Float32Array.of(1, 0.941, 0.961, 1),
              lawngreen: Float32Array.of(0.486, 0.988, 0, 1),
              lemonchiffon: Float32Array.of(1, 0.98, 0.804, 1),
              lightblue: Float32Array.of(0.678, 0.847, 0.902, 1),
              lightcoral: Float32Array.of(0.941, 0.502, 0.502, 1),
              lightcyan: Float32Array.of(0.878, 1, 1, 1),
              lightgoldenrodyellow: Float32Array.of(0.98, 0.98, 0.824, 1),
              lightgray: Float32Array.of(0.827, 0.827, 0.827, 1),
              lightgreen: Float32Array.of(
                0.565,
                0.933,
                0.565,
                1
              ),
              lightgrey: Float32Array.of(0.827, 0.827, 0.827, 1),
              lightpink: Float32Array.of(1, 0.714, 0.757, 1),
              lightsalmon: Float32Array.of(1, 0.627, 0.478, 1),
              lightseagreen: Float32Array.of(0.125, 0.698, 0.667, 1),
              lightskyblue: Float32Array.of(0.529, 0.808, 0.98, 1),
              lightslategray: Float32Array.of(0.467, 0.533, 0.6, 1),
              lightslategrey: Float32Array.of(0.467, 0.533, 0.6, 1),
              lightsteelblue: Float32Array.of(0.69, 0.769, 0.871, 1),
              lightyellow: Float32Array.of(1, 1, 0.878, 1),
              lime: Float32Array.of(0, 1, 0, 1),
              limegreen: Float32Array.of(0.196, 0.804, 0.196, 1),
              linen: Float32Array.of(
                0.98,
                0.941,
                0.902,
                1
              ),
              magenta: Float32Array.of(1, 0, 1, 1),
              maroon: Float32Array.of(0.502, 0, 0, 1),
              mediumaquamarine: Float32Array.of(0.4, 0.804, 0.667, 1),
              mediumblue: Float32Array.of(0, 0, 0.804, 1),
              mediumorchid: Float32Array.of(0.729, 0.333, 0.827, 1),
              mediumpurple: Float32Array.of(0.576, 0.439, 0.859, 1),
              mediumseagreen: Float32Array.of(0.235, 0.702, 0.443, 1),
              mediumslateblue: Float32Array.of(0.482, 0.408, 0.933, 1),
              mediumspringgreen: Float32Array.of(0, 0.98, 0.604, 1),
              mediumturquoise: Float32Array.of(0.282, 0.82, 0.8, 1),
              mediumvioletred: Float32Array.of(
                0.78,
                0.082,
                0.522,
                1
              ),
              midnightblue: Float32Array.of(0.098, 0.098, 0.439, 1),
              mintcream: Float32Array.of(0.961, 1, 0.98, 1),
              mistyrose: Float32Array.of(1, 0.894, 0.882, 1),
              moccasin: Float32Array.of(1, 0.894, 0.71, 1),
              navajowhite: Float32Array.of(1, 0.871, 0.678, 1),
              navy: Float32Array.of(0, 0, 0.502, 1),
              oldlace: Float32Array.of(0.992, 0.961, 0.902, 1),
              olive: Float32Array.of(0.502, 0.502, 0, 1),
              olivedrab: Float32Array.of(0.42, 0.557, 0.137, 1),
              orange: Float32Array.of(1, 0.647, 0, 1),
              orangered: Float32Array.of(1, 0.271, 0, 1),
              orchid: Float32Array.of(0.855, 0.439, 0.839, 1),
              palegoldenrod: Float32Array.of(
                0.933,
                0.91,
                0.667,
                1
              ),
              palegreen: Float32Array.of(0.596, 0.984, 0.596, 1),
              paleturquoise: Float32Array.of(0.686, 0.933, 0.933, 1),
              palevioletred: Float32Array.of(0.859, 0.439, 0.576, 1),
              papayawhip: Float32Array.of(1, 0.937, 0.835, 1),
              peachpuff: Float32Array.of(1, 0.855, 0.725, 1),
              peru: Float32Array.of(0.804, 0.522, 0.247, 1),
              pink: Float32Array.of(1, 0.753, 0.796, 1),
              plum: Float32Array.of(0.867, 0.627, 0.867, 1),
              powderblue: Float32Array.of(0.69, 0.878, 0.902, 1),
              purple: Float32Array.of(0.502, 0, 0.502, 1),
              rebeccapurple: Float32Array.of(0.4, 0.2, 0.6, 1),
              red: Float32Array.of(1, 0, 0, 1),
              rosybrown: Float32Array.of(0.737, 0.561, 0.561, 1),
              royalblue: Float32Array.of(0.255, 0.412, 0.882, 1),
              saddlebrown: Float32Array.of(0.545, 0.271, 0.075, 1),
              salmon: Float32Array.of(0.98, 0.502, 0.447, 1),
              sandybrown: Float32Array.of(0.957, 0.643, 0.376, 1),
              seagreen: Float32Array.of(0.18, 0.545, 0.341, 1),
              seashell: Float32Array.of(1, 0.961, 0.933, 1),
              sienna: Float32Array.of(0.627, 0.322, 0.176, 1),
              silver: Float32Array.of(0.753, 0.753, 0.753, 1),
              skyblue: Float32Array.of(0.529, 0.808, 0.922, 1),
              slateblue: Float32Array.of(0.416, 0.353, 0.804, 1),
              slategray: Float32Array.of(
                0.439,
                0.502,
                0.565,
                1
              ),
              slategrey: Float32Array.of(0.439, 0.502, 0.565, 1),
              snow: Float32Array.of(1, 0.98, 0.98, 1),
              springgreen: Float32Array.of(0, 1, 0.498, 1),
              steelblue: Float32Array.of(0.275, 0.51, 0.706, 1),
              tan: Float32Array.of(0.824, 0.706, 0.549, 1),
              teal: Float32Array.of(0, 0.502, 0.502, 1),
              thistle: Float32Array.of(0.847, 0.749, 0.847, 1),
              tomato: Float32Array.of(1, 0.388, 0.278, 1),
              transparent: Float32Array.of(0, 0, 0, 0),
              turquoise: Float32Array.of(0.251, 0.878, 0.816, 1),
              violet: Float32Array.of(0.933, 0.51, 0.933, 1),
              wheat: Float32Array.of(0.961, 0.871, 0.702, 1),
              white: Float32Array.of(
                1,
                1,
                1,
                1
              ),
              whitesmoke: Float32Array.of(0.961, 0.961, 0.961, 1),
              yellow: Float32Array.of(1, 1, 0, 1),
              yellowgreen: Float32Array.of(0.604, 0.804, 0.196, 1)
            };
            a2._testing.parseColor = g2;
            a2._testing.colorToString = d2;
            var wa = RegExp("(italic|oblique|normal|)\\s*(small-caps|normal|)\\s*(bold|bolder|lighter|[1-9]00|normal|)\\s*([\\d\\.]+)(px|pt|pc|in|cm|mm|%|em|ex|ch|rem|q)(.+)"), na = { "Noto Mono": { "*": null }, monospace: { "*": null } };
            a2._testing.parseFontString = l2;
            a2.MakeCanvas = function(G2, k2) {
              return (G2 = a2.MakeSurface(G2, k2)) ? new x2(G2) : null;
            };
            a2.ImageData = function() {
              if (2 === arguments.length) {
                var G2 = arguments[0], k2 = arguments[1];
                return new J2(new Uint8ClampedArray(4 * G2 * k2), G2, k2);
              }
              if (3 === arguments.length) {
                var q2 = arguments[0];
                if (q2.prototype.constructor !== Uint8ClampedArray) throw "bytes must be given as a Uint8ClampedArray";
                G2 = arguments[1];
                k2 = arguments[2];
                if (q2 % 4) throw "bytes must be given in a multiple of 4";
                if (q2 % G2) throw "bytes must divide evenly by width";
                if (k2 && k2 !== q2 / (4 * G2)) throw "invalid height given";
                return new J2(q2, G2, q2 / (4 * G2));
              }
              throw "invalid number of arguments - takes 2 or 3, saw " + arguments.length;
            };
          })();
        })(w2);
        var ta = Object.assign({}, w2), ua = "./this.program", xa = (a2, b2) => {
          throw b2;
        }, ya = "object" == typeof window, za = "function" == typeof importScripts, Aa = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, Ca = "", Da, Ea, Fa;
        if (Aa) {
          var fs = __require("fs"), Ga = __require("path");
          Ca = za ? Ga.dirname(Ca) + "/" : __dirname + "/";
          Da = (a2, b2) => {
            a2 = a2.startsWith("file://") ? new URL(a2) : Ga.normalize(a2);
            return fs.readFileSync(a2, b2 ? void 0 : "utf8");
          };
          Fa = (a2) => {
            a2 = Da(a2, true);
            a2.buffer || (a2 = new Uint8Array(a2));
            return a2;
          };
          Ea = (a2, b2, c2, f2 = true) => {
            a2 = a2.startsWith("file://") ? new URL(a2) : Ga.normalize(a2);
            fs.readFile(a2, f2 ? void 0 : "utf8", (h2, m2) => {
              h2 ? c2(h2) : b2(f2 ? m2.buffer : m2);
            });
          };
          !w2.thisProgram && 1 < process.argv.length && (ua = process.argv[1].replace(/\\/g, "/"));
          process.argv.slice(2);
          xa = (a2, b2) => {
            process.exitCode = a2;
            throw b2;
          };
          w2.inspect = () => "[Emscripten Module object]";
        } else if (ya || za) za ? Ca = self.location.href : "undefined" != typeof document && document.currentScript && (Ca = document.currentScript.src), _scriptDir && (Ca = _scriptDir), 0 !== Ca.indexOf("blob:") ? Ca = Ca.substr(0, Ca.replace(/[?#].*/, "").lastIndexOf("/") + 1) : Ca = "", Da = (a2) => {
          var b2 = new XMLHttpRequest();
          b2.open("GET", a2, false);
          b2.send(null);
          return b2.responseText;
        }, za && (Fa = (a2) => {
          var b2 = new XMLHttpRequest();
          b2.open("GET", a2, false);
          b2.responseType = "arraybuffer";
          b2.send(null);
          return new Uint8Array(b2.response);
        }), Ea = (a2, b2, c2) => {
          var f2 = new XMLHttpRequest();
          f2.open("GET", a2, true);
          f2.responseType = "arraybuffer";
          f2.onload = () => {
            200 == f2.status || 0 == f2.status && f2.response ? b2(f2.response) : c2();
          };
          f2.onerror = c2;
          f2.send(null);
        };
        var Ha = w2.print || console.log.bind(console), Ja = w2.printErr || console.error.bind(console);
        Object.assign(w2, ta);
        ta = null;
        w2.thisProgram && (ua = w2.thisProgram);
        w2.quit && (xa = w2.quit);
        var Ka;
        w2.wasmBinary && (Ka = w2.wasmBinary);
        var noExitRuntime = w2.noExitRuntime || true;
        "object" != typeof WebAssembly && La("no native wasm support detected");
        var Ma, Q2, Pa = false, Qa, K2, Ra, Sa, R2, Ua, V2, Va;
        function Wa() {
          var a2 = Ma.buffer;
          w2.HEAP8 = Qa = new Int8Array(a2);
          w2.HEAP16 = Ra = new Int16Array(a2);
          w2.HEAP32 = R2 = new Int32Array(a2);
          w2.HEAPU8 = K2 = new Uint8Array(a2);
          w2.HEAPU16 = Sa = new Uint16Array(a2);
          w2.HEAPU32 = Ua = new Uint32Array(a2);
          w2.HEAPF32 = V2 = new Float32Array(a2);
          w2.HEAPF64 = Va = new Float64Array(a2);
        }
        var Xa, Ya = [], Za = [], bb = [];
        function cb() {
          var a2 = w2.preRun.shift();
          Ya.unshift(a2);
        }
        var db = 0, eb = null, fb = null;
        function La(a2) {
          if (w2.onAbort) w2.onAbort(a2);
          a2 = "Aborted(" + a2 + ")";
          Ja(a2);
          Pa = true;
          a2 = new WebAssembly.RuntimeError(a2 + ". Build with -sASSERTIONS for more info.");
          fa(a2);
          throw a2;
        }
        function kb(a2) {
          return a2.startsWith("data:application/octet-stream;base64,");
        }
        var lb;
        lb = "canvaskit.wasm";
        if (!kb(lb)) {
          var mb = lb;
          lb = w2.locateFile ? w2.locateFile(mb, Ca) : Ca + mb;
        }
        function nb(a2) {
          if (a2 == lb && Ka) return new Uint8Array(Ka);
          if (Fa) return Fa(a2);
          throw "both async and sync fetching of the wasm failed";
        }
        function ob(a2) {
          if (!Ka && (ya || za)) {
            if ("function" == typeof fetch && !a2.startsWith("file://")) return fetch(a2, { credentials: "same-origin" }).then((b2) => {
              if (!b2.ok) throw "failed to load wasm binary file at '" + a2 + "'";
              return b2.arrayBuffer();
            }).catch(() => nb(a2));
            if (Ea) return new Promise((b2, c2) => {
              Ea(a2, (f2) => b2(new Uint8Array(f2)), c2);
            });
          }
          return Promise.resolve().then(() => nb(a2));
        }
        function pb(a2, b2, c2) {
          return ob(a2).then((f2) => WebAssembly.instantiate(f2, b2)).then((f2) => f2).then(c2, (f2) => {
            Ja("failed to asynchronously prepare wasm: " + f2);
            La(f2);
          });
        }
        function qb(a2, b2) {
          var c2 = lb;
          return Ka || "function" != typeof WebAssembly.instantiateStreaming || kb(c2) || c2.startsWith("file://") || Aa || "function" != typeof fetch ? pb(c2, a2, b2) : fetch(c2, { credentials: "same-origin" }).then((f2) => WebAssembly.instantiateStreaming(f2, a2).then(b2, function(h2) {
            Ja("wasm streaming compile failed: " + h2);
            Ja("falling back to ArrayBuffer instantiation");
            return pb(c2, a2, b2);
          }));
        }
        function rb(a2) {
          this.name = "ExitStatus";
          this.message = `Program terminated with exit(${a2})`;
          this.status = a2;
        }
        var sb = (a2) => {
          for (; 0 < a2.length; ) a2.shift()(w2);
        }, tb = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, ub = (a2, b2, c2) => {
          var f2 = b2 + c2;
          for (c2 = b2; a2[c2] && !(c2 >= f2); ) ++c2;
          if (16 < c2 - b2 && a2.buffer && tb) return tb.decode(a2.subarray(b2, c2));
          for (f2 = ""; b2 < c2; ) {
            var h2 = a2[b2++];
            if (h2 & 128) {
              var m2 = a2[b2++] & 63;
              if (192 == (h2 & 224)) f2 += String.fromCharCode((h2 & 31) << 6 | m2);
              else {
                var u2 = a2[b2++] & 63;
                h2 = 224 == (h2 & 240) ? (h2 & 15) << 12 | m2 << 6 | u2 : (h2 & 7) << 18 | m2 << 12 | u2 << 6 | a2[b2++] & 63;
                65536 > h2 ? f2 += String.fromCharCode(h2) : (h2 -= 65536, f2 += String.fromCharCode(55296 | h2 >> 10, 56320 | h2 & 1023));
              }
            } else f2 += String.fromCharCode(h2);
          }
          return f2;
        }, vb = {};
        function wb(a2) {
          for (; a2.length; ) {
            var b2 = a2.pop();
            a2.pop()(b2);
          }
        }
        function xb(a2) {
          return this.fromWireType(R2[a2 >> 2]);
        }
        var zb = {}, Ab = {}, Bb = {}, Cb = void 0;
        function Db(a2) {
          throw new Cb(a2);
        }
        function Eb(a2, b2, c2) {
          function f2(n2) {
            n2 = c2(n2);
            n2.length !== a2.length && Db("Mismatched type converter count");
            for (var p2 = 0; p2 < a2.length; ++p2) Fb(a2[p2], n2[p2]);
          }
          a2.forEach(function(n2) {
            Bb[n2] = b2;
          });
          var h2 = Array(b2.length), m2 = [], u2 = 0;
          b2.forEach((n2, p2) => {
            Ab.hasOwnProperty(n2) ? h2[p2] = Ab[n2] : (m2.push(n2), zb.hasOwnProperty(n2) || (zb[n2] = []), zb[n2].push(() => {
              h2[p2] = Ab[n2];
              ++u2;
              u2 === m2.length && f2(h2);
            }));
          });
          0 === m2.length && f2(h2);
        }
        function Gb(a2) {
          switch (a2) {
            case 1:
              return 0;
            case 2:
              return 1;
            case 4:
              return 2;
            case 8:
              return 3;
            default:
              throw new TypeError(`Unknown type size: ${a2}`);
          }
        }
        var Hb = void 0;
        function Ib(a2) {
          for (var b2 = ""; K2[a2]; ) b2 += Hb[K2[a2++]];
          return b2;
        }
        var Jb = void 0;
        function X2(a2) {
          throw new Jb(a2);
        }
        function Kb(a2, b2, c2 = {}) {
          var f2 = b2.name;
          a2 || X2(`type "${f2}" must have a positive integer typeid pointer`);
          if (Ab.hasOwnProperty(a2)) {
            if (c2.Wf) return;
            X2(`Cannot register type '${f2}' twice`);
          }
          Ab[a2] = b2;
          delete Bb[a2];
          zb.hasOwnProperty(a2) && (b2 = zb[a2], delete zb[a2], b2.forEach((h2) => h2()));
        }
        function Fb(a2, b2, c2 = {}) {
          if (!("argPackAdvance" in b2)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
          Kb(a2, b2, c2);
        }
        function Lb(a2) {
          X2(a2.Jd.Vd.Pd.name + " instance already deleted");
        }
        var Mb = false;
        function Nb() {
        }
        function Ob(a2) {
          --a2.count.value;
          0 === a2.count.value && (a2.Yd ? a2.ee.ke(a2.Yd) : a2.Vd.Pd.ke(a2.Rd));
        }
        function Pb(a2, b2, c2) {
          if (b2 === c2) return a2;
          if (void 0 === c2.$d) return null;
          a2 = Pb(a2, b2, c2.$d);
          return null === a2 ? null : c2.Mf(a2);
        }
        var Qb = {}, Rb = [];
        function Sb() {
          for (; Rb.length; ) {
            var a2 = Rb.pop();
            a2.Jd.Ee = false;
            a2["delete"]();
          }
        }
        var Tb = void 0, Ub = {};
        function ac(a2, b2) {
          for (void 0 === b2 && X2("ptr should not be undefined"); a2.$d; ) b2 = a2.Oe(b2), a2 = a2.$d;
          return Ub[b2];
        }
        function bc(a2, b2) {
          b2.Vd && b2.Rd || Db("makeClassHandle requires ptr and ptrType");
          !!b2.ee !== !!b2.Yd && Db("Both smartPtrType and smartPtr must be specified");
          b2.count = { value: 1 };
          return cc(Object.create(a2, { Jd: { value: b2 } }));
        }
        function cc(a2) {
          if ("undefined" === typeof FinalizationRegistry) return cc = (b2) => b2, a2;
          Mb = new FinalizationRegistry((b2) => {
            Ob(b2.Jd);
          });
          cc = (b2) => {
            var c2 = b2.Jd;
            c2.Yd && Mb.register(b2, { Jd: c2 }, b2);
            return b2;
          };
          Nb = (b2) => {
            Mb.unregister(b2);
          };
          return cc(a2);
        }
        function dc() {
        }
        function ec(a2) {
          if (void 0 === a2) return "_unknown";
          a2 = a2.replace(/[^a-zA-Z0-9_]/g, "$");
          var b2 = a2.charCodeAt(0);
          return 48 <= b2 && 57 >= b2 ? `_${a2}` : a2;
        }
        function fc(a2, b2) {
          a2 = ec(a2);
          return { [a2]: function() {
            return b2.apply(this, arguments);
          } }[a2];
        }
        function gc(a2, b2, c2) {
          if (void 0 === a2[b2].Xd) {
            var f2 = a2[b2];
            a2[b2] = function() {
              a2[b2].Xd.hasOwnProperty(arguments.length) || X2(`Function '${c2}' called with an invalid number of arguments (${arguments.length}) - expects one of (${a2[b2].Xd})!`);
              return a2[b2].Xd[arguments.length].apply(this, arguments);
            };
            a2[b2].Xd = [];
            a2[b2].Xd[f2.Ce] = f2;
          }
        }
        function hc(a2, b2, c2) {
          w2.hasOwnProperty(a2) ? ((void 0 === c2 || void 0 !== w2[a2].Xd && void 0 !== w2[a2].Xd[c2]) && X2(`Cannot register public name '${a2}' twice`), gc(w2, a2, a2), w2.hasOwnProperty(c2) && X2(`Cannot register multiple overloads of a function with the same number of arguments (${c2})!`), w2[a2].Xd[c2] = b2) : (w2[a2] = b2, void 0 !== c2 && (w2[a2].tg = c2));
        }
        function ic(a2, b2, c2, f2, h2, m2, u2, n2) {
          this.name = a2;
          this.constructor = b2;
          this.Fe = c2;
          this.ke = f2;
          this.$d = h2;
          this.Rf = m2;
          this.Oe = u2;
          this.Mf = n2;
          this.cg = [];
        }
        function jc(a2, b2, c2) {
          for (; b2 !== c2; ) b2.Oe || X2(`Expected null or instance of ${c2.name}, got an instance of ${b2.name}`), a2 = b2.Oe(a2), b2 = b2.$d;
          return a2;
        }
        function kc(a2, b2) {
          if (null === b2) return this.gf && X2(`null is not a valid ${this.name}`), 0;
          b2.Jd || X2(`Cannot pass "${lc(b2)}" as a ${this.name}`);
          b2.Jd.Rd || X2(`Cannot pass deleted object as a pointer of type ${this.name}`);
          return jc(b2.Jd.Rd, b2.Jd.Vd.Pd, this.Pd);
        }
        function mc(a2, b2) {
          if (null === b2) {
            this.gf && X2(`null is not a valid ${this.name}`);
            if (this.Ve) {
              var c2 = this.hf();
              null !== a2 && a2.push(this.ke, c2);
              return c2;
            }
            return 0;
          }
          b2.Jd || X2(`Cannot pass "${lc(b2)}" as a ${this.name}`);
          b2.Jd.Rd || X2(`Cannot pass deleted object as a pointer of type ${this.name}`);
          !this.Ue && b2.Jd.Vd.Ue && X2(`Cannot convert argument of type ${b2.Jd.ee ? b2.Jd.ee.name : b2.Jd.Vd.name} to parameter type ${this.name}`);
          c2 = jc(b2.Jd.Rd, b2.Jd.Vd.Pd, this.Pd);
          if (this.Ve) switch (void 0 === b2.Jd.Yd && X2("Passing raw pointer to smart pointer is illegal"), this.hg) {
            case 0:
              b2.Jd.ee === this ? c2 = b2.Jd.Yd : X2(`Cannot convert argument of type ${b2.Jd.ee ? b2.Jd.ee.name : b2.Jd.Vd.name} to parameter type ${this.name}`);
              break;
            case 1:
              c2 = b2.Jd.Yd;
              break;
            case 2:
              if (b2.Jd.ee === this) c2 = b2.Jd.Yd;
              else {
                var f2 = b2.clone();
                c2 = this.dg(c2, nc(function() {
                  f2["delete"]();
                }));
                null !== a2 && a2.push(this.ke, c2);
              }
              break;
            default:
              X2("Unsupporting sharing policy");
          }
          return c2;
        }
        function oc(a2, b2) {
          if (null === b2) return this.gf && X2(`null is not a valid ${this.name}`), 0;
          b2.Jd || X2(`Cannot pass "${lc(b2)}" as a ${this.name}`);
          b2.Jd.Rd || X2(`Cannot pass deleted object as a pointer of type ${this.name}`);
          b2.Jd.Vd.Ue && X2(`Cannot convert argument of type ${b2.Jd.Vd.name} to parameter type ${this.name}`);
          return jc(b2.Jd.Rd, b2.Jd.Vd.Pd, this.Pd);
        }
        function pc(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2, E2) {
          this.name = a2;
          this.Pd = b2;
          this.gf = c2;
          this.Ue = f2;
          this.Ve = h2;
          this.bg = m2;
          this.hg = u2;
          this.vf = n2;
          this.hf = p2;
          this.dg = v2;
          this.ke = E2;
          h2 || void 0 !== b2.$d ? this.toWireType = mc : (this.toWireType = f2 ? kc : oc, this.de = null);
        }
        function qc(a2, b2, c2) {
          w2.hasOwnProperty(a2) || Db("Replacing nonexistant public symbol");
          void 0 !== w2[a2].Xd && void 0 !== c2 ? w2[a2].Xd[c2] = b2 : (w2[a2] = b2, w2[a2].Ce = c2);
        }
        var rc = (a2, b2) => {
          var c2 = [];
          return function() {
            c2.length = 0;
            Object.assign(c2, arguments);
            if (a2.includes("j")) {
              var f2 = w2["dynCall_" + a2];
              f2 = c2 && c2.length ? f2.apply(null, [b2].concat(c2)) : f2.call(null, b2);
            } else f2 = Xa.get(b2).apply(null, c2);
            return f2;
          };
        };
        function sc(a2, b2) {
          a2 = Ib(a2);
          var c2 = a2.includes("j") ? rc(a2, b2) : Xa.get(b2);
          "function" != typeof c2 && X2(`unknown function pointer with signature ${a2}: ${b2}`);
          return c2;
        }
        var tc = void 0;
        function uc(a2) {
          a2 = vc(a2);
          var b2 = Ib(a2);
          wc(a2);
          return b2;
        }
        function Dc(a2, b2) {
          function c2(m2) {
            h2[m2] || Ab[m2] || (Bb[m2] ? Bb[m2].forEach(c2) : (f2.push(m2), h2[m2] = true));
          }
          var f2 = [], h2 = {};
          b2.forEach(c2);
          throw new tc(`${a2}: ` + f2.map(uc).join([", "]));
        }
        function Ec(a2, b2, c2, f2, h2) {
          var m2 = b2.length;
          2 > m2 && X2("argTypes array size mismatch! Must at least get return value and 'this' types!");
          var u2 = null !== b2[1] && null !== c2, n2 = false;
          for (c2 = 1; c2 < b2.length; ++c2) if (null !== b2[c2] && void 0 === b2[c2].de) {
            n2 = true;
            break;
          }
          var p2 = "void" !== b2[0].name, v2 = m2 - 2, E2 = Array(v2), H2 = [], L2 = [];
          return function() {
            arguments.length !== v2 && X2(`function ${a2} called with ${arguments.length} arguments, expected ${v2} args!`);
            L2.length = 0;
            H2.length = u2 ? 2 : 1;
            H2[0] = h2;
            if (u2) {
              var y2 = b2[1].toWireType(L2, this);
              H2[1] = y2;
            }
            for (var N2 = 0; N2 < v2; ++N2) E2[N2] = b2[N2 + 2].toWireType(L2, arguments[N2]), H2.push(E2[N2]);
            N2 = f2.apply(null, H2);
            if (n2) wb(L2);
            else for (var T2 = u2 ? 1 : 2; T2 < b2.length; T2++) {
              var S2 = 1 === T2 ? y2 : E2[T2 - 2];
              null !== b2[T2].de && b2[T2].de(S2);
            }
            y2 = p2 ? b2[0].fromWireType(N2) : void 0;
            return y2;
          };
        }
        function Fc(a2, b2) {
          for (var c2 = [], f2 = 0; f2 < a2; f2++) c2.push(Ua[b2 + 4 * f2 >> 2]);
          return c2;
        }
        function Gc() {
          this.je = [void 0];
          this.sf = [];
        }
        var Hc = new Gc();
        function Ic(a2) {
          a2 >= Hc.Ge && 0 === --Hc.get(a2).wf && Hc.Bf(a2);
        }
        var Jc = (a2) => {
          a2 || X2("Cannot use deleted val. handle = " + a2);
          return Hc.get(a2).value;
        }, nc = (a2) => {
          switch (a2) {
            case void 0:
              return 1;
            case null:
              return 2;
            case true:
              return 3;
            case false:
              return 4;
            default:
              return Hc.Af({ wf: 1, value: a2 });
          }
        };
        function Kc(a2, b2, c2) {
          switch (b2) {
            case 0:
              return function(f2) {
                return this.fromWireType((c2 ? Qa : K2)[f2]);
              };
            case 1:
              return function(f2) {
                return this.fromWireType((c2 ? Ra : Sa)[f2 >> 1]);
              };
            case 2:
              return function(f2) {
                return this.fromWireType((c2 ? R2 : Ua)[f2 >> 2]);
              };
            default:
              throw new TypeError("Unknown integer type: " + a2);
          }
        }
        function Lc(a2, b2) {
          var c2 = Ab[a2];
          void 0 === c2 && X2(b2 + " has unknown type " + uc(a2));
          return c2;
        }
        function lc(a2) {
          if (null === a2) return "null";
          var b2 = typeof a2;
          return "object" === b2 || "array" === b2 || "function" === b2 ? a2.toString() : "" + a2;
        }
        function Mc(a2, b2) {
          switch (b2) {
            case 2:
              return function(c2) {
                return this.fromWireType(V2[c2 >> 2]);
              };
            case 3:
              return function(c2) {
                return this.fromWireType(Va[c2 >> 3]);
              };
            default:
              throw new TypeError("Unknown float type: " + a2);
          }
        }
        function Nc(a2, b2, c2) {
          switch (b2) {
            case 0:
              return c2 ? function(f2) {
                return Qa[f2];
              } : function(f2) {
                return K2[f2];
              };
            case 1:
              return c2 ? function(f2) {
                return Ra[f2 >> 1];
              } : function(f2) {
                return Sa[f2 >> 1];
              };
            case 2:
              return c2 ? function(f2) {
                return R2[f2 >> 2];
              } : function(f2) {
                return Ua[f2 >> 2];
              };
            default:
              throw new TypeError("Unknown integer type: " + a2);
          }
        }
        var ra = (a2, b2, c2, f2) => {
          if (!(0 < f2)) return 0;
          var h2 = c2;
          f2 = c2 + f2 - 1;
          for (var m2 = 0; m2 < a2.length; ++m2) {
            var u2 = a2.charCodeAt(m2);
            if (55296 <= u2 && 57343 >= u2) {
              var n2 = a2.charCodeAt(++m2);
              u2 = 65536 + ((u2 & 1023) << 10) | n2 & 1023;
            }
            if (127 >= u2) {
              if (c2 >= f2) break;
              b2[c2++] = u2;
            } else {
              if (2047 >= u2) {
                if (c2 + 1 >= f2) break;
                b2[c2++] = 192 | u2 >> 6;
              } else {
                if (65535 >= u2) {
                  if (c2 + 2 >= f2) break;
                  b2[c2++] = 224 | u2 >> 12;
                } else {
                  if (c2 + 3 >= f2) break;
                  b2[c2++] = 240 | u2 >> 18;
                  b2[c2++] = 128 | u2 >> 12 & 63;
                }
                b2[c2++] = 128 | u2 >> 6 & 63;
              }
              b2[c2++] = 128 | u2 & 63;
            }
          }
          b2[c2] = 0;
          return c2 - h2;
        }, qa = (a2) => {
          for (var b2 = 0, c2 = 0; c2 < a2.length; ++c2) {
            var f2 = a2.charCodeAt(c2);
            127 >= f2 ? b2++ : 2047 >= f2 ? b2 += 2 : 55296 <= f2 && 57343 >= f2 ? (b2 += 4, ++c2) : b2 += 3;
          }
          return b2;
        }, Oc = "undefined" != typeof TextDecoder ? new TextDecoder("utf-16le") : void 0, Pc = (a2, b2) => {
          var c2 = a2 >> 1;
          for (var f2 = c2 + b2 / 2; !(c2 >= f2) && Sa[c2]; ) ++c2;
          c2 <<= 1;
          if (32 < c2 - a2 && Oc) return Oc.decode(K2.subarray(a2, c2));
          c2 = "";
          for (f2 = 0; !(f2 >= b2 / 2); ++f2) {
            var h2 = Ra[a2 + 2 * f2 >> 1];
            if (0 == h2) break;
            c2 += String.fromCharCode(h2);
          }
          return c2;
        }, Qc = (a2, b2, c2) => {
          void 0 === c2 && (c2 = 2147483647);
          if (2 > c2) return 0;
          c2 -= 2;
          var f2 = b2;
          c2 = c2 < 2 * a2.length ? c2 / 2 : a2.length;
          for (var h2 = 0; h2 < c2; ++h2) Ra[b2 >> 1] = a2.charCodeAt(h2), b2 += 2;
          Ra[b2 >> 1] = 0;
          return b2 - f2;
        }, Rc = (a2) => 2 * a2.length, Sc = (a2, b2) => {
          for (var c2 = 0, f2 = ""; !(c2 >= b2 / 4); ) {
            var h2 = R2[a2 + 4 * c2 >> 2];
            if (0 == h2) break;
            ++c2;
            65536 <= h2 ? (h2 -= 65536, f2 += String.fromCharCode(55296 | h2 >> 10, 56320 | h2 & 1023)) : f2 += String.fromCharCode(h2);
          }
          return f2;
        }, Tc = (a2, b2, c2) => {
          void 0 === c2 && (c2 = 2147483647);
          if (4 > c2) return 0;
          var f2 = b2;
          c2 = f2 + c2 - 4;
          for (var h2 = 0; h2 < a2.length; ++h2) {
            var m2 = a2.charCodeAt(h2);
            if (55296 <= m2 && 57343 >= m2) {
              var u2 = a2.charCodeAt(++h2);
              m2 = 65536 + ((m2 & 1023) << 10) | u2 & 1023;
            }
            R2[b2 >> 2] = m2;
            b2 += 4;
            if (b2 + 4 > c2) break;
          }
          R2[b2 >> 2] = 0;
          return b2 - f2;
        }, Uc = (a2) => {
          for (var b2 = 0, c2 = 0; c2 < a2.length; ++c2) {
            var f2 = a2.charCodeAt(c2);
            55296 <= f2 && 57343 >= f2 && ++c2;
            b2 += 4;
          }
          return b2;
        }, Vc = {};
        function Wc(a2) {
          var b2 = Vc[a2];
          return void 0 === b2 ? Ib(a2) : b2;
        }
        var Xc = [];
        function Yc() {
          function a2(b2) {
            b2.$$$embind_global$$$ = b2;
            var c2 = "object" == typeof $$$embind_global$$$ && b2.$$$embind_global$$$ == b2;
            c2 || delete b2.$$$embind_global$$$;
            return c2;
          }
          if ("object" == typeof globalThis) return globalThis;
          if ("object" == typeof $$$embind_global$$$) return $$$embind_global$$$;
          "object" == typeof global && a2(global) ? $$$embind_global$$$ = global : "object" == typeof self && a2(self) && ($$$embind_global$$$ = self);
          if ("object" == typeof $$$embind_global$$$) return $$$embind_global$$$;
          throw Error("unable to get global object.");
        }
        function Zc(a2) {
          var b2 = Xc.length;
          Xc.push(a2);
          return b2;
        }
        function $c(a2, b2) {
          for (var c2 = Array(a2), f2 = 0; f2 < a2; ++f2) c2[f2] = Lc(Ua[b2 + 4 * f2 >> 2], "parameter " + f2);
          return c2;
        }
        var ad = [];
        function bd(a2) {
          var b2 = Array(a2 + 1);
          return function(c2, f2, h2) {
            b2[0] = c2;
            for (var m2 = 0; m2 < a2; ++m2) {
              var u2 = Lc(Ua[f2 + 4 * m2 >> 2], "parameter " + m2);
              b2[m2 + 1] = u2.readValueFromPointer(h2);
              h2 += u2.argPackAdvance;
            }
            c2 = new (c2.bind.apply(c2, b2))();
            return nc(c2);
          };
        }
        var cd = {};
        function dd(a2) {
          var b2 = a2.getExtension("ANGLE_instanced_arrays");
          b2 && (a2.vertexAttribDivisor = function(c2, f2) {
            b2.vertexAttribDivisorANGLE(c2, f2);
          }, a2.drawArraysInstanced = function(c2, f2, h2, m2) {
            b2.drawArraysInstancedANGLE(c2, f2, h2, m2);
          }, a2.drawElementsInstanced = function(c2, f2, h2, m2, u2) {
            b2.drawElementsInstancedANGLE(c2, f2, h2, m2, u2);
          });
        }
        function ed(a2) {
          var b2 = a2.getExtension("OES_vertex_array_object");
          b2 && (a2.createVertexArray = function() {
            return b2.createVertexArrayOES();
          }, a2.deleteVertexArray = function(c2) {
            b2.deleteVertexArrayOES(c2);
          }, a2.bindVertexArray = function(c2) {
            b2.bindVertexArrayOES(c2);
          }, a2.isVertexArray = function(c2) {
            return b2.isVertexArrayOES(c2);
          });
        }
        function fd(a2) {
          var b2 = a2.getExtension("WEBGL_draw_buffers");
          b2 && (a2.drawBuffers = function(c2, f2) {
            b2.drawBuffersWEBGL(c2, f2);
          });
        }
        var gd = 1, hd = [], jd = [], kd = [], ld = [], ia = [], md = [], nd = [], pa = [], od = [], pd = [], qd = {}, rd = {}, sd = 4;
        function td(a2) {
          ud || (ud = a2);
        }
        function ha(a2) {
          for (var b2 = gd++, c2 = a2.length; c2 < b2; c2++) a2[c2] = null;
          return b2;
        }
        function la(a2, b2) {
          a2.Ge || (a2.Ge = a2.getContext, a2.getContext = function(f2, h2) {
            h2 = a2.Ge(f2, h2);
            return "webgl" == f2 == h2 instanceof WebGLRenderingContext ? h2 : null;
          });
          var c2 = 1 < b2.majorVersion ? a2.getContext("webgl2", b2) : a2.getContext("webgl", b2);
          return c2 ? vd(c2, b2) : 0;
        }
        function vd(a2, b2) {
          var c2 = ha(pa), f2 = { handle: c2, attributes: b2, version: b2.majorVersion, fe: a2 };
          a2.canvas && (a2.canvas.zf = f2);
          pa[c2] = f2;
          ("undefined" == typeof b2.Nf || b2.Nf) && yd(f2);
          return c2;
        }
        function oa(a2) {
          A2 = pa[a2];
          w2.rg = Z2 = A2 && A2.fe;
          return !(a2 && !Z2);
        }
        function yd(a2) {
          a2 || (a2 = A2);
          if (!a2.Xf) {
            a2.Xf = true;
            var b2 = a2.fe;
            dd(b2);
            ed(b2);
            fd(b2);
            b2.pf = b2.getExtension("WEBGL_draw_instanced_base_vertex_base_instance");
            b2.uf = b2.getExtension("WEBGL_multi_draw_instanced_base_vertex_base_instance");
            2 <= a2.version && (b2.qf = b2.getExtension("EXT_disjoint_timer_query_webgl2"));
            if (2 > a2.version || !b2.qf) b2.qf = b2.getExtension("EXT_disjoint_timer_query");
            b2.sg = b2.getExtension("WEBGL_multi_draw");
            (b2.getSupportedExtensions() || []).forEach(function(c2) {
              c2.includes("lose_context") || c2.includes("debug") || b2.getExtension(c2);
            });
          }
        }
        var A2, ud, zd = {}, Bd = () => {
          if (!Ad) {
            var a2 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: ua || "./this.program" }, b2;
            for (b2 in zd) void 0 === zd[b2] ? delete a2[b2] : a2[b2] = zd[b2];
            var c2 = [];
            for (b2 in a2) c2.push(`${b2}=${a2[b2]}`);
            Ad = c2;
          }
          return Ad;
        }, Ad, Cd = [null, [], []];
        function Dd(a2) {
          Z2.bindVertexArray(nd[a2]);
        }
        function Ed(a2, b2) {
          for (var c2 = 0; c2 < a2; c2++) {
            var f2 = R2[b2 + 4 * c2 >> 2];
            Z2.deleteVertexArray(nd[f2]);
            nd[f2] = null;
          }
        }
        var Fd = [];
        function Gd(a2, b2, c2, f2) {
          Z2.drawElements(a2, b2, c2, f2);
        }
        function Hd(a2, b2, c2, f2) {
          for (var h2 = 0; h2 < a2; h2++) {
            var m2 = Z2[c2](), u2 = m2 && ha(f2);
            m2 ? (m2.name = u2, f2[u2] = m2) : td(1282);
            R2[b2 + 4 * h2 >> 2] = u2;
          }
        }
        function Id(a2, b2) {
          Hd(a2, b2, "createVertexArray", nd);
        }
        function Jd(a2, b2, c2) {
          if (b2) {
            var f2 = void 0;
            switch (a2) {
              case 36346:
                f2 = 1;
                break;
              case 36344:
                0 != c2 && 1 != c2 && td(1280);
                return;
              case 34814:
              case 36345:
                f2 = 0;
                break;
              case 34466:
                var h2 = Z2.getParameter(34467);
                f2 = h2 ? h2.length : 0;
                break;
              case 33309:
                if (2 > A2.version) {
                  td(1282);
                  return;
                }
                f2 = 2 * (Z2.getSupportedExtensions() || []).length;
                break;
              case 33307:
              case 33308:
                if (2 > A2.version) {
                  td(1280);
                  return;
                }
                f2 = 33307 == a2 ? 3 : 0;
            }
            if (void 0 === f2) switch (h2 = Z2.getParameter(a2), typeof h2) {
              case "number":
                f2 = h2;
                break;
              case "boolean":
                f2 = h2 ? 1 : 0;
                break;
              case "string":
                td(1280);
                return;
              case "object":
                if (null === h2) switch (a2) {
                  case 34964:
                  case 35725:
                  case 34965:
                  case 36006:
                  case 36007:
                  case 32873:
                  case 34229:
                  case 36662:
                  case 36663:
                  case 35053:
                  case 35055:
                  case 36010:
                  case 35097:
                  case 35869:
                  case 32874:
                  case 36389:
                  case 35983:
                  case 35368:
                  case 34068:
                    f2 = 0;
                    break;
                  default:
                    td(1280);
                    return;
                }
                else {
                  if (h2 instanceof Float32Array || h2 instanceof Uint32Array || h2 instanceof Int32Array || h2 instanceof Array) {
                    for (a2 = 0; a2 < h2.length; ++a2) switch (c2) {
                      case 0:
                        R2[b2 + 4 * a2 >> 2] = h2[a2];
                        break;
                      case 2:
                        V2[b2 + 4 * a2 >> 2] = h2[a2];
                        break;
                      case 4:
                        Qa[b2 + a2 >> 0] = h2[a2] ? 1 : 0;
                    }
                    return;
                  }
                  try {
                    f2 = h2.name | 0;
                  } catch (m2) {
                    td(1280);
                    Ja("GL_INVALID_ENUM in glGet" + c2 + "v: Unknown object returned from WebGL getParameter(" + a2 + ")! (error: " + m2 + ")");
                    return;
                  }
                }
                break;
              default:
                td(1280);
                Ja("GL_INVALID_ENUM in glGet" + c2 + "v: Native code calling glGet" + c2 + "v(" + a2 + ") and it returns " + h2 + " of type " + typeof h2 + "!");
                return;
            }
            switch (c2) {
              case 1:
                c2 = f2;
                Ua[b2 >> 2] = c2;
                Ua[b2 + 4 >> 2] = (c2 - Ua[b2 >> 2]) / 4294967296;
                break;
              case 0:
                R2[b2 >> 2] = f2;
                break;
              case 2:
                V2[b2 >> 2] = f2;
                break;
              case 4:
                Qa[b2 >> 0] = f2 ? 1 : 0;
            }
          } else td(1281);
        }
        var Ld = (a2) => {
          var b2 = qa(a2) + 1, c2 = Kd(b2);
          c2 && ra(a2, K2, c2, b2);
          return c2;
        };
        function Md(a2) {
          return "]" == a2.slice(-1) && a2.lastIndexOf("[");
        }
        function Nd(a2) {
          a2 -= 5120;
          return 0 == a2 ? Qa : 1 == a2 ? K2 : 2 == a2 ? Ra : 4 == a2 ? R2 : 6 == a2 ? V2 : 5 == a2 || 28922 == a2 || 28520 == a2 || 30779 == a2 || 30782 == a2 ? Ua : Sa;
        }
        function Od(a2, b2, c2, f2, h2) {
          a2 = Nd(a2);
          var m2 = 31 - Math.clz32(a2.BYTES_PER_ELEMENT), u2 = sd;
          return a2.subarray(h2 >> m2, h2 + f2 * (c2 * ({ 5: 3, 6: 4, 8: 2, 29502: 3, 29504: 4, 26917: 2, 26918: 2, 29846: 3, 29847: 4 }[b2 - 6402] || 1) * (1 << m2) + u2 - 1 & -u2) >> m2);
        }
        function Pd(a2) {
          var b2 = Z2.Kf;
          if (b2) {
            var c2 = b2.Ne[a2];
            "number" == typeof c2 && (b2.Ne[a2] = c2 = Z2.getUniformLocation(b2, b2.xf[a2] + (0 < c2 ? "[" + c2 + "]" : "")));
            return c2;
          }
          td(1282);
        }
        var Qd = [], Rd = [], Sd = (a2) => 0 === a2 % 4 && (0 !== a2 % 100 || 0 === a2 % 400), Td = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Ud = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function Vd(a2) {
          var b2 = Array(qa(a2) + 1);
          ra(a2, b2, 0, b2.length);
          return b2;
        }
        var Wd = (a2, b2, c2, f2) => {
          function h2(y2, N2, T2) {
            for (y2 = "number" == typeof y2 ? y2.toString() : y2 || ""; y2.length < N2; ) y2 = T2[0] + y2;
            return y2;
          }
          function m2(y2, N2) {
            return h2(y2, N2, "0");
          }
          function u2(y2, N2) {
            function T2(sa) {
              return 0 > sa ? -1 : 0 < sa ? 1 : 0;
            }
            var S2;
            0 === (S2 = T2(y2.getFullYear() - N2.getFullYear())) && 0 === (S2 = T2(y2.getMonth() - N2.getMonth())) && (S2 = T2(y2.getDate() - N2.getDate()));
            return S2;
          }
          function n2(y2) {
            switch (y2.getDay()) {
              case 0:
                return new Date(y2.getFullYear() - 1, 11, 29);
              case 1:
                return y2;
              case 2:
                return new Date(y2.getFullYear(), 0, 3);
              case 3:
                return new Date(
                  y2.getFullYear(),
                  0,
                  2
                );
              case 4:
                return new Date(y2.getFullYear(), 0, 1);
              case 5:
                return new Date(y2.getFullYear() - 1, 11, 31);
              case 6:
                return new Date(y2.getFullYear() - 1, 11, 30);
            }
          }
          function p2(y2) {
            var N2 = y2.oe;
            for (y2 = new Date(new Date(y2.pe + 1900, 0, 1).getTime()); 0 < N2; ) {
              var T2 = y2.getMonth(), S2 = (Sd(y2.getFullYear()) ? Td : Ud)[T2];
              if (N2 > S2 - y2.getDate()) N2 -= S2 - y2.getDate() + 1, y2.setDate(1), 11 > T2 ? y2.setMonth(T2 + 1) : (y2.setMonth(0), y2.setFullYear(y2.getFullYear() + 1));
              else {
                y2.setDate(y2.getDate() + N2);
                break;
              }
            }
            T2 = new Date(y2.getFullYear() + 1, 0, 4);
            N2 = n2(new Date(
              y2.getFullYear(),
              0,
              4
            ));
            T2 = n2(T2);
            return 0 >= u2(N2, y2) ? 0 >= u2(T2, y2) ? y2.getFullYear() + 1 : y2.getFullYear() : y2.getFullYear() - 1;
          }
          var v2 = R2[f2 + 40 >> 2];
          f2 = { pg: R2[f2 >> 2], og: R2[f2 + 4 >> 2], Ze: R2[f2 + 8 >> 2], jf: R2[f2 + 12 >> 2], $e: R2[f2 + 16 >> 2], pe: R2[f2 + 20 >> 2], he: R2[f2 + 24 >> 2], oe: R2[f2 + 28 >> 2], vg: R2[f2 + 32 >> 2], ng: R2[f2 + 36 >> 2], qg: v2 ? v2 ? ub(K2, v2) : "" : "" };
          c2 = c2 ? ub(K2, c2) : "";
          v2 = {
            "%c": "%a %b %d %H:%M:%S %Y",
            "%D": "%m/%d/%y",
            "%F": "%Y-%m-%d",
            "%h": "%b",
            "%r": "%I:%M:%S %p",
            "%R": "%H:%M",
            "%T": "%H:%M:%S",
            "%x": "%m/%d/%y",
            "%X": "%H:%M:%S",
            "%Ec": "%c",
            "%EC": "%C",
            "%Ex": "%m/%d/%y",
            "%EX": "%H:%M:%S",
            "%Ey": "%y",
            "%EY": "%Y",
            "%Od": "%d",
            "%Oe": "%e",
            "%OH": "%H",
            "%OI": "%I",
            "%Om": "%m",
            "%OM": "%M",
            "%OS": "%S",
            "%Ou": "%u",
            "%OU": "%U",
            "%OV": "%V",
            "%Ow": "%w",
            "%OW": "%W",
            "%Oy": "%y"
          };
          for (var E2 in v2) c2 = c2.replace(new RegExp(E2, "g"), v2[E2]);
          var H2 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), L2 = "January February March April May June July August September October November December".split(" ");
          v2 = { "%a": (y2) => H2[y2.he].substring(0, 3), "%A": (y2) => H2[y2.he], "%b": (y2) => L2[y2.$e].substring(0, 3), "%B": (y2) => L2[y2.$e], "%C": (y2) => m2((y2.pe + 1900) / 100 | 0, 2), "%d": (y2) => m2(y2.jf, 2), "%e": (y2) => h2(y2.jf, 2, " "), "%g": (y2) => p2(y2).toString().substring(2), "%G": (y2) => p2(y2), "%H": (y2) => m2(y2.Ze, 2), "%I": (y2) => {
            y2 = y2.Ze;
            0 == y2 ? y2 = 12 : 12 < y2 && (y2 -= 12);
            return m2(y2, 2);
          }, "%j": (y2) => {
            for (var N2 = 0, T2 = 0; T2 <= y2.$e - 1; N2 += (Sd(y2.pe + 1900) ? Td : Ud)[T2++]) ;
            return m2(y2.jf + N2, 3);
          }, "%m": (y2) => m2(y2.$e + 1, 2), "%M": (y2) => m2(y2.og, 2), "%n": () => "\n", "%p": (y2) => 0 <= y2.Ze && 12 > y2.Ze ? "AM" : "PM", "%S": (y2) => m2(y2.pg, 2), "%t": () => "	", "%u": (y2) => y2.he || 7, "%U": (y2) => m2(Math.floor((y2.oe + 7 - y2.he) / 7), 2), "%V": (y2) => {
            var N2 = Math.floor((y2.oe + 7 - (y2.he + 6) % 7) / 7);
            2 >= (y2.he + 371 - y2.oe - 2) % 7 && N2++;
            if (N2) 53 == N2 && (T2 = (y2.he + 371 - y2.oe) % 7, 4 == T2 || 3 == T2 && Sd(y2.pe) || (N2 = 1));
            else {
              N2 = 52;
              var T2 = (y2.he + 7 - y2.oe - 1) % 7;
              (4 == T2 || 5 == T2 && Sd(y2.pe % 400 - 1)) && N2++;
            }
            return m2(N2, 2);
          }, "%w": (y2) => y2.he, "%W": (y2) => m2(Math.floor((y2.oe + 7 - (y2.he + 6) % 7) / 7), 2), "%y": (y2) => (y2.pe + 1900).toString().substring(2), "%Y": (y2) => y2.pe + 1900, "%z": (y2) => {
            y2 = y2.ng;
            var N2 = 0 <= y2;
            y2 = Math.abs(y2) / 60;
            return (N2 ? "+" : "-") + String("0000" + (y2 / 60 * 100 + y2 % 60)).slice(-4);
          }, "%Z": (y2) => y2.qg, "%%": () => "%" };
          c2 = c2.replace(/%%/g, "\0\0");
          for (E2 in v2) c2.includes(E2) && (c2 = c2.replace(new RegExp(E2, "g"), v2[E2](f2)));
          c2 = c2.replace(/\0\0/g, "%");
          E2 = Vd(c2);
          if (E2.length > b2) return 0;
          Qa.set(E2, a2);
          return E2.length - 1;
        };
        Cb = w2.InternalError = class extends Error {
          constructor(a2) {
            super(a2);
            this.name = "InternalError";
          }
        };
        for (var Xd = Array(256), Yd = 0; 256 > Yd; ++Yd) Xd[Yd] = String.fromCharCode(Yd);
        Hb = Xd;
        Jb = w2.BindingError = class extends Error {
          constructor(a2) {
            super(a2);
            this.name = "BindingError";
          }
        };
        dc.prototype.isAliasOf = function(a2) {
          if (!(this instanceof dc && a2 instanceof dc)) return false;
          var b2 = this.Jd.Vd.Pd, c2 = this.Jd.Rd, f2 = a2.Jd.Vd.Pd;
          for (a2 = a2.Jd.Rd; b2.$d; ) c2 = b2.Oe(c2), b2 = b2.$d;
          for (; f2.$d; ) a2 = f2.Oe(a2), f2 = f2.$d;
          return b2 === f2 && c2 === a2;
        };
        dc.prototype.clone = function() {
          this.Jd.Rd || Lb(this);
          if (this.Jd.Me) return this.Jd.count.value += 1, this;
          var a2 = cc, b2 = Object, c2 = b2.create, f2 = Object.getPrototypeOf(this), h2 = this.Jd;
          a2 = a2(c2.call(b2, f2, { Jd: { value: { count: h2.count, Ee: h2.Ee, Me: h2.Me, Rd: h2.Rd, Vd: h2.Vd, Yd: h2.Yd, ee: h2.ee } } }));
          a2.Jd.count.value += 1;
          a2.Jd.Ee = false;
          return a2;
        };
        dc.prototype["delete"] = function() {
          this.Jd.Rd || Lb(this);
          this.Jd.Ee && !this.Jd.Me && X2("Object already scheduled for deletion");
          Nb(this);
          Ob(this.Jd);
          this.Jd.Me || (this.Jd.Yd = void 0, this.Jd.Rd = void 0);
        };
        dc.prototype.isDeleted = function() {
          return !this.Jd.Rd;
        };
        dc.prototype.deleteLater = function() {
          this.Jd.Rd || Lb(this);
          this.Jd.Ee && !this.Jd.Me && X2("Object already scheduled for deletion");
          Rb.push(this);
          1 === Rb.length && Tb && Tb(Sb);
          this.Jd.Ee = true;
          return this;
        };
        w2.getInheritedInstanceCount = function() {
          return Object.keys(Ub).length;
        };
        w2.getLiveInheritedInstances = function() {
          var a2 = [], b2;
          for (b2 in Ub) Ub.hasOwnProperty(b2) && a2.push(Ub[b2]);
          return a2;
        };
        w2.flushPendingDeletes = Sb;
        w2.setDelayFunction = function(a2) {
          Tb = a2;
          Rb.length && Tb && Tb(Sb);
        };
        pc.prototype.Sf = function(a2) {
          this.vf && (a2 = this.vf(a2));
          return a2;
        };
        pc.prototype.nf = function(a2) {
          this.ke && this.ke(a2);
        };
        pc.prototype.argPackAdvance = 8;
        pc.prototype.readValueFromPointer = xb;
        pc.prototype.deleteObject = function(a2) {
          if (null !== a2) a2["delete"]();
        };
        pc.prototype.fromWireType = function(a2) {
          function b2() {
            return this.Ve ? bc(this.Pd.Fe, { Vd: this.bg, Rd: c2, ee: this, Yd: a2 }) : bc(this.Pd.Fe, { Vd: this, Rd: a2 });
          }
          var c2 = this.Sf(a2);
          if (!c2) return this.nf(a2), null;
          var f2 = ac(this.Pd, c2);
          if (void 0 !== f2) {
            if (0 === f2.Jd.count.value) return f2.Jd.Rd = c2, f2.Jd.Yd = a2, f2.clone();
            f2 = f2.clone();
            this.nf(a2);
            return f2;
          }
          f2 = this.Pd.Rf(c2);
          f2 = Qb[f2];
          if (!f2) return b2.call(this);
          f2 = this.Ue ? f2.If : f2.pointerType;
          var h2 = Pb(c2, this.Pd, f2.Pd);
          return null === h2 ? b2.call(this) : this.Ve ? bc(f2.Pd.Fe, { Vd: f2, Rd: h2, ee: this, Yd: a2 }) : bc(
            f2.Pd.Fe,
            { Vd: f2, Rd: h2 }
          );
        };
        tc = w2.UnboundTypeError = function(a2, b2) {
          var c2 = fc(b2, function(f2) {
            this.name = b2;
            this.message = f2;
            f2 = Error(f2).stack;
            void 0 !== f2 && (this.stack = this.toString() + "\n" + f2.replace(/^Error(:[^\n]*)?\n/, ""));
          });
          c2.prototype = Object.create(a2.prototype);
          c2.prototype.constructor = c2;
          c2.prototype.toString = function() {
            return void 0 === this.message ? this.name : `${this.name}: ${this.message}`;
          };
          return c2;
        }(Error, "UnboundTypeError");
        Object.assign(Gc.prototype, { get(a2) {
          return this.je[a2];
        }, has(a2) {
          return void 0 !== this.je[a2];
        }, Af(a2) {
          var b2 = this.sf.pop() || this.je.length;
          this.je[b2] = a2;
          return b2;
        }, Bf(a2) {
          this.je[a2] = void 0;
          this.sf.push(a2);
        } });
        Hc.je.push({ value: void 0 }, { value: null }, { value: true }, { value: false });
        Hc.Ge = Hc.je.length;
        w2.count_emval_handles = function() {
          for (var a2 = 0, b2 = Hc.Ge; b2 < Hc.je.length; ++b2) void 0 !== Hc.je[b2] && ++a2;
          return a2;
        };
        for (var Z2, Zd = 0; 32 > Zd; ++Zd) Fd.push(Array(Zd));
        var $d = new Float32Array(288);
        for (Zd = 0; 288 > Zd; ++Zd) Qd[Zd] = $d.subarray(0, Zd + 1);
        var ae2 = new Int32Array(288);
        for (Zd = 0; 288 > Zd; ++Zd) Rd[Zd] = ae2.subarray(0, Zd + 1);
        var qe2 = {
          T: function() {
            return 0;
          },
          Bb: () => {
          },
          Db: function() {
            return 0;
          },
          yb: () => {
          },
          zb: () => {
          },
          U: function() {
          },
          Ab: () => {
          },
          C: function(a2) {
            var b2 = vb[a2];
            delete vb[a2];
            var c2 = b2.hf, f2 = b2.ke, h2 = b2.rf, m2 = h2.map((u2) => u2.Vf).concat(h2.map((u2) => u2.fg));
            Eb([a2], m2, (u2) => {
              var n2 = {};
              h2.forEach((p2, v2) => {
                var E2 = u2[v2], H2 = p2.Tf, L2 = p2.Uf, y2 = u2[v2 + h2.length], N2 = p2.eg, T2 = p2.gg;
                n2[p2.Of] = { read: (S2) => E2.fromWireType(H2(L2, S2)), write: (S2, sa) => {
                  var ma = [];
                  N2(T2, S2, y2.toWireType(ma, sa));
                  wb(ma);
                } };
              });
              return [{ name: b2.name, fromWireType: function(p2) {
                var v2 = {}, E2;
                for (E2 in n2) v2[E2] = n2[E2].read(p2);
                f2(p2);
                return v2;
              }, toWireType: function(p2, v2) {
                for (var E2 in n2) if (!(E2 in v2)) throw new TypeError(`Missing field: "${E2}"`);
                var H2 = c2();
                for (E2 in n2) n2[E2].write(H2, v2[E2]);
                null !== p2 && p2.push(f2, H2);
                return H2;
              }, argPackAdvance: 8, readValueFromPointer: xb, de: f2 }];
            });
          },
          qb: function() {
          },
          Hb: function(a2, b2, c2, f2, h2) {
            var m2 = Gb(c2);
            b2 = Ib(b2);
            Fb(a2, { name: b2, fromWireType: function(u2) {
              return !!u2;
            }, toWireType: function(u2, n2) {
              return n2 ? f2 : h2;
            }, argPackAdvance: 8, readValueFromPointer: function(u2) {
              if (1 === c2) var n2 = Qa;
              else if (2 === c2) n2 = Ra;
              else if (4 === c2) n2 = R2;
              else throw new TypeError("Unknown boolean type size: " + b2);
              return this.fromWireType(n2[u2 >> m2]);
            }, de: null });
          },
          m: function(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2, E2, H2, L2) {
            E2 = Ib(E2);
            m2 = sc(h2, m2);
            n2 && (n2 = sc(u2, n2));
            v2 && (v2 = sc(p2, v2));
            L2 = sc(H2, L2);
            var y2 = ec(E2);
            hc(y2, function() {
              Dc(`Cannot construct ${E2} due to unbound types`, [f2]);
            });
            Eb([a2, b2, c2], f2 ? [f2] : [], function(N2) {
              N2 = N2[0];
              if (f2) {
                var T2 = N2.Pd;
                var S2 = T2.Fe;
              } else S2 = dc.prototype;
              N2 = fc(y2, function() {
                if (Object.getPrototypeOf(this) !== sa) throw new Jb("Use 'new' to construct " + E2);
                if (void 0 === ma.ne) throw new Jb(E2 + " has no accessible constructor");
                var hb = ma.ne[arguments.length];
                if (void 0 === hb) throw new Jb(`Tried to invoke ctor of ${E2} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(ma.ne).toString()}) parameters instead!`);
                return hb.apply(this, arguments);
              });
              var sa = Object.create(S2, { constructor: { value: N2 } });
              N2.prototype = sa;
              var ma = new ic(E2, N2, sa, L2, T2, m2, n2, v2);
              ma.$d && (void 0 === ma.$d.Pe && (ma.$d.Pe = []), ma.$d.Pe.push(ma));
              T2 = new pc(E2, ma, true, false, false);
              S2 = new pc(E2 + "*", ma, false, false, false);
              var gb = new pc(E2 + " const*", ma, false, true, false);
              Qb[a2] = { pointerType: S2, If: gb };
              qc(y2, N2);
              return [
                T2,
                S2,
                gb
              ];
            });
          },
          f: function(a2, b2, c2, f2, h2, m2, u2) {
            var n2 = Fc(c2, f2);
            b2 = Ib(b2);
            m2 = sc(h2, m2);
            Eb([], [a2], function(p2) {
              function v2() {
                Dc(`Cannot call ${E2} due to unbound types`, n2);
              }
              p2 = p2[0];
              var E2 = `${p2.name}.${b2}`;
              b2.startsWith("@@") && (b2 = Symbol[b2.substring(2)]);
              var H2 = p2.Pd.constructor;
              void 0 === H2[b2] ? (v2.Ce = c2 - 1, H2[b2] = v2) : (gc(H2, b2, E2), H2[b2].Xd[c2 - 1] = v2);
              Eb([], n2, function(L2) {
                L2 = [L2[0], null].concat(L2.slice(1));
                L2 = Ec(E2, L2, null, m2, u2);
                void 0 === H2[b2].Xd ? (L2.Ce = c2 - 1, H2[b2] = L2) : H2[b2].Xd[c2 - 1] = L2;
                if (p2.Pd.Pe) for (const y2 of p2.Pd.Pe) y2.constructor.hasOwnProperty(b2) || (y2.constructor[b2] = L2);
                return [];
              });
              return [];
            });
          },
          A: function(a2, b2, c2, f2, h2, m2) {
            var u2 = Fc(b2, c2);
            h2 = sc(f2, h2);
            Eb([], [a2], function(n2) {
              n2 = n2[0];
              var p2 = `constructor ${n2.name}`;
              void 0 === n2.Pd.ne && (n2.Pd.ne = []);
              if (void 0 !== n2.Pd.ne[b2 - 1]) throw new Jb(`Cannot register multiple constructors with identical number of parameters (${b2 - 1}) for class '${n2.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
              n2.Pd.ne[b2 - 1] = () => {
                Dc(`Cannot construct ${n2.name} due to unbound types`, u2);
              };
              Eb([], u2, function(v2) {
                v2.splice(
                  1,
                  0,
                  null
                );
                n2.Pd.ne[b2 - 1] = Ec(p2, v2, null, h2, m2);
                return [];
              });
              return [];
            });
          },
          b: function(a2, b2, c2, f2, h2, m2, u2, n2) {
            var p2 = Fc(c2, f2);
            b2 = Ib(b2);
            m2 = sc(h2, m2);
            Eb([], [a2], function(v2) {
              function E2() {
                Dc(`Cannot call ${H2} due to unbound types`, p2);
              }
              v2 = v2[0];
              var H2 = `${v2.name}.${b2}`;
              b2.startsWith("@@") && (b2 = Symbol[b2.substring(2)]);
              n2 && v2.Pd.cg.push(b2);
              var L2 = v2.Pd.Fe, y2 = L2[b2];
              void 0 === y2 || void 0 === y2.Xd && y2.className !== v2.name && y2.Ce === c2 - 2 ? (E2.Ce = c2 - 2, E2.className = v2.name, L2[b2] = E2) : (gc(L2, b2, H2), L2[b2].Xd[c2 - 2] = E2);
              Eb([], p2, function(N2) {
                N2 = Ec(H2, N2, v2, m2, u2);
                void 0 === L2[b2].Xd ? (N2.Ce = c2 - 2, L2[b2] = N2) : L2[b2].Xd[c2 - 2] = N2;
                return [];
              });
              return [];
            });
          },
          t: function(a2, b2, c2) {
            a2 = Ib(a2);
            Eb([], [b2], function(f2) {
              f2 = f2[0];
              w2[a2] = f2.fromWireType(c2);
              return [];
            });
          },
          Gb: function(a2, b2) {
            b2 = Ib(b2);
            Fb(a2, { name: b2, fromWireType: function(c2) {
              var f2 = Jc(c2);
              Ic(c2);
              return f2;
            }, toWireType: function(c2, f2) {
              return nc(f2);
            }, argPackAdvance: 8, readValueFromPointer: xb, de: null });
          },
          l: function(a2, b2, c2, f2) {
            function h2() {
            }
            c2 = Gb(c2);
            b2 = Ib(b2);
            h2.values = {};
            Fb(a2, {
              name: b2,
              constructor: h2,
              fromWireType: function(m2) {
                return this.constructor.values[m2];
              },
              toWireType: function(m2, u2) {
                return u2.value;
              },
              argPackAdvance: 8,
              readValueFromPointer: Kc(b2, c2, f2),
              de: null
            });
            hc(b2, h2);
          },
          c: function(a2, b2, c2) {
            var f2 = Lc(a2, "enum");
            b2 = Ib(b2);
            a2 = f2.constructor;
            f2 = Object.create(f2.constructor.prototype, { value: { value: c2 }, constructor: { value: fc(`${f2.name}_${b2}`, function() {
            }) } });
            a2.values[c2] = f2;
            a2[b2] = f2;
          },
          W: function(a2, b2, c2) {
            c2 = Gb(c2);
            b2 = Ib(b2);
            Fb(a2, { name: b2, fromWireType: function(f2) {
              return f2;
            }, toWireType: function(f2, h2) {
              return h2;
            }, argPackAdvance: 8, readValueFromPointer: Mc(b2, c2), de: null });
          },
          y: function(a2, b2, c2, f2, h2, m2) {
            var u2 = Fc(b2, c2);
            a2 = Ib(a2);
            h2 = sc(f2, h2);
            hc(a2, function() {
              Dc(
                `Cannot call ${a2} due to unbound types`,
                u2
              );
            }, b2 - 1);
            Eb([], u2, function(n2) {
              n2 = [n2[0], null].concat(n2.slice(1));
              qc(a2, Ec(a2, n2, null, h2, m2), b2 - 1);
              return [];
            });
          },
          E: function(a2, b2, c2, f2, h2) {
            b2 = Ib(b2);
            -1 === h2 && (h2 = 4294967295);
            h2 = Gb(c2);
            var m2 = (n2) => n2;
            if (0 === f2) {
              var u2 = 32 - 8 * c2;
              m2 = (n2) => n2 << u2 >>> u2;
            }
            c2 = b2.includes("unsigned") ? function(n2, p2) {
              return p2 >>> 0;
            } : function(n2, p2) {
              return p2;
            };
            Fb(a2, { name: b2, fromWireType: m2, toWireType: c2, argPackAdvance: 8, readValueFromPointer: Nc(b2, h2, 0 !== f2), de: null });
          },
          s: function(a2, b2, c2) {
            function f2(m2) {
              m2 >>= 2;
              var u2 = Ua;
              return new h2(u2.buffer, u2[m2 + 1], u2[m2]);
            }
            var h2 = [
              Int8Array,
              Uint8Array,
              Int16Array,
              Uint16Array,
              Int32Array,
              Uint32Array,
              Float32Array,
              Float64Array
            ][b2];
            c2 = Ib(c2);
            Fb(a2, { name: c2, fromWireType: f2, argPackAdvance: 8, readValueFromPointer: f2 }, { Wf: true });
          },
          q: function(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2, E2, H2) {
            c2 = Ib(c2);
            m2 = sc(h2, m2);
            n2 = sc(u2, n2);
            v2 = sc(p2, v2);
            H2 = sc(E2, H2);
            Eb([a2], [b2], function(L2) {
              L2 = L2[0];
              return [new pc(c2, L2.Pd, false, false, true, L2, f2, m2, n2, v2, H2)];
            });
          },
          V: function(a2, b2) {
            b2 = Ib(b2);
            var c2 = "std::string" === b2;
            Fb(a2, { name: b2, fromWireType: function(f2) {
              var h2 = Ua[f2 >> 2], m2 = f2 + 4;
              if (c2) for (var u2 = m2, n2 = 0; n2 <= h2; ++n2) {
                var p2 = m2 + n2;
                if (n2 == h2 || 0 == K2[p2]) {
                  u2 = u2 ? ub(
                    K2,
                    u2,
                    p2 - u2
                  ) : "";
                  if (void 0 === v2) var v2 = u2;
                  else v2 += String.fromCharCode(0), v2 += u2;
                  u2 = p2 + 1;
                }
              }
              else {
                v2 = Array(h2);
                for (n2 = 0; n2 < h2; ++n2) v2[n2] = String.fromCharCode(K2[m2 + n2]);
                v2 = v2.join("");
              }
              wc(f2);
              return v2;
            }, toWireType: function(f2, h2) {
              h2 instanceof ArrayBuffer && (h2 = new Uint8Array(h2));
              var m2 = "string" == typeof h2;
              m2 || h2 instanceof Uint8Array || h2 instanceof Uint8ClampedArray || h2 instanceof Int8Array || X2("Cannot pass non-string to std::string");
              var u2 = c2 && m2 ? qa(h2) : h2.length;
              var n2 = Kd(4 + u2 + 1), p2 = n2 + 4;
              Ua[n2 >> 2] = u2;
              if (c2 && m2) ra(h2, K2, p2, u2 + 1);
              else if (m2) for (m2 = 0; m2 < u2; ++m2) {
                var v2 = h2.charCodeAt(m2);
                255 < v2 && (wc(p2), X2("String has UTF-16 code units that do not fit in 8 bits"));
                K2[p2 + m2] = v2;
              }
              else for (m2 = 0; m2 < u2; ++m2) K2[p2 + m2] = h2[m2];
              null !== f2 && f2.push(wc, n2);
              return n2;
            }, argPackAdvance: 8, readValueFromPointer: xb, de: function(f2) {
              wc(f2);
            } });
          },
          N: function(a2, b2, c2) {
            c2 = Ib(c2);
            if (2 === b2) {
              var f2 = Pc;
              var h2 = Qc;
              var m2 = Rc;
              var u2 = () => Sa;
              var n2 = 1;
            } else 4 === b2 && (f2 = Sc, h2 = Tc, m2 = Uc, u2 = () => Ua, n2 = 2);
            Fb(a2, { name: c2, fromWireType: function(p2) {
              for (var v2 = Ua[p2 >> 2], E2 = u2(), H2, L2 = p2 + 4, y2 = 0; y2 <= v2; ++y2) {
                var N2 = p2 + 4 + y2 * b2;
                if (y2 == v2 || 0 == E2[N2 >> n2]) L2 = f2(L2, N2 - L2), void 0 === H2 ? H2 = L2 : (H2 += String.fromCharCode(0), H2 += L2), L2 = N2 + b2;
              }
              wc(p2);
              return H2;
            }, toWireType: function(p2, v2) {
              "string" != typeof v2 && X2(`Cannot pass non-string to C++ string type ${c2}`);
              var E2 = m2(v2), H2 = Kd(4 + E2 + b2);
              Ua[H2 >> 2] = E2 >> n2;
              h2(v2, H2 + 4, E2 + b2);
              null !== p2 && p2.push(wc, H2);
              return H2;
            }, argPackAdvance: 8, readValueFromPointer: xb, de: function(p2) {
              wc(p2);
            } });
          },
          D: function(a2, b2, c2, f2, h2, m2) {
            vb[a2] = { name: Ib(b2), hf: sc(c2, f2), ke: sc(h2, m2), rf: [] };
          },
          e: function(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2) {
            vb[a2].rf.push({ Of: Ib(b2), Vf: c2, Tf: sc(f2, h2), Uf: m2, fg: u2, eg: sc(n2, p2), gg: v2 });
          },
          Ib: function(a2, b2) {
            b2 = Ib(b2);
            Fb(a2, { Yf: true, name: b2, argPackAdvance: 0, fromWireType: function() {
            }, toWireType: function() {
            } });
          },
          Fb: () => true,
          ub: () => {
            throw Infinity;
          },
          F: function(a2, b2, c2) {
            a2 = Jc(a2);
            b2 = Lc(b2, "emval::as");
            var f2 = [], h2 = nc(f2);
            Ua[c2 >> 2] = h2;
            return b2.toWireType(f2, a2);
          },
          Z: function(a2, b2, c2, f2, h2) {
            a2 = Xc[a2];
            b2 = Jc(b2);
            c2 = Wc(c2);
            var m2 = [];
            Ua[f2 >> 2] = nc(m2);
            return a2(b2, c2, m2, h2);
          },
          w: function(a2, b2, c2, f2) {
            a2 = Xc[a2];
            b2 = Jc(b2);
            c2 = Wc(c2);
            a2(b2, c2, null, f2);
          },
          d: Ic,
          K: function(a2) {
            if (0 === a2) return nc(Yc());
            a2 = Wc(a2);
            return nc(Yc()[a2]);
          },
          u: function(a2, b2) {
            var c2 = $c(a2, b2), f2 = c2[0];
            b2 = f2.name + "_$" + c2.slice(1).map(function(u2) {
              return u2.name;
            }).join("_") + "$";
            var h2 = ad[b2];
            if (void 0 !== h2) return h2;
            var m2 = Array(a2 - 1);
            h2 = Zc((u2, n2, p2, v2) => {
              for (var E2 = 0, H2 = 0; H2 < a2 - 1; ++H2) m2[H2] = c2[H2 + 1].readValueFromPointer(v2 + E2), E2 += c2[H2 + 1].argPackAdvance;
              u2 = u2[n2].apply(u2, m2);
              for (H2 = 0; H2 < a2 - 1; ++H2) c2[H2 + 1].Lf && c2[H2 + 1].Lf(m2[H2]);
              if (!f2.Yf) return f2.toWireType(p2, u2);
            });
            return ad[b2] = h2;
          },
          z: function(a2, b2) {
            a2 = Jc(a2);
            b2 = Jc(b2);
            return nc(a2[b2]);
          },
          p: function(a2) {
            4 < a2 && (Hc.get(a2).wf += 1);
          },
          J: function(a2, b2, c2, f2) {
            a2 = Jc(a2);
            var h2 = cd[b2];
            h2 || (h2 = bd(b2), cd[b2] = h2);
            return h2(a2, c2, f2);
          },
          H: function() {
            return nc([]);
          },
          g: function(a2) {
            return nc(Wc(a2));
          },
          G: function() {
            return nc({});
          },
          kb: function(a2) {
            a2 = Jc(a2);
            return !a2;
          },
          B: function(a2) {
            var b2 = Jc(a2);
            wb(b2);
            Ic(a2);
          },
          i: function(a2, b2, c2) {
            a2 = Jc(a2);
            b2 = Jc(b2);
            c2 = Jc(c2);
            a2[b2] = c2;
          },
          h: function(a2, b2) {
            a2 = Lc(a2, "_emval_take_value");
            a2 = a2.readValueFromPointer(b2);
            return nc(a2);
          },
          nb: function() {
            return -52;
          },
          ob: function() {
          },
          a: () => {
            La("");
          },
          Eb: () => performance.now(),
          vb: (a2) => {
            var b2 = K2.length;
            a2 >>>= 0;
            if (2147483648 < a2) return false;
            for (var c2 = 1; 4 >= c2; c2 *= 2) {
              var f2 = b2 * (1 + 0.2 / c2);
              f2 = Math.min(f2, a2 + 100663296);
              var h2 = Math;
              f2 = Math.max(a2, f2);
              a: {
                h2 = h2.min.call(h2, 2147483648, f2 + (65536 - f2 % 65536) % 65536) - Ma.buffer.byteLength + 65535 >>> 16;
                try {
                  Ma.grow(h2);
                  Wa();
                  var m2 = 1;
                  break a;
                } catch (u2) {
                }
                m2 = void 0;
              }
              if (m2) return true;
            }
            return false;
          },
          lb: function() {
            return A2 ? A2.handle : 0;
          },
          wb: (a2, b2) => {
            var c2 = 0;
            Bd().forEach(function(f2, h2) {
              var m2 = b2 + c2;
              h2 = Ua[a2 + 4 * h2 >> 2] = m2;
              for (m2 = 0; m2 < f2.length; ++m2) Qa[h2++ >> 0] = f2.charCodeAt(m2);
              Qa[h2 >> 0] = 0;
              c2 += f2.length + 1;
            });
            return 0;
          },
          xb: (a2, b2) => {
            var c2 = Bd();
            Ua[a2 >> 2] = c2.length;
            var f2 = 0;
            c2.forEach(function(h2) {
              f2 += h2.length + 1;
            });
            Ua[b2 >> 2] = f2;
            return 0;
          },
          Jb: (a2) => {
            if (!noExitRuntime) {
              if (w2.onExit) w2.onExit(a2);
              Pa = true;
            }
            xa(a2, new rb(a2));
          },
          M: () => 52,
          mb: function() {
            return 52;
          },
          Cb: () => 52,
          pb: function() {
            return 70;
          },
          S: (a2, b2, c2, f2) => {
            for (var h2 = 0, m2 = 0; m2 < c2; m2++) {
              var u2 = Ua[b2 >> 2], n2 = Ua[b2 + 4 >> 2];
              b2 += 8;
              for (var p2 = 0; p2 < n2; p2++) {
                var v2 = K2[u2 + p2], E2 = Cd[a2];
                0 === v2 || 10 === v2 ? ((1 === a2 ? Ha : Ja)(ub(E2, 0)), E2.length = 0) : E2.push(v2);
              }
              h2 += n2;
            }
            Ua[f2 >> 2] = h2;
            return 0;
          },
          aa: function(a2) {
            Z2.activeTexture(a2);
          },
          ba: function(a2, b2) {
            Z2.attachShader(jd[a2], md[b2]);
          },
          ca: function(a2, b2, c2) {
            Z2.bindAttribLocation(jd[a2], b2, c2 ? ub(K2, c2) : "");
          },
          da: function(a2, b2) {
            35051 == a2 ? Z2.ef = b2 : 35052 == a2 && (Z2.De = b2);
            Z2.bindBuffer(a2, hd[b2]);
          },
          $: function(a2, b2) {
            Z2.bindFramebuffer(a2, kd[b2]);
          },
          fc: function(a2, b2) {
            Z2.bindRenderbuffer(a2, ld[b2]);
          },
          Rb: function(a2, b2) {
            Z2.bindSampler(a2, od[b2]);
          },
          ea: function(a2, b2) {
            Z2.bindTexture(a2, ia[b2]);
          },
          zc: Dd,
          Cc: Dd,
          fa: function(a2, b2, c2, f2) {
            Z2.blendColor(a2, b2, c2, f2);
          },
          ga: function(a2) {
            Z2.blendEquation(a2);
          },
          ha: function(a2, b2) {
            Z2.blendFunc(a2, b2);
          },
          $b: function(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2) {
            Z2.blitFramebuffer(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2);
          },
          ia: function(a2, b2, c2, f2) {
            2 <= A2.version ? c2 && b2 ? Z2.bufferData(a2, K2, f2, c2, b2) : Z2.bufferData(a2, b2, f2) : Z2.bufferData(a2, c2 ? K2.subarray(c2, c2 + b2) : b2, f2);
          },
          ja: function(a2, b2, c2, f2) {
            2 <= A2.version ? c2 && Z2.bufferSubData(a2, b2, K2, f2, c2) : Z2.bufferSubData(a2, b2, K2.subarray(f2, f2 + c2));
          },
          gc: function(a2) {
            return Z2.checkFramebufferStatus(a2);
          },
          Q: function(a2) {
            Z2.clear(a2);
          },
          _: function(a2, b2, c2, f2) {
            Z2.clearColor(a2, b2, c2, f2);
          },
          R: function(a2) {
            Z2.clearStencil(a2);
          },
          sb: function(a2, b2, c2, f2) {
            return Z2.clientWaitSync(pd[a2], b2, (c2 >>> 0) + 4294967296 * f2);
          },
          ka: function(a2, b2, c2, f2) {
            Z2.colorMask(!!a2, !!b2, !!c2, !!f2);
          },
          la: function(a2) {
            Z2.compileShader(md[a2]);
          },
          ma: function(a2, b2, c2, f2, h2, m2, u2, n2) {
            2 <= A2.version ? Z2.De || !u2 ? Z2.compressedTexImage2D(a2, b2, c2, f2, h2, m2, u2, n2) : Z2.compressedTexImage2D(
              a2,
              b2,
              c2,
              f2,
              h2,
              m2,
              K2,
              n2,
              u2
            ) : Z2.compressedTexImage2D(a2, b2, c2, f2, h2, m2, n2 ? K2.subarray(n2, n2 + u2) : null);
          },
          na: function(a2, b2, c2, f2, h2, m2, u2, n2, p2) {
            2 <= A2.version ? Z2.De || !n2 ? Z2.compressedTexSubImage2D(a2, b2, c2, f2, h2, m2, u2, n2, p2) : Z2.compressedTexSubImage2D(a2, b2, c2, f2, h2, m2, u2, K2, p2, n2) : Z2.compressedTexSubImage2D(a2, b2, c2, f2, h2, m2, u2, p2 ? K2.subarray(p2, p2 + n2) : null);
          },
          Zb: function(a2, b2, c2, f2, h2) {
            Z2.copyBufferSubData(a2, b2, c2, f2, h2);
          },
          oa: function(a2, b2, c2, f2, h2, m2, u2, n2) {
            Z2.copyTexSubImage2D(a2, b2, c2, f2, h2, m2, u2, n2);
          },
          pa: function() {
            var a2 = ha(jd), b2 = Z2.createProgram();
            b2.name = a2;
            b2.Ye = b2.We = b2.Xe = 0;
            b2.kf = 1;
            jd[a2] = b2;
            return a2;
          },
          qa: function(a2) {
            var b2 = ha(md);
            md[b2] = Z2.createShader(a2);
            return b2;
          },
          ra: function(a2) {
            Z2.cullFace(a2);
          },
          sa: function(a2, b2) {
            for (var c2 = 0; c2 < a2; c2++) {
              var f2 = R2[b2 + 4 * c2 >> 2], h2 = hd[f2];
              h2 && (Z2.deleteBuffer(h2), h2.name = 0, hd[f2] = null, f2 == Z2.ef && (Z2.ef = 0), f2 == Z2.De && (Z2.De = 0));
            }
          },
          hc: function(a2, b2) {
            for (var c2 = 0; c2 < a2; ++c2) {
              var f2 = R2[b2 + 4 * c2 >> 2], h2 = kd[f2];
              h2 && (Z2.deleteFramebuffer(h2), h2.name = 0, kd[f2] = null);
            }
          },
          ta: function(a2) {
            if (a2) {
              var b2 = jd[a2];
              b2 ? (Z2.deleteProgram(b2), b2.name = 0, jd[a2] = null) : td(1281);
            }
          },
          ic: function(a2, b2) {
            for (var c2 = 0; c2 < a2; c2++) {
              var f2 = R2[b2 + 4 * c2 >> 2], h2 = ld[f2];
              h2 && (Z2.deleteRenderbuffer(h2), h2.name = 0, ld[f2] = null);
            }
          },
          Sb: function(a2, b2) {
            for (var c2 = 0; c2 < a2; c2++) {
              var f2 = R2[b2 + 4 * c2 >> 2], h2 = od[f2];
              h2 && (Z2.deleteSampler(h2), h2.name = 0, od[f2] = null);
            }
          },
          ua: function(a2) {
            if (a2) {
              var b2 = md[a2];
              b2 ? (Z2.deleteShader(b2), md[a2] = null) : td(1281);
            }
          },
          _b: function(a2) {
            if (a2) {
              var b2 = pd[a2];
              b2 ? (Z2.deleteSync(b2), b2.name = 0, pd[a2] = null) : td(1281);
            }
          },
          va: function(a2, b2) {
            for (var c2 = 0; c2 < a2; c2++) {
              var f2 = R2[b2 + 4 * c2 >> 2], h2 = ia[f2];
              h2 && (Z2.deleteTexture(h2), h2.name = 0, ia[f2] = null);
            }
          },
          Ac: Ed,
          Dc: Ed,
          wa: function(a2) {
            Z2.depthMask(!!a2);
          },
          xa: function(a2) {
            Z2.disable(a2);
          },
          ya: function(a2) {
            Z2.disableVertexAttribArray(a2);
          },
          za: function(a2, b2, c2) {
            Z2.drawArrays(a2, b2, c2);
          },
          xc: function(a2, b2, c2, f2) {
            Z2.drawArraysInstanced(a2, b2, c2, f2);
          },
          vc: function(a2, b2, c2, f2, h2) {
            Z2.pf.drawArraysInstancedBaseInstanceWEBGL(a2, b2, c2, f2, h2);
          },
          tc: function(a2, b2) {
            for (var c2 = Fd[a2], f2 = 0; f2 < a2; f2++) c2[f2] = R2[b2 + 4 * f2 >> 2];
            Z2.drawBuffers(c2);
          },
          Aa: Gd,
          yc: function(a2, b2, c2, f2, h2) {
            Z2.drawElementsInstanced(a2, b2, c2, f2, h2);
          },
          wc: function(a2, b2, c2, f2, h2, m2, u2) {
            Z2.pf.drawElementsInstancedBaseVertexBaseInstanceWEBGL(a2, b2, c2, f2, h2, m2, u2);
          },
          nc: function(a2, b2, c2, f2, h2, m2) {
            Gd(a2, f2, h2, m2);
          },
          Ba: function(a2) {
            Z2.enable(a2);
          },
          Ca: function(a2) {
            Z2.enableVertexAttribArray(a2);
          },
          Xb: function(a2, b2) {
            return (a2 = Z2.fenceSync(a2, b2)) ? (b2 = ha(pd), a2.name = b2, pd[b2] = a2, b2) : 0;
          },
          Da: function() {
            Z2.finish();
          },
          Ea: function() {
            Z2.flush();
          },
          jc: function(a2, b2, c2, f2) {
            Z2.framebufferRenderbuffer(a2, b2, c2, ld[f2]);
          },
          kc: function(a2, b2, c2, f2, h2) {
            Z2.framebufferTexture2D(a2, b2, c2, ia[f2], h2);
          },
          Fa: function(a2) {
            Z2.frontFace(a2);
          },
          Ga: function(a2, b2) {
            Hd(a2, b2, "createBuffer", hd);
          },
          lc: function(a2, b2) {
            Hd(a2, b2, "createFramebuffer", kd);
          },
          mc: function(a2, b2) {
            Hd(a2, b2, "createRenderbuffer", ld);
          },
          Tb: function(a2, b2) {
            Hd(
              a2,
              b2,
              "createSampler",
              od
            );
          },
          Ha: function(a2, b2) {
            Hd(a2, b2, "createTexture", ia);
          },
          Bc: Id,
          Ec: Id,
          bc: function(a2) {
            Z2.generateMipmap(a2);
          },
          Ia: function(a2, b2, c2) {
            c2 ? R2[c2 >> 2] = Z2.getBufferParameter(a2, b2) : td(1281);
          },
          Ja: function() {
            var a2 = Z2.getError() || ud;
            ud = 0;
            return a2;
          },
          Ka: function(a2, b2) {
            Jd(a2, b2, 2);
          },
          cc: function(a2, b2, c2, f2) {
            a2 = Z2.getFramebufferAttachmentParameter(a2, b2, c2);
            if (a2 instanceof WebGLRenderbuffer || a2 instanceof WebGLTexture) a2 = a2.name | 0;
            R2[f2 >> 2] = a2;
          },
          L: function(a2, b2) {
            Jd(a2, b2, 0);
          },
          La: function(a2, b2, c2, f2) {
            a2 = Z2.getProgramInfoLog(jd[a2]);
            null === a2 && (a2 = "(unknown error)");
            b2 = 0 < b2 && f2 ? ra(a2, K2, f2, b2) : 0;
            c2 && (R2[c2 >> 2] = b2);
          },
          Ma: function(a2, b2, c2) {
            if (c2) if (a2 >= gd) td(1281);
            else if (a2 = jd[a2], 35716 == b2) a2 = Z2.getProgramInfoLog(a2), null === a2 && (a2 = "(unknown error)"), R2[c2 >> 2] = a2.length + 1;
            else if (35719 == b2) {
              if (!a2.Ye) for (b2 = 0; b2 < Z2.getProgramParameter(a2, 35718); ++b2) a2.Ye = Math.max(a2.Ye, Z2.getActiveUniform(a2, b2).name.length + 1);
              R2[c2 >> 2] = a2.Ye;
            } else if (35722 == b2) {
              if (!a2.We) for (b2 = 0; b2 < Z2.getProgramParameter(a2, 35721); ++b2) a2.We = Math.max(a2.We, Z2.getActiveAttrib(a2, b2).name.length + 1);
              R2[c2 >> 2] = a2.We;
            } else if (35381 == b2) {
              if (!a2.Xe) for (b2 = 0; b2 < Z2.getProgramParameter(a2, 35382); ++b2) a2.Xe = Math.max(a2.Xe, Z2.getActiveUniformBlockName(a2, b2).length + 1);
              R2[c2 >> 2] = a2.Xe;
            } else R2[c2 >> 2] = Z2.getProgramParameter(a2, b2);
            else td(1281);
          },
          dc: function(a2, b2, c2) {
            c2 ? R2[c2 >> 2] = Z2.getRenderbufferParameter(a2, b2) : td(1281);
          },
          Na: function(a2, b2, c2, f2) {
            a2 = Z2.getShaderInfoLog(md[a2]);
            null === a2 && (a2 = "(unknown error)");
            b2 = 0 < b2 && f2 ? ra(a2, K2, f2, b2) : 0;
            c2 && (R2[c2 >> 2] = b2);
          },
          Ob: function(a2, b2, c2, f2) {
            a2 = Z2.getShaderPrecisionFormat(a2, b2);
            R2[c2 >> 2] = a2.rangeMin;
            R2[c2 + 4 >> 2] = a2.rangeMax;
            R2[f2 >> 2] = a2.precision;
          },
          Oa: function(a2, b2, c2) {
            c2 ? 35716 == b2 ? (a2 = Z2.getShaderInfoLog(md[a2]), null === a2 && (a2 = "(unknown error)"), R2[c2 >> 2] = a2 ? a2.length + 1 : 0) : 35720 == b2 ? (a2 = Z2.getShaderSource(md[a2]), R2[c2 >> 2] = a2 ? a2.length + 1 : 0) : R2[c2 >> 2] = Z2.getShaderParameter(md[a2], b2) : td(1281);
          },
          P: function(a2) {
            var b2 = qd[a2];
            if (!b2) {
              switch (a2) {
                case 7939:
                  b2 = Z2.getSupportedExtensions() || [];
                  b2 = b2.concat(b2.map(function(f2) {
                    return "GL_" + f2;
                  }));
                  b2 = Ld(b2.join(" "));
                  break;
                case 7936:
                case 7937:
                case 37445:
                case 37446:
                  (b2 = Z2.getParameter(a2)) || td(1280);
                  b2 = b2 && Ld(b2);
                  break;
                case 7938:
                  b2 = Z2.getParameter(7938);
                  b2 = 2 <= A2.version ? "OpenGL ES 3.0 (" + b2 + ")" : "OpenGL ES 2.0 (" + b2 + ")";
                  b2 = Ld(b2);
                  break;
                case 35724:
                  b2 = Z2.getParameter(35724);
                  var c2 = b2.match(/^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/);
                  null !== c2 && (3 == c2[1].length && (c2[1] += "0"), b2 = "OpenGL ES GLSL ES " + c2[1] + " (" + b2 + ")");
                  b2 = Ld(b2);
                  break;
                default:
                  td(1280);
              }
              qd[a2] = b2;
            }
            return b2;
          },
          jb: function(a2, b2) {
            if (2 > A2.version) return td(1282), 0;
            var c2 = rd[a2];
            if (c2) return 0 > b2 || b2 >= c2.length ? (td(1281), 0) : c2[b2];
            switch (a2) {
              case 7939:
                return c2 = Z2.getSupportedExtensions() || [], c2 = c2.concat(c2.map(function(f2) {
                  return "GL_" + f2;
                })), c2 = c2.map(function(f2) {
                  return Ld(f2);
                }), c2 = rd[a2] = c2, 0 > b2 || b2 >= c2.length ? (td(1281), 0) : c2[b2];
              default:
                return td(1280), 0;
            }
          },
          Pa: function(a2, b2) {
            b2 = b2 ? ub(K2, b2) : "";
            if (a2 = jd[a2]) {
              var c2 = a2, f2 = c2.Ne, h2 = c2.yf, m2;
              if (!f2) for (c2.Ne = f2 = {}, c2.xf = {}, m2 = 0; m2 < Z2.getProgramParameter(c2, 35718); ++m2) {
                var u2 = Z2.getActiveUniform(c2, m2);
                var n2 = u2.name;
                u2 = u2.size;
                var p2 = Md(n2);
                p2 = 0 < p2 ? n2.slice(0, p2) : n2;
                var v2 = c2.kf;
                c2.kf += u2;
                h2[p2] = [u2, v2];
                for (n2 = 0; n2 < u2; ++n2) f2[v2] = n2, c2.xf[v2++] = p2;
              }
              c2 = a2.Ne;
              f2 = 0;
              h2 = b2;
              m2 = Md(b2);
              0 < m2 && (f2 = parseInt(b2.slice(m2 + 1)) >>> 0, h2 = b2.slice(0, m2));
              if ((h2 = a2.yf[h2]) && f2 < h2[0] && (f2 += h2[1], c2[f2] = c2[f2] || Z2.getUniformLocation(
                a2,
                b2
              ))) return f2;
            } else td(1281);
            return -1;
          },
          Pb: function(a2, b2, c2) {
            for (var f2 = Fd[b2], h2 = 0; h2 < b2; h2++) f2[h2] = R2[c2 + 4 * h2 >> 2];
            Z2.invalidateFramebuffer(a2, f2);
          },
          Qb: function(a2, b2, c2, f2, h2, m2, u2) {
            for (var n2 = Fd[b2], p2 = 0; p2 < b2; p2++) n2[p2] = R2[c2 + 4 * p2 >> 2];
            Z2.invalidateSubFramebuffer(a2, n2, f2, h2, m2, u2);
          },
          Yb: function(a2) {
            return Z2.isSync(pd[a2]);
          },
          Qa: function(a2) {
            return (a2 = ia[a2]) ? Z2.isTexture(a2) : 0;
          },
          Ra: function(a2) {
            Z2.lineWidth(a2);
          },
          Sa: function(a2) {
            a2 = jd[a2];
            Z2.linkProgram(a2);
            a2.Ne = 0;
            a2.yf = {};
          },
          rc: function(a2, b2, c2, f2, h2, m2) {
            Z2.uf.multiDrawArraysInstancedBaseInstanceWEBGL(
              a2,
              R2,
              b2 >> 2,
              R2,
              c2 >> 2,
              R2,
              f2 >> 2,
              Ua,
              h2 >> 2,
              m2
            );
          },
          sc: function(a2, b2, c2, f2, h2, m2, u2, n2) {
            Z2.uf.multiDrawElementsInstancedBaseVertexBaseInstanceWEBGL(a2, R2, b2 >> 2, c2, R2, f2 >> 2, R2, h2 >> 2, R2, m2 >> 2, Ua, u2 >> 2, n2);
          },
          Ta: function(a2, b2) {
            3317 == a2 && (sd = b2);
            Z2.pixelStorei(a2, b2);
          },
          uc: function(a2) {
            Z2.readBuffer(a2);
          },
          Ua: function(a2, b2, c2, f2, h2, m2, u2) {
            if (2 <= A2.version) if (Z2.ef) Z2.readPixels(a2, b2, c2, f2, h2, m2, u2);
            else {
              var n2 = Nd(m2);
              Z2.readPixels(a2, b2, c2, f2, h2, m2, n2, u2 >> 31 - Math.clz32(n2.BYTES_PER_ELEMENT));
            }
            else (u2 = Od(m2, h2, c2, f2, u2)) ? Z2.readPixels(a2, b2, c2, f2, h2, m2, u2) : td(1280);
          },
          ec: function(a2, b2, c2, f2) {
            Z2.renderbufferStorage(
              a2,
              b2,
              c2,
              f2
            );
          },
          ac: function(a2, b2, c2, f2, h2) {
            Z2.renderbufferStorageMultisample(a2, b2, c2, f2, h2);
          },
          Ub: function(a2, b2, c2) {
            Z2.samplerParameterf(od[a2], b2, c2);
          },
          Vb: function(a2, b2, c2) {
            Z2.samplerParameteri(od[a2], b2, c2);
          },
          Wb: function(a2, b2, c2) {
            Z2.samplerParameteri(od[a2], b2, R2[c2 >> 2]);
          },
          Va: function(a2, b2, c2, f2) {
            Z2.scissor(a2, b2, c2, f2);
          },
          Wa: function(a2, b2, c2, f2) {
            for (var h2 = "", m2 = 0; m2 < b2; ++m2) {
              var u2 = f2 ? R2[f2 + 4 * m2 >> 2] : -1, n2 = R2[c2 + 4 * m2 >> 2];
              u2 = n2 ? ub(K2, n2, 0 > u2 ? void 0 : u2) : "";
              h2 += u2;
            }
            Z2.shaderSource(md[a2], h2);
          },
          Xa: function(a2, b2, c2) {
            Z2.stencilFunc(a2, b2, c2);
          },
          Ya: function(a2, b2, c2, f2) {
            Z2.stencilFuncSeparate(
              a2,
              b2,
              c2,
              f2
            );
          },
          Za: function(a2) {
            Z2.stencilMask(a2);
          },
          _a: function(a2, b2) {
            Z2.stencilMaskSeparate(a2, b2);
          },
          $a: function(a2, b2, c2) {
            Z2.stencilOp(a2, b2, c2);
          },
          ab: function(a2, b2, c2, f2) {
            Z2.stencilOpSeparate(a2, b2, c2, f2);
          },
          bb: function(a2, b2, c2, f2, h2, m2, u2, n2, p2) {
            if (2 <= A2.version) if (Z2.De) Z2.texImage2D(a2, b2, c2, f2, h2, m2, u2, n2, p2);
            else if (p2) {
              var v2 = Nd(n2);
              Z2.texImage2D(a2, b2, c2, f2, h2, m2, u2, n2, v2, p2 >> 31 - Math.clz32(v2.BYTES_PER_ELEMENT));
            } else Z2.texImage2D(a2, b2, c2, f2, h2, m2, u2, n2, null);
            else Z2.texImage2D(a2, b2, c2, f2, h2, m2, u2, n2, p2 ? Od(n2, u2, f2, h2, p2) : null);
          },
          cb: function(a2, b2, c2) {
            Z2.texParameterf(a2, b2, c2);
          },
          db: function(a2, b2, c2) {
            Z2.texParameterf(a2, b2, V2[c2 >> 2]);
          },
          eb: function(a2, b2, c2) {
            Z2.texParameteri(a2, b2, c2);
          },
          fb: function(a2, b2, c2) {
            Z2.texParameteri(a2, b2, R2[c2 >> 2]);
          },
          oc: function(a2, b2, c2, f2, h2) {
            Z2.texStorage2D(a2, b2, c2, f2, h2);
          },
          gb: function(a2, b2, c2, f2, h2, m2, u2, n2, p2) {
            if (2 <= A2.version) if (Z2.De) Z2.texSubImage2D(a2, b2, c2, f2, h2, m2, u2, n2, p2);
            else if (p2) {
              var v2 = Nd(n2);
              Z2.texSubImage2D(a2, b2, c2, f2, h2, m2, u2, n2, v2, p2 >> 31 - Math.clz32(v2.BYTES_PER_ELEMENT));
            } else Z2.texSubImage2D(a2, b2, c2, f2, h2, m2, u2, n2, null);
            else v2 = null, p2 && (v2 = Od(n2, u2, h2, m2, p2)), Z2.texSubImage2D(a2, b2, c2, f2, h2, m2, u2, n2, v2);
          },
          hb: function(a2, b2) {
            Z2.uniform1f(
              Pd(a2),
              b2
            );
          },
          ib: function(a2, b2, c2) {
            if (2 <= A2.version) b2 && Z2.uniform1fv(Pd(a2), V2, c2 >> 2, b2);
            else {
              if (288 >= b2) for (var f2 = Qd[b2 - 1], h2 = 0; h2 < b2; ++h2) f2[h2] = V2[c2 + 4 * h2 >> 2];
              else f2 = V2.subarray(c2 >> 2, c2 + 4 * b2 >> 2);
              Z2.uniform1fv(Pd(a2), f2);
            }
          },
          Zc: function(a2, b2) {
            Z2.uniform1i(Pd(a2), b2);
          },
          _c: function(a2, b2, c2) {
            if (2 <= A2.version) b2 && Z2.uniform1iv(Pd(a2), R2, c2 >> 2, b2);
            else {
              if (288 >= b2) for (var f2 = Rd[b2 - 1], h2 = 0; h2 < b2; ++h2) f2[h2] = R2[c2 + 4 * h2 >> 2];
              else f2 = R2.subarray(c2 >> 2, c2 + 4 * b2 >> 2);
              Z2.uniform1iv(Pd(a2), f2);
            }
          },
          $c: function(a2, b2, c2) {
            Z2.uniform2f(Pd(a2), b2, c2);
          },
          ad: function(a2, b2, c2) {
            if (2 <= A2.version) b2 && Z2.uniform2fv(
              Pd(a2),
              V2,
              c2 >> 2,
              2 * b2
            );
            else {
              if (144 >= b2) for (var f2 = Qd[2 * b2 - 1], h2 = 0; h2 < 2 * b2; h2 += 2) f2[h2] = V2[c2 + 4 * h2 >> 2], f2[h2 + 1] = V2[c2 + (4 * h2 + 4) >> 2];
              else f2 = V2.subarray(c2 >> 2, c2 + 8 * b2 >> 2);
              Z2.uniform2fv(Pd(a2), f2);
            }
          },
          Yc: function(a2, b2, c2) {
            Z2.uniform2i(Pd(a2), b2, c2);
          },
          Xc: function(a2, b2, c2) {
            if (2 <= A2.version) b2 && Z2.uniform2iv(Pd(a2), R2, c2 >> 2, 2 * b2);
            else {
              if (144 >= b2) for (var f2 = Rd[2 * b2 - 1], h2 = 0; h2 < 2 * b2; h2 += 2) f2[h2] = R2[c2 + 4 * h2 >> 2], f2[h2 + 1] = R2[c2 + (4 * h2 + 4) >> 2];
              else f2 = R2.subarray(c2 >> 2, c2 + 8 * b2 >> 2);
              Z2.uniform2iv(Pd(a2), f2);
            }
          },
          Wc: function(a2, b2, c2, f2) {
            Z2.uniform3f(Pd(a2), b2, c2, f2);
          },
          Vc: function(a2, b2, c2) {
            if (2 <= A2.version) b2 && Z2.uniform3fv(Pd(a2), V2, c2 >> 2, 3 * b2);
            else {
              if (96 >= b2) for (var f2 = Qd[3 * b2 - 1], h2 = 0; h2 < 3 * b2; h2 += 3) f2[h2] = V2[c2 + 4 * h2 >> 2], f2[h2 + 1] = V2[c2 + (4 * h2 + 4) >> 2], f2[h2 + 2] = V2[c2 + (4 * h2 + 8) >> 2];
              else f2 = V2.subarray(c2 >> 2, c2 + 12 * b2 >> 2);
              Z2.uniform3fv(Pd(a2), f2);
            }
          },
          Uc: function(a2, b2, c2, f2) {
            Z2.uniform3i(Pd(a2), b2, c2, f2);
          },
          Tc: function(a2, b2, c2) {
            if (2 <= A2.version) b2 && Z2.uniform3iv(Pd(a2), R2, c2 >> 2, 3 * b2);
            else {
              if (96 >= b2) for (var f2 = Rd[3 * b2 - 1], h2 = 0; h2 < 3 * b2; h2 += 3) f2[h2] = R2[c2 + 4 * h2 >> 2], f2[h2 + 1] = R2[c2 + (4 * h2 + 4) >> 2], f2[h2 + 2] = R2[c2 + (4 * h2 + 8) >> 2];
              else f2 = R2.subarray(c2 >> 2, c2 + 12 * b2 >> 2);
              Z2.uniform3iv(Pd(a2), f2);
            }
          },
          Sc: function(a2, b2, c2, f2, h2) {
            Z2.uniform4f(Pd(a2), b2, c2, f2, h2);
          },
          Rc: function(a2, b2, c2) {
            if (2 <= A2.version) b2 && Z2.uniform4fv(Pd(a2), V2, c2 >> 2, 4 * b2);
            else {
              if (72 >= b2) {
                var f2 = Qd[4 * b2 - 1], h2 = V2;
                c2 >>= 2;
                for (var m2 = 0; m2 < 4 * b2; m2 += 4) {
                  var u2 = c2 + m2;
                  f2[m2] = h2[u2];
                  f2[m2 + 1] = h2[u2 + 1];
                  f2[m2 + 2] = h2[u2 + 2];
                  f2[m2 + 3] = h2[u2 + 3];
                }
              } else f2 = V2.subarray(c2 >> 2, c2 + 16 * b2 >> 2);
              Z2.uniform4fv(Pd(a2), f2);
            }
          },
          Fc: function(a2, b2, c2, f2, h2) {
            Z2.uniform4i(Pd(a2), b2, c2, f2, h2);
          },
          Gc: function(a2, b2, c2) {
            if (2 <= A2.version) b2 && Z2.uniform4iv(Pd(a2), R2, c2 >> 2, 4 * b2);
            else {
              if (72 >= b2) for (var f2 = Rd[4 * b2 - 1], h2 = 0; h2 < 4 * b2; h2 += 4) f2[h2] = R2[c2 + 4 * h2 >> 2], f2[h2 + 1] = R2[c2 + (4 * h2 + 4) >> 2], f2[h2 + 2] = R2[c2 + (4 * h2 + 8) >> 2], f2[h2 + 3] = R2[c2 + (4 * h2 + 12) >> 2];
              else f2 = R2.subarray(c2 >> 2, c2 + 16 * b2 >> 2);
              Z2.uniform4iv(Pd(a2), f2);
            }
          },
          Hc: function(a2, b2, c2, f2) {
            if (2 <= A2.version) b2 && Z2.uniformMatrix2fv(Pd(a2), !!c2, V2, f2 >> 2, 4 * b2);
            else {
              if (72 >= b2) for (var h2 = Qd[4 * b2 - 1], m2 = 0; m2 < 4 * b2; m2 += 4) h2[m2] = V2[f2 + 4 * m2 >> 2], h2[m2 + 1] = V2[f2 + (4 * m2 + 4) >> 2], h2[m2 + 2] = V2[f2 + (4 * m2 + 8) >> 2], h2[m2 + 3] = V2[f2 + (4 * m2 + 12) >> 2];
              else h2 = V2.subarray(f2 >> 2, f2 + 16 * b2 >> 2);
              Z2.uniformMatrix2fv(Pd(a2), !!c2, h2);
            }
          },
          Ic: function(a2, b2, c2, f2) {
            if (2 <= A2.version) b2 && Z2.uniformMatrix3fv(Pd(a2), !!c2, V2, f2 >> 2, 9 * b2);
            else {
              if (32 >= b2) for (var h2 = Qd[9 * b2 - 1], m2 = 0; m2 < 9 * b2; m2 += 9) h2[m2] = V2[f2 + 4 * m2 >> 2], h2[m2 + 1] = V2[f2 + (4 * m2 + 4) >> 2], h2[m2 + 2] = V2[f2 + (4 * m2 + 8) >> 2], h2[m2 + 3] = V2[f2 + (4 * m2 + 12) >> 2], h2[m2 + 4] = V2[f2 + (4 * m2 + 16) >> 2], h2[m2 + 5] = V2[f2 + (4 * m2 + 20) >> 2], h2[m2 + 6] = V2[f2 + (4 * m2 + 24) >> 2], h2[m2 + 7] = V2[f2 + (4 * m2 + 28) >> 2], h2[m2 + 8] = V2[f2 + (4 * m2 + 32) >> 2];
              else h2 = V2.subarray(f2 >> 2, f2 + 36 * b2 >> 2);
              Z2.uniformMatrix3fv(Pd(a2), !!c2, h2);
            }
          },
          Jc: function(a2, b2, c2, f2) {
            if (2 <= A2.version) b2 && Z2.uniformMatrix4fv(Pd(a2), !!c2, V2, f2 >> 2, 16 * b2);
            else {
              if (18 >= b2) {
                var h2 = Qd[16 * b2 - 1], m2 = V2;
                f2 >>= 2;
                for (var u2 = 0; u2 < 16 * b2; u2 += 16) {
                  var n2 = f2 + u2;
                  h2[u2] = m2[n2];
                  h2[u2 + 1] = m2[n2 + 1];
                  h2[u2 + 2] = m2[n2 + 2];
                  h2[u2 + 3] = m2[n2 + 3];
                  h2[u2 + 4] = m2[n2 + 4];
                  h2[u2 + 5] = m2[n2 + 5];
                  h2[u2 + 6] = m2[n2 + 6];
                  h2[u2 + 7] = m2[n2 + 7];
                  h2[u2 + 8] = m2[n2 + 8];
                  h2[u2 + 9] = m2[n2 + 9];
                  h2[u2 + 10] = m2[n2 + 10];
                  h2[u2 + 11] = m2[n2 + 11];
                  h2[u2 + 12] = m2[n2 + 12];
                  h2[u2 + 13] = m2[n2 + 13];
                  h2[u2 + 14] = m2[n2 + 14];
                  h2[u2 + 15] = m2[n2 + 15];
                }
              } else h2 = V2.subarray(f2 >> 2, f2 + 64 * b2 >> 2);
              Z2.uniformMatrix4fv(Pd(a2), !!c2, h2);
            }
          },
          Kc: function(a2) {
            a2 = jd[a2];
            Z2.useProgram(a2);
            Z2.Kf = a2;
          },
          Lc: function(a2, b2) {
            Z2.vertexAttrib1f(a2, b2);
          },
          Mc: function(a2, b2) {
            Z2.vertexAttrib2f(a2, V2[b2 >> 2], V2[b2 + 4 >> 2]);
          },
          Nc: function(a2, b2) {
            Z2.vertexAttrib3f(a2, V2[b2 >> 2], V2[b2 + 4 >> 2], V2[b2 + 8 >> 2]);
          },
          Oc: function(a2, b2) {
            Z2.vertexAttrib4f(a2, V2[b2 >> 2], V2[b2 + 4 >> 2], V2[b2 + 8 >> 2], V2[b2 + 12 >> 2]);
          },
          pc: function(a2, b2) {
            Z2.vertexAttribDivisor(a2, b2);
          },
          qc: function(a2, b2, c2, f2, h2) {
            Z2.vertexAttribIPointer(a2, b2, c2, f2, h2);
          },
          Pc: function(a2, b2, c2, f2, h2, m2) {
            Z2.vertexAttribPointer(a2, b2, c2, !!f2, h2, m2);
          },
          Qc: function(a2, b2, c2, f2) {
            Z2.viewport(a2, b2, c2, f2);
          },
          rb: function(a2, b2, c2, f2) {
            Z2.waitSync(pd[a2], b2, (c2 >>> 0) + 4294967296 * f2);
          },
          j: be2,
          n: ce2,
          k: de2,
          I: ee2,
          Lb: fe2,
          Y: ge2,
          X: he2,
          O: ie2,
          o: je2,
          x: ke2,
          r: le2,
          v: me2,
          Kb: ne2,
          Mb: oe2,
          Nb: pe2,
          tb: (a2, b2, c2, f2) => Wd(a2, b2, c2, f2)
        };
        (function() {
          function a2(c2) {
            Q2 = c2 = c2.exports;
            Ma = Q2.bd;
            Wa();
            Xa = Q2.dd;
            Za.unshift(Q2.cd);
            db--;
            w2.monitorRunDependencies && w2.monitorRunDependencies(db);
            if (0 == db && (null !== eb && (clearInterval(eb), eb = null), fb)) {
              var f2 = fb;
              fb = null;
              f2();
            }
            return c2;
          }
          var b2 = { a: qe2 };
          db++;
          w2.monitorRunDependencies && w2.monitorRunDependencies(db);
          if (w2.instantiateWasm) try {
            return w2.instantiateWasm(b2, a2);
          } catch (c2) {
            Ja("Module.instantiateWasm callback failed with error: " + c2), fa(c2);
          }
          qb(b2, function(c2) {
            a2(c2.instance);
          }).catch(fa);
          return {};
        })();
        var wc = w2._free = (a2) => (wc = w2._free = Q2.ed)(a2), Kd = w2._malloc = (a2) => (Kd = w2._malloc = Q2.fd)(a2), vc = (a2) => (vc = Q2.gd)(a2);
        w2.__embind_initialize_bindings = () => (w2.__embind_initialize_bindings = Q2.hd)();
        var re2 = (a2, b2) => (re2 = Q2.id)(a2, b2), se2 = () => (se2 = Q2.jd)(), te2 = (a2) => (te2 = Q2.kd)(a2);
        w2.dynCall_viji = (a2, b2, c2, f2, h2) => (w2.dynCall_viji = Q2.ld)(a2, b2, c2, f2, h2);
        w2.dynCall_vijiii = (a2, b2, c2, f2, h2, m2, u2) => (w2.dynCall_vijiii = Q2.md)(a2, b2, c2, f2, h2, m2, u2);
        w2.dynCall_viiiiij = (a2, b2, c2, f2, h2, m2, u2, n2) => (w2.dynCall_viiiiij = Q2.nd)(a2, b2, c2, f2, h2, m2, u2, n2);
        w2.dynCall_jiiiijiiiii = (a2, b2, c2, f2, h2, m2, u2, n2, p2, v2, E2, H2) => (w2.dynCall_jiiiijiiiii = Q2.od)(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2, E2, H2);
        w2.dynCall_viiij = (a2, b2, c2, f2, h2, m2) => (w2.dynCall_viiij = Q2.pd)(a2, b2, c2, f2, h2, m2);
        w2.dynCall_jii = (a2, b2, c2) => (w2.dynCall_jii = Q2.qd)(a2, b2, c2);
        w2.dynCall_vij = (a2, b2, c2, f2) => (w2.dynCall_vij = Q2.rd)(a2, b2, c2, f2);
        w2.dynCall_iiij = (a2, b2, c2, f2, h2) => (w2.dynCall_iiij = Q2.sd)(a2, b2, c2, f2, h2);
        w2.dynCall_iiiij = (a2, b2, c2, f2, h2, m2) => (w2.dynCall_iiiij = Q2.td)(a2, b2, c2, f2, h2, m2);
        w2.dynCall_viij = (a2, b2, c2, f2, h2) => (w2.dynCall_viij = Q2.ud)(a2, b2, c2, f2, h2);
        w2.dynCall_ji = (a2, b2) => (w2.dynCall_ji = Q2.vd)(a2, b2);
        w2.dynCall_iij = (a2, b2, c2, f2) => (w2.dynCall_iij = Q2.wd)(a2, b2, c2, f2);
        w2.dynCall_jiiiiii = (a2, b2, c2, f2, h2, m2, u2) => (w2.dynCall_jiiiiii = Q2.xd)(a2, b2, c2, f2, h2, m2, u2);
        w2.dynCall_jiiiiji = (a2, b2, c2, f2, h2, m2, u2, n2) => (w2.dynCall_jiiiiji = Q2.yd)(a2, b2, c2, f2, h2, m2, u2, n2);
        w2.dynCall_iijj = (a2, b2, c2, f2, h2, m2) => (w2.dynCall_iijj = Q2.zd)(a2, b2, c2, f2, h2, m2);
        w2.dynCall_iiiji = (a2, b2, c2, f2, h2, m2) => (w2.dynCall_iiiji = Q2.Ad)(a2, b2, c2, f2, h2, m2);
        w2.dynCall_iiji = (a2, b2, c2, f2, h2) => (w2.dynCall_iiji = Q2.Bd)(a2, b2, c2, f2, h2);
        w2.dynCall_iijjiii = (a2, b2, c2, f2, h2, m2, u2, n2, p2) => (w2.dynCall_iijjiii = Q2.Cd)(a2, b2, c2, f2, h2, m2, u2, n2, p2);
        w2.dynCall_vijjjii = (a2, b2, c2, f2, h2, m2, u2, n2, p2, v2) => (w2.dynCall_vijjjii = Q2.Dd)(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2);
        w2.dynCall_jiji = (a2, b2, c2, f2, h2) => (w2.dynCall_jiji = Q2.Ed)(a2, b2, c2, f2, h2);
        w2.dynCall_viijii = (a2, b2, c2, f2, h2, m2, u2) => (w2.dynCall_viijii = Q2.Fd)(a2, b2, c2, f2, h2, m2, u2);
        w2.dynCall_iiiiij = (a2, b2, c2, f2, h2, m2, u2) => (w2.dynCall_iiiiij = Q2.Gd)(a2, b2, c2, f2, h2, m2, u2);
        w2.dynCall_iiiiijj = (a2, b2, c2, f2, h2, m2, u2, n2, p2) => (w2.dynCall_iiiiijj = Q2.Hd)(a2, b2, c2, f2, h2, m2, u2, n2, p2);
        w2.dynCall_iiiiiijj = (a2, b2, c2, f2, h2, m2, u2, n2, p2, v2) => (w2.dynCall_iiiiiijj = Q2.Id)(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2);
        function de2(a2, b2, c2, f2) {
          var h2 = se2();
          try {
            return Xa.get(a2)(b2, c2, f2);
          } catch (m2) {
            te2(h2);
            if (m2 !== m2 + 0) throw m2;
            re2(1, 0);
          }
        }
        function be2(a2, b2) {
          var c2 = se2();
          try {
            return Xa.get(a2)(b2);
          } catch (f2) {
            te2(c2);
            if (f2 !== f2 + 0) throw f2;
            re2(1, 0);
          }
        }
        function pe2(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2) {
          var E2 = se2();
          try {
            Xa.get(a2)(b2, c2, f2, h2, m2, u2, n2, p2, v2);
          } catch (H2) {
            te2(E2);
            if (H2 !== H2 + 0) throw H2;
            re2(1, 0);
          }
        }
        function le2(a2, b2, c2, f2) {
          var h2 = se2();
          try {
            Xa.get(a2)(b2, c2, f2);
          } catch (m2) {
            te2(h2);
            if (m2 !== m2 + 0) throw m2;
            re2(1, 0);
          }
        }
        function ke2(a2, b2, c2) {
          var f2 = se2();
          try {
            Xa.get(a2)(b2, c2);
          } catch (h2) {
            te2(f2);
            if (h2 !== h2 + 0) throw h2;
            re2(1, 0);
          }
        }
        function ie2(a2) {
          var b2 = se2();
          try {
            Xa.get(a2)();
          } catch (c2) {
            te2(b2);
            if (c2 !== c2 + 0) throw c2;
            re2(1, 0);
          }
        }
        function me2(a2, b2, c2, f2, h2) {
          var m2 = se2();
          try {
            Xa.get(a2)(b2, c2, f2, h2);
          } catch (u2) {
            te2(m2);
            if (u2 !== u2 + 0) throw u2;
            re2(1, 0);
          }
        }
        function je2(a2, b2) {
          var c2 = se2();
          try {
            Xa.get(a2)(b2);
          } catch (f2) {
            te2(c2);
            if (f2 !== f2 + 0) throw f2;
            re2(1, 0);
          }
        }
        function ce2(a2, b2, c2) {
          var f2 = se2();
          try {
            return Xa.get(a2)(b2, c2);
          } catch (h2) {
            te2(f2);
            if (h2 !== h2 + 0) throw h2;
            re2(1, 0);
          }
        }
        function oe2(a2, b2, c2, f2, h2, m2, u2) {
          var n2 = se2();
          try {
            Xa.get(a2)(b2, c2, f2, h2, m2, u2);
          } catch (p2) {
            te2(n2);
            if (p2 !== p2 + 0) throw p2;
            re2(1, 0);
          }
        }
        function ee2(a2, b2, c2, f2, h2) {
          var m2 = se2();
          try {
            return Xa.get(a2)(b2, c2, f2, h2);
          } catch (u2) {
            te2(m2);
            if (u2 !== u2 + 0) throw u2;
            re2(1, 0);
          }
        }
        function fe2(a2, b2, c2, f2, h2, m2) {
          var u2 = se2();
          try {
            return Xa.get(a2)(b2, c2, f2, h2, m2);
          } catch (n2) {
            te2(u2);
            if (n2 !== n2 + 0) throw n2;
            re2(1, 0);
          }
        }
        function ge2(a2, b2, c2, f2, h2, m2, u2) {
          var n2 = se2();
          try {
            return Xa.get(a2)(b2, c2, f2, h2, m2, u2);
          } catch (p2) {
            te2(n2);
            if (p2 !== p2 + 0) throw p2;
            re2(1, 0);
          }
        }
        function ne2(a2, b2, c2, f2, h2, m2) {
          var u2 = se2();
          try {
            Xa.get(a2)(b2, c2, f2, h2, m2);
          } catch (n2) {
            te2(u2);
            if (n2 !== n2 + 0) throw n2;
            re2(1, 0);
          }
        }
        function he2(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2) {
          var E2 = se2();
          try {
            return Xa.get(a2)(b2, c2, f2, h2, m2, u2, n2, p2, v2);
          } catch (H2) {
            te2(E2);
            if (H2 !== H2 + 0) throw H2;
            re2(1, 0);
          }
        }
        var ue2;
        fb = function ve2() {
          ue2 || we2();
          ue2 || (fb = ve2);
        };
        function we2() {
          function a2() {
            if (!ue2 && (ue2 = true, w2.calledRun = true, !Pa)) {
              sb(Za);
              ba(w2);
              if (w2.onRuntimeInitialized) w2.onRuntimeInitialized();
              if (w2.postRun) for ("function" == typeof w2.postRun && (w2.postRun = [w2.postRun]); w2.postRun.length; ) {
                var b2 = w2.postRun.shift();
                bb.unshift(b2);
              }
              sb(bb);
            }
          }
          if (!(0 < db)) {
            if (w2.preRun) for ("function" == typeof w2.preRun && (w2.preRun = [w2.preRun]); w2.preRun.length; ) cb();
            sb(Ya);
            0 < db || (w2.setStatus ? (w2.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                w2.setStatus("");
              }, 1);
              a2();
            }, 1)) : a2());
          }
        }
        if (w2.preInit) for ("function" == typeof w2.preInit && (w2.preInit = [w2.preInit]); 0 < w2.preInit.length; ) w2.preInit.pop()();
        we2();
        return moduleArg.ready;
      };
    })();
    if (typeof exports2 === "object" && typeof module === "object")
      module.exports = CanvasKitInit;
    else if (typeof define === "function" && define["amd"])
      define([], () => CanvasKitInit);
  }
});

// node_modules/scribe.js-ocr/tess/tesseract.esm.min.js
var tesseract_esm_min_exports = {};
__export(tesseract_esm_min_exports, {
  default: () => tesseract_min
});
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var tesseract_min$1, tesseract_minExports, tesseract_min;
var init_tesseract_esm_min = __esm({
  "node_modules/scribe.js-ocr/tess/tesseract.esm.min.js"() {
    tesseract_min$1 = { exports: {} };
    (function(module, exports2) {
      !function(t2, r2) {
        module.exports = r2();
      }(self, () => (() => {
        var t2 = { 30: (t3, r3, e3) => {
          function n2(t4) {
            return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, n2(t4);
          }
          var o2 = function(t4) {
            var r4, e4 = Object.prototype, o3 = e4.hasOwnProperty, i2 = Object.defineProperty || function(t5, r5, e5) {
              t5[r5] = e5.value;
            }, a2 = "function" == typeof Symbol ? Symbol : {}, c2 = a2.iterator || "@@iterator", u2 = a2.asyncIterator || "@@asyncIterator", f2 = a2.toStringTag || "@@toStringTag";
            function l2(t5, r5, e5) {
              return Object.defineProperty(t5, r5, { value: e5, enumerable: true, configurable: true, writable: true }), t5[r5];
            }
            try {
              l2({}, "");
            } catch (t5) {
              l2 = function(t6, r5, e5) {
                return t6[r5] = e5;
              };
            }
            function s2(t5, r5, e5, n3) {
              var o4 = r5 && r5.prototype instanceof m2 ? r5 : m2, a3 = Object.create(o4.prototype), c3 = new N2(n3 || []);
              return i2(a3, "_invoke", { value: P2(t5, e5, c3) }), a3;
            }
            function h2(t5, r5, e5) {
              try {
                return { type: "normal", arg: t5.call(r5, e5) };
              } catch (t6) {
                return { type: "throw", arg: t6 };
              }
            }
            t4.wrap = s2;
            var p2 = "suspendedStart", y2 = "suspendedYield", v2 = "executing", d2 = "completed", g2 = {};
            function m2() {
            }
            function b2() {
            }
            function w2() {
            }
            var L2 = {};
            l2(L2, c2, function() {
              return this;
            });
            var x2 = Object.getPrototypeOf, O2 = x2 && x2(x2(A2([])));
            O2 && O2 !== e4 && o3.call(O2, c2) && (L2 = O2);
            var E2 = w2.prototype = m2.prototype = Object.create(L2);
            function S2(t5) {
              ["next", "throw", "return"].forEach(function(r5) {
                l2(t5, r5, function(t6) {
                  return this._invoke(r5, t6);
                });
              });
            }
            function j2(t5, r5) {
              function e5(i3, a4, c3, u3) {
                var f3 = h2(t5[i3], t5, a4);
                if ("throw" !== f3.type) {
                  var l3 = f3.arg, s3 = l3.value;
                  return s3 && "object" === n2(s3) && o3.call(s3, "__await") ? r5.resolve(s3.__await).then(function(t6) {
                    e5("next", t6, c3, u3);
                  }, function(t6) {
                    e5("throw", t6, c3, u3);
                  }) : r5.resolve(s3).then(function(t6) {
                    l3.value = t6, c3(l3);
                  }, function(t6) {
                    return e5("throw", t6, c3, u3);
                  });
                }
                u3(f3.arg);
              }
              var a3;
              i2(this, "_invoke", { value: function(t6, n3) {
                function o4() {
                  return new r5(function(r6, o5) {
                    e5(t6, n3, r6, o5);
                  });
                }
                return a3 = a3 ? a3.then(o4, o4) : o4();
              } });
            }
            function P2(t5, r5, e5) {
              var n3 = p2;
              return function(o4, i3) {
                if (n3 === v2) throw new Error("Generator is already running");
                if (n3 === d2) {
                  if ("throw" === o4) throw i3;
                  return I2();
                }
                for (e5.method = o4, e5.arg = i3; ; ) {
                  var a3 = e5.delegate;
                  if (a3) {
                    var c3 = k2(a3, e5);
                    if (c3) {
                      if (c3 === g2) continue;
                      return c3;
                    }
                  }
                  if ("next" === e5.method) e5.sent = e5._sent = e5.arg;
                  else if ("throw" === e5.method) {
                    if (n3 === p2) throw n3 = d2, e5.arg;
                    e5.dispatchException(e5.arg);
                  } else "return" === e5.method && e5.abrupt("return", e5.arg);
                  n3 = v2;
                  var u3 = h2(t5, r5, e5);
                  if ("normal" === u3.type) {
                    if (n3 = e5.done ? d2 : y2, u3.arg === g2) continue;
                    return { value: u3.arg, done: e5.done };
                  }
                  "throw" === u3.type && (n3 = d2, e5.method = "throw", e5.arg = u3.arg);
                }
              };
            }
            function k2(t5, e5) {
              var n3 = e5.method, o4 = t5.iterator[n3];
              if (o4 === r4) return e5.delegate = null, "throw" === n3 && t5.iterator.return && (e5.method = "return", e5.arg = r4, k2(t5, e5), "throw" === e5.method) || "return" !== n3 && (e5.method = "throw", e5.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), g2;
              var i3 = h2(o4, t5.iterator, e5.arg);
              if ("throw" === i3.type) return e5.method = "throw", e5.arg = i3.arg, e5.delegate = null, g2;
              var a3 = i3.arg;
              return a3 ? a3.done ? (e5[t5.resultName] = a3.value, e5.next = t5.nextLoc, "return" !== e5.method && (e5.method = "next", e5.arg = r4), e5.delegate = null, g2) : a3 : (e5.method = "throw", e5.arg = new TypeError("iterator result is not an object"), e5.delegate = null, g2);
            }
            function _2(t5) {
              var r5 = { tryLoc: t5[0] };
              1 in t5 && (r5.catchLoc = t5[1]), 2 in t5 && (r5.finallyLoc = t5[2], r5.afterLoc = t5[3]), this.tryEntries.push(r5);
            }
            function T2(t5) {
              var r5 = t5.completion || {};
              r5.type = "normal", delete r5.arg, t5.completion = r5;
            }
            function N2(t5) {
              this.tryEntries = [{ tryLoc: "root" }], t5.forEach(_2, this), this.reset(true);
            }
            function A2(t5) {
              if (t5) {
                var e5 = t5[c2];
                if (e5) return e5.call(t5);
                if ("function" == typeof t5.next) return t5;
                if (!isNaN(t5.length)) {
                  var n3 = -1, i3 = function e6() {
                    for (; ++n3 < t5.length; ) if (o3.call(t5, n3)) return e6.value = t5[n3], e6.done = false, e6;
                    return e6.value = r4, e6.done = true, e6;
                  };
                  return i3.next = i3;
                }
              }
              return { next: I2 };
            }
            function I2() {
              return { value: r4, done: true };
            }
            return b2.prototype = w2, i2(E2, "constructor", { value: w2, configurable: true }), i2(w2, "constructor", { value: b2, configurable: true }), b2.displayName = l2(w2, f2, "GeneratorFunction"), t4.isGeneratorFunction = function(t5) {
              var r5 = "function" == typeof t5 && t5.constructor;
              return !!r5 && (r5 === b2 || "GeneratorFunction" === (r5.displayName || r5.name));
            }, t4.mark = function(t5) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(t5, w2) : (t5.__proto__ = w2, l2(t5, f2, "GeneratorFunction")), t5.prototype = Object.create(E2), t5;
            }, t4.awrap = function(t5) {
              return { __await: t5 };
            }, S2(j2.prototype), l2(j2.prototype, u2, function() {
              return this;
            }), t4.AsyncIterator = j2, t4.async = function(r5, e5, n3, o4, i3) {
              void 0 === i3 && (i3 = Promise);
              var a3 = new j2(s2(r5, e5, n3, o4), i3);
              return t4.isGeneratorFunction(e5) ? a3 : a3.next().then(function(t5) {
                return t5.done ? t5.value : a3.next();
              });
            }, S2(E2), l2(E2, f2, "Generator"), l2(E2, c2, function() {
              return this;
            }), l2(E2, "toString", function() {
              return "[object Generator]";
            }), t4.keys = function(t5) {
              var r5 = Object(t5), e5 = [];
              for (var n3 in r5) e5.push(n3);
              return e5.reverse(), function t6() {
                for (; e5.length; ) {
                  var n4 = e5.pop();
                  if (n4 in r5) return t6.value = n4, t6.done = false, t6;
                }
                return t6.done = true, t6;
              };
            }, t4.values = A2, N2.prototype = { constructor: N2, reset: function(t5) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = r4, this.done = false, this.delegate = null, this.method = "next", this.arg = r4, this.tryEntries.forEach(T2), !t5) for (var e5 in this) "t" === e5.charAt(0) && o3.call(this, e5) && !isNaN(+e5.slice(1)) && (this[e5] = r4);
            }, stop: function() {
              this.done = true;
              var t5 = this.tryEntries[0].completion;
              if ("throw" === t5.type) throw t5.arg;
              return this.rval;
            }, dispatchException: function(t5) {
              if (this.done) throw t5;
              var e5 = this;
              function n3(n4, o4) {
                return c3.type = "throw", c3.arg = t5, e5.next = n4, o4 && (e5.method = "next", e5.arg = r4), !!o4;
              }
              for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
                var a3 = this.tryEntries[i3], c3 = a3.completion;
                if ("root" === a3.tryLoc) return n3("end");
                if (a3.tryLoc <= this.prev) {
                  var u3 = o3.call(a3, "catchLoc"), f3 = o3.call(a3, "finallyLoc");
                  if (u3 && f3) {
                    if (this.prev < a3.catchLoc) return n3(a3.catchLoc, true);
                    if (this.prev < a3.finallyLoc) return n3(a3.finallyLoc);
                  } else if (u3) {
                    if (this.prev < a3.catchLoc) return n3(a3.catchLoc, true);
                  } else {
                    if (!f3) throw new Error("try statement without catch or finally");
                    if (this.prev < a3.finallyLoc) return n3(a3.finallyLoc);
                  }
                }
              }
            }, abrupt: function(t5, r5) {
              for (var e5 = this.tryEntries.length - 1; e5 >= 0; --e5) {
                var n3 = this.tryEntries[e5];
                if (n3.tryLoc <= this.prev && o3.call(n3, "finallyLoc") && this.prev < n3.finallyLoc) {
                  var i3 = n3;
                  break;
                }
              }
              i3 && ("break" === t5 || "continue" === t5) && i3.tryLoc <= r5 && r5 <= i3.finallyLoc && (i3 = null);
              var a3 = i3 ? i3.completion : {};
              return a3.type = t5, a3.arg = r5, i3 ? (this.method = "next", this.next = i3.finallyLoc, g2) : this.complete(a3);
            }, complete: function(t5, r5) {
              if ("throw" === t5.type) throw t5.arg;
              return "break" === t5.type || "continue" === t5.type ? this.next = t5.arg : "return" === t5.type ? (this.rval = this.arg = t5.arg, this.method = "return", this.next = "end") : "normal" === t5.type && r5 && (this.next = r5), g2;
            }, finish: function(t5) {
              for (var r5 = this.tryEntries.length - 1; r5 >= 0; --r5) {
                var e5 = this.tryEntries[r5];
                if (e5.finallyLoc === t5) return this.complete(e5.completion, e5.afterLoc), T2(e5), g2;
              }
            }, catch: function(t5) {
              for (var r5 = this.tryEntries.length - 1; r5 >= 0; --r5) {
                var e5 = this.tryEntries[r5];
                if (e5.tryLoc === t5) {
                  var n3 = e5.completion;
                  if ("throw" === n3.type) {
                    var o4 = n3.arg;
                    T2(e5);
                  }
                  return o4;
                }
              }
              throw new Error("illegal catch attempt");
            }, delegateYield: function(t5, e5, n3) {
              return this.delegate = { iterator: A2(t5), resultName: e5, nextLoc: n3 }, "next" === this.method && (this.arg = r4), g2;
            } }, t4;
          }("object" === n2(t3 = e3.nmd(t3)) ? t3.exports : {});
          try {
            regeneratorRuntime = o2;
          } catch (t4) {
            "object" === ("undefined" == typeof globalThis ? "undefined" : n2(globalThis)) ? globalThis.regeneratorRuntime = o2 : Function("r", "regeneratorRuntime = r")(o2);
          }
        }, 52: (t3, r3, e3) => {
          function n2(t4) {
            return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, n2(t4);
          }
          function o2() {
            o2 = function() {
              return r4;
            };
            var t4, r4 = {}, e4 = Object.prototype, i3 = e4.hasOwnProperty, a3 = Object.defineProperty || function(t5, r5, e5) {
              t5[r5] = e5.value;
            }, c3 = "function" == typeof Symbol ? Symbol : {}, u3 = c3.iterator || "@@iterator", f3 = c3.asyncIterator || "@@asyncIterator", l2 = c3.toStringTag || "@@toStringTag";
            function s2(t5, r5, e5) {
              return Object.defineProperty(t5, r5, { value: e5, enumerable: true, configurable: true, writable: true }), t5[r5];
            }
            try {
              s2({}, "");
            } catch (t5) {
              s2 = function(t6, r5, e5) {
                return t6[r5] = e5;
              };
            }
            function h2(t5, r5, e5, n3) {
              var o3 = r5 && r5.prototype instanceof b2 ? r5 : b2, i4 = Object.create(o3.prototype), c4 = new A2(n3 || []);
              return a3(i4, "_invoke", { value: k2(t5, e5, c4) }), i4;
            }
            function p2(t5, r5, e5) {
              try {
                return { type: "normal", arg: t5.call(r5, e5) };
              } catch (t6) {
                return { type: "throw", arg: t6 };
              }
            }
            r4.wrap = h2;
            var y2 = "suspendedStart", v2 = "suspendedYield", d2 = "executing", g2 = "completed", m2 = {};
            function b2() {
            }
            function w2() {
            }
            function L2() {
            }
            var x2 = {};
            s2(x2, u3, function() {
              return this;
            });
            var O2 = Object.getPrototypeOf, E2 = O2 && O2(O2(I2([])));
            E2 && E2 !== e4 && i3.call(E2, u3) && (x2 = E2);
            var S2 = L2.prototype = b2.prototype = Object.create(x2);
            function j2(t5) {
              ["next", "throw", "return"].forEach(function(r5) {
                s2(t5, r5, function(t6) {
                  return this._invoke(r5, t6);
                });
              });
            }
            function P2(t5, r5) {
              function e5(o4, a4, c4, u4) {
                var f4 = p2(t5[o4], t5, a4);
                if ("throw" !== f4.type) {
                  var l3 = f4.arg, s3 = l3.value;
                  return s3 && "object" == n2(s3) && i3.call(s3, "__await") ? r5.resolve(s3.__await).then(function(t6) {
                    e5("next", t6, c4, u4);
                  }, function(t6) {
                    e5("throw", t6, c4, u4);
                  }) : r5.resolve(s3).then(function(t6) {
                    l3.value = t6, c4(l3);
                  }, function(t6) {
                    return e5("throw", t6, c4, u4);
                  });
                }
                u4(f4.arg);
              }
              var o3;
              a3(this, "_invoke", { value: function(t6, n3) {
                function i4() {
                  return new r5(function(r6, o4) {
                    e5(t6, n3, r6, o4);
                  });
                }
                return o3 = o3 ? o3.then(i4, i4) : i4();
              } });
            }
            function k2(r5, e5, n3) {
              var o3 = y2;
              return function(i4, a4) {
                if (o3 === d2) throw Error("Generator is already running");
                if (o3 === g2) {
                  if ("throw" === i4) throw a4;
                  return { value: t4, done: true };
                }
                for (n3.method = i4, n3.arg = a4; ; ) {
                  var c4 = n3.delegate;
                  if (c4) {
                    var u4 = _2(c4, n3);
                    if (u4) {
                      if (u4 === m2) continue;
                      return u4;
                    }
                  }
                  if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
                  else if ("throw" === n3.method) {
                    if (o3 === y2) throw o3 = g2, n3.arg;
                    n3.dispatchException(n3.arg);
                  } else "return" === n3.method && n3.abrupt("return", n3.arg);
                  o3 = d2;
                  var f4 = p2(r5, e5, n3);
                  if ("normal" === f4.type) {
                    if (o3 = n3.done ? g2 : v2, f4.arg === m2) continue;
                    return { value: f4.arg, done: n3.done };
                  }
                  "throw" === f4.type && (o3 = g2, n3.method = "throw", n3.arg = f4.arg);
                }
              };
            }
            function _2(r5, e5) {
              var n3 = e5.method, o3 = r5.iterator[n3];
              if (o3 === t4) return e5.delegate = null, "throw" === n3 && r5.iterator.return && (e5.method = "return", e5.arg = t4, _2(r5, e5), "throw" === e5.method) || "return" !== n3 && (e5.method = "throw", e5.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), m2;
              var i4 = p2(o3, r5.iterator, e5.arg);
              if ("throw" === i4.type) return e5.method = "throw", e5.arg = i4.arg, e5.delegate = null, m2;
              var a4 = i4.arg;
              return a4 ? a4.done ? (e5[r5.resultName] = a4.value, e5.next = r5.nextLoc, "return" !== e5.method && (e5.method = "next", e5.arg = t4), e5.delegate = null, m2) : a4 : (e5.method = "throw", e5.arg = new TypeError("iterator result is not an object"), e5.delegate = null, m2);
            }
            function T2(t5) {
              var r5 = { tryLoc: t5[0] };
              1 in t5 && (r5.catchLoc = t5[1]), 2 in t5 && (r5.finallyLoc = t5[2], r5.afterLoc = t5[3]), this.tryEntries.push(r5);
            }
            function N2(t5) {
              var r5 = t5.completion || {};
              r5.type = "normal", delete r5.arg, t5.completion = r5;
            }
            function A2(t5) {
              this.tryEntries = [{ tryLoc: "root" }], t5.forEach(T2, this), this.reset(true);
            }
            function I2(r5) {
              if (r5 || "" === r5) {
                var e5 = r5[u3];
                if (e5) return e5.call(r5);
                if ("function" == typeof r5.next) return r5;
                if (!isNaN(r5.length)) {
                  var o3 = -1, a4 = function e6() {
                    for (; ++o3 < r5.length; ) if (i3.call(r5, o3)) return e6.value = r5[o3], e6.done = false, e6;
                    return e6.value = t4, e6.done = true, e6;
                  };
                  return a4.next = a4;
                }
              }
              throw new TypeError(n2(r5) + " is not iterable");
            }
            return w2.prototype = L2, a3(S2, "constructor", { value: L2, configurable: true }), a3(L2, "constructor", { value: w2, configurable: true }), w2.displayName = s2(L2, l2, "GeneratorFunction"), r4.isGeneratorFunction = function(t5) {
              var r5 = "function" == typeof t5 && t5.constructor;
              return !!r5 && (r5 === w2 || "GeneratorFunction" === (r5.displayName || r5.name));
            }, r4.mark = function(t5) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(t5, L2) : (t5.__proto__ = L2, s2(t5, l2, "GeneratorFunction")), t5.prototype = Object.create(S2), t5;
            }, r4.awrap = function(t5) {
              return { __await: t5 };
            }, j2(P2.prototype), s2(P2.prototype, f3, function() {
              return this;
            }), r4.AsyncIterator = P2, r4.async = function(t5, e5, n3, o3, i4) {
              void 0 === i4 && (i4 = Promise);
              var a4 = new P2(h2(t5, e5, n3, o3), i4);
              return r4.isGeneratorFunction(e5) ? a4 : a4.next().then(function(t6) {
                return t6.done ? t6.value : a4.next();
              });
            }, j2(S2), s2(S2, l2, "Generator"), s2(S2, u3, function() {
              return this;
            }), s2(S2, "toString", function() {
              return "[object Generator]";
            }), r4.keys = function(t5) {
              var r5 = Object(t5), e5 = [];
              for (var n3 in r5) e5.push(n3);
              return e5.reverse(), function t6() {
                for (; e5.length; ) {
                  var n4 = e5.pop();
                  if (n4 in r5) return t6.value = n4, t6.done = false, t6;
                }
                return t6.done = true, t6;
              };
            }, r4.values = I2, A2.prototype = { constructor: A2, reset: function(r5) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = t4, this.done = false, this.delegate = null, this.method = "next", this.arg = t4, this.tryEntries.forEach(N2), !r5) for (var e5 in this) "t" === e5.charAt(0) && i3.call(this, e5) && !isNaN(+e5.slice(1)) && (this[e5] = t4);
            }, stop: function() {
              this.done = true;
              var t5 = this.tryEntries[0].completion;
              if ("throw" === t5.type) throw t5.arg;
              return this.rval;
            }, dispatchException: function(r5) {
              if (this.done) throw r5;
              var e5 = this;
              function n3(n4, o4) {
                return c4.type = "throw", c4.arg = r5, e5.next = n4, o4 && (e5.method = "next", e5.arg = t4), !!o4;
              }
              for (var o3 = this.tryEntries.length - 1; o3 >= 0; --o3) {
                var a4 = this.tryEntries[o3], c4 = a4.completion;
                if ("root" === a4.tryLoc) return n3("end");
                if (a4.tryLoc <= this.prev) {
                  var u4 = i3.call(a4, "catchLoc"), f4 = i3.call(a4, "finallyLoc");
                  if (u4 && f4) {
                    if (this.prev < a4.catchLoc) return n3(a4.catchLoc, true);
                    if (this.prev < a4.finallyLoc) return n3(a4.finallyLoc);
                  } else if (u4) {
                    if (this.prev < a4.catchLoc) return n3(a4.catchLoc, true);
                  } else {
                    if (!f4) throw Error("try statement without catch or finally");
                    if (this.prev < a4.finallyLoc) return n3(a4.finallyLoc);
                  }
                }
              }
            }, abrupt: function(t5, r5) {
              for (var e5 = this.tryEntries.length - 1; e5 >= 0; --e5) {
                var n3 = this.tryEntries[e5];
                if (n3.tryLoc <= this.prev && i3.call(n3, "finallyLoc") && this.prev < n3.finallyLoc) {
                  var o3 = n3;
                  break;
                }
              }
              o3 && ("break" === t5 || "continue" === t5) && o3.tryLoc <= r5 && r5 <= o3.finallyLoc && (o3 = null);
              var a4 = o3 ? o3.completion : {};
              return a4.type = t5, a4.arg = r5, o3 ? (this.method = "next", this.next = o3.finallyLoc, m2) : this.complete(a4);
            }, complete: function(t5, r5) {
              if ("throw" === t5.type) throw t5.arg;
              return "break" === t5.type || "continue" === t5.type ? this.next = t5.arg : "return" === t5.type ? (this.rval = this.arg = t5.arg, this.method = "return", this.next = "end") : "normal" === t5.type && r5 && (this.next = r5), m2;
            }, finish: function(t5) {
              for (var r5 = this.tryEntries.length - 1; r5 >= 0; --r5) {
                var e5 = this.tryEntries[r5];
                if (e5.finallyLoc === t5) return this.complete(e5.completion, e5.afterLoc), N2(e5), m2;
              }
            }, catch: function(t5) {
              for (var r5 = this.tryEntries.length - 1; r5 >= 0; --r5) {
                var e5 = this.tryEntries[r5];
                if (e5.tryLoc === t5) {
                  var n3 = e5.completion;
                  if ("throw" === n3.type) {
                    var o3 = n3.arg;
                    N2(e5);
                  }
                  return o3;
                }
              }
              throw Error("illegal catch attempt");
            }, delegateYield: function(r5, e5, n3) {
              return this.delegate = { iterator: I2(r5), resultName: e5, nextLoc: n3 }, "next" === this.method && (this.arg = t4), m2;
            } }, r4;
          }
          function i2(t4, r4, e4, n3, o3, i3, a3) {
            try {
              var c3 = t4[i3](a3), u3 = c3.value;
            } catch (t5) {
              return void e4(t5);
            }
            c3.done ? r4(u3) : Promise.resolve(u3).then(n3, o3);
          }
          function a2(t4) {
            return function() {
              var r4 = this, e4 = arguments;
              return new Promise(function(n3, o3) {
                var a3 = t4.apply(r4, e4);
                function c3(t5) {
                  i2(a3, n3, o3, c3, u3, "next", t5);
                }
                function u3(t5) {
                  i2(a3, n3, o3, c3, u3, "throw", t5);
                }
                c3(void 0);
              });
            };
          }
          var c2 = e3(738), u2 = function() {
            var t4 = a2(o2().mark(function t5(r4, e4, n3) {
              var i3;
              return o2().wrap(function(t6) {
                for (; ; ) switch (t6.prev = t6.next) {
                  case 0:
                    return t6.next = 2, c2(e4, 1, n3);
                  case 2:
                    return i3 = t6.sent, t6.abrupt("return", i3.recognize(r4).finally(a2(o2().mark(function t7() {
                      return o2().wrap(function(t8) {
                        for (; ; ) switch (t8.prev = t8.next) {
                          case 0:
                            return t8.next = 2, i3.terminate();
                          case 2:
                          case "end":
                            return t8.stop();
                        }
                      }, t7);
                    }))));
                  case 4:
                  case "end":
                    return t6.stop();
                }
              }, t5);
            }));
            return function(r4, e4, n3) {
              return t4.apply(this, arguments);
            };
          }(), f2 = function() {
            var t4 = a2(o2().mark(function t5(r4, e4) {
              var n3;
              return o2().wrap(function(t6) {
                for (; ; ) switch (t6.prev = t6.next) {
                  case 0:
                    return t6.next = 2, c2("osd", 0, e4);
                  case 2:
                    return n3 = t6.sent, t6.abrupt("return", n3.detect(r4).finally(a2(o2().mark(function t7() {
                      return o2().wrap(function(t8) {
                        for (; ; ) switch (t8.prev = t8.next) {
                          case 0:
                            return t8.next = 2, n3.terminate();
                          case 2:
                          case "end":
                            return t8.stop();
                        }
                      }, t7);
                    }))));
                  case 4:
                  case "end":
                    return t6.stop();
                }
              }, t5);
            }));
            return function(r4, e4) {
              return t4.apply(this, arguments);
            };
          }();
          t3.exports = { recognize: u2, detect: f2 };
        }, 287: (t3) => {
          t3.exports = { TESSERACT_ONLY: 0, LSTM_ONLY: 1, TESSERACT_LSTM_COMBINED: 2, DEFAULT: 3 };
        }, 188: (t3) => {
          t3.exports = { OSD_ONLY: "0", AUTO_OSD: "1", AUTO_ONLY: "2", AUTO: "3", SINGLE_COLUMN: "4", SINGLE_BLOCK_VERT_TEXT: "5", SINGLE_BLOCK: "6", SINGLE_LINE: "7", SINGLE_WORD: "8", CIRCLE_WORD: "9", SINGLE_CHAR: "10", SPARSE_TEXT: "11", SPARSE_TEXT_OSD: "12", RAW_LINE: "13" };
        }, 491: (t3) => {
          t3.exports = { workerBlobURL: true, logger: function() {
          } };
        }, 11: (t3) => {
          t3.exports = { AFR: "afr", AMH: "amh", ARA: "ara", ASM: "asm", AZE: "aze", AZE_CYRL: "aze_cyrl", BEL: "bel", BEN: "ben", BOD: "bod", BOS: "bos", BUL: "bul", CAT: "cat", CEB: "ceb", CES: "ces", CHI_SIM: "chi_sim", CHI_TRA: "chi_tra", CHR: "chr", CYM: "cym", DAN: "dan", DEU: "deu", DZO: "dzo", ELL: "ell", ENG: "eng", ENM: "enm", EPO: "epo", EST: "est", EUS: "eus", FAS: "fas", FIN: "fin", FRA: "fra", FRK: "frk", FRM: "frm", GLE: "gle", GLG: "glg", GRC: "grc", GUJ: "guj", HAT: "hat", HEB: "heb", HIN: "hin", HRV: "hrv", HUN: "hun", IKU: "iku", IND: "ind", ISL: "isl", ITA: "ita", ITA_OLD: "ita_old", JAV: "jav", JPN: "jpn", KAN: "kan", KAT: "kat", KAT_OLD: "kat_old", KAZ: "kaz", KHM: "khm", KIR: "kir", KOR: "kor", KUR: "kur", LAO: "lao", LAT: "lat", LAV: "lav", LIT: "lit", MAL: "mal", MAR: "mar", MKD: "mkd", MLT: "mlt", MSA: "msa", MYA: "mya", NEP: "nep", NLD: "nld", NOR: "nor", ORI: "ori", PAN: "pan", POL: "pol", POR: "por", PUS: "pus", RON: "ron", RUS: "rus", SAN: "san", SIN: "sin", SLK: "slk", SLV: "slv", SPA: "spa", SPA_OLD: "spa_old", SQI: "sqi", SRP: "srp", SRP_LATN: "srp_latn", SWA: "swa", SWE: "swe", SYR: "syr", TAM: "tam", TEL: "tel", TGK: "tgk", TGL: "tgl", THA: "tha", TIR: "tir", TUR: "tur", UIG: "uig", UKR: "ukr", URD: "urd", UZB: "uzb", UZB_CYRL: "uzb_cyrl", VIE: "vie", YID: "yid" };
        }, 13: (t3, r3, e3) => {
          var n2 = e3(857), o2 = 0;
          t3.exports = function(t4) {
            var r4 = t4.id, e4 = t4.action, i2 = t4.payload, a2 = void 0 === i2 ? {} : i2, c2 = r4;
            return void 0 === c2 && (c2 = n2("Job", o2), o2 += 1), { id: c2, action: e4, payload: a2 };
          };
        }, 695: function(t3, r3, e3) {
          function n2(t4) {
            return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, n2(t4);
          }
          var o2 = this;
          function i2() {
            i2 = function() {
              return r4;
            };
            var t4, r4 = {}, e4 = Object.prototype, o3 = e4.hasOwnProperty, a3 = Object.defineProperty || function(t5, r5, e5) {
              t5[r5] = e5.value;
            }, c3 = "function" == typeof Symbol ? Symbol : {}, u3 = c3.iterator || "@@iterator", f3 = c3.asyncIterator || "@@asyncIterator", l3 = c3.toStringTag || "@@toStringTag";
            function s3(t5, r5, e5) {
              return Object.defineProperty(t5, r5, { value: e5, enumerable: true, configurable: true, writable: true }), t5[r5];
            }
            try {
              s3({}, "");
            } catch (t5) {
              s3 = function(t6, r5, e5) {
                return t6[r5] = e5;
              };
            }
            function h3(t5, r5, e5, n3) {
              var o4 = r5 && r5.prototype instanceof b2 ? r5 : b2, i3 = Object.create(o4.prototype), c4 = new A2(n3 || []);
              return a3(i3, "_invoke", { value: k2(t5, e5, c4) }), i3;
            }
            function p2(t5, r5, e5) {
              try {
                return { type: "normal", arg: t5.call(r5, e5) };
              } catch (t6) {
                return { type: "throw", arg: t6 };
              }
            }
            r4.wrap = h3;
            var y2 = "suspendedStart", v2 = "suspendedYield", d2 = "executing", g2 = "completed", m2 = {};
            function b2() {
            }
            function w2() {
            }
            function L2() {
            }
            var x2 = {};
            s3(x2, u3, function() {
              return this;
            });
            var O2 = Object.getPrototypeOf, E2 = O2 && O2(O2(I2([])));
            E2 && E2 !== e4 && o3.call(E2, u3) && (x2 = E2);
            var S2 = L2.prototype = b2.prototype = Object.create(x2);
            function j2(t5) {
              ["next", "throw", "return"].forEach(function(r5) {
                s3(t5, r5, function(t6) {
                  return this._invoke(r5, t6);
                });
              });
            }
            function P2(t5, r5) {
              function e5(i4, a4, c4, u4) {
                var f4 = p2(t5[i4], t5, a4);
                if ("throw" !== f4.type) {
                  var l4 = f4.arg, s4 = l4.value;
                  return s4 && "object" == n2(s4) && o3.call(s4, "__await") ? r5.resolve(s4.__await).then(function(t6) {
                    e5("next", t6, c4, u4);
                  }, function(t6) {
                    e5("throw", t6, c4, u4);
                  }) : r5.resolve(s4).then(function(t6) {
                    l4.value = t6, c4(l4);
                  }, function(t6) {
                    return e5("throw", t6, c4, u4);
                  });
                }
                u4(f4.arg);
              }
              var i3;
              a3(this, "_invoke", { value: function(t6, n3) {
                function o4() {
                  return new r5(function(r6, o5) {
                    e5(t6, n3, r6, o5);
                  });
                }
                return i3 = i3 ? i3.then(o4, o4) : o4();
              } });
            }
            function k2(r5, e5, n3) {
              var o4 = y2;
              return function(i3, a4) {
                if (o4 === d2) throw Error("Generator is already running");
                if (o4 === g2) {
                  if ("throw" === i3) throw a4;
                  return { value: t4, done: true };
                }
                for (n3.method = i3, n3.arg = a4; ; ) {
                  var c4 = n3.delegate;
                  if (c4) {
                    var u4 = _2(c4, n3);
                    if (u4) {
                      if (u4 === m2) continue;
                      return u4;
                    }
                  }
                  if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
                  else if ("throw" === n3.method) {
                    if (o4 === y2) throw o4 = g2, n3.arg;
                    n3.dispatchException(n3.arg);
                  } else "return" === n3.method && n3.abrupt("return", n3.arg);
                  o4 = d2;
                  var f4 = p2(r5, e5, n3);
                  if ("normal" === f4.type) {
                    if (o4 = n3.done ? g2 : v2, f4.arg === m2) continue;
                    return { value: f4.arg, done: n3.done };
                  }
                  "throw" === f4.type && (o4 = g2, n3.method = "throw", n3.arg = f4.arg);
                }
              };
            }
            function _2(r5, e5) {
              var n3 = e5.method, o4 = r5.iterator[n3];
              if (o4 === t4) return e5.delegate = null, "throw" === n3 && r5.iterator.return && (e5.method = "return", e5.arg = t4, _2(r5, e5), "throw" === e5.method) || "return" !== n3 && (e5.method = "throw", e5.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), m2;
              var i3 = p2(o4, r5.iterator, e5.arg);
              if ("throw" === i3.type) return e5.method = "throw", e5.arg = i3.arg, e5.delegate = null, m2;
              var a4 = i3.arg;
              return a4 ? a4.done ? (e5[r5.resultName] = a4.value, e5.next = r5.nextLoc, "return" !== e5.method && (e5.method = "next", e5.arg = t4), e5.delegate = null, m2) : a4 : (e5.method = "throw", e5.arg = new TypeError("iterator result is not an object"), e5.delegate = null, m2);
            }
            function T2(t5) {
              var r5 = { tryLoc: t5[0] };
              1 in t5 && (r5.catchLoc = t5[1]), 2 in t5 && (r5.finallyLoc = t5[2], r5.afterLoc = t5[3]), this.tryEntries.push(r5);
            }
            function N2(t5) {
              var r5 = t5.completion || {};
              r5.type = "normal", delete r5.arg, t5.completion = r5;
            }
            function A2(t5) {
              this.tryEntries = [{ tryLoc: "root" }], t5.forEach(T2, this), this.reset(true);
            }
            function I2(r5) {
              if (r5 || "" === r5) {
                var e5 = r5[u3];
                if (e5) return e5.call(r5);
                if ("function" == typeof r5.next) return r5;
                if (!isNaN(r5.length)) {
                  var i3 = -1, a4 = function e6() {
                    for (; ++i3 < r5.length; ) if (o3.call(r5, i3)) return e6.value = r5[i3], e6.done = false, e6;
                    return e6.value = t4, e6.done = true, e6;
                  };
                  return a4.next = a4;
                }
              }
              throw new TypeError(n2(r5) + " is not iterable");
            }
            return w2.prototype = L2, a3(S2, "constructor", { value: L2, configurable: true }), a3(L2, "constructor", { value: w2, configurable: true }), w2.displayName = s3(L2, l3, "GeneratorFunction"), r4.isGeneratorFunction = function(t5) {
              var r5 = "function" == typeof t5 && t5.constructor;
              return !!r5 && (r5 === w2 || "GeneratorFunction" === (r5.displayName || r5.name));
            }, r4.mark = function(t5) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(t5, L2) : (t5.__proto__ = L2, s3(t5, l3, "GeneratorFunction")), t5.prototype = Object.create(S2), t5;
            }, r4.awrap = function(t5) {
              return { __await: t5 };
            }, j2(P2.prototype), s3(P2.prototype, f3, function() {
              return this;
            }), r4.AsyncIterator = P2, r4.async = function(t5, e5, n3, o4, i3) {
              void 0 === i3 && (i3 = Promise);
              var a4 = new P2(h3(t5, e5, n3, o4), i3);
              return r4.isGeneratorFunction(e5) ? a4 : a4.next().then(function(t6) {
                return t6.done ? t6.value : a4.next();
              });
            }, j2(S2), s3(S2, l3, "Generator"), s3(S2, u3, function() {
              return this;
            }), s3(S2, "toString", function() {
              return "[object Generator]";
            }), r4.keys = function(t5) {
              var r5 = Object(t5), e5 = [];
              for (var n3 in r5) e5.push(n3);
              return e5.reverse(), function t6() {
                for (; e5.length; ) {
                  var n4 = e5.pop();
                  if (n4 in r5) return t6.value = n4, t6.done = false, t6;
                }
                return t6.done = true, t6;
              };
            }, r4.values = I2, A2.prototype = { constructor: A2, reset: function(r5) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = t4, this.done = false, this.delegate = null, this.method = "next", this.arg = t4, this.tryEntries.forEach(N2), !r5) for (var e5 in this) "t" === e5.charAt(0) && o3.call(this, e5) && !isNaN(+e5.slice(1)) && (this[e5] = t4);
            }, stop: function() {
              this.done = true;
              var t5 = this.tryEntries[0].completion;
              if ("throw" === t5.type) throw t5.arg;
              return this.rval;
            }, dispatchException: function(r5) {
              if (this.done) throw r5;
              var e5 = this;
              function n3(n4, o4) {
                return c4.type = "throw", c4.arg = r5, e5.next = n4, o4 && (e5.method = "next", e5.arg = t4), !!o4;
              }
              for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
                var a4 = this.tryEntries[i3], c4 = a4.completion;
                if ("root" === a4.tryLoc) return n3("end");
                if (a4.tryLoc <= this.prev) {
                  var u4 = o3.call(a4, "catchLoc"), f4 = o3.call(a4, "finallyLoc");
                  if (u4 && f4) {
                    if (this.prev < a4.catchLoc) return n3(a4.catchLoc, true);
                    if (this.prev < a4.finallyLoc) return n3(a4.finallyLoc);
                  } else if (u4) {
                    if (this.prev < a4.catchLoc) return n3(a4.catchLoc, true);
                  } else {
                    if (!f4) throw Error("try statement without catch or finally");
                    if (this.prev < a4.finallyLoc) return n3(a4.finallyLoc);
                  }
                }
              }
            }, abrupt: function(t5, r5) {
              for (var e5 = this.tryEntries.length - 1; e5 >= 0; --e5) {
                var n3 = this.tryEntries[e5];
                if (n3.tryLoc <= this.prev && o3.call(n3, "finallyLoc") && this.prev < n3.finallyLoc) {
                  var i3 = n3;
                  break;
                }
              }
              i3 && ("break" === t5 || "continue" === t5) && i3.tryLoc <= r5 && r5 <= i3.finallyLoc && (i3 = null);
              var a4 = i3 ? i3.completion : {};
              return a4.type = t5, a4.arg = r5, i3 ? (this.method = "next", this.next = i3.finallyLoc, m2) : this.complete(a4);
            }, complete: function(t5, r5) {
              if ("throw" === t5.type) throw t5.arg;
              return "break" === t5.type || "continue" === t5.type ? this.next = t5.arg : "return" === t5.type ? (this.rval = this.arg = t5.arg, this.method = "return", this.next = "end") : "normal" === t5.type && r5 && (this.next = r5), m2;
            }, finish: function(t5) {
              for (var r5 = this.tryEntries.length - 1; r5 >= 0; --r5) {
                var e5 = this.tryEntries[r5];
                if (e5.finallyLoc === t5) return this.complete(e5.completion, e5.afterLoc), N2(e5), m2;
              }
            }, catch: function(t5) {
              for (var r5 = this.tryEntries.length - 1; r5 >= 0; --r5) {
                var e5 = this.tryEntries[r5];
                if (e5.tryLoc === t5) {
                  var n3 = e5.completion;
                  if ("throw" === n3.type) {
                    var o4 = n3.arg;
                    N2(e5);
                  }
                  return o4;
                }
              }
              throw Error("illegal catch attempt");
            }, delegateYield: function(r5, e5, n3) {
              return this.delegate = { iterator: I2(r5), resultName: e5, nextLoc: n3 }, "next" === this.method && (this.arg = t4), m2;
            } }, r4;
          }
          function a2(t4, r4) {
            (null == r4 || r4 > t4.length) && (r4 = t4.length);
            for (var e4 = 0, n3 = Array(r4); e4 < r4; e4++) n3[e4] = t4[e4];
            return n3;
          }
          function c2(t4, r4, e4, n3, o3, i3, a3) {
            try {
              var c3 = t4[i3](a3), u3 = c3.value;
            } catch (t5) {
              return void e4(t5);
            }
            c3.done ? r4(u3) : Promise.resolve(u3).then(n3, o3);
          }
          function u2(t4) {
            return function() {
              var r4 = this, e4 = arguments;
              return new Promise(function(n3, o3) {
                var i3 = t4.apply(r4, e4);
                function a3(t5) {
                  c2(i3, n3, o3, a3, u3, "next", t5);
                }
                function u3(t5) {
                  c2(i3, n3, o3, a3, u3, "throw", t5);
                }
                a3(void 0);
              });
            };
          }
          var f2 = e3(13), l2 = e3(86).log, s2 = e3(857), h2 = 0;
          t3.exports = function() {
            var t4 = s2("Scheduler", h2), r4 = {}, e4 = {}, n3 = [];
            h2 += 1;
            var c3 = function() {
              return Object.keys(r4).length;
            }, p2 = function() {
              if (0 !== n3.length) {
                for (var t5 = Object.keys(r4), o3 = 0; o3 < t5.length; o3 += 1) if (void 0 === e4[t5[o3]]) {
                  n3[0](r4[t5[o3]]);
                  break;
                }
              }
            }, y2 = function(r5, c4) {
              return new Promise(function(s3, h3) {
                var y3 = f2({ action: r5, payload: c4 });
                n3.push(function() {
                  var t5 = u2(i2().mark(function t6(u3) {
                    var f3;
                    return i2().wrap(function(t7) {
                      for (; ; ) switch (t7.prev = t7.next) {
                        case 0:
                          return n3.shift(), e4[u3.id] = y3, t7.prev = 2, t7.next = 5, u3[r5].apply(o2, [].concat(function(t8) {
                            if (Array.isArray(t8)) return a2(t8);
                          }(i3 = c4) || function(t8) {
                            if ("undefined" != typeof Symbol && null != t8[Symbol.iterator] || null != t8["@@iterator"]) return Array.from(t8);
                          }(i3) || function(t8, r6) {
                            if (t8) {
                              if ("string" == typeof t8) return a2(t8, r6);
                              var e5 = {}.toString.call(t8).slice(8, -1);
                              return "Object" === e5 && t8.constructor && (e5 = t8.constructor.name), "Map" === e5 || "Set" === e5 ? Array.from(t8) : "Arguments" === e5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e5) ? a2(t8, r6) : void 0;
                            }
                          }(i3) || function() {
                            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                          }(), [y3.id]));
                        case 5:
                          if (f3 = t7.sent, s3(f3), !Array.isArray(f3)) {
                            t7.next = 10;
                            break;
                          }
                          return t7.next = 10, Promise.allSettled(f3);
                        case 10:
                          t7.next = 15;
                          break;
                        case 12:
                          t7.prev = 12, t7.t0 = t7.catch(2), h3(t7.t0);
                        case 15:
                          return t7.prev = 15, delete e4[u3.id], p2(), t7.finish(15);
                        case 19:
                        case "end":
                          return t7.stop();
                      }
                      var i3;
                    }, t6, null, [[2, 12, 15, 19]]);
                  }));
                  return function(r6) {
                    return t5.apply(this, arguments);
                  };
                }()), l2("[".concat(t4, "]: Add ").concat(y3.id, " to JobQueue")), l2("[".concat(t4, "]: JobQueue length=").concat(n3.length)), p2();
              });
            }, v2 = function() {
              var r5 = u2(i2().mark(function r6(e5) {
                var n4, o3, a3, u3 = arguments;
                return i2().wrap(function(r7) {
                  for (; ; ) switch (r7.prev = r7.next) {
                    case 0:
                      if (0 !== c3()) {
                        r7.next = 2;
                        break;
                      }
                      throw Error("[".concat(t4, "]: You need to have at least one worker before adding jobs"));
                    case 2:
                      for (n4 = u3.length, o3 = new Array(n4 > 1 ? n4 - 1 : 0), a3 = 1; a3 < n4; a3++) o3[a3 - 1] = u3[a3];
                      return r7.abrupt("return", y2(e5, o3));
                    case 4:
                    case "end":
                      return r7.stop();
                  }
                }, r6);
              }));
              return function(t5) {
                return r5.apply(this, arguments);
              };
            }(), d2 = function() {
              var t5 = u2(i2().mark(function t6() {
                return i2().wrap(function(t7) {
                  for (; ; ) switch (t7.prev = t7.next) {
                    case 0:
                      Object.keys(r4).forEach(function() {
                        var t8 = u2(i2().mark(function t9(e5) {
                          return i2().wrap(function(t10) {
                            for (; ; ) switch (t10.prev = t10.next) {
                              case 0:
                                return t10.next = 2, r4[e5].terminate();
                              case 2:
                              case "end":
                                return t10.stop();
                            }
                          }, t9);
                        }));
                        return function(r5) {
                          return t8.apply(this, arguments);
                        };
                      }()), n3 = [];
                    case 2:
                    case "end":
                      return t7.stop();
                  }
                }, t6);
              }));
              return function() {
                return t5.apply(this, arguments);
              };
            }();
            return { addWorker: function(e5) {
              return r4[e5.id] = e5, l2("[".concat(t4, "]: Add ").concat(e5.id)), l2("[".concat(t4, "]: Number of workers=").concat(c3())), p2(), e5.id;
            }, addJob: v2, terminate: d2, getQueueLen: function() {
              return n3.length;
            }, getNumWorkers: c3 };
          };
        }, 738: (t3, r3, e3) => {
          function n2(t4) {
            return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, n2(t4);
          }
          var o2 = ["logger", "errorHandler"];
          function i2() {
            i2 = function() {
              return r4;
            };
            var t4, r4 = {}, e4 = Object.prototype, o3 = e4.hasOwnProperty, a3 = Object.defineProperty || function(t5, r5, e5) {
              t5[r5] = e5.value;
            }, c3 = "function" == typeof Symbol ? Symbol : {}, u3 = c3.iterator || "@@iterator", f3 = c3.asyncIterator || "@@asyncIterator", l3 = c3.toStringTag || "@@toStringTag";
            function s3(t5, r5, e5) {
              return Object.defineProperty(t5, r5, { value: e5, enumerable: true, configurable: true, writable: true }), t5[r5];
            }
            try {
              s3({}, "");
            } catch (t5) {
              s3 = function(t6, r5, e5) {
                return t6[r5] = e5;
              };
            }
            function h3(t5, r5, e5, n3) {
              var o4 = r5 && r5.prototype instanceof b3 ? r5 : b3, i3 = Object.create(o4.prototype), c4 = new A2(n3 || []);
              return a3(i3, "_invoke", { value: k2(t5, e5, c4) }), i3;
            }
            function p3(t5, r5, e5) {
              try {
                return { type: "normal", arg: t5.call(r5, e5) };
              } catch (t6) {
                return { type: "throw", arg: t6 };
              }
            }
            r4.wrap = h3;
            var y3 = "suspendedStart", v3 = "suspendedYield", d3 = "executing", g3 = "completed", m3 = {};
            function b3() {
            }
            function w3() {
            }
            function L3() {
            }
            var x3 = {};
            s3(x3, u3, function() {
              return this;
            });
            var O3 = Object.getPrototypeOf, E3 = O3 && O3(O3(I2([])));
            E3 && E3 !== e4 && o3.call(E3, u3) && (x3 = E3);
            var S3 = L3.prototype = b3.prototype = Object.create(x3);
            function j3(t5) {
              ["next", "throw", "return"].forEach(function(r5) {
                s3(t5, r5, function(t6) {
                  return this._invoke(r5, t6);
                });
              });
            }
            function P2(t5, r5) {
              function e5(i4, a4, c4, u4) {
                var f4 = p3(t5[i4], t5, a4);
                if ("throw" !== f4.type) {
                  var l4 = f4.arg, s4 = l4.value;
                  return s4 && "object" == n2(s4) && o3.call(s4, "__await") ? r5.resolve(s4.__await).then(function(t6) {
                    e5("next", t6, c4, u4);
                  }, function(t6) {
                    e5("throw", t6, c4, u4);
                  }) : r5.resolve(s4).then(function(t6) {
                    l4.value = t6, c4(l4);
                  }, function(t6) {
                    return e5("throw", t6, c4, u4);
                  });
                }
                u4(f4.arg);
              }
              var i3;
              a3(this, "_invoke", { value: function(t6, n3) {
                function o4() {
                  return new r5(function(r6, o5) {
                    e5(t6, n3, r6, o5);
                  });
                }
                return i3 = i3 ? i3.then(o4, o4) : o4();
              } });
            }
            function k2(r5, e5, n3) {
              var o4 = y3;
              return function(i3, a4) {
                if (o4 === d3) throw Error("Generator is already running");
                if (o4 === g3) {
                  if ("throw" === i3) throw a4;
                  return { value: t4, done: true };
                }
                for (n3.method = i3, n3.arg = a4; ; ) {
                  var c4 = n3.delegate;
                  if (c4) {
                    var u4 = _2(c4, n3);
                    if (u4) {
                      if (u4 === m3) continue;
                      return u4;
                    }
                  }
                  if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
                  else if ("throw" === n3.method) {
                    if (o4 === y3) throw o4 = g3, n3.arg;
                    n3.dispatchException(n3.arg);
                  } else "return" === n3.method && n3.abrupt("return", n3.arg);
                  o4 = d3;
                  var f4 = p3(r5, e5, n3);
                  if ("normal" === f4.type) {
                    if (o4 = n3.done ? g3 : v3, f4.arg === m3) continue;
                    return { value: f4.arg, done: n3.done };
                  }
                  "throw" === f4.type && (o4 = g3, n3.method = "throw", n3.arg = f4.arg);
                }
              };
            }
            function _2(r5, e5) {
              var n3 = e5.method, o4 = r5.iterator[n3];
              if (o4 === t4) return e5.delegate = null, "throw" === n3 && r5.iterator.return && (e5.method = "return", e5.arg = t4, _2(r5, e5), "throw" === e5.method) || "return" !== n3 && (e5.method = "throw", e5.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), m3;
              var i3 = p3(o4, r5.iterator, e5.arg);
              if ("throw" === i3.type) return e5.method = "throw", e5.arg = i3.arg, e5.delegate = null, m3;
              var a4 = i3.arg;
              return a4 ? a4.done ? (e5[r5.resultName] = a4.value, e5.next = r5.nextLoc, "return" !== e5.method && (e5.method = "next", e5.arg = t4), e5.delegate = null, m3) : a4 : (e5.method = "throw", e5.arg = new TypeError("iterator result is not an object"), e5.delegate = null, m3);
            }
            function T2(t5) {
              var r5 = { tryLoc: t5[0] };
              1 in t5 && (r5.catchLoc = t5[1]), 2 in t5 && (r5.finallyLoc = t5[2], r5.afterLoc = t5[3]), this.tryEntries.push(r5);
            }
            function N2(t5) {
              var r5 = t5.completion || {};
              r5.type = "normal", delete r5.arg, t5.completion = r5;
            }
            function A2(t5) {
              this.tryEntries = [{ tryLoc: "root" }], t5.forEach(T2, this), this.reset(true);
            }
            function I2(r5) {
              if (r5 || "" === r5) {
                var e5 = r5[u3];
                if (e5) return e5.call(r5);
                if ("function" == typeof r5.next) return r5;
                if (!isNaN(r5.length)) {
                  var i3 = -1, a4 = function e6() {
                    for (; ++i3 < r5.length; ) if (o3.call(r5, i3)) return e6.value = r5[i3], e6.done = false, e6;
                    return e6.value = t4, e6.done = true, e6;
                  };
                  return a4.next = a4;
                }
              }
              throw new TypeError(n2(r5) + " is not iterable");
            }
            return w3.prototype = L3, a3(S3, "constructor", { value: L3, configurable: true }), a3(L3, "constructor", { value: w3, configurable: true }), w3.displayName = s3(L3, l3, "GeneratorFunction"), r4.isGeneratorFunction = function(t5) {
              var r5 = "function" == typeof t5 && t5.constructor;
              return !!r5 && (r5 === w3 || "GeneratorFunction" === (r5.displayName || r5.name));
            }, r4.mark = function(t5) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(t5, L3) : (t5.__proto__ = L3, s3(t5, l3, "GeneratorFunction")), t5.prototype = Object.create(S3), t5;
            }, r4.awrap = function(t5) {
              return { __await: t5 };
            }, j3(P2.prototype), s3(P2.prototype, f3, function() {
              return this;
            }), r4.AsyncIterator = P2, r4.async = function(t5, e5, n3, o4, i3) {
              void 0 === i3 && (i3 = Promise);
              var a4 = new P2(h3(t5, e5, n3, o4), i3);
              return r4.isGeneratorFunction(e5) ? a4 : a4.next().then(function(t6) {
                return t6.done ? t6.value : a4.next();
              });
            }, j3(S3), s3(S3, l3, "Generator"), s3(S3, u3, function() {
              return this;
            }), s3(S3, "toString", function() {
              return "[object Generator]";
            }), r4.keys = function(t5) {
              var r5 = Object(t5), e5 = [];
              for (var n3 in r5) e5.push(n3);
              return e5.reverse(), function t6() {
                for (; e5.length; ) {
                  var n4 = e5.pop();
                  if (n4 in r5) return t6.value = n4, t6.done = false, t6;
                }
                return t6.done = true, t6;
              };
            }, r4.values = I2, A2.prototype = { constructor: A2, reset: function(r5) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = t4, this.done = false, this.delegate = null, this.method = "next", this.arg = t4, this.tryEntries.forEach(N2), !r5) for (var e5 in this) "t" === e5.charAt(0) && o3.call(this, e5) && !isNaN(+e5.slice(1)) && (this[e5] = t4);
            }, stop: function() {
              this.done = true;
              var t5 = this.tryEntries[0].completion;
              if ("throw" === t5.type) throw t5.arg;
              return this.rval;
            }, dispatchException: function(r5) {
              if (this.done) throw r5;
              var e5 = this;
              function n3(n4, o4) {
                return c4.type = "throw", c4.arg = r5, e5.next = n4, o4 && (e5.method = "next", e5.arg = t4), !!o4;
              }
              for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
                var a4 = this.tryEntries[i3], c4 = a4.completion;
                if ("root" === a4.tryLoc) return n3("end");
                if (a4.tryLoc <= this.prev) {
                  var u4 = o3.call(a4, "catchLoc"), f4 = o3.call(a4, "finallyLoc");
                  if (u4 && f4) {
                    if (this.prev < a4.catchLoc) return n3(a4.catchLoc, true);
                    if (this.prev < a4.finallyLoc) return n3(a4.finallyLoc);
                  } else if (u4) {
                    if (this.prev < a4.catchLoc) return n3(a4.catchLoc, true);
                  } else {
                    if (!f4) throw Error("try statement without catch or finally");
                    if (this.prev < a4.finallyLoc) return n3(a4.finallyLoc);
                  }
                }
              }
            }, abrupt: function(t5, r5) {
              for (var e5 = this.tryEntries.length - 1; e5 >= 0; --e5) {
                var n3 = this.tryEntries[e5];
                if (n3.tryLoc <= this.prev && o3.call(n3, "finallyLoc") && this.prev < n3.finallyLoc) {
                  var i3 = n3;
                  break;
                }
              }
              i3 && ("break" === t5 || "continue" === t5) && i3.tryLoc <= r5 && r5 <= i3.finallyLoc && (i3 = null);
              var a4 = i3 ? i3.completion : {};
              return a4.type = t5, a4.arg = r5, i3 ? (this.method = "next", this.next = i3.finallyLoc, m3) : this.complete(a4);
            }, complete: function(t5, r5) {
              if ("throw" === t5.type) throw t5.arg;
              return "break" === t5.type || "continue" === t5.type ? this.next = t5.arg : "return" === t5.type ? (this.rval = this.arg = t5.arg, this.method = "return", this.next = "end") : "normal" === t5.type && r5 && (this.next = r5), m3;
            }, finish: function(t5) {
              for (var r5 = this.tryEntries.length - 1; r5 >= 0; --r5) {
                var e5 = this.tryEntries[r5];
                if (e5.finallyLoc === t5) return this.complete(e5.completion, e5.afterLoc), N2(e5), m3;
              }
            }, catch: function(t5) {
              for (var r5 = this.tryEntries.length - 1; r5 >= 0; --r5) {
                var e5 = this.tryEntries[r5];
                if (e5.tryLoc === t5) {
                  var n3 = e5.completion;
                  if ("throw" === n3.type) {
                    var o4 = n3.arg;
                    N2(e5);
                  }
                  return o4;
                }
              }
              throw Error("illegal catch attempt");
            }, delegateYield: function(r5, e5, n3) {
              return this.delegate = { iterator: I2(r5), resultName: e5, nextLoc: n3 }, "next" === this.method && (this.arg = t4), m3;
            } }, r4;
          }
          function a2(t4, r4) {
            (null == r4 || r4 > t4.length) && (r4 = t4.length);
            for (var e4 = 0, n3 = Array(r4); e4 < r4; e4++) n3[e4] = t4[e4];
            return n3;
          }
          function c2(t4, r4) {
            var e4 = Object.keys(t4);
            if (Object.getOwnPropertySymbols) {
              var n3 = Object.getOwnPropertySymbols(t4);
              r4 && (n3 = n3.filter(function(r5) {
                return Object.getOwnPropertyDescriptor(t4, r5).enumerable;
              })), e4.push.apply(e4, n3);
            }
            return e4;
          }
          function u2(t4) {
            for (var r4 = 1; r4 < arguments.length; r4++) {
              var e4 = null != arguments[r4] ? arguments[r4] : {};
              r4 % 2 ? c2(Object(e4), true).forEach(function(r5) {
                f2(t4, r5, e4[r5]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(e4)) : c2(Object(e4)).forEach(function(r5) {
                Object.defineProperty(t4, r5, Object.getOwnPropertyDescriptor(e4, r5));
              });
            }
            return t4;
          }
          function f2(t4, r4, e4) {
            return (r4 = function(t5) {
              var r5 = function(t6) {
                if ("object" != n2(t6) || !t6) return t6;
                var r6 = t6[Symbol.toPrimitive];
                if (void 0 !== r6) {
                  var e5 = r6.call(t6, "string");
                  if ("object" != n2(e5)) return e5;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(t6);
              }(t5);
              return "symbol" == n2(r5) ? r5 : r5 + "";
            }(r4)) in t4 ? Object.defineProperty(t4, r4, { value: e4, enumerable: true, configurable: true, writable: true }) : t4[r4] = e4, t4;
          }
          function l2(t4, r4) {
            if (null == t4) return {};
            var e4, n3, o3 = function(t5, r5) {
              if (null == t5) return {};
              var e5 = {};
              for (var n4 in t5) if ({}.hasOwnProperty.call(t5, n4)) {
                if (r5.includes(n4)) continue;
                e5[n4] = t5[n4];
              }
              return e5;
            }(t4, r4);
            if (Object.getOwnPropertySymbols) {
              var i3 = Object.getOwnPropertySymbols(t4);
              for (n3 = 0; n3 < i3.length; n3++) e4 = i3[n3], r4.includes(e4) || {}.propertyIsEnumerable.call(t4, e4) && (o3[e4] = t4[e4]);
            }
            return o3;
          }
          function s2(t4, r4, e4, n3, o3, i3, a3) {
            try {
              var c3 = t4[i3](a3), u3 = c3.value;
            } catch (t5) {
              return void e4(t5);
            }
            c3.done ? r4(u3) : Promise.resolve(u3).then(n3, o3);
          }
          function h2(t4) {
            return function() {
              var r4 = this, e4 = arguments;
              return new Promise(function(n3, o3) {
                var i3 = t4.apply(r4, e4);
                function a3(t5) {
                  s2(i3, n3, o3, a3, c3, "next", t5);
                }
                function c3(t5) {
                  s2(i3, n3, o3, a3, c3, "throw", t5);
                }
                a3(void 0);
              });
            };
          }
          var p2 = e3(898), y2 = e3(825), v2 = e3(13), d2 = e3(86).log, g2 = e3(857), m2 = e3(287), b2 = e3(250), w2 = b2.defaultOptions, L2 = b2.spawnWorker, x2 = b2.terminateWorker, O2 = b2.onMessage, E2 = b2.loadImage, S2 = b2.send, j2 = 0;
          t3.exports = h2(i2().mark(function t4() {
            var r4, e4, n3, c3, f3, s3, b3, P2, k2, _2, T2, N2, A2, I2, G2, F2, R2, D2, M2, C2, U2, Y2, B2, z2, H2, K2, W2, J2, V2, Z2, Q2, q2, X2, $2, tt2, rt2, et2, nt2, ot2, it2 = arguments;
            return i2().wrap(function(t5) {
              for (; ; ) switch (t5.prev = t5.next) {
                case 0:
                  return r4 = it2.length > 0 && void 0 !== it2[0] ? it2[0] : "eng", e4 = it2.length > 1 && void 0 !== it2[1] ? it2[1] : m2.LSTM_ONLY, n3 = it2.length > 2 && void 0 !== it2[2] ? it2[2] : {}, c3 = it2.length > 3 && void 0 !== it2[3] ? it2[3] : {}, f3 = g2("Worker", j2), s3 = p2(u2(u2({}, w2), n3)), b3 = s3.logger, P2 = s3.errorHandler, k2 = l2(s3, o2), _2 = {}, T2 = "string" == typeof r4 ? r4.split("+") : r4, N2 = e4, A2 = c3, I2 = [m2.DEFAULT, m2.LSTM_ONLY].includes(e4) && !k2.legacyCore, R2 = new Promise(function(t6, r5) {
                    F2 = t6, G2 = r5;
                  }), D2 = function(t6) {
                    G2(t6.message);
                  }, (M2 = L2(k2)).onerror = D2, j2 += 1, C2 = function(t6) {
                    var r5 = t6.id, e5 = t6.action, n4 = t6.payload;
                    return new Promise(function(t7, o3) {
                      d2("[".concat(f3, "]: Start ").concat(r5, ", action=").concat(e5));
                      var i3 = "".concat(e5, "-").concat(r5);
                      _2[i3] = { resolve: t7, reject: o3 }, S2(M2, { workerId: f3, jobId: r5, action: e5, payload: n4 });
                    });
                  }, U2 = function(t6) {
                    var r5 = t6.id, e5 = t6.action, n4 = t6.payload, o3 = new Promise(function(t7, n5) {
                      d2("[".concat(f3, "]: Start ").concat(r5, ", action=").concat(e5));
                      var o4 = "".concat(e5, "-").concat(r5, "b");
                      _2[o4] = { resolve: t7, reject: n5 };
                    });
                    return [new Promise(function(t7, o4) {
                      d2("[".concat(f3, "]: Start ").concat(r5, ", action=").concat(e5));
                      var i3 = "".concat(e5, "-").concat(r5);
                      _2[i3] = { resolve: t7, reject: o4 }, S2(M2, { workerId: f3, jobId: r5, action: e5, payload: n4 });
                    }), o3];
                  }, Y2 = function() {
                    return console.warn("`load` is depreciated and should be removed from code (workers now come pre-loaded)");
                  }, B2 = function(t6) {
                    return C2(v2({ id: t6, action: "load", payload: { options: { lstmOnly: I2, corePath: k2.corePath, logging: k2.logging } } }));
                  }, z2 = function(t6, r5, e5) {
                    return C2(v2({ id: e5, action: "FS", payload: { method: "writeFile", args: [t6, r5] } }));
                  }, H2 = function(t6, r5) {
                    return C2(v2({ id: r5, action: "FS", payload: { method: "readFile", args: [t6, { encoding: "utf8" }] } }));
                  }, K2 = function(t6, r5) {
                    return C2(v2({ id: r5, action: "FS", payload: { method: "unlink", args: [t6] } }));
                  }, W2 = function(t6, r5, e5) {
                    return C2(v2({ id: e5, action: "FS", payload: { method: t6, args: r5 } }));
                  }, J2 = function() {
                    return console.warn("`loadLanguage` is depreciated and should be removed from code (workers now come with language pre-loaded)");
                  }, V2 = function(t6, r5) {
                    return C2(v2({ id: r5, action: "loadLanguage", payload: { langs: t6, options: { langPath: k2.langPath, dataPath: k2.dataPath, cachePath: k2.cachePath, cacheMethod: k2.cacheMethod, gzip: k2.gzip, lstmOnly: [m2.LSTM_ONLY, m2.TESSERACT_LSTM_COMBINED].includes(N2) && !k2.legacyLang } } }));
                  }, Z2 = function() {
                    return console.warn("`initialize` is depreciated and should be removed from code (workers now come pre-initialized)");
                  }, Q2 = function(t6, r5, e5, n4) {
                    return C2(v2({ id: n4, action: "initialize", payload: { langs: t6, oem: r5, config: e5 } }));
                  }, q2 = function() {
                    var t6 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "eng", r5 = arguments.length > 1 ? arguments[1] : void 0, e5 = arguments.length > 2 ? arguments[2] : void 0, n4 = arguments.length > 3 ? arguments[3] : void 0;
                    if (I2 && [m2.TESSERACT_ONLY, m2.TESSERACT_LSTM_COMBINED].includes(r5)) throw Error("Legacy model requested but code missing.");
                    var o3 = r5 || N2;
                    N2 = o3;
                    var i3 = e5 || A2;
                    A2 = i3;
                    var c4, u3 = ("string" == typeof t6 ? t6.split("+") : t6).filter(function(t7) {
                      return !T2.includes(t7);
                    });
                    return T2.push.apply(T2, function(t7) {
                      if (Array.isArray(t7)) return a2(t7);
                    }(c4 = u3) || function(t7) {
                      if ("undefined" != typeof Symbol && null != t7[Symbol.iterator] || null != t7["@@iterator"]) return Array.from(t7);
                    }(c4) || function(t7, r6) {
                      if (t7) {
                        if ("string" == typeof t7) return a2(t7, r6);
                        var e6 = {}.toString.call(t7).slice(8, -1);
                        return "Object" === e6 && t7.constructor && (e6 = t7.constructor.name), "Map" === e6 || "Set" === e6 ? Array.from(t7) : "Arguments" === e6 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e6) ? a2(t7, r6) : void 0;
                      }
                    }(c4) || function() {
                      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    }()), u3.length > 0 ? V2(u3, n4).then(function() {
                      return Q2(t6, o3, i3, n4);
                    }) : Q2(t6, o3, i3, n4);
                  }, X2 = function() {
                    return C2(v2({ id: arguments.length > 1 ? arguments[1] : void 0, action: "setParameters", payload: { params: arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {} } }));
                  }, $2 = function() {
                    var t6 = h2(i2().mark(function t7(r5) {
                      var e5, n4, o3, a3 = arguments;
                      return i2().wrap(function(t8) {
                        for (; ; ) switch (t8.prev = t8.next) {
                          case 0:
                            return e5 = a3.length > 1 && void 0 !== a3[1] ? a3[1] : {}, n4 = a3.length > 2 && void 0 !== a3[2] ? a3[2] : { blocks: true, text: true, hocr: true, tsv: true }, o3 = a3.length > 3 ? a3[3] : void 0, t8.t0 = C2, t8.t1 = v2, t8.t2 = o3, t8.next = 8, E2(r5);
                          case 8:
                            return t8.t3 = t8.sent, t8.t4 = e5, t8.t5 = n4, t8.t6 = { image: t8.t3, options: t8.t4, output: t8.t5 }, t8.t7 = { id: t8.t2, action: "recognize", payload: t8.t6 }, t8.t8 = (0, t8.t1)(t8.t7), t8.abrupt("return", (0, t8.t0)(t8.t8));
                          case 15:
                          case "end":
                            return t8.stop();
                        }
                      }, t7);
                    }));
                    return function(r5) {
                      return t6.apply(this, arguments);
                    };
                  }(), tt2 = function() {
                    var t6 = h2(i2().mark(function t7(r5) {
                      var e5, n4, o3, a3 = arguments;
                      return i2().wrap(function(t8) {
                        for (; ; ) switch (t8.prev = t8.next) {
                          case 0:
                            return e5 = a3.length > 1 && void 0 !== a3[1] ? a3[1] : {}, n4 = a3.length > 2 && void 0 !== a3[2] ? a3[2] : { blocks: true, text: true, hocr: true, tsv: true }, o3 = a3.length > 3 ? a3[3] : void 0, t8.t0 = U2, t8.t1 = v2, t8.t2 = o3, t8.next = 8, E2(r5);
                          case 8:
                            return t8.t3 = t8.sent, t8.t4 = e5, t8.t5 = n4, t8.t6 = { image: t8.t3, options: t8.t4, output: t8.t5 }, t8.t7 = { id: t8.t2, action: "recognize2", payload: t8.t6 }, t8.t8 = (0, t8.t1)(t8.t7), t8.abrupt("return", (0, t8.t0)(t8.t8));
                          case 15:
                          case "end":
                            return t8.stop();
                        }
                      }, t7);
                    }));
                    return function(r5) {
                      return t6.apply(this, arguments);
                    };
                  }(), rt2 = function() {
                    var t6 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "Tesseract OCR Result", r5 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], e5 = arguments.length > 2 ? arguments[2] : void 0;
                    return console.log("`getPDF` function is depreciated. `recognize` option `savePDF` should be used instead."), C2(v2({ id: e5, action: "getPDF", payload: { title: t6, textonly: r5 } }));
                  }, et2 = function() {
                    var t6 = h2(i2().mark(function t7(r5, e5) {
                      return i2().wrap(function(t8) {
                        for (; ; ) switch (t8.prev = t8.next) {
                          case 0:
                            if (!I2) {
                              t8.next = 2;
                              break;
                            }
                            throw Error("`worker.detect` requires Legacy model, which was not loaded.");
                          case 2:
                            return t8.t0 = C2, t8.t1 = v2, t8.t2 = e5, t8.next = 7, E2(r5);
                          case 7:
                            return t8.t3 = t8.sent, t8.t4 = { image: t8.t3 }, t8.t5 = { id: t8.t2, action: "detect", payload: t8.t4 }, t8.t6 = (0, t8.t1)(t8.t5), t8.abrupt("return", (0, t8.t0)(t8.t6));
                          case 12:
                          case "end":
                            return t8.stop();
                        }
                      }, t7);
                    }));
                    return function(r5, e5) {
                      return t6.apply(this, arguments);
                    };
                  }(), nt2 = function() {
                    var t6 = h2(i2().mark(function t7() {
                      return i2().wrap(function(t8) {
                        for (; ; ) switch (t8.prev = t8.next) {
                          case 0:
                            return null !== M2 && (x2(M2), M2 = null), t8.abrupt("return", Promise.resolve());
                          case 2:
                          case "end":
                            return t8.stop();
                        }
                      }, t7);
                    }));
                    return function() {
                      return t6.apply(this, arguments);
                    };
                  }(), O2(M2, function(t6) {
                    var r5 = t6.workerId, e5 = t6.jobId, n4 = t6.status, o3 = t6.action, i3 = t6.data, a3 = "".concat(o3, "-").concat(e5);
                    if ("resolve" === n4) {
                      d2("[".concat(r5, "]: Complete ").concat(e5));
                      var c4 = i3;
                      "recognize" === o3 ? c4 = y2(i3) : "getPDF" === o3 && (c4 = Array.from(u2(u2({}, i3), {}, { length: Object.keys(i3).length }))), _2[a3].resolve({ jobId: e5, data: c4 }), delete _2[a3];
                    } else if ("reject" === n4) {
                      if (_2[a3].reject(i3), delete _2[a3], "load" === o3 && G2(i3), !P2) throw Error(i3);
                      P2(i3);
                    } else "progress" === n4 && b3(u2(u2({}, i3), {}, { userJobId: e5 }));
                  }), ot2 = { id: f3, worker: M2, load: Y2, writeText: z2, readText: H2, removeFile: K2, FS: W2, loadLanguage: J2, initialize: Z2, reinitialize: q2, setParameters: X2, recognize: $2, recognize2: tt2, getPDF: rt2, detect: et2, terminate: nt2 }, B2().then(function() {
                    return V2(r4);
                  }).then(function() {
                    return Q2(r4, e4, c3);
                  }).then(function() {
                    return F2(ot2);
                  }).catch(function() {
                  }), t5.abrupt("return", R2);
                case 39:
                case "end":
                  return t5.stop();
              }
            }, t4);
          }));
        }, 954: (t3, r3, e3) => {
          function n2(t4) {
            return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, n2(t4);
          }
          function o2(t4, r4) {
            var e4 = Object.keys(t4);
            if (Object.getOwnPropertySymbols) {
              var n3 = Object.getOwnPropertySymbols(t4);
              r4 && (n3 = n3.filter(function(r5) {
                return Object.getOwnPropertyDescriptor(t4, r5).enumerable;
              })), e4.push.apply(e4, n3);
            }
            return e4;
          }
          function i2(t4, r4, e4) {
            return (r4 = function(t5) {
              var r5 = function(t6) {
                if ("object" != n2(t6) || !t6) return t6;
                var r6 = t6[Symbol.toPrimitive];
                if (void 0 !== r6) {
                  var e5 = r6.call(t6, "string");
                  if ("object" != n2(e5)) return e5;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(t6);
              }(t5);
              return "symbol" == n2(r5) ? r5 : r5 + "";
            }(r4)) in t4 ? Object.defineProperty(t4, r4, { value: e4, enumerable: true, configurable: true, writable: true }) : t4[r4] = e4, t4;
          }
          e3(30);
          var a2 = e3(695), c2 = e3(738), u2 = e3(52), f2 = e3(11), l2 = e3(287), s2 = e3(188), h2 = e3(86).setLogging;
          t3.exports = function(t4) {
            for (var r4 = 1; r4 < arguments.length; r4++) {
              var e4 = null != arguments[r4] ? arguments[r4] : {};
              r4 % 2 ? o2(Object(e4), true).forEach(function(r5) {
                i2(t4, r5, e4[r5]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(e4)) : o2(Object(e4)).forEach(function(r5) {
                Object.defineProperty(t4, r5, Object.getOwnPropertyDescriptor(e4, r5));
              });
            }
            return t4;
          }({ languages: f2, OEM: l2, PSM: s2, createScheduler: a2, createWorker: c2, setLogging: h2 }, u2);
        }, 825: (t3) => {
          function r3(t4) {
            return r3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, r3(t4);
          }
          function e3(t4, r4) {
            var e4 = Object.keys(t4);
            if (Object.getOwnPropertySymbols) {
              var n3 = Object.getOwnPropertySymbols(t4);
              r4 && (n3 = n3.filter(function(r5) {
                return Object.getOwnPropertyDescriptor(t4, r5).enumerable;
              })), e4.push.apply(e4, n3);
            }
            return e4;
          }
          function n2(t4) {
            for (var r4 = 1; r4 < arguments.length; r4++) {
              var n3 = null != arguments[r4] ? arguments[r4] : {};
              r4 % 2 ? e3(Object(n3), true).forEach(function(r5) {
                o2(t4, r5, n3[r5]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(n3)) : e3(Object(n3)).forEach(function(r5) {
                Object.defineProperty(t4, r5, Object.getOwnPropertyDescriptor(n3, r5));
              });
            }
            return t4;
          }
          function o2(t4, e4, n3) {
            return (e4 = function(t5) {
              var e5 = function(t6) {
                if ("object" != r3(t6) || !t6) return t6;
                var e6 = t6[Symbol.toPrimitive];
                if (void 0 !== e6) {
                  var n4 = e6.call(t6, "string");
                  if ("object" != r3(n4)) return n4;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(t6);
              }(t5);
              return "symbol" == r3(e5) ? e5 : e5 + "";
            }(e4)) in t4 ? Object.defineProperty(t4, e4, { value: n3, enumerable: true, configurable: true, writable: true }) : t4[e4] = n3, t4;
          }
          t3.exports = function(t4) {
            var r4 = [], e4 = [], o3 = [], i2 = [], a2 = [];
            return t4.blocks && t4.blocks.forEach(function(c2) {
              c2.paragraphs.forEach(function(r5) {
                r5.lines.forEach(function(e5) {
                  e5.words.forEach(function(o4) {
                    o4.symbols.forEach(function(i3) {
                      a2.push(n2(n2({}, i3), {}, { page: t4, block: c2, paragraph: r5, line: e5, word: o4 }));
                    }), i2.push(n2(n2({}, o4), {}, { page: t4, block: c2, paragraph: r5, line: e5 }));
                  }), o3.push(n2(n2({}, e5), {}, { page: t4, block: c2, paragraph: r5 }));
                }), e4.push(n2(n2({}, r5), {}, { page: t4, block: c2 }));
              }), r4.push(n2(n2({}, c2), {}, { page: t4 }));
            }), n2(n2({}, t4), {}, { blocks: r4, paragraphs: e4, lines: o3, words: i2, symbols: a2 });
          };
        }, 827: (t3) => {
          function r3(t4) {
            return r3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, r3(t4);
          }
          t3.exports = function(t4) {
            var e3 = {};
            return "undefined" != typeof WorkerGlobalScope ? e3.type = "webworker" : "object" === ("undefined" == typeof document ? "undefined" : r3(document)) ? e3.type = "browser" : "object" === ("undefined" == typeof process ? "undefined" : r3(process)) && (e3.type = "node"), void 0 === t4 ? e3 : e3[t4];
          };
        }, 857: (t3) => {
          t3.exports = function(t4, r3) {
            return "".concat(t4, "-").concat(r3, "-").concat(Math.random().toString(16).slice(3, 8));
          };
        }, 86: function(t3, r3) {
          var e3 = this, n2 = false;
          r3.logging = n2, r3.setLogging = function(t4) {
            n2 = t4;
          }, r3.log = function() {
            for (var t4 = arguments.length, r4 = new Array(t4), o2 = 0; o2 < t4; o2++) r4[o2] = arguments[o2];
            return n2 ? console.log.apply(e3, r4) : null;
          };
        }, 898: (t3, r3, e3) => {
          function n2(t4) {
            return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, n2(t4);
          }
          function o2(t4, r4) {
            var e4 = Object.keys(t4);
            if (Object.getOwnPropertySymbols) {
              var n3 = Object.getOwnPropertySymbols(t4);
              r4 && (n3 = n3.filter(function(r5) {
                return Object.getOwnPropertyDescriptor(t4, r5).enumerable;
              })), e4.push.apply(e4, n3);
            }
            return e4;
          }
          function i2(t4, r4, e4) {
            return (r4 = function(t5) {
              var r5 = function(t6) {
                if ("object" != n2(t6) || !t6) return t6;
                var r6 = t6[Symbol.toPrimitive];
                if (void 0 !== r6) {
                  var e5 = r6.call(t6, "string");
                  if ("object" != n2(e5)) return e5;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(t6);
              }(t5);
              return "symbol" == n2(r5) ? r5 : r5 + "";
            }(r4)) in t4 ? Object.defineProperty(t4, r4, { value: e4, enumerable: true, configurable: true, writable: true }) : t4[r4] = e4, t4;
          }
          var a2 = "browser" === e3(827)("type") ? function(t4) {
            return new URL(t4, window.location.href).href;
          } : function(t4) {
            return t4;
          };
          t3.exports = function(t4) {
            var r4 = function(t5) {
              for (var r5 = 1; r5 < arguments.length; r5++) {
                var e4 = null != arguments[r5] ? arguments[r5] : {};
                r5 % 2 ? o2(Object(e4), true).forEach(function(r6) {
                  i2(t5, r6, e4[r6]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t5, Object.getOwnPropertyDescriptors(e4)) : o2(Object(e4)).forEach(function(r6) {
                  Object.defineProperty(t5, r6, Object.getOwnPropertyDescriptor(e4, r6));
                });
              }
              return t5;
            }({}, t4);
            return ["corePath", "workerPath", "langPath"].forEach(function(e4) {
              t4[e4] && (r4[e4] = a2(r4[e4]));
            }), r4;
          };
        }, 989: (t3, r3, e3) => {
          function n2(t4) {
            return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, n2(t4);
          }
          function o2(t4, r4) {
            var e4 = Object.keys(t4);
            if (Object.getOwnPropertySymbols) {
              var n3 = Object.getOwnPropertySymbols(t4);
              r4 && (n3 = n3.filter(function(r5) {
                return Object.getOwnPropertyDescriptor(t4, r5).enumerable;
              })), e4.push.apply(e4, n3);
            }
            return e4;
          }
          function i2(t4) {
            for (var r4 = 1; r4 < arguments.length; r4++) {
              var e4 = null != arguments[r4] ? arguments[r4] : {};
              r4 % 2 ? o2(Object(e4), true).forEach(function(r5) {
                a2(t4, r5, e4[r5]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(e4)) : o2(Object(e4)).forEach(function(r5) {
                Object.defineProperty(t4, r5, Object.getOwnPropertyDescriptor(e4, r5));
              });
            }
            return t4;
          }
          function a2(t4, r4, e4) {
            return (r4 = function(t5) {
              var r5 = function(t6) {
                if ("object" != n2(t6) || !t6) return t6;
                var r6 = t6[Symbol.toPrimitive];
                if (void 0 !== r6) {
                  var e5 = r6.call(t6, "string");
                  if ("object" != n2(e5)) return e5;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(t6);
              }(t5);
              return "symbol" == n2(r5) ? r5 : r5 + "";
            }(r4)) in t4 ? Object.defineProperty(t4, r4, { value: e4, enumerable: true, configurable: true, writable: true }) : t4[r4] = e4, t4;
          }
          var c2 = e3(330).rE, u2 = e3(491);
          t3.exports = i2(i2({}, u2), {}, { workerPath: "https://cdn.jsdelivr.net/npm/tesseract.js@v".concat(c2, "/dist/worker.min.js") });
        }, 250: (t3, r3, e3) => {
          var n2 = e3(989), o2 = e3(423), i2 = e3(399), a2 = e3(278), c2 = e3(782), u2 = e3(383);
          t3.exports = { defaultOptions: n2, spawnWorker: o2, terminateWorker: i2, onMessage: a2, send: c2, loadImage: u2 };
        }, 383: (t3) => {
          function r3(t4) {
            return r3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, r3(t4);
          }
          function e3() {
            e3 = function() {
              return n3;
            };
            var t4, n3 = {}, o3 = Object.prototype, i3 = o3.hasOwnProperty, a3 = Object.defineProperty || function(t5, r4, e4) {
              t5[r4] = e4.value;
            }, c2 = "function" == typeof Symbol ? Symbol : {}, u2 = c2.iterator || "@@iterator", f2 = c2.asyncIterator || "@@asyncIterator", l2 = c2.toStringTag || "@@toStringTag";
            function s2(t5, r4, e4) {
              return Object.defineProperty(t5, r4, { value: e4, enumerable: true, configurable: true, writable: true }), t5[r4];
            }
            try {
              s2({}, "");
            } catch (t5) {
              s2 = function(t6, r4, e4) {
                return t6[r4] = e4;
              };
            }
            function h2(t5, r4, e4, n4) {
              var o4 = r4 && r4.prototype instanceof b2 ? r4 : b2, i4 = Object.create(o4.prototype), c3 = new A2(n4 || []);
              return a3(i4, "_invoke", { value: k2(t5, e4, c3) }), i4;
            }
            function p2(t5, r4, e4) {
              try {
                return { type: "normal", arg: t5.call(r4, e4) };
              } catch (t6) {
                return { type: "throw", arg: t6 };
              }
            }
            n3.wrap = h2;
            var y2 = "suspendedStart", v2 = "suspendedYield", d2 = "executing", g2 = "completed", m2 = {};
            function b2() {
            }
            function w2() {
            }
            function L2() {
            }
            var x2 = {};
            s2(x2, u2, function() {
              return this;
            });
            var O2 = Object.getPrototypeOf, E2 = O2 && O2(O2(I2([])));
            E2 && E2 !== o3 && i3.call(E2, u2) && (x2 = E2);
            var S2 = L2.prototype = b2.prototype = Object.create(x2);
            function j2(t5) {
              ["next", "throw", "return"].forEach(function(r4) {
                s2(t5, r4, function(t6) {
                  return this._invoke(r4, t6);
                });
              });
            }
            function P2(t5, e4) {
              function n4(o5, a4, c3, u3) {
                var f3 = p2(t5[o5], t5, a4);
                if ("throw" !== f3.type) {
                  var l3 = f3.arg, s3 = l3.value;
                  return s3 && "object" == r3(s3) && i3.call(s3, "__await") ? e4.resolve(s3.__await).then(function(t6) {
                    n4("next", t6, c3, u3);
                  }, function(t6) {
                    n4("throw", t6, c3, u3);
                  }) : e4.resolve(s3).then(function(t6) {
                    l3.value = t6, c3(l3);
                  }, function(t6) {
                    return n4("throw", t6, c3, u3);
                  });
                }
                u3(f3.arg);
              }
              var o4;
              a3(this, "_invoke", { value: function(t6, r4) {
                function i4() {
                  return new e4(function(e5, o5) {
                    n4(t6, r4, e5, o5);
                  });
                }
                return o4 = o4 ? o4.then(i4, i4) : i4();
              } });
            }
            function k2(r4, e4, n4) {
              var o4 = y2;
              return function(i4, a4) {
                if (o4 === d2) throw Error("Generator is already running");
                if (o4 === g2) {
                  if ("throw" === i4) throw a4;
                  return { value: t4, done: true };
                }
                for (n4.method = i4, n4.arg = a4; ; ) {
                  var c3 = n4.delegate;
                  if (c3) {
                    var u3 = _2(c3, n4);
                    if (u3) {
                      if (u3 === m2) continue;
                      return u3;
                    }
                  }
                  if ("next" === n4.method) n4.sent = n4._sent = n4.arg;
                  else if ("throw" === n4.method) {
                    if (o4 === y2) throw o4 = g2, n4.arg;
                    n4.dispatchException(n4.arg);
                  } else "return" === n4.method && n4.abrupt("return", n4.arg);
                  o4 = d2;
                  var f3 = p2(r4, e4, n4);
                  if ("normal" === f3.type) {
                    if (o4 = n4.done ? g2 : v2, f3.arg === m2) continue;
                    return { value: f3.arg, done: n4.done };
                  }
                  "throw" === f3.type && (o4 = g2, n4.method = "throw", n4.arg = f3.arg);
                }
              };
            }
            function _2(r4, e4) {
              var n4 = e4.method, o4 = r4.iterator[n4];
              if (o4 === t4) return e4.delegate = null, "throw" === n4 && r4.iterator.return && (e4.method = "return", e4.arg = t4, _2(r4, e4), "throw" === e4.method) || "return" !== n4 && (e4.method = "throw", e4.arg = new TypeError("The iterator does not provide a '" + n4 + "' method")), m2;
              var i4 = p2(o4, r4.iterator, e4.arg);
              if ("throw" === i4.type) return e4.method = "throw", e4.arg = i4.arg, e4.delegate = null, m2;
              var a4 = i4.arg;
              return a4 ? a4.done ? (e4[r4.resultName] = a4.value, e4.next = r4.nextLoc, "return" !== e4.method && (e4.method = "next", e4.arg = t4), e4.delegate = null, m2) : a4 : (e4.method = "throw", e4.arg = new TypeError("iterator result is not an object"), e4.delegate = null, m2);
            }
            function T2(t5) {
              var r4 = { tryLoc: t5[0] };
              1 in t5 && (r4.catchLoc = t5[1]), 2 in t5 && (r4.finallyLoc = t5[2], r4.afterLoc = t5[3]), this.tryEntries.push(r4);
            }
            function N2(t5) {
              var r4 = t5.completion || {};
              r4.type = "normal", delete r4.arg, t5.completion = r4;
            }
            function A2(t5) {
              this.tryEntries = [{ tryLoc: "root" }], t5.forEach(T2, this), this.reset(true);
            }
            function I2(e4) {
              if (e4 || "" === e4) {
                var n4 = e4[u2];
                if (n4) return n4.call(e4);
                if ("function" == typeof e4.next) return e4;
                if (!isNaN(e4.length)) {
                  var o4 = -1, a4 = function r4() {
                    for (; ++o4 < e4.length; ) if (i3.call(e4, o4)) return r4.value = e4[o4], r4.done = false, r4;
                    return r4.value = t4, r4.done = true, r4;
                  };
                  return a4.next = a4;
                }
              }
              throw new TypeError(r3(e4) + " is not iterable");
            }
            return w2.prototype = L2, a3(S2, "constructor", { value: L2, configurable: true }), a3(L2, "constructor", { value: w2, configurable: true }), w2.displayName = s2(L2, l2, "GeneratorFunction"), n3.isGeneratorFunction = function(t5) {
              var r4 = "function" == typeof t5 && t5.constructor;
              return !!r4 && (r4 === w2 || "GeneratorFunction" === (r4.displayName || r4.name));
            }, n3.mark = function(t5) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(t5, L2) : (t5.__proto__ = L2, s2(t5, l2, "GeneratorFunction")), t5.prototype = Object.create(S2), t5;
            }, n3.awrap = function(t5) {
              return { __await: t5 };
            }, j2(P2.prototype), s2(P2.prototype, f2, function() {
              return this;
            }), n3.AsyncIterator = P2, n3.async = function(t5, r4, e4, o4, i4) {
              void 0 === i4 && (i4 = Promise);
              var a4 = new P2(h2(t5, r4, e4, o4), i4);
              return n3.isGeneratorFunction(r4) ? a4 : a4.next().then(function(t6) {
                return t6.done ? t6.value : a4.next();
              });
            }, j2(S2), s2(S2, l2, "Generator"), s2(S2, u2, function() {
              return this;
            }), s2(S2, "toString", function() {
              return "[object Generator]";
            }), n3.keys = function(t5) {
              var r4 = Object(t5), e4 = [];
              for (var n4 in r4) e4.push(n4);
              return e4.reverse(), function t6() {
                for (; e4.length; ) {
                  var n5 = e4.pop();
                  if (n5 in r4) return t6.value = n5, t6.done = false, t6;
                }
                return t6.done = true, t6;
              };
            }, n3.values = I2, A2.prototype = { constructor: A2, reset: function(r4) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = t4, this.done = false, this.delegate = null, this.method = "next", this.arg = t4, this.tryEntries.forEach(N2), !r4) for (var e4 in this) "t" === e4.charAt(0) && i3.call(this, e4) && !isNaN(+e4.slice(1)) && (this[e4] = t4);
            }, stop: function() {
              this.done = true;
              var t5 = this.tryEntries[0].completion;
              if ("throw" === t5.type) throw t5.arg;
              return this.rval;
            }, dispatchException: function(r4) {
              if (this.done) throw r4;
              var e4 = this;
              function n4(n5, o5) {
                return c3.type = "throw", c3.arg = r4, e4.next = n5, o5 && (e4.method = "next", e4.arg = t4), !!o5;
              }
              for (var o4 = this.tryEntries.length - 1; o4 >= 0; --o4) {
                var a4 = this.tryEntries[o4], c3 = a4.completion;
                if ("root" === a4.tryLoc) return n4("end");
                if (a4.tryLoc <= this.prev) {
                  var u3 = i3.call(a4, "catchLoc"), f3 = i3.call(a4, "finallyLoc");
                  if (u3 && f3) {
                    if (this.prev < a4.catchLoc) return n4(a4.catchLoc, true);
                    if (this.prev < a4.finallyLoc) return n4(a4.finallyLoc);
                  } else if (u3) {
                    if (this.prev < a4.catchLoc) return n4(a4.catchLoc, true);
                  } else {
                    if (!f3) throw Error("try statement without catch or finally");
                    if (this.prev < a4.finallyLoc) return n4(a4.finallyLoc);
                  }
                }
              }
            }, abrupt: function(t5, r4) {
              for (var e4 = this.tryEntries.length - 1; e4 >= 0; --e4) {
                var n4 = this.tryEntries[e4];
                if (n4.tryLoc <= this.prev && i3.call(n4, "finallyLoc") && this.prev < n4.finallyLoc) {
                  var o4 = n4;
                  break;
                }
              }
              o4 && ("break" === t5 || "continue" === t5) && o4.tryLoc <= r4 && r4 <= o4.finallyLoc && (o4 = null);
              var a4 = o4 ? o4.completion : {};
              return a4.type = t5, a4.arg = r4, o4 ? (this.method = "next", this.next = o4.finallyLoc, m2) : this.complete(a4);
            }, complete: function(t5, r4) {
              if ("throw" === t5.type) throw t5.arg;
              return "break" === t5.type || "continue" === t5.type ? this.next = t5.arg : "return" === t5.type ? (this.rval = this.arg = t5.arg, this.method = "return", this.next = "end") : "normal" === t5.type && r4 && (this.next = r4), m2;
            }, finish: function(t5) {
              for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
                var e4 = this.tryEntries[r4];
                if (e4.finallyLoc === t5) return this.complete(e4.completion, e4.afterLoc), N2(e4), m2;
              }
            }, catch: function(t5) {
              for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
                var e4 = this.tryEntries[r4];
                if (e4.tryLoc === t5) {
                  var n4 = e4.completion;
                  if ("throw" === n4.type) {
                    var o4 = n4.arg;
                    N2(e4);
                  }
                  return o4;
                }
              }
              throw Error("illegal catch attempt");
            }, delegateYield: function(r4, e4, n4) {
              return this.delegate = { iterator: I2(r4), resultName: e4, nextLoc: n4 }, "next" === this.method && (this.arg = t4), m2;
            } }, n3;
          }
          function n2(t4, r4, e4, n3, o3, i3, a3) {
            try {
              var c2 = t4[i3](a3), u2 = c2.value;
            } catch (t5) {
              return void e4(t5);
            }
            c2.done ? r4(u2) : Promise.resolve(u2).then(n3, o3);
          }
          function o2(t4) {
            return function() {
              var r4 = this, e4 = arguments;
              return new Promise(function(o3, i3) {
                var a3 = t4.apply(r4, e4);
                function c2(t5) {
                  n2(a3, o3, i3, c2, u2, "next", t5);
                }
                function u2(t5) {
                  n2(a3, o3, i3, c2, u2, "throw", t5);
                }
                c2(void 0);
              });
            };
          }
          var i2 = function(t4) {
            return new Promise(function(r4, e4) {
              var n3 = new FileReader();
              n3.onload = function() {
                r4(n3.result);
              }, n3.onerror = function(t5) {
                var r5 = t5.target.error.code;
                e4(Error("File could not be read! Code=".concat(r5)));
              }, n3.readAsArrayBuffer(t4);
            });
          }, a2 = function() {
            var t4 = o2(e3().mark(function t5(r4) {
              var n3, c2, u2;
              return e3().wrap(function(t6) {
                for (; ; ) switch (t6.prev = t6.next) {
                  case 0:
                    if (n3 = r4, void 0 !== r4) {
                      t6.next = 3;
                      break;
                    }
                    return t6.abrupt("return", "undefined");
                  case 3:
                    if ("string" != typeof r4) {
                      t6.next = 16;
                      break;
                    }
                    if (!/data:image\/([a-zA-Z]*);base64,([^"]*)/.test(r4)) {
                      t6.next = 8;
                      break;
                    }
                    n3 = atob(r4.split(",")[1]).split("").map(function(t7) {
                      return t7.charCodeAt(0);
                    }), t6.next = 14;
                    break;
                  case 8:
                    return t6.next = 10, fetch(r4);
                  case 10:
                    return c2 = t6.sent, t6.next = 13, c2.arrayBuffer();
                  case 13:
                    n3 = t6.sent;
                  case 14:
                    t6.next = 43;
                    break;
                  case 16:
                    if (!("undefined" != typeof HTMLElement && r4 instanceof HTMLElement)) {
                      t6.next = 30;
                      break;
                    }
                    if ("IMG" !== r4.tagName) {
                      t6.next = 21;
                      break;
                    }
                    return t6.next = 20, a2(r4.src);
                  case 20:
                    n3 = t6.sent;
                  case 21:
                    if ("VIDEO" !== r4.tagName) {
                      t6.next = 25;
                      break;
                    }
                    return t6.next = 24, a2(r4.poster);
                  case 24:
                    n3 = t6.sent;
                  case 25:
                    if ("CANVAS" !== r4.tagName) {
                      t6.next = 28;
                      break;
                    }
                    return t6.next = 28, new Promise(function(t7) {
                      r4.toBlob(function() {
                        var r5 = o2(e3().mark(function r6(o3) {
                          return e3().wrap(function(r7) {
                            for (; ; ) switch (r7.prev = r7.next) {
                              case 0:
                                return r7.next = 2, i2(o3);
                              case 2:
                                n3 = r7.sent, t7();
                              case 4:
                              case "end":
                                return r7.stop();
                            }
                          }, r6);
                        }));
                        return function(t8) {
                          return r5.apply(this, arguments);
                        };
                      }());
                    });
                  case 28:
                    t6.next = 43;
                    break;
                  case 30:
                    if (!("undefined" != typeof OffscreenCanvas && r4 instanceof OffscreenCanvas)) {
                      t6.next = 39;
                      break;
                    }
                    return t6.next = 33, r4.convertToBlob();
                  case 33:
                    return u2 = t6.sent, t6.next = 36, i2(u2);
                  case 36:
                    n3 = t6.sent, t6.next = 43;
                    break;
                  case 39:
                    if (!(r4 instanceof File || r4 instanceof Blob)) {
                      t6.next = 43;
                      break;
                    }
                    return t6.next = 42, i2(r4);
                  case 42:
                    n3 = t6.sent;
                  case 43:
                    return t6.abrupt("return", new Uint8Array(n3));
                  case 44:
                  case "end":
                    return t6.stop();
                }
              }, t5);
            }));
            return function(r4) {
              return t4.apply(this, arguments);
            };
          }();
          t3.exports = a2;
        }, 278: (t3) => {
          t3.exports = function(t4, r3) {
            t4.onmessage = function(t5) {
              var e3 = t5.data;
              r3(e3);
            };
          };
        }, 782: (t3) => {
          function r3(t4) {
            return r3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, r3(t4);
          }
          function e3() {
            e3 = function() {
              return n3;
            };
            var t4, n3 = {}, o2 = Object.prototype, i2 = o2.hasOwnProperty, a2 = Object.defineProperty || function(t5, r4, e4) {
              t5[r4] = e4.value;
            }, c2 = "function" == typeof Symbol ? Symbol : {}, u2 = c2.iterator || "@@iterator", f2 = c2.asyncIterator || "@@asyncIterator", l2 = c2.toStringTag || "@@toStringTag";
            function s2(t5, r4, e4) {
              return Object.defineProperty(t5, r4, { value: e4, enumerable: true, configurable: true, writable: true }), t5[r4];
            }
            try {
              s2({}, "");
            } catch (t5) {
              s2 = function(t6, r4, e4) {
                return t6[r4] = e4;
              };
            }
            function h2(t5, r4, e4, n4) {
              var o3 = r4 && r4.prototype instanceof b2 ? r4 : b2, i3 = Object.create(o3.prototype), c3 = new A2(n4 || []);
              return a2(i3, "_invoke", { value: k2(t5, e4, c3) }), i3;
            }
            function p2(t5, r4, e4) {
              try {
                return { type: "normal", arg: t5.call(r4, e4) };
              } catch (t6) {
                return { type: "throw", arg: t6 };
              }
            }
            n3.wrap = h2;
            var y2 = "suspendedStart", v2 = "suspendedYield", d2 = "executing", g2 = "completed", m2 = {};
            function b2() {
            }
            function w2() {
            }
            function L2() {
            }
            var x2 = {};
            s2(x2, u2, function() {
              return this;
            });
            var O2 = Object.getPrototypeOf, E2 = O2 && O2(O2(I2([])));
            E2 && E2 !== o2 && i2.call(E2, u2) && (x2 = E2);
            var S2 = L2.prototype = b2.prototype = Object.create(x2);
            function j2(t5) {
              ["next", "throw", "return"].forEach(function(r4) {
                s2(t5, r4, function(t6) {
                  return this._invoke(r4, t6);
                });
              });
            }
            function P2(t5, e4) {
              function n4(o4, a3, c3, u3) {
                var f3 = p2(t5[o4], t5, a3);
                if ("throw" !== f3.type) {
                  var l3 = f3.arg, s3 = l3.value;
                  return s3 && "object" == r3(s3) && i2.call(s3, "__await") ? e4.resolve(s3.__await).then(function(t6) {
                    n4("next", t6, c3, u3);
                  }, function(t6) {
                    n4("throw", t6, c3, u3);
                  }) : e4.resolve(s3).then(function(t6) {
                    l3.value = t6, c3(l3);
                  }, function(t6) {
                    return n4("throw", t6, c3, u3);
                  });
                }
                u3(f3.arg);
              }
              var o3;
              a2(this, "_invoke", { value: function(t6, r4) {
                function i3() {
                  return new e4(function(e5, o4) {
                    n4(t6, r4, e5, o4);
                  });
                }
                return o3 = o3 ? o3.then(i3, i3) : i3();
              } });
            }
            function k2(r4, e4, n4) {
              var o3 = y2;
              return function(i3, a3) {
                if (o3 === d2) throw Error("Generator is already running");
                if (o3 === g2) {
                  if ("throw" === i3) throw a3;
                  return { value: t4, done: true };
                }
                for (n4.method = i3, n4.arg = a3; ; ) {
                  var c3 = n4.delegate;
                  if (c3) {
                    var u3 = _2(c3, n4);
                    if (u3) {
                      if (u3 === m2) continue;
                      return u3;
                    }
                  }
                  if ("next" === n4.method) n4.sent = n4._sent = n4.arg;
                  else if ("throw" === n4.method) {
                    if (o3 === y2) throw o3 = g2, n4.arg;
                    n4.dispatchException(n4.arg);
                  } else "return" === n4.method && n4.abrupt("return", n4.arg);
                  o3 = d2;
                  var f3 = p2(r4, e4, n4);
                  if ("normal" === f3.type) {
                    if (o3 = n4.done ? g2 : v2, f3.arg === m2) continue;
                    return { value: f3.arg, done: n4.done };
                  }
                  "throw" === f3.type && (o3 = g2, n4.method = "throw", n4.arg = f3.arg);
                }
              };
            }
            function _2(r4, e4) {
              var n4 = e4.method, o3 = r4.iterator[n4];
              if (o3 === t4) return e4.delegate = null, "throw" === n4 && r4.iterator.return && (e4.method = "return", e4.arg = t4, _2(r4, e4), "throw" === e4.method) || "return" !== n4 && (e4.method = "throw", e4.arg = new TypeError("The iterator does not provide a '" + n4 + "' method")), m2;
              var i3 = p2(o3, r4.iterator, e4.arg);
              if ("throw" === i3.type) return e4.method = "throw", e4.arg = i3.arg, e4.delegate = null, m2;
              var a3 = i3.arg;
              return a3 ? a3.done ? (e4[r4.resultName] = a3.value, e4.next = r4.nextLoc, "return" !== e4.method && (e4.method = "next", e4.arg = t4), e4.delegate = null, m2) : a3 : (e4.method = "throw", e4.arg = new TypeError("iterator result is not an object"), e4.delegate = null, m2);
            }
            function T2(t5) {
              var r4 = { tryLoc: t5[0] };
              1 in t5 && (r4.catchLoc = t5[1]), 2 in t5 && (r4.finallyLoc = t5[2], r4.afterLoc = t5[3]), this.tryEntries.push(r4);
            }
            function N2(t5) {
              var r4 = t5.completion || {};
              r4.type = "normal", delete r4.arg, t5.completion = r4;
            }
            function A2(t5) {
              this.tryEntries = [{ tryLoc: "root" }], t5.forEach(T2, this), this.reset(true);
            }
            function I2(e4) {
              if (e4 || "" === e4) {
                var n4 = e4[u2];
                if (n4) return n4.call(e4);
                if ("function" == typeof e4.next) return e4;
                if (!isNaN(e4.length)) {
                  var o3 = -1, a3 = function r4() {
                    for (; ++o3 < e4.length; ) if (i2.call(e4, o3)) return r4.value = e4[o3], r4.done = false, r4;
                    return r4.value = t4, r4.done = true, r4;
                  };
                  return a3.next = a3;
                }
              }
              throw new TypeError(r3(e4) + " is not iterable");
            }
            return w2.prototype = L2, a2(S2, "constructor", { value: L2, configurable: true }), a2(L2, "constructor", { value: w2, configurable: true }), w2.displayName = s2(L2, l2, "GeneratorFunction"), n3.isGeneratorFunction = function(t5) {
              var r4 = "function" == typeof t5 && t5.constructor;
              return !!r4 && (r4 === w2 || "GeneratorFunction" === (r4.displayName || r4.name));
            }, n3.mark = function(t5) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(t5, L2) : (t5.__proto__ = L2, s2(t5, l2, "GeneratorFunction")), t5.prototype = Object.create(S2), t5;
            }, n3.awrap = function(t5) {
              return { __await: t5 };
            }, j2(P2.prototype), s2(P2.prototype, f2, function() {
              return this;
            }), n3.AsyncIterator = P2, n3.async = function(t5, r4, e4, o3, i3) {
              void 0 === i3 && (i3 = Promise);
              var a3 = new P2(h2(t5, r4, e4, o3), i3);
              return n3.isGeneratorFunction(r4) ? a3 : a3.next().then(function(t6) {
                return t6.done ? t6.value : a3.next();
              });
            }, j2(S2), s2(S2, l2, "Generator"), s2(S2, u2, function() {
              return this;
            }), s2(S2, "toString", function() {
              return "[object Generator]";
            }), n3.keys = function(t5) {
              var r4 = Object(t5), e4 = [];
              for (var n4 in r4) e4.push(n4);
              return e4.reverse(), function t6() {
                for (; e4.length; ) {
                  var n5 = e4.pop();
                  if (n5 in r4) return t6.value = n5, t6.done = false, t6;
                }
                return t6.done = true, t6;
              };
            }, n3.values = I2, A2.prototype = { constructor: A2, reset: function(r4) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = t4, this.done = false, this.delegate = null, this.method = "next", this.arg = t4, this.tryEntries.forEach(N2), !r4) for (var e4 in this) "t" === e4.charAt(0) && i2.call(this, e4) && !isNaN(+e4.slice(1)) && (this[e4] = t4);
            }, stop: function() {
              this.done = true;
              var t5 = this.tryEntries[0].completion;
              if ("throw" === t5.type) throw t5.arg;
              return this.rval;
            }, dispatchException: function(r4) {
              if (this.done) throw r4;
              var e4 = this;
              function n4(n5, o4) {
                return c3.type = "throw", c3.arg = r4, e4.next = n5, o4 && (e4.method = "next", e4.arg = t4), !!o4;
              }
              for (var o3 = this.tryEntries.length - 1; o3 >= 0; --o3) {
                var a3 = this.tryEntries[o3], c3 = a3.completion;
                if ("root" === a3.tryLoc) return n4("end");
                if (a3.tryLoc <= this.prev) {
                  var u3 = i2.call(a3, "catchLoc"), f3 = i2.call(a3, "finallyLoc");
                  if (u3 && f3) {
                    if (this.prev < a3.catchLoc) return n4(a3.catchLoc, true);
                    if (this.prev < a3.finallyLoc) return n4(a3.finallyLoc);
                  } else if (u3) {
                    if (this.prev < a3.catchLoc) return n4(a3.catchLoc, true);
                  } else {
                    if (!f3) throw Error("try statement without catch or finally");
                    if (this.prev < a3.finallyLoc) return n4(a3.finallyLoc);
                  }
                }
              }
            }, abrupt: function(t5, r4) {
              for (var e4 = this.tryEntries.length - 1; e4 >= 0; --e4) {
                var n4 = this.tryEntries[e4];
                if (n4.tryLoc <= this.prev && i2.call(n4, "finallyLoc") && this.prev < n4.finallyLoc) {
                  var o3 = n4;
                  break;
                }
              }
              o3 && ("break" === t5 || "continue" === t5) && o3.tryLoc <= r4 && r4 <= o3.finallyLoc && (o3 = null);
              var a3 = o3 ? o3.completion : {};
              return a3.type = t5, a3.arg = r4, o3 ? (this.method = "next", this.next = o3.finallyLoc, m2) : this.complete(a3);
            }, complete: function(t5, r4) {
              if ("throw" === t5.type) throw t5.arg;
              return "break" === t5.type || "continue" === t5.type ? this.next = t5.arg : "return" === t5.type ? (this.rval = this.arg = t5.arg, this.method = "return", this.next = "end") : "normal" === t5.type && r4 && (this.next = r4), m2;
            }, finish: function(t5) {
              for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
                var e4 = this.tryEntries[r4];
                if (e4.finallyLoc === t5) return this.complete(e4.completion, e4.afterLoc), N2(e4), m2;
              }
            }, catch: function(t5) {
              for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
                var e4 = this.tryEntries[r4];
                if (e4.tryLoc === t5) {
                  var n4 = e4.completion;
                  if ("throw" === n4.type) {
                    var o3 = n4.arg;
                    N2(e4);
                  }
                  return o3;
                }
              }
              throw Error("illegal catch attempt");
            }, delegateYield: function(r4, e4, n4) {
              return this.delegate = { iterator: I2(r4), resultName: e4, nextLoc: n4 }, "next" === this.method && (this.arg = t4), m2;
            } }, n3;
          }
          function n2(t4, r4, e4, n3, o2, i2, a2) {
            try {
              var c2 = t4[i2](a2), u2 = c2.value;
            } catch (t5) {
              return void e4(t5);
            }
            c2.done ? r4(u2) : Promise.resolve(u2).then(n3, o2);
          }
          t3.exports = function() {
            var t4, r4 = (t4 = e3().mark(function t5(r5, n3) {
              return e3().wrap(function(t6) {
                for (; ; ) switch (t6.prev = t6.next) {
                  case 0:
                    r5.postMessage(n3);
                  case 1:
                  case "end":
                    return t6.stop();
                }
              }, t5);
            }), function() {
              var r5 = this, e4 = arguments;
              return new Promise(function(o2, i2) {
                var a2 = t4.apply(r5, e4);
                function c2(t5) {
                  n2(a2, o2, i2, c2, u2, "next", t5);
                }
                function u2(t5) {
                  n2(a2, o2, i2, c2, u2, "throw", t5);
                }
                c2(void 0);
              });
            });
            return function(t5, e4) {
              return r4.apply(this, arguments);
            };
          }();
        }, 423: (t3) => {
          t3.exports = function(t4) {
            var r3, e3 = t4.workerPath, n2 = t4.workerBlobURL;
            if (Blob && URL && n2) {
              var o2 = new Blob(['importScripts("'.concat(e3, '");')], { type: "application/javascript" });
              r3 = new Worker(URL.createObjectURL(o2));
            } else r3 = new Worker(e3);
            return r3;
          };
        }, 399: (t3) => {
          t3.exports = function(t4) {
            t4.terminate();
          };
        }, 330: (t3) => {
          t3.exports = { rE: "6.0.3" };
        } }, r2 = {};
        function e2(n2) {
          var o2 = r2[n2];
          if (void 0 !== o2) return o2.exports;
          var i2 = r2[n2] = { id: n2, loaded: false, exports: {} };
          return t2[n2].call(i2.exports, i2, i2.exports, e2), i2.loaded = true, i2.exports;
        }
        return e2.nmd = (t3) => (t3.paths = [], t3.children || (t3.children = []), t3), e2(954);
      })());
    })(tesseract_min$1);
    tesseract_minExports = tesseract_min$1.exports;
    tesseract_min = /* @__PURE__ */ getDefaultExportFromCjs(tesseract_minExports);
  }
});

// node_modules/regenerator-runtime/runtime.js
var require_runtime = __commonJS({
  "node_modules/regenerator-runtime/runtime.js"(exports2, module) {
    var runtime = function(exports3) {
      "use strict";
      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      };
      var undefined2;
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define2(obj, key, value) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }
      try {
        define2({}, "");
      } catch (err) {
        define2 = function(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []);
        defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context) });
        return generator;
      }
      exports3.wrap = wrap;
      function tryCatch(fn2, obj, arg) {
        try {
          return { type: "normal", arg: fn2.call(obj, arg) };
        } catch (err) {
          return { type: "throw", arg: err };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define2(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        IteratorPrototype = NativeIteratorPrototype;
      }
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
      defineProperty(
        GeneratorFunctionPrototype,
        "constructor",
        { value: GeneratorFunction, configurable: true }
      );
      GeneratorFunction.displayName = define2(
        GeneratorFunctionPrototype,
        toStringTagSymbol,
        "GeneratorFunction"
      );
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define2(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      exports3.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      exports3.mark = function(genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define2(genFun, toStringTagSymbol, "GeneratorFunction");
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };
      exports3.awrap = function(arg) {
        return { __await: arg };
      };
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;
            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve, reject);
              }, function(err) {
                invoke("throw", err, resolve, reject);
              });
            }
            return PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped;
              resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
        }
        var previousPromise;
        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
        }
        defineProperty(this, "_invoke", { value: enqueue });
      }
      defineIteratorMethods(AsyncIterator.prototype);
      define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      });
      exports3.AsyncIterator = AsyncIterator;
      exports3.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0) PromiseImpl = Promise;
        var iter = new AsyncIterator(
          wrap(innerFn, outerFn, self2, tryLocsList),
          PromiseImpl
        );
        return exports3.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self2, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          context.method = method;
          context.arg = arg;
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }
            if (context.method === "next") {
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }
              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self2, context);
            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              if (record.arg === ContinueSentinel) {
                continue;
              }
              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method;
        var method = delegate.iterator[methodName];
        if (method === undefined2) {
          context.delegate = null;
          if (methodName === "throw" && delegate.iterator["return"]) {
            context.method = "return";
            context.arg = undefined2;
            maybeInvokeDelegate(delegate, context);
            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }
          if (methodName !== "return") {
            context.method = "throw";
            context.arg = new TypeError(
              "The iterator does not provide a '" + methodName + "' method"
            );
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }
        var info = record.arg;
        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }
        if (info.done) {
          context[delegate.resultName] = info.value;
          context.next = delegate.nextLoc;
          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined2;
          }
        } else {
          return info;
        }
        context.delegate = null;
        return ContinueSentinel;
      }
      defineIteratorMethods(Gp);
      define2(Gp, toStringTagSymbol, "Generator");
      define2(Gp, iteratorSymbol, function() {
        return this;
      });
      define2(Gp, "toString", function() {
        return "[object Generator]";
      });
      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{ tryLoc: "root" }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      exports3.keys = function(val) {
        var object = Object(val);
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key2 = keys.pop();
            if (key2 in object) {
              next.value = key2;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i2 = -1, next = function next2() {
              while (++i2 < iterable.length) {
                if (hasOwn.call(iterable, i2)) {
                  next2.value = iterable[i2];
                  next2.done = false;
                  return next2;
                }
              }
              next2.value = undefined2;
              next2.done = true;
              return next2;
            };
            return next.next = next;
          }
        }
        return { next: doneResult };
      }
      exports3.values = values;
      function doneResult() {
        return { value: undefined2, done: true };
      }
      Context.prototype = {
        constructor: Context,
        reset: function(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined2;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined2;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined2;
              }
            }
          }
        },
        stop: function() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            if (caught) {
              context.method = "next";
              context.arg = undefined2;
            }
            return !!caught;
          }
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function(type, arg) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }
          return this.complete(record);
        },
        complete: function(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
          return ContinueSentinel;
        },
        finish: function(finallyLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function(tryLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          };
          if (this.method === "next") {
            this.arg = undefined2;
          }
          return ContinueSentinel;
        }
      };
      return exports3;
    }(
      // If this script is executing as a CommonJS module, use module.exports
      // as the regeneratorRuntime namespace. Otherwise create a new empty
      // object. Either way, the resulting object will be used to initialize
      // the regeneratorRuntime variable at the top of this file.
      typeof module === "object" ? module.exports : {}
    );
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@scribe.js/tesseract.js/src/utils/getId.js
var require_getId = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/utils/getId.js"(exports2, module) {
    module.exports = (prefix, cnt) => `${prefix}-${cnt}-${Math.random().toString(16).slice(3, 8)}`;
  }
});

// node_modules/@scribe.js/tesseract.js/src/createJob.js
var require_createJob = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/createJob.js"(exports2, module) {
    var getId = require_getId();
    var jobCounter = 0;
    module.exports = ({
      id: _id,
      action,
      payload = {},
      priorityJob = false
    }) => {
      let id = _id;
      if (typeof id === "undefined") {
        id = getId("Job", jobCounter);
        jobCounter += 1;
      }
      return {
        id,
        action,
        payload,
        priorityJob
      };
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/createScheduler.js
var require_createScheduler = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/createScheduler.js"(exports2, module) {
    var createJob = require_createJob();
    var getId = require_getId();
    var schedulerCounter = 0;
    module.exports = () => {
      const id = getId("Scheduler", schedulerCounter);
      const workers = {};
      const runningWorkers = {};
      let jobQueue = [];
      schedulerCounter += 1;
      const getQueueLen = () => jobQueue.length;
      const getNumWorkers = () => Object.keys(workers).length;
      const dequeue = () => {
        if (jobQueue.length !== 0) {
          const wIds = Object.keys(workers);
          for (let i2 = 0; i2 < wIds.length; i2 += 1) {
            if (typeof runningWorkers[wIds[i2]] === "undefined") {
              jobQueue[0](workers[wIds[i2]]);
              break;
            }
          }
        }
      };
      const queue = (action, payload, priorityJob = false) => new Promise((resolve, reject) => {
        const job = createJob({ action, payload, priorityJob });
        const jobFunction = async (w2) => {
          jobQueue.shift();
          runningWorkers[w2.id] = job;
          try {
            const res1 = await w2[action].apply(exports2, [payload, job.id]);
            resolve(res1);
            if (Array.isArray(res1)) await Promise.allSettled(res1);
          } catch (err) {
            reject(err);
          } finally {
            delete runningWorkers[w2.id];
            dequeue();
          }
        };
        jobFunction.priorityJob = priorityJob;
        if (priorityJob) {
          let insertIndex = 0;
          for (let i2 = 0; i2 < jobQueue.length; i2 += 1) {
            if (!jobQueue[i2].priorityJob) {
              insertIndex = i2;
              break;
            }
            insertIndex = i2 + 1;
          }
          jobQueue.splice(insertIndex, 0, jobFunction);
        } else {
          jobQueue.push(jobFunction);
        }
        dequeue();
      });
      const addWorker = (w2) => {
        workers[w2.id] = w2;
        dequeue();
        return w2.id;
      };
      const addJob = async (action, payload, priorityJob = false) => {
        if (getNumWorkers() === 0) {
          throw Error(`[${id}]: You need to have at least one worker before adding jobs`);
        }
        return queue(action, payload, priorityJob);
      };
      const terminate = async () => {
        Object.keys(workers).forEach(async (wid) => {
          await workers[wid].terminate();
        });
        jobQueue = [];
      };
      return {
        addWorker,
        addJob,
        terminate,
        getQueueLen,
        getNumWorkers
      };
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/utils/getEnvironment.js
var require_getEnvironment = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/utils/getEnvironment.js"(exports2, module) {
    module.exports = (key) => {
      const env = {};
      if (typeof WorkerGlobalScope !== "undefined") {
        env.type = "webworker";
      } else if (typeof document === "object") {
        env.type = "browser";
      } else if (typeof process === "object" && typeof __require === "function") {
        env.type = "node";
      }
      if (typeof key === "undefined") {
        return env;
      }
      return env[key];
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/utils/resolvePaths.js
var require_resolvePaths = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/utils/resolvePaths.js"(exports2, module) {
    var isBrowser = require_getEnvironment()("type") === "browser";
    var resolveURL = isBrowser ? (s2) => new URL(s2, window.location.href).href : (s2) => s2;
    module.exports = (options) => {
      const opts = { ...options };
      ["corePath", "workerPath", "langPath"].forEach((key) => {
        if (options[key]) {
          opts[key] = resolveURL(opts[key]);
        }
      });
      return opts;
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/utils/circularize.js
var require_circularize = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/utils/circularize.js"(exports2, module) {
    module.exports = (page) => {
      const blocks = [];
      const paragraphs = [];
      const lines = [];
      const words = [];
      const symbols = [];
      if (page.blocks) {
        page.blocks.forEach((block) => {
          block.paragraphs.forEach((paragraph) => {
            paragraph.lines.forEach((line) => {
              line.words.forEach((word) => {
                word.symbols.forEach((sym) => {
                  symbols.push({
                    ...sym,
                    page,
                    block,
                    paragraph,
                    line,
                    word
                  });
                });
                words.push({
                  ...word,
                  page,
                  block,
                  paragraph,
                  line
                });
              });
              lines.push({
                ...line,
                page,
                block,
                paragraph
              });
            });
            paragraphs.push({
              ...paragraph,
              page,
              block
            });
          });
          blocks.push({
            ...block,
            page
          });
        });
      }
      return {
        ...page,
        blocks,
        paragraphs,
        lines,
        words,
        symbols
      };
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/utils/log.js
var require_log = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/utils/log.js"(exports2) {
    var logging = false;
    exports2.logging = logging;
    exports2.setLogging = (_logging) => {
      logging = _logging;
    };
    exports2.log = (...args) => logging ? console.log.apply(exports2, args) : null;
  }
});

// node_modules/@scribe.js/tesseract.js/src/constants/OEM.js
var require_OEM = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/constants/OEM.js"(exports2, module) {
    module.exports = {
      TESSERACT_ONLY: 0,
      LSTM_ONLY: 1,
      TESSERACT_LSTM_COMBINED: 2,
      DEFAULT: 3
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/constants/defaultOptions.js
var require_defaultOptions = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/constants/defaultOptions.js"(exports2, module) {
    module.exports = {
      /*
       * Use BlobURL for worker script by default
       * TODO: remove this option
       *
       */
      workerBlobURL: true,
      logger: () => {
      }
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/worker/node/defaultOptions.js
var require_defaultOptions2 = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/worker/node/defaultOptions.js"(exports2, module) {
    var path = __require("path");
    var defaultOptions = require_defaultOptions();
    module.exports = {
      ...defaultOptions,
      workerPath: path.join(__dirname, "tesseract-worker.js")
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/worker/node/spawnWorker.js
var require_spawnWorker = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/worker/node/spawnWorker.js"(exports2, module) {
    var { Worker: Worker2 } = __require("worker_threads");
    module.exports = ({ workerPath: workerPath2 }) => new Worker2(workerPath2);
  }
});

// node_modules/@scribe.js/tesseract.js/src/worker/node/terminateWorker.js
var require_terminateWorker = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/worker/node/terminateWorker.js"(exports2, module) {
    module.exports = (worker2) => {
      worker2.terminate();
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/worker/node/onMessage.js
var require_onMessage = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/worker/node/onMessage.js"(exports2, module) {
    module.exports = (worker2, handler) => {
      worker2.on("message", handler);
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/worker/node/send.js
var require_send = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/worker/node/send.js"(exports2, module) {
    module.exports = async (worker2, packet) => {
      worker2.postMessage(packet);
    };
  }
});

// node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS({
  "node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js"(exports2, module) {
    "use strict";
    var conversions = {};
    module.exports = conversions;
    function sign(x2) {
      return x2 < 0 ? -1 : 1;
    }
    function evenRound(x2) {
      if (x2 % 1 === 0.5 && (x2 & 1) === 0) {
        return Math.floor(x2);
      } else {
        return Math.round(x2);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V2, opts) {
        if (!opts) opts = {};
        let x2 = +V2;
        if (opts.enforceRange) {
          if (!Number.isFinite(x2)) {
            throw new TypeError("Argument is not a finite number");
          }
          x2 = sign(x2) * Math.floor(Math.abs(x2));
          if (x2 < lowerBound || x2 > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x2;
        }
        if (!isNaN(x2) && opts.clamp) {
          x2 = evenRound(x2);
          if (x2 < lowerBound) x2 = lowerBound;
          if (x2 > upperBound) x2 = upperBound;
          return x2;
        }
        if (!Number.isFinite(x2) || x2 === 0) {
          return 0;
        }
        x2 = sign(x2) * Math.floor(Math.abs(x2));
        x2 = x2 % moduloVal;
        if (!typeOpts.unsigned && x2 >= moduloBound) {
          return x2 - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x2 < 0) {
            x2 += moduloVal;
          } else if (x2 === -0) {
            return 0;
          }
        }
        return x2;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V2) {
      const x2 = +V2;
      if (!Number.isFinite(x2)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x2;
    };
    conversions["unrestricted double"] = function(V2) {
      const x2 = +V2;
      if (isNaN(x2)) {
        throw new TypeError("Argument is NaN");
      }
      return x2;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V2, opts) {
      if (!opts) opts = {};
      if (opts.treatNullAsEmptyString && V2 === null) {
        return "";
      }
      return String(V2);
    };
    conversions["ByteString"] = function(V2, opts) {
      const x2 = String(V2);
      let c2 = void 0;
      for (let i2 = 0; (c2 = x2.codePointAt(i2)) !== void 0; ++i2) {
        if (c2 > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x2;
    };
    conversions["USVString"] = function(V2) {
      const S2 = String(V2);
      const n2 = S2.length;
      const U2 = [];
      for (let i2 = 0; i2 < n2; ++i2) {
        const c2 = S2.charCodeAt(i2);
        if (c2 < 55296 || c2 > 57343) {
          U2.push(String.fromCodePoint(c2));
        } else if (56320 <= c2 && c2 <= 57343) {
          U2.push(String.fromCodePoint(65533));
        } else {
          if (i2 === n2 - 1) {
            U2.push(String.fromCodePoint(65533));
          } else {
            const d2 = S2.charCodeAt(i2 + 1);
            if (56320 <= d2 && d2 <= 57343) {
              const a2 = c2 & 1023;
              const b2 = d2 & 1023;
              U2.push(String.fromCodePoint((2 << 15) + (2 << 9) * a2 + b2));
              ++i2;
            } else {
              U2.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U2.join("");
    };
    conversions["Date"] = function(V2, opts) {
      if (!(V2 instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V2)) {
        return void 0;
      }
      return V2;
    };
    conversions["RegExp"] = function(V2, opts) {
      if (!(V2 instanceof RegExp)) {
        V2 = new RegExp(V2);
      }
      return V2;
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js
var require_utils = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js"(exports2, module) {
    "use strict";
    module.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i2 = 0; i2 < keys.length; ++i2) {
        Object.defineProperty(target, keys[i2], Object.getOwnPropertyDescriptor(source, keys[i2]));
      }
    };
    module.exports.wrapperSymbol = Symbol("wrapper");
    module.exports.implSymbol = Symbol("impl");
    module.exports.wrapperForImpl = function(impl) {
      return impl[module.exports.wrapperSymbol];
    };
    module.exports.implForWrapper = function(wrapper) {
      return wrapper[module.exports.implSymbol];
    };
  }
});

// node_modules/node-fetch/node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/node-fetch/node_modules/tr46/lib/mappingTable.json"(exports2, module) {
    module.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// node_modules/node-fetch/node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/node-fetch/node_modules/tr46/index.js"(exports2, module) {
    "use strict";
    var punycode = __require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s2) {
        return s2.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i2 = 0; i2 < len; ++i2) {
        var codePoint = domain_name.codePointAt(i2);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i2 = 0; i2 < len; ++i2) {
        var status = findStatus(label.codePointAt(i2));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error = true;
          break;
        }
      }
      return {
        label,
        error
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i2 = 0; i2 < labels.length; ++i2) {
        try {
          var validation = validateLabel(labels[i2]);
          labels[i2] = validation.label;
          result.error = result.error || validation.error;
        } catch (e2) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l2) {
        try {
          return punycode.toASCII(l2);
        } catch (e2) {
          result.error = true;
          return l2;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i2 = 0; i2 < labels.length; ++i2) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error) return null;
      return labels.join(".");
    };
    module.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js"(exports2, module) {
    "use strict";
    var punycode = __require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at2(input, idx) {
      const c2 = input[idx];
      return isNaN(c2) ? void 0 : String.fromCodePoint(c2);
    }
    function isASCIIDigit(c2) {
      return c2 >= 48 && c2 <= 57;
    }
    function isASCIIAlpha(c2) {
      return c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122;
    }
    function isASCIIAlphanumeric(c2) {
      return isASCIIAlpha(c2) || isASCIIDigit(c2);
    }
    function isASCIIHex(c2) {
      return isASCIIDigit(c2) || c2 >= 65 && c2 <= 70 || c2 >= 97 && c2 <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c2) {
      let hex = c2.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c2) {
      const buf = new Buffer(c2);
      let str = "";
      for (let i2 = 0; i2 < buf.length; ++i2) {
        str += percentEncode(buf[i2]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i2 = 0; i2 < input.length; ++i2) {
        if (input[i2] !== 37) {
          output.push(input[i2]);
        } else if (input[i2] === 37 && isASCIIHex(input[i2 + 1]) && isASCIIHex(input[i2 + 2])) {
          output.push(parseInt(input.slice(i2 + 1, i2 + 3).toString(), 16));
          i2 += 2;
        } else {
          output.push(input[i2]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c2) {
      return c2 <= 31 || c2 > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c2) {
      return isC0ControlPercentEncode(c2) || extraPathPercentEncodeSet.has(c2);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c2) {
      return isPathPercentEncode(c2) || extraUserinfoPercentEncodeSet.has(c2);
    }
    function percentEncodeChar(c2, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c2);
      if (encodeSetPredicate(c2)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R2 = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R2 = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R2 = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R2 === 10 ? /[^0-9]/ : R2 === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R2);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n2 = parseIPv4Number(part);
        if (n2 === failure) {
          return input;
        }
        numbers.push(n2);
      }
      for (let i2 = 0; i2 < numbers.length - 1; ++i2) {
        if (numbers[i2] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n2 of numbers) {
        ipv4 += n2 * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n2 = address;
      for (let i2 = 1; i2 <= 4; ++i2) {
        output = String(n2 % 256) + output;
        if (i2 !== 4) {
          output = "." + output;
        }
        n2 = Math.floor(n2 / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at2(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at2(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        output += percentEncodeChar(decoded[i2], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i2 = 0; i2 < arr.length; ++i2) {
        if (arr[i2] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i2;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path = url.path;
      if (path.length === 0) {
        return;
      }
      if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
        return;
      }
      path.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c2 = this.input[this.pointer];
        const cStr = isNaN(c2) ? void 0 : String.fromCodePoint(c2);
        const ret = this["parse " + this.state](c2, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c2, cStr) {
      if (isASCIIAlpha(c2)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c2, cStr) {
      if (isASCIIAlphanumeric(c2) || c2 === 43 || c2 === 45 || c2 === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c2 === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c2) {
      if (this.base === null || this.base.cannotBeABaseURL && c2 !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c2 === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c2) {
      if (c2 === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c2) {
      if (c2 === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c2) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c2)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c2 === 47) {
        this.state = "relative slash";
      } else if (c2 === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c2 === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c2 === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c2) {
      if (isSpecial(this.url) && (c2 === 47 || c2 === 92)) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c2 === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c2) {
      if (c2 === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c2) {
      if (c2 !== 47 && c2 !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c2, cStr) {
      if (c2 === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c2) || c2 === 47 || c2 === 63 || c2 === 35 || isSpecial(this.url) && c2 === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c2, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c2 === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c2) || c2 === 47 || c2 === 63 || c2 === 35 || isSpecial(this.url) && c2 === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c2 === 91) {
          this.arrFlag = true;
        } else if (c2 === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c2, cStr) {
      if (isASCIIDigit(c2)) {
        this.buffer += cStr;
      } else if (isNaN(c2) || c2 === 47 || c2 === 63 || c2 === 35 || isSpecial(this.url) && c2 === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c2) {
      this.url.scheme = "file";
      if (c2 === 47 || c2 === 92) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c2)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c2 === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c2 === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c2, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c2) {
      if (c2 === 47 || c2 === 92) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c2, cStr) {
      if (isNaN(c2) || c2 === 47 || c2 === 92 || c2 === 63 || c2 === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c2) {
      if (isSpecial(this.url)) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c2 !== 47 && c2 !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c2 === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c2 === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c2 !== void 0) {
        this.state = "path";
        if (c2 !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c2) {
      if (isNaN(c2) || c2 === 47 || isSpecial(this.url) && c2 === 92 || !this.stateOverride && (c2 === 63 || c2 === 35)) {
        if (isSpecial(this.url) && c2 === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c2 !== 47 && !(isSpecial(this.url) && c2 === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c2 !== 47 && !(isSpecial(this.url) && c2 === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c2 === void 0 || c2 === 63 || c2 === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c2 === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c2 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c2, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c2) {
      if (c2 === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c2 === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c2) && c2 !== 37) {
          this.parseError = true;
        }
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c2)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c2, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c2, cStr) {
      if (isNaN(c2) || !this.stateOverride && c2 === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i2 = 0; i2 < buffer.length; ++i2) {
          if (buffer[i2] < 33 || buffer[i2] > 126 || buffer[i2] === 34 || buffer[i2] === 35 || buffer[i2] === 60 || buffer[i2] === 62) {
            this.url.query += percentEncode(buffer[i2]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i2]);
          }
        }
        this.buffer = "";
        if (c2 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c2) {
      if (isNaN(c2)) {
      } else if (c2 === 0) {
        this.parseError = true;
      } else {
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c2, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string of url.path) {
          output += "/" + string;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module.exports.serializeURL = serializeURL;
    module.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
          } catch (e2) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        url.username += percentEncodeChar(decoded[i2], isUserinfoPercentEncode);
      }
    };
    module.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        url.password += percentEncodeChar(decoded[i2], isUserinfoPercentEncode);
      }
    };
    module.exports.serializeHost = serializeHost;
    module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js"(exports2) {
    "use strict";
    var usm = require_url_state_machine();
    exports2.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v2) {
        const parsedURL = usm.basicURLParse(v2);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v2) {
        usm.basicURLParse(v2 + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v2);
      }
      get password() {
        return this._url.password;
      }
      set password(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v2);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v2) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v2, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v2) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v2, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v2 === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v2, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v2) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v2, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v2) {
        const url = this._url;
        if (v2 === "") {
          url.query = null;
          return;
        }
        const input = v2[0] === "?" ? v2.substring(1) : v2;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v2) {
        if (v2 === "") {
          this._url.fragment = null;
          return;
        }
        const input = v2[0] === "#" ? v2.substring(1) : v2;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js"(exports2, module) {
    "use strict";
    var conversions = require_lib();
    var utils = require_utils();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL2(url) {
      if (!this || this[impl] || !(this instanceof URL2)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i2 = 0; i2 < arguments.length && i2 < 2; ++i2) {
        args[i2] = arguments[i2];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module.exports.setup(this, args);
    }
    URL2.prototype.toJSON = function toJSON() {
      if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i2 = 0; i2 < arguments.length && i2 < 0; ++i2) {
        args[i2] = arguments[i2];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL2.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].href = V2;
      },
      enumerable: true,
      configurable: true
    });
    URL2.prototype.toString = function() {
      if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL2.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].protocol = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].username = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].password = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].host = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].hostname = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].port = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].pathname = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].search = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].hash = V2;
      },
      enumerable: true,
      configurable: true
    });
    module.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL2.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData) privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL2,
      expose: {
        Window: { URL: URL2 },
        Worker: { URL: URL2 }
      }
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js"(exports2) {
    "use strict";
    exports2.URL = require_URL().interface;
    exports2.serializeURL = require_url_state_machine().serializeURL;
    exports2.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports2.basicURLParse = require_url_state_machine().basicURLParse;
    exports2.setTheUsername = require_url_state_machine().setTheUsername;
    exports2.setThePassword = require_url_state_machine().setThePassword;
    exports2.serializeHost = require_url_state_machine().serializeHost;
    exports2.serializeInteger = require_url_state_machine().serializeInteger;
    exports2.parseURL = require_url_state_machine().parseURL;
  }
});

// node_modules/node-fetch/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/node-fetch/lib/index.js"(exports2, module) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream = _interopDefault(__require("stream"));
    var http = _interopDefault(__require("http"));
    var Url = _interopDefault(__require("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https = _interopDefault(__require("https"));
    var zlib = _interopDefault(__require("zlib"));
    var Readable = Stream.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob2 = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a2 = blobParts;
          const length = Number(a2.length);
          for (let i2 = 0; i2 < length; i2++) {
            const element = a2[i2];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new _Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob2.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = __require("encoding").convert;
    } catch (e2) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough = Stream.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob(body)) ;
      else if (Buffer.isBuffer(body)) ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream) ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream) {
        body.on("error", function(err) {
          const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS].error = error;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct2 = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob2([], {
              type: ct2.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
      }
      if (!(body instanceof Stream)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function(resolve, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct2 = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct2) {
        res = /charset=([^;]*)/i.exec(ct2);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name) {
      name = name.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof _Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null) ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i2 = 0;
        while (i2 < pairs.length) {
          var _pairs$i = pairs[i2];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i2++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(kind === "key" ? function(k2) {
        return k2.toLowerCase();
      } : kind === "value" ? function(k2) {
        return headers[MAP][k2].join(", ");
      } : function(k2) {
        return [k2.toLowerCase(), headers[MAP][k2].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers();
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = http.STATUS_CODES;
    var Response = class _Response {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var URL2 = Url.URL || whatwgUrl.URL;
    var parse_url = Url.parse;
    var format_url = Url.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL2(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request = class _Request {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init) signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var URL$1 = Url.URL || whatwgUrl.URL;
    var PassThrough$1 = Stream.PassThrough;
    var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    var isSameProtocol = function isSameProtocol2(destination, original) {
      const orig = new URL$1(original).protocol;
      const dest = new URL$1(destination).protocol;
      return orig === dest;
    };
    function fetch2(url, opts) {
      if (!fetch2.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body.Promise = fetch2.Promise;
      return new fetch2.Promise(function(resolve, reject) {
        const request = new Request(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === "https:" ? https : http).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error = new AbortError("The user aborted a request.");
          reject(error);
          if (request.body && request.body instanceof Stream.Readable) {
            destroyStream(request.body, error);
          }
          if (!response || !response.body) return;
          response.body.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal) signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          if (response && response.body) {
            destroyStream(response.body, err);
          }
          finalize();
        });
        fixResponseChunkedTransferBadEnding(req, function(err) {
          if (signal && signal.aborted) {
            return;
          }
          if (response && response.body) {
            destroyStream(response.body, err);
          }
        });
        if (parseInt(process.version.substring(1)) < 14) {
          req.on("socket", function(s2) {
            s2.addListener("close", function(hadError) {
              const hasDataListener = s2.listenerCount("data") > 0;
              if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                const err = new Error("Premature close");
                err.code = "ERR_STREAM_PREMATURE_CLOSE";
                response.body.emit("error", err);
              }
            });
          });
        }
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch2.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location === null ? null : new URL$1(location, request.url).toString();
            } catch (err) {
              if (request.redirect !== "manual") {
                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                  for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOpts.headers.delete(name);
                  }
                }
                if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve(fetch2(new Request(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal) signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          const zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib.createGunzip(zlibOptions));
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib.createInflate());
              } else {
                body = body.pipe(zlib.createInflateRaw());
              }
              response = new Response(body, response_options);
              resolve(response);
            });
            raw.on("end", function() {
              if (!response) {
                response = new Response(body, response_options);
                resolve(response);
              }
            });
            return;
          }
          if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
            body = body.pipe(zlib.createBrotliDecompress());
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          response = new Response(body, response_options);
          resolve(response);
        });
        writeToStream(req, request);
      });
    }
    function fixResponseChunkedTransferBadEnding(request, errorCallback) {
      let socket;
      request.on("socket", function(s2) {
        socket = s2;
      });
      request.on("response", function(response) {
        const headers = response.headers;
        if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
          response.once("close", function(hadError) {
            const hasDataListener = socket && socket.listenerCount("data") > 0;
            if (hasDataListener && !hadError) {
              const err = new Error("Premature close");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              errorCallback(err);
            }
          });
        }
      });
    }
    function destroyStream(stream, err) {
      if (stream.destroy) {
        stream.destroy(err);
      } else {
        stream.emit("error", err);
        stream.end();
      }
    }
    fetch2.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch2.Promise = global.Promise;
    module.exports = exports2 = fetch2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = exports2;
    exports2.Headers = Headers;
    exports2.Request = Request;
    exports2.Response = Response;
    exports2.FetchError = FetchError;
    exports2.AbortError = AbortError;
  }
});

// node_modules/is-url/index.js
var require_is_url = __commonJS({
  "node_modules/is-url/index.js"(exports2, module) {
    module.exports = isUrl;
    var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;
    var localhostDomainRE = /^localhost[\:?\d]*(?:[^\:?\d]\S*)?$/;
    var nonLocalhostDomainRE = /^[^\s\.]+\.\S{2,}$/;
    function isUrl(string) {
      if (typeof string !== "string") {
        return false;
      }
      var match = string.match(protocolAndDomainRE);
      if (!match) {
        return false;
      }
      var everythingAfterProtocol = match[1];
      if (!everythingAfterProtocol) {
        return false;
      }
      if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {
        return true;
      }
      return false;
    }
  }
});

// node_modules/@scribe.js/tesseract.js/src/worker/node/loadImage.js
var require_loadImage = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/worker/node/loadImage.js"(exports2, module) {
    var util = __require("util");
    var fs = __require("fs");
    var fetch2 = global.fetch || require_lib2();
    var isURL = require_is_url();
    var readFile = util.promisify(fs.readFile);
    module.exports = async (image) => {
      let data = image;
      if (typeof image === "undefined") {
        return image;
      }
      if (typeof image === "string") {
        if (isURL(image) || image.startsWith("moz-extension://") || image.startsWith("chrome-extension://") || image.startsWith("file://")) {
          const resp = await fetch2(image);
          data = await resp.arrayBuffer();
        } else if (/data:image\/([a-zA-Z]*);base64,([^"]*)/.test(image)) {
          data = Buffer.from(image.split(",")[1], "base64");
        } else {
          data = await readFile(image);
        }
      } else if (Buffer.isBuffer(image)) {
        data = image;
      }
      return new Uint8Array(data);
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/worker/node/index.js
var require_node = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/worker/node/index.js"(exports2, module) {
    var defaultOptions = require_defaultOptions2();
    var spawnWorker = require_spawnWorker();
    var terminateWorker = require_terminateWorker();
    var onMessage = require_onMessage();
    var send = require_send();
    var loadImage = require_loadImage();
    module.exports = {
      defaultOptions,
      spawnWorker,
      terminateWorker,
      onMessage,
      send,
      loadImage
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/createWorker.js
var require_createWorker = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/createWorker.js"(exports2, module) {
    var resolvePaths = require_resolvePaths();
    var circularize = require_circularize();
    var createJob = require_createJob();
    var { log } = require_log();
    var getId = require_getId();
    var OEM = require_OEM();
    var {
      defaultOptions,
      spawnWorker,
      terminateWorker,
      onMessage,
      loadImage,
      send
    } = require_node();
    var workerCounter = 0;
    module.exports = async (langs = "eng", oem = OEM.LSTM_ONLY, _options = {}, config = {}) => {
      const id = getId("Worker", workerCounter);
      const {
        logger,
        errorHandler,
        ...options
      } = resolvePaths({
        ...defaultOptions,
        ..._options
      });
      const promises = {};
      const currentLangs = typeof langs === "string" ? langs.split("+") : langs;
      let currentOem = oem;
      let currentConfig = config;
      const lstmOnlyCore = [OEM.DEFAULT, OEM.LSTM_ONLY].includes(oem) && !options.legacyCore;
      let workerResReject;
      let workerResResolve;
      const workerRes = new Promise((resolve, reject) => {
        workerResResolve = resolve;
        workerResReject = reject;
      });
      const workerError = (event) => {
        workerResReject(event.message);
      };
      let worker2 = spawnWorker(options);
      worker2.onerror = workerError;
      workerCounter += 1;
      const startJob = ({ id: jobId, action, payload }) => new Promise((resolve, reject) => {
        log(`[${id}]: Start ${jobId}, action=${action}`);
        const promiseId = `${action}-${jobId}`;
        promises[promiseId] = { resolve, reject };
        send(worker2, {
          workerId: id,
          jobId,
          action,
          payload
        });
      });
      const startJob2 = ({ id: jobId, action, payload }) => {
        const promiseB = new Promise((resolve, reject) => {
          log(`[${id}]: Start ${jobId}, action=${action}`);
          const promiseId = `${action}-${jobId}b`;
          promises[promiseId] = { resolve, reject };
        });
        const promiseA = new Promise((resolve, reject) => {
          log(`[${id}]: Start ${jobId}, action=${action}`);
          const promiseId = `${action}-${jobId}`;
          promises[promiseId] = { resolve, reject };
          send(worker2, {
            workerId: id,
            jobId,
            action,
            payload
          });
        });
        return [promiseA, promiseB];
      };
      const load = () => console.warn("`load` is depreciated and should be removed from code (workers now come pre-loaded)");
      const loadInternal = (jobId) => startJob(createJob({
        id: jobId,
        action: "load",
        payload: { options: { lstmOnly: lstmOnlyCore, corePath: options.corePath, logging: options.logging } }
      }));
      const writeText = (path, text, jobId) => startJob(createJob({
        id: jobId,
        action: "FS",
        payload: { method: "writeFile", args: [path, text] }
      }));
      const readText = (path, jobId) => startJob(createJob({
        id: jobId,
        action: "FS",
        payload: { method: "readFile", args: [path, { encoding: "utf8" }] }
      }));
      const removeFile = (path, jobId) => startJob(createJob({
        id: jobId,
        action: "FS",
        payload: { method: "unlink", args: [path] }
      }));
      const FS = (method, args, jobId) => startJob(createJob({
        id: jobId,
        action: "FS",
        payload: { method, args }
      }));
      const loadLanguage = () => console.warn("`loadLanguage` is depreciated and should be removed from code (workers now come with language pre-loaded)");
      const loadLanguageInternal = (_langs, jobId) => startJob(createJob({
        id: jobId,
        action: "loadLanguage",
        payload: {
          langs: _langs,
          options: {
            langPath: options.langPath,
            dataPath: options.dataPath,
            cachePath: options.cachePath,
            cacheMethod: options.cacheMethod,
            gzip: options.gzip,
            lstmOnly: [OEM.LSTM_ONLY, OEM.TESSERACT_LSTM_COMBINED].includes(currentOem) && !options.legacyLang
          }
        }
      }));
      const initialize = () => console.warn("`initialize` is depreciated and should be removed from code (workers now come pre-initialized)");
      const initializeInternal = (_langs, _oem, _config, jobId) => startJob(createJob({
        id: jobId,
        action: "initialize",
        payload: { langs: _langs, oem: _oem, config: _config }
      }));
      const reinitialize3 = (langs2 = "eng", oem2, config2, jobId) => {
        if (lstmOnlyCore && [OEM.TESSERACT_ONLY, OEM.TESSERACT_LSTM_COMBINED].includes(oem2)) throw Error("Legacy model requested but code missing.");
        const _oem = oem2 || currentOem;
        currentOem = _oem;
        const _config = config2 || currentConfig;
        currentConfig = _config;
        const langsArr = typeof langs2 === "string" ? langs2.split("+") : langs2;
        const _langs = langsArr.filter((x2) => !currentLangs.includes(x2));
        currentLangs.push(..._langs);
        if (_langs.length > 0) {
          return loadLanguageInternal(_langs, jobId).then(() => initializeInternal(langs2, _oem, _config, jobId));
        }
        return initializeInternal(langs2, _oem, _config, jobId);
      };
      const setParameters = (params = {}, jobId) => startJob(createJob({
        id: jobId,
        action: "setParameters",
        payload: { params }
      }));
      const recognize2 = async (image, opts = {}, output = {
        blocks: true,
        text: true,
        hocr: true,
        tsv: true
      }, jobId) => startJob(createJob({
        id: jobId,
        action: "recognize",
        payload: { image: await loadImage(image), options: opts, output }
      }));
      const recognize22 = async (image, opts = {}, output = {
        blocks: true,
        text: true,
        hocr: true,
        tsv: true
      }, jobId) => startJob2(createJob({
        id: jobId,
        action: "recognize2",
        payload: { image: await loadImage(image), options: opts, output }
      }));
      const getPDF = (title = "Tesseract OCR Result", textonly = false, jobId) => {
        console.log("`getPDF` function is depreciated. `recognize` option `savePDF` should be used instead.");
        return startJob(createJob({
          id: jobId,
          action: "getPDF",
          payload: { title, textonly }
        }));
      };
      const detect = async (image, jobId) => {
        if (lstmOnlyCore) throw Error("`worker.detect` requires Legacy model, which was not loaded.");
        return startJob(createJob({
          id: jobId,
          action: "detect",
          payload: { image: await loadImage(image) }
        }));
      };
      const terminate = async () => {
        if (worker2 !== null) {
          terminateWorker(worker2);
          worker2 = null;
        }
        return Promise.resolve();
      };
      onMessage(worker2, ({
        workerId,
        jobId,
        status,
        action,
        data
      }) => {
        const promiseId = `${action}-${jobId}`;
        if (status === "resolve") {
          log(`[${workerId}]: Complete ${jobId}`);
          let d2 = data;
          if (action === "recognize") {
            d2 = circularize(data);
          } else if (action === "getPDF") {
            d2 = Array.from({ ...data, length: Object.keys(data).length });
          }
          promises[promiseId].resolve({ jobId, data: d2 });
          delete promises[promiseId];
        } else if (status === "reject") {
          promises[promiseId].reject(data);
          delete promises[promiseId];
          if (action === "load") workerResReject(data);
          if (errorHandler) {
            errorHandler(data);
          } else {
            throw Error(data);
          }
        } else if (status === "progress") {
          logger({ ...data, userJobId: jobId });
        }
      });
      const resolveObj = {
        id,
        worker: worker2,
        load,
        writeText,
        readText,
        removeFile,
        FS,
        loadLanguage,
        initialize,
        reinitialize: reinitialize3,
        setParameters,
        recognize: recognize2,
        recognize2: recognize22,
        getPDF,
        detect,
        terminate
      };
      loadInternal().then(() => loadLanguageInternal(langs)).then(() => initializeInternal(langs, oem, config)).then(() => workerResResolve(resolveObj)).catch(() => {
      });
      return workerRes;
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/Tesseract.js
var require_Tesseract = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/Tesseract.js"(exports2, module) {
    var createWorker = require_createWorker();
    var recognize2 = async (image, langs, options) => {
      const worker2 = await createWorker(langs, 1, options);
      return worker2.recognize(image).finally(async () => {
        await worker2.terminate();
      });
    };
    var detect = async (image, options) => {
      const worker2 = await createWorker("osd", 0, options);
      return worker2.detect(image).finally(async () => {
        await worker2.terminate();
      });
    };
    module.exports = {
      recognize: recognize2,
      detect
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/constants/languages.js
var require_languages = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/constants/languages.js"(exports2, module) {
    module.exports = {
      AFR: "afr",
      AMH: "amh",
      ARA: "ara",
      ASM: "asm",
      AZE: "aze",
      AZE_CYRL: "aze_cyrl",
      BEL: "bel",
      BEN: "ben",
      BOD: "bod",
      BOS: "bos",
      BUL: "bul",
      CAT: "cat",
      CEB: "ceb",
      CES: "ces",
      CHI_SIM: "chi_sim",
      CHI_TRA: "chi_tra",
      CHR: "chr",
      CYM: "cym",
      DAN: "dan",
      DEU: "deu",
      DZO: "dzo",
      ELL: "ell",
      ENG: "eng",
      ENM: "enm",
      EPO: "epo",
      EST: "est",
      EUS: "eus",
      FAS: "fas",
      FIN: "fin",
      FRA: "fra",
      FRK: "frk",
      FRM: "frm",
      GLE: "gle",
      GLG: "glg",
      GRC: "grc",
      GUJ: "guj",
      HAT: "hat",
      HEB: "heb",
      HIN: "hin",
      HRV: "hrv",
      HUN: "hun",
      IKU: "iku",
      IND: "ind",
      ISL: "isl",
      ITA: "ita",
      ITA_OLD: "ita_old",
      JAV: "jav",
      JPN: "jpn",
      KAN: "kan",
      KAT: "kat",
      KAT_OLD: "kat_old",
      KAZ: "kaz",
      KHM: "khm",
      KIR: "kir",
      KOR: "kor",
      KUR: "kur",
      LAO: "lao",
      LAT: "lat",
      LAV: "lav",
      LIT: "lit",
      MAL: "mal",
      MAR: "mar",
      MKD: "mkd",
      MLT: "mlt",
      MSA: "msa",
      MYA: "mya",
      NEP: "nep",
      NLD: "nld",
      NOR: "nor",
      ORI: "ori",
      PAN: "pan",
      POL: "pol",
      POR: "por",
      PUS: "pus",
      RON: "ron",
      RUS: "rus",
      SAN: "san",
      SIN: "sin",
      SLK: "slk",
      SLV: "slv",
      SPA: "spa",
      SPA_OLD: "spa_old",
      SQI: "sqi",
      SRP: "srp",
      SRP_LATN: "srp_latn",
      SWA: "swa",
      SWE: "swe",
      SYR: "syr",
      TAM: "tam",
      TEL: "tel",
      TGK: "tgk",
      TGL: "tgl",
      THA: "tha",
      TIR: "tir",
      TUR: "tur",
      UIG: "uig",
      UKR: "ukr",
      URD: "urd",
      UZB: "uzb",
      UZB_CYRL: "uzb_cyrl",
      VIE: "vie",
      YID: "yid"
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/constants/PSM.js
var require_PSM = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/constants/PSM.js"(exports2, module) {
    module.exports = {
      OSD_ONLY: "0",
      AUTO_OSD: "1",
      AUTO_ONLY: "2",
      AUTO: "3",
      SINGLE_COLUMN: "4",
      SINGLE_BLOCK_VERT_TEXT: "5",
      SINGLE_BLOCK: "6",
      SINGLE_LINE: "7",
      SINGLE_WORD: "8",
      CIRCLE_WORD: "9",
      SINGLE_CHAR: "10",
      SPARSE_TEXT: "11",
      SPARSE_TEXT_OSD: "12",
      RAW_LINE: "13"
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/index.js
var require_src = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/index.js"(exports2, module) {
    require_runtime();
    var createScheduler = require_createScheduler();
    var createWorker = require_createWorker();
    var Tesseract2 = require_Tesseract();
    var languages = require_languages();
    var OEM = require_OEM();
    var PSM = require_PSM();
    var { setLogging } = require_log();
    module.exports = {
      languages,
      OEM,
      PSM,
      createScheduler,
      createWorker,
      setLogging,
      ...Tesseract2
    };
  }
});

// node_modules/scribe.js-ocr/js/utils/miscUtils.js
var ascCharArr = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "b",
  "d",
  "h",
  "k",
  "l",
  "t",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9"
];
var xCharArr = ["a", "c", "e", "m", "n", "o", "r", "s", "u", "v", "w", "x", "z"];
var descCharArr = ["g", "j", "p", "q", "y"];
var calcBboxUnion = (bboxArr) => ({
  left: Math.min(...bboxArr.map((x2) => x2.left)),
  top: Math.min(...bboxArr.map((x2) => x2.top)),
  right: Math.max(...bboxArr.map((x2) => x2.right)),
  bottom: Math.max(...bboxArr.map((x2) => x2.bottom))
});
function calcBoxOverlap(boxA, boxB) {
  const left = Math.max(boxA.left, boxB.left);
  const top = Math.max(boxA.top, boxB.top);
  const right = Math.min(boxA.right, boxB.right);
  const bottom = Math.min(boxA.bottom, boxB.bottom);
  const width = right - left;
  const height = bottom - top;
  if (width < 0 || height < 0) return 0;
  const areaA = (boxA.bottom - boxA.top) * (boxA.right - boxA.left);
  const area = width * height;
  return area / areaA;
}
function calcHorizontalOverlap(boxA, boxB) {
  const left = Math.max(boxA.left, boxB.left);
  const right = Math.min(boxA.right, boxB.right);
  const widthOverlap = right - left;
  if (widthOverlap < 0) return 0;
  const widthA = boxA.right - boxA.left;
  return widthOverlap / widthA;
}
function getRandomInt(min, max) {
  const minI = Math.ceil(min);
  const maxI = Math.floor(max);
  return Math.floor(Math.random() * (maxI - minI) + minI);
}
function getRandomAlphanum(num) {
  const outArr = new Array(num);
  for (let i2 = 0; i2 < num; i2++) {
    let intI = getRandomInt(1, 62);
    if (intI <= 10) {
      intI += 47;
    } else if (intI <= 36) {
      intI = intI - 10 + 64;
    } else {
      intI = intI - 36 + 96;
    }
    outArr[i2] = String.fromCharCode(intI);
  }
  return outArr.join("");
}
function quantile(arr, ntile) {
  if (arr.length === 0) {
    return null;
  }
  const arr1 = [...arr];
  const mid = Math.floor(arr.length * ntile);
  arr1.sort((a2, b2) => a2 - b2);
  return arr1[mid];
}
var mean50 = (arr) => {
  if (arr.length === 0) {
    return null;
  }
  const per25 = Math.floor(arr.length / 4) - 1;
  const per75 = Math.ceil(arr.length * 3 / 4) - 1;
  const nums = [...arr].sort((a2, b2) => a2 - b2);
  const numsMiddle = nums.slice(per25, per75 + 1);
  return numsMiddle.reduce((a2, b2) => a2 + b2) / numsMiddle.length;
};
function unescapeXml(string) {
  const replaceFunc = (match, p1) => String.fromCharCode(parseInt(p1, 16));
  return string.replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&apos;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&gt;/g, ">").replace(/&#39;/g, "'").replace(/&#34;/g, '"').replace(/&#x([0-9a-f]+);/g, replaceFunc).replace(/\u00AD/g, "-");
}
function calcLang(str) {
  for (const char of str) {
    const code = char.charCodeAt(0);
    if (code >= 0 && code <= 127) continue;
    if (code >= 19968 && code <= 40959 || code >= 13312 && code <= 19903 || code >= 131072 && code <= 173791 || code >= 173824 && code <= 177983 || code >= 177984 && code <= 178207 || code >= 178208 && code <= 183983 || code >= 63744 && code <= 64255 || code >= 194560 && code <= 195103) return "chi_sim";
    if (code >= 1024 && code <= 1279 || code >= 1280 && code <= 1327 || code === 7296 || code === 7297) return "rus";
  }
  return "eng";
}
function round6(x2) {
  return Math.round(x2 * 1e6) / 1e6;
}
function clearObjectProperties(obj) {
  for (const prop in obj) {
    if (Object.hasOwnProperty.call(obj, prop)) {
      delete obj[prop];
    }
  }
}
var serifFonts = [
  "SerifDefault",
  "Baskerville",
  "Bembo",
  "Bodoni",
  "Bookman",
  "C059",
  "Calibri",
  "Cambria",
  "Century",
  "Cheltenham",
  "Courier",
  "Garamond",
  "Georgia",
  "LucidaBright",
  "Minion",
  "NimbusMono",
  "Optima",
  "P052",
  "Palatino",
  "Times"
];
var sansFonts = [
  "SansDefault",
  "Avenir",
  "Arial",
  "Calibri",
  "Candara",
  "Carlito",
  "Comic",
  "Franklin",
  "Futura",
  "Gotham",
  "Gothic",
  "Helvetica",
  "Impact",
  "Interstate",
  "Myriad",
  "Tahoma",
  "Trebuchet",
  "Univers",
  "Verdana"
];
var serifFontsRegex = new RegExp(serifFonts.reduce((x2, y2) => `${x2}|${y2}`), "i");
var sansFontsRegex = new RegExp(sansFonts.reduce((x2, y2) => `${x2}|${y2}`), "i");
var unidentifiedFonts = /* @__PURE__ */ new Set();
var FontProps = class {
  static sansFontsDoc = /* @__PURE__ */ new Set();
  static serifFontsDoc = /* @__PURE__ */ new Set();
  static sizeMult = {};
};
function determineSansSerif(fontName) {
  fontName = fontName?.replaceAll(/[_\s]/gi, "");
  let fontFamily = "Default";
  if (fontName && !["Default", "GlyphLessFont", "HiddenHorzOCR"].includes(fontName)) {
    if (/(^|\W|_)sans($|\W|_)/i.test(fontName)) {
      fontFamily = "SansDefault";
    } else if (/(^|\W|_)serif($|\W|_)/i.test(fontName)) {
      fontFamily = "SerifDefault";
    } else if (serifFontsRegex.test(fontName)) {
      fontFamily = "SerifDefault";
    } else if (sansFontsRegex.test(fontName)) {
      fontFamily = "SansDefault";
    } else if (fontName !== "Default Metrics Font") {
      if (/serif|rom/i.test(fontName) && !/sans/i.test(fontName)) {
        fontFamily = "SerifDefault";
      } else if (/san/i.test(fontName)) {
        fontFamily = "SansDefault";
      } else if (FontProps.sansFontsDoc.has(fontName)) {
        fontFamily = "SansDefault";
      } else if (FontProps.serifFontsDoc.has(fontName)) {
        fontFamily = "SerifDefault";
      } else if (!unidentifiedFonts.has(fontName)) {
        unidentifiedFonts.add(fontName);
        console.log(`Unidentified font: ${fontName}`);
      }
    }
  }
  return fontFamily;
}
function getTextScript(text) {
  let han = 0;
  let latin = 0;
  const letterArr = typeof text === "string" ? text.split("") : text;
  for (let j2 = 0; j2 < letterArr.length; j2++) {
    if (/\p{Script=Han}/u.test(letterArr[j2])) han++;
    if (/\p{Script=Latin}/u.test(letterArr[j2])) latin++;
  }
  return { han, latin };
}
var superscriptMap = {
  // Superscript digits
  "\u2070": "0",
  "\xB9": "1",
  "\xB2": "2",
  "\xB3": "3",
  "\u2074": "4",
  "\u2075": "5",
  "\u2076": "6",
  "\u2077": "7",
  "\u2078": "8",
  "\u2079": "9",
  // Superscript lowercase Latin letters
  "\u1D43": "a",
  "\u1D47": "b",
  "\u1D9C": "c",
  "\u1D48": "d",
  "\u1D49": "e",
  "\u1DA0": "f",
  "\u1D4D": "g",
  \u02B0: "h",
  "\u2071": "i",
  \u02B2: "j",
  "\u1D4F": "k",
  \u02E1: "l",
  "\u1D50": "m",
  \u207F: "n",
  "\u1D52": "o",
  "\u1D56": "p",
  \u02B3: "r",
  \u02E2: "s",
  "\u1D57": "t",
  "\u1D58": "u",
  "\u1D5B": "v",
  \u02B7: "w",
  \u02E3: "x",
  \u02B8: "y",
  "\u1DBB": "z",
  // Superscript uppercase Latin letters
  "\u1D2C": "A",
  "\u1D2E": "B",
  "\u1D30": "D",
  "\u1D31": "E",
  "\u1D33": "G",
  "\u1D34": "H",
  "\u1D35": "I",
  "\u1D36": "J",
  "\u1D37": "K",
  "\u1D38": "L",
  "\u1D39": "M",
  "\u1D3A": "N",
  "\u1D3C": "O",
  "\u1D3E": "P",
  "\u1D3F": "R",
  "\u1D40": "T",
  "\u1D41": "U",
  "\u2C7D": "V",
  "\u1D42": "W",
  // Superscript symbols and punctuation
  "\u207A": "+",
  "\u207B": "-",
  "\u207C": "=",
  "\u207D": "(",
  "\u207E": ")"
};
function removeSuperscript(text) {
  if (typeof text !== "string") {
    throw new TypeError("Input must be a string");
  }
  return text.replace(/[]/g, (match) => superscriptMap[match] || match);
}
var getStyleLookup = (style) => {
  let styleStr = "normal";
  if (style.bold && style.italic) {
    styleStr = "boldItalic";
  } else if (style.bold) {
    styleStr = "bold";
  } else if (style.italic) {
    styleStr = "italic";
  }
  return styleStr;
};
var cleanFamilyName = (family) => {
  let familyClean = family;
  if (/NimbusRom/i.test(family)) {
    familyClean = "NimbusRoman";
  } else if (/TimesNewRom/i.test(family)) {
    familyClean = "TimesNewRoman";
  } else if (/NimbusSan/i.test(family)) {
    familyClean = "NimbusSans";
  } else if (/Helvetica/i.test(family)) {
    familyClean = "Helvetica";
  } else if (/Arial/i.test(family)) {
    familyClean = "Arial";
  } else if (/CenturySch/i.test(family)) {
    familyClean = "CenturySchoolbook";
  } else if (/Palatino/i.test(family)) {
    familyClean = "Palatino";
  } else if (/Garamond/i.test(family)) {
    familyClean = "Garamond";
  } else if (/CenturyGothic/i.test(family)) {
    familyClean = "CenturyGothic";
  } else if (/AvantGarde/i.test(family)) {
    familyClean = "AvantGarde";
  } else if (/Carlito/i.test(family)) {
    familyClean = "Carlito";
  } else if (/Calibri/i.test(family)) {
    familyClean = "Calibri";
  } else if (/Courier/i.test(family)) {
    familyClean = "Courier";
  } else if (/NimbusMono/i.test(family)) {
    familyClean = "NimbusMono";
  } else if (/Dingbats/i.test(family)) {
    familyClean = "Dingbats";
  } else if (/Wingdings/i.test(family)) {
    familyClean = "Wingdings";
  }
  return familyClean;
};

// node_modules/scribe.js-ocr/js/objects/ocrObjects.js
function OcrPage(n2, dims) {
  this.n = n2;
  this.dims = dims;
  this.angle = 0;
  this.pars = [];
  this.lines = [];
  this.textSource = null;
}
function OcrPar(page, bbox) {
  this.page = page;
  this.bbox = bbox;
  this.lines = [];
  this.reason = "";
}
function OcrLine(page, bbox, baseline, ascHeight = null, xHeight = null) {
  this.bbox = bbox;
  this.baseline = baseline;
  this.ascHeight = ascHeight;
  this.xHeight = xHeight;
  this.words = [];
  this.page = page;
  this._sizeCalc = null;
  this._size = null;
  this.raw = null;
  this._angleAdj = null;
  this.par = null;
  this.orientation = 0;
}
function OcrWord(line, id, text, bbox, poly) {
  this.text = text;
  this.textAlt = null;
  this.style = {
    font: null,
    size: null,
    bold: false,
    italic: false,
    underline: false,
    smallCaps: false,
    sup: false,
    dropcap: false
  };
  this.lang = "eng";
  this.conf = 0;
  this.bbox = bbox;
  this.poly = poly || null;
  this.compTruth = false;
  this.matchTruth = false;
  this.id = id;
  this.line = line;
  this.raw = null;
  this.chars = null;
  this._angleAdj = null;
  this.visualCoords = true;
}
function OcrChar(text, bbox) {
  this.text = text;
  this.bbox = bbox;
}
function scaleChar(char, scale) {
  char.bbox.left *= scale;
  char.bbox.top *= scale;
  char.bbox.right *= scale;
  char.bbox.bottom *= scale;
}
function scaleWord(word, scale) {
  word.bbox.left *= scale;
  word.bbox.top *= scale;
  word.bbox.right *= scale;
  word.bbox.bottom *= scale;
  if (word.chars) {
    for (const char of word.chars) {
      scaleChar(char, scale);
    }
  }
}
function scaleLine(line, scale) {
  line.bbox.left *= scale;
  line.bbox.top *= scale;
  line.bbox.right *= scale;
  line.bbox.bottom *= scale;
  for (const word of line.words) {
    scaleWord(word, scale);
  }
  if (line.ascHeight) line.ascHeight *= scale;
  if (line.xHeight) line.xHeight *= scale;
  line.baseline[1] *= scale;
}
function scalePage(page, scale) {
  for (const line of page.lines) {
    scaleLine(line, scale);
  }
  page.dims.width *= scale;
  page.dims.height *= scale;
}
var getPrevLine = (lineObj) => {
  if (!lineObj.words[0]) throw new Error("All lines must contain >=1 word");
  const lineIndex = lineObj.page.lines.findIndex((elem) => elem.words?.[0]?.id === lineObj.words[0].id);
  if (lineIndex < 1) return null;
  return lineObj.page.lines[lineIndex - 1];
};
var getNextLine = (lineObj) => {
  if (!lineObj.words[0]) throw new Error("All lines must contain >=1 word");
  const lineIndex = lineObj.page.lines.findIndex((elem) => elem.words?.[0]?.id === lineObj.words[0].id);
  if (lineIndex + 1 >= lineObj.page.lines.length) return null;
  return lineObj.page.lines[lineIndex + 1];
};
var getPageWord = (page, id) => {
  for (let i2 = 0; i2 < page.lines.length; i2++) {
    for (let j2 = 0; j2 < page.lines[i2].words.length; j2++) {
      if (page.lines[i2].words[j2].id === id) return page.lines[i2].words[j2];
    }
  }
  return null;
};
var deletePageWords = (page, ids) => {
  for (let i2 = 0; i2 < page.lines.length; i2++) {
    for (let j2 = 0; j2 < page.lines[i2].words.length; j2++) {
      const idsIndex = ids.indexOf(page.lines[i2].words[j2].id);
      if (idsIndex >= 0) {
        ids.splice(idsIndex, 1);
        page.lines[i2].words.splice(j2, 1);
        j2--;
        if (page.lines[i2].words.length === 0) {
          page.lines.splice(i2, 1);
          i2--;
          break;
        } else if (j2 + 1 === page.lines[i2].words.length || ids.length === 0) {
          ocr.updateLineBbox(page.lines[i2]);
        }
        if (ids.length === 0) return;
      }
    }
  }
};
var getPageWords = (page) => {
  const words = [];
  for (let i2 = 0; i2 < page.lines.length; i2++) {
    words.push(...page.lines[i2].words);
  }
  return words;
};
var getDistinctChars = (ocrPageArr) => {
  const charsAll = {};
  for (const ocrPage of ocrPageArr) {
    for (const ocrLine of ocrPage.lines) {
      for (const ocrWord of ocrLine.words) {
        ocrWord.text.split("").forEach((x2) => {
          charsAll[x2] = true;
        });
      }
    }
  }
  return Object.keys(charsAll);
};
var getLineText = (line) => {
  let text = "";
  for (let i2 = 0; i2 < line.words.length; i2++) {
    text += `${line.words[i2].text}`;
    if (i2 < line.words.length - 1) text += " ";
  }
  return text;
};
var getParText = (par) => {
  let text = "";
  for (let i2 = 0; i2 < par.lines.length; i2++) {
    if (i2 > 0) text += " ";
    text += getLineText(par.lines[i2]);
  }
  return text;
};
var getPageText = (page) => {
  let text = "";
  for (let i2 = 0; i2 < page.lines.length; i2++) {
    if (i2 > 0) text += "\n";
    text += getLineText(page.lines[i2]);
  }
  return text;
};
function calcLineStartAngleAdj(line) {
  if (!line.words[0]) {
    console.log("No words in line, report as bug.");
    return { x: 0, y: 0 };
  }
  const angle = line.page.angle * -1;
  const dims = line.page.dims;
  const sinAngle = Math.sin(angle * (Math.PI / 180));
  const cosAngle = Math.cos(angle * (Math.PI / 180));
  let bbox;
  const char0Bbox = line.words[0]?.chars?.[0]?.bbox;
  if (char0Bbox) {
    bbox = char0Bbox;
  } else {
    bbox = line.words[0].bbox;
  }
  const width = line.orientation % 2 === 0 ? dims.width : dims.height;
  const height = line.orientation % 2 === 0 ? dims.height : dims.width;
  const bboxRot = rotateBbox(bbox, cosAngle, sinAngle, width, height);
  line._angleAdj = { x: bboxRot.left - bbox.left, y: bboxRot.bottom - bbox.bottom };
  return line._angleAdj;
}
function calcWordAngleAdj(word) {
  if (true) {
    word._angleAdj = { x: 0, y: 0 };
    const { angle } = word.line.page;
    if (Math.abs(angle ?? 0) > 0.05) {
      const sinAngle = Math.sin(angle * (Math.PI / 180));
      const cosAngle = Math.cos(angle * (Math.PI / 180));
      const x2 = word.bbox.left - word.line.bbox.left;
      const y2 = word.bbox.bottom - (word.line.bbox.bottom + word.line.baseline[1]);
      if (word.style.sup || word.style.dropcap) {
        const tanAngle = sinAngle / cosAngle;
        const angleAdjYSup = (y2 - x2 * tanAngle) * cosAngle - y2;
        const angleAdjXSup = angle > 0 ? 0 : angleAdjYSup * tanAngle;
        word._angleAdj = { x: 0 - angleAdjXSup, y: angleAdjYSup };
      } else {
        const angleAdjXBaseline = x2 / cosAngle - x2;
        word._angleAdj = { x: angleAdjXBaseline, y: 0 };
      }
    }
  }
  return word._angleAdj;
}
function replaceLigatures(text) {
  return text.replace(//g, "IJ").replace(//g, "ij").replace(//g, "\u02BCn").replace(//g, "DZ").replace(//g, "Dz").replace(//g, "dz").replace(//g, "D\u017D").replace(//g, "D\u017E").replace(//g, "d\u017E").replace(//g, "LJ").replace(//g, "Lj").replace(//g, "lj").replace(//g, "NJ").replace(//g, "Nj").replace(//g, "nj").replace(//g, "ff").replace(//g, "fi").replace(//g, "fl").replace(//g, "ffi").replace(//g, "ffl").replace(//g, "\u017Ft").replace(//g, "st");
}
function escapeXml(string) {
  return string.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function updateLineBbox(line, adjustBaseline = true) {
  const lineboxBottomOrig = line.bbox.bottom;
  const wordBoxArr = line.words.map((x2) => x2.bbox);
  line.bbox = calcBboxUnion(wordBoxArr);
  if (adjustBaseline) line.baseline[1] += lineboxBottomOrig - line.bbox.bottom;
}
function calcWordBbox(word) {
  if (!word.chars || word.chars.length === 0) return;
  const charBoxArr = word.chars.map((x2) => x2.bbox);
  word.bbox = calcBboxUnion(charBoxArr);
}
function rotateBbox(bbox, cosAngle, sinAngle, width, height) {
  const bboxOut = { ...bbox };
  const xCenter = width / 2;
  const yCenter = height / 2;
  bboxOut.left = cosAngle * (bbox.left - xCenter) - sinAngle * (bbox.bottom - yCenter) + xCenter;
  bboxOut.right = cosAngle * (bbox.right - xCenter) - sinAngle * (bbox.bottom - yCenter) + xCenter;
  bboxOut.top = sinAngle * (bbox.left - xCenter) + cosAngle * (bbox.top - yCenter) + yCenter;
  bboxOut.bottom = sinAngle * (bbox.left - xCenter) + cosAngle * (bbox.bottom - yCenter) + yCenter;
  return bboxOut;
}
function rotateLine(line, angle, dims = null, useCharLevel = false) {
  if (Math.abs(angle) <= 0.05) return;
  const dims1 = dims || line.page.dims;
  const sinAngle = Math.sin(angle * (Math.PI / 180));
  const cosAngle = Math.cos(angle * (Math.PI / 180));
  const { baseline } = line;
  const baselineAngleRadXML = Math.atan(baseline[0]);
  const baselineAngleRadAdj = angle * (Math.PI / 180);
  const baselineAngleRadTotal = Math.tan(baselineAngleRadXML + baselineAngleRadAdj);
  for (let i2 = 0; i2 < line.words.length; i2++) {
    const word = line.words[i2];
    if (useCharLevel && word.chars && word.chars.length > 0) {
      for (let j2 = 0; j2 < word.chars.length; j2++) {
        const char = word.chars[j2];
        char.bbox = rotateBbox(char.bbox, cosAngle, sinAngle, dims1.width, dims1.height);
      }
      ocr.calcWordBbox(word);
    } else {
      word.bbox = rotateBbox(word.bbox, cosAngle, sinAngle, dims1.width, dims1.height);
    }
  }
  const lineBoxRot = rotateBbox(line.bbox, cosAngle, sinAngle, dims1.width, dims1.height);
  updateLineBbox(line, false);
  const baselineOffsetAdj = lineBoxRot.bottom - line.bbox.bottom;
  const baselineOffsetTotal = baseline[1] + baselineOffsetAdj;
  line.baseline[0] = baselineAngleRadTotal;
  line.baseline[1] = baselineOffsetTotal;
}
function clonePage(page) {
  const pageNew = new OcrPage(page.n, { ...page.dims });
  for (const line of page.lines) {
    const lineNew = cloneLine(line);
    lineNew.page = pageNew;
    pageNew.lines.push(lineNew);
  }
  return pageNew;
}
function cloneLine(line) {
  const lineNew = new OcrLine(line.page, { ...line.bbox }, line.baseline.slice(), line.ascHeight, line.xHeight);
  for (const word of line.words) {
    const wordNew = cloneWord(word);
    wordNew.line = lineNew;
    lineNew.words.push(wordNew);
  }
  return lineNew;
}
function cloneWord(word) {
  const wordNew = new OcrWord(word.line, word.id, word.text, { ...word.bbox });
  if (word.poly) wordNew.poly = { ...word.poly };
  wordNew.conf = word.conf;
  wordNew.style = { ...word.style };
  wordNew.lang = word.lang;
  wordNew.compTruth = word.compTruth;
  wordNew.matchTruth = word.matchTruth;
  wordNew.visualCoords = word.visualCoords;
  wordNew.raw = word.raw;
  if (word.chars) {
    wordNew.chars = [];
    for (const char of word.chars) {
      wordNew.chars.push(cloneChar(char));
    }
  }
  return wordNew;
}
function cloneChar(char) {
  const charNew = new OcrChar(char.text, { ...char.bbox });
  return charNew;
}
function getMatchingWords(text, ocrPage) {
  text = text.trim().toLowerCase();
  if (!text) return [];
  const textArr = text.split(" ");
  const wordArr = ocr.getPageWords(ocrPage);
  const matchArr = [];
  for (let i2 = 0; i2 < wordArr.length - (textArr.length - 1); i2++) {
    const word = wordArr[i2];
    if (!word.text.toLowerCase().includes(textArr[0])) continue;
    const candArr = wordArr.slice(i2, i2 + textArr.length);
    const candText = candArr.map((x2) => x2.text).join(" ").toLowerCase();
    if (candText.toLowerCase().includes(text)) {
      matchArr.push(...candArr);
    }
  }
  return matchArr;
}
function getMatchingWordIds(text, ocrPage) {
  text = text.trim().toLowerCase();
  if (!text) return [];
  const textArr = text.split(" ");
  const wordArr = ocr.getPageWords(ocrPage);
  const matchIdArr = [];
  for (let i2 = 0; i2 < wordArr.length - (textArr.length - 1); i2++) {
    const word = wordArr[i2];
    if (!word.text.toLowerCase().includes(textArr[0])) continue;
    const candArr = wordArr.slice(i2, i2 + textArr.length);
    const candText = candArr.map((x2) => x2.text).join(" ").toLowerCase();
    if (candText.toLowerCase().includes(text)) {
      matchIdArr.push(...candArr.map((x2) => x2.id));
    }
  }
  return matchIdArr;
}
function getWordFillOpacity(word, displayMode, confThreshMed = 75, confThreshHigh = 85, overlayOpacity = 80) {
  let fillColorHex;
  if (word.conf > confThreshHigh) {
    fillColorHex = "#00ff7b";
  } else if (word.conf > confThreshMed) {
    fillColorHex = "#ffc800";
  } else {
    fillColorHex = "#ff0000";
  }
  const fillColorHexMatch = word.matchTruth ? "#00ff7b" : "#ff0000";
  let opacity;
  let fill;
  if (displayMode === "invis") {
    opacity = 0;
    fill = "black";
  } else if (displayMode === "ebook") {
    opacity = 1;
    fill = "black";
  } else if (displayMode === "eval") {
    opacity = overlayOpacity / 100;
    fill = fillColorHexMatch;
  } else {
    opacity = overlayOpacity / 100;
    fill = fillColorHex;
  }
  return { opacity, fill };
}
var ocr = {
  OcrPage,
  OcrPar,
  OcrLine,
  OcrWord,
  OcrChar,
  calcLineStartAngleAdj,
  updateLineBbox,
  calcBboxUnion,
  calcWordBbox,
  calcWordAngleAdj,
  getPageWord,
  getPageWords,
  getDistinctChars,
  getMatchingWords,
  getMatchingWordIds,
  getPageText,
  getParText,
  getLineText,
  getPrevLine,
  getNextLine,
  getWordFillOpacity,
  clonePage,
  cloneLine,
  cloneWord,
  cloneChar,
  rotateLine,
  deletePageWords,
  replaceLigatures,
  scaleLine,
  scalePage,
  escapeXml
};
var ocrObjects_default = ocr;

// node_modules/scribe.js-ocr/js/objects/layoutObjects.js
var LayoutBoxBase = class {
  /**
   * Create a layout box.
   * @param {bbox} coords - The coordinates of the layout box.
   */
  constructor(coords) {
    this.id = getRandomAlphanum(10);
    this.coords = coords;
    this.inclusionRule = "majority";
    this.inclusionLevel = "word";
  }
};
var LayoutDataColumn = class extends LayoutBoxBase {
  /**
   * Create a layout data column.
   * @param {bbox} coords - The coordinates of the layout data column.
   * @param {LayoutDataTable} table - The layout data table to which the column belongs.
   */
  constructor(coords, table) {
    super(coords);
    this.type = "dataColumn";
    this.table = table;
  }
};
var LayoutDataTable = class {
  /**
   * Create a layout data table.
   * @param {LayoutDataTablePage} page - The layout data table page to which the table belongs.
   */
  constructor(page) {
    this.page = page;
    this.id = getRandomAlphanum(10);
    this.boxes = [];
  }
};
function LayoutDataTablePage(n2) {
  this.n = n2;
  this.default = true;
  this.tables = [];
}

// node_modules/scribe.js-ocr/js/import/convertPageShared.js
function pass2(pageObj, rotateAngle) {
  for (const lineObj of pageObj.lines) {
    ocrObjects_default.updateLineBbox(lineObj);
  }
  if (Math.abs(rotateAngle) > 0.05) {
    for (let i2 = 0; i2 < pageObj.lines.length; i2++) {
      ocrObjects_default.rotateLine(pageObj.lines[i2], rotateAngle, null, true);
    }
  }
  for (let i2 = 0; i2 < pageObj.lines.length; i2++) {
    const lineObj = pageObj.lines[i2];
    let firstWord = false;
    const smallCapsWordArr = [];
    const titleCaseArr = [];
    for (let j2 = 0; j2 < lineObj.words.length; j2++) {
      const wordObj = lineObj.words[j2];
      if (wordObj.style.smallCaps) {
        smallCapsWordArr.push(wordObj);
        firstWord = true;
        continue;
      }
      if (!/[a-z]/.test(wordObj.text) && /[A-Z].?[A-Z]/.test(wordObj.text) && wordObj.chars) {
        const letterChars = wordObj.chars.filter((x2) => /[a-z]/i.test(x2.text));
        const firstLetterHeight = letterChars[0].bbox.bottom - letterChars[0].bbox.top;
        const otherLetters = letterChars.slice(1).filter((x2) => !/[q]/i.test(x2.text));
        if (otherLetters.length === 0) continue;
        const otherLetterHeightArr = otherLetters.map((x2) => x2.bbox.bottom - x2.bbox.top);
        const otherLetterHeightMax = Math.max(...otherLetterHeightArr);
        const otherLetterHeightMin = Math.min(...otherLetterHeightArr);
        const firstLetterThresh = ["q", "Q"].includes(letterChars[0].text) ? 1.3 : 1.1;
        if (firstLetterHeight > otherLetterHeightMax * firstLetterThresh) {
          if (otherLetterHeightMax / otherLetterHeightMin < 1.15) {
            smallCapsWordArr.push(wordObj);
            if (j2 === 0) firstWord = true;
            titleCaseArr[smallCapsWordArr.length - 1] = true;
          }
        } else {
          const letterCharsAsc = wordObj.chars.filter((x2) => /[a-pr-z]/i.test(x2.text));
          if (letterCharsAsc.length < 2) continue;
          const allLetterHeightArr = letterCharsAsc.map((x2) => x2.bbox.bottom - x2.bbox.top);
          const allLetterHeightMax = Math.max(...allLetterHeightArr);
          const allLetterHeightMin = Math.min(...allLetterHeightArr);
          if (allLetterHeightMax / allLetterHeightMin < 1.15) {
            smallCapsWordArr.push(wordObj);
            if (j2 === 0) firstWord = true;
            titleCaseArr[smallCapsWordArr.length - 1] = false;
          }
        }
      }
    }
    if (firstWord || smallCapsWordArr.length >= 2) {
      const titleCaseTotal = titleCaseArr.reduce((x2, y2) => Number(x2) + Number(y2), 0);
      for (let k2 = 0; k2 < smallCapsWordArr.length; k2++) {
        const wordObj = smallCapsWordArr[k2];
        wordObj.style.smallCaps = true;
        if (!wordObj.chars || !titleCaseTotal) continue;
        if (titleCaseArr[k2]) {
          wordObj.chars.slice(1).forEach((x2) => {
            x2.text = x2.text.toLowerCase();
          });
          wordObj.text = wordObj.chars.map((x2) => x2.text).join("");
        } else {
          wordObj.chars.forEach((x2) => {
            x2.text = x2.text.toLowerCase();
          });
          wordObj.text = wordObj.chars.map((x2) => x2.text).join("");
        }
      }
    }
  }
  for (const lineObj of pageObj.lines) {
    for (let i2 = 0; i2 < lineObj.words.length; i2++) {
      const wordObj = lineObj.words[i2];
      if (["chi_sim", "chi_tra"].includes(wordObj.lang) || !wordObj.chars || wordObj.chars.length === 0) continue;
      const trailingNumStr = wordObj.text.match(/\d+$/)?.[0];
      if (!trailingNumStr) continue;
      const lineboxAdj = { ...lineObj.bbox };
      if (lineObj.baseline[0] < 0) {
        lineboxAdj.top -= (lineboxAdj.right - lineboxAdj.left) * lineObj.baseline[0];
      } else {
        lineboxAdj.bottom -= (lineboxAdj.right - lineboxAdj.left) * lineObj.baseline[0];
      }
      const baselinePointAdj = lineObj.baseline[0] < 0 ? lineObj.baseline[1] : lineObj.baseline[1] + (lineObj.bbox.bottom - lineboxAdj.bottom);
      const expectedBaseline = (wordObj.bbox.left + (wordObj.bbox.right - wordObj.bbox.left) / 2 - lineboxAdj.left) * lineObj.baseline[0] + baselinePointAdj + lineboxAdj.bottom;
      const lineAscHeight = expectedBaseline - lineboxAdj.top;
      let baseN = 0;
      for (let j2 = wordObj.chars.length - 1; j2 >= 0; j2--) {
        const charObj = wordObj.chars[j2];
        if (charObj.bbox.bottom < expectedBaseline - lineAscHeight / 4) {
          baseN++;
        } else {
          break;
        }
      }
      const superN = Math.min(trailingNumStr.length, baseN);
      if (superN === 0) continue;
      if (superN === wordObj.text.length) {
        wordObj.style.sup = true;
        wordObj.style.bold = false;
        wordObj.style.italic = false;
        wordObj.style.underline = false;
        continue;
      }
      const wordObjSup = ocrObjects_default.cloneWord(wordObj);
      const charCoreArr = wordObj.chars.slice(0, wordObj.chars.length - superN);
      const wordObjSupChars = (
        /** @type {OcrChar[]} */
        wordObjSup.chars
      );
      const charSuperArr = wordObjSupChars.slice(wordObj.chars.length - superN, wordObj.chars.length);
      const textCore = charCoreArr.map((x2) => x2.text).join("");
      const textSuper = charSuperArr.map((x2) => x2.text).join("");
      wordObjSup.text = textSuper;
      wordObjSup.chars = charSuperArr;
      wordObjSup.style.bold = false;
      wordObjSup.style.italic = false;
      wordObjSup.style.underline = false;
      wordObjSup.style.sup = true;
      wordObjSup.id = `${wordObj.id}a`;
      ocrObjects_default.calcWordBbox(wordObjSup);
      wordObj.text = textCore;
      wordObj.chars = charCoreArr;
      ocrObjects_default.calcWordBbox(wordObj);
      lineObj.words.splice(i2 + 1, 0, wordObjSup);
      i2++;
    }
  }
}
function pass3(pageObj) {
  const langSet = /* @__PURE__ */ new Set();
  if (!pageObj.angle) {
    const angleRisePage = [];
    for (const lineObj of pageObj.lines) {
      if (lineObj.bbox.right - lineObj.bbox.left >= 200) {
        angleRisePage.push(lineObj.baseline[0]);
      }
    }
    const angleRiseMedian = mean50(angleRisePage) || 0;
    pageObj.angle = Math.asin(angleRiseMedian) * (180 / Math.PI);
  }
  for (const lineObj of pageObj.lines) {
    const lineAscHeightArr = [];
    const lineXHeightArr = [];
    const lineAllHeightArr = [];
    for (const wordObj of lineObj.words) {
      const letterArr = wordObj.text.split("");
      const charObjArr = wordObj.chars;
      langSet.add(wordObj.lang);
      if (wordObj.chars && wordObj.chars.length !== wordObj.text.length) continue;
      if (['"', "'"].includes(letterArr[0]) && letterArr.length > 1 && /[a-z\d]/i.test(letterArr[1])) {
        if (letterArr[0] === '"') {
          letterArr[0] = "\u201C";
          if (charObjArr) charObjArr[0].text = "\u201C";
        } else if (letterArr[0] === "'") {
          letterArr[0] = "\u2018";
          if (charObjArr) charObjArr[0].text = "\u2018";
        }
      }
      if (['"', "'"].includes(letterArr[letterArr.length - 1]) && /[a-z\d][.,!?;]?['"]$/i.test(wordObj.text)) {
        if (letterArr[letterArr.length - 1] === '"') {
          letterArr[letterArr.length - 1] = "\u201D";
          if (charObjArr) charObjArr[letterArr.length - 1].text = "\u201D";
        } else if (letterArr[letterArr.length - 1] === "'") {
          letterArr[letterArr.length - 1] = "\u2019";
          if (charObjArr) charObjArr[letterArr.length - 1].text = "\u2019";
        }
      }
      for (let k2 = 0; k2 < letterArr.length; k2++) {
        if (["'"].includes(letterArr[k2]) && k2 > 0 && k2 + 1 < letterArr.length && /[a-z\d]/i.test(letterArr[k2 + 1]) && /[a-z\d]/i.test(letterArr[k2 - 1])) {
          letterArr[k2] = "\u2019";
          if (charObjArr) charObjArr[k2].text = "\u2019";
        }
      }
      if (wordObj.chars) {
        for (let k2 = 0; k2 < letterArr.length; k2++) {
          const charObj = wordObj.chars[k2];
          if (wordObj.style.sup || wordObj.style.dropcap) continue;
          const contentStrLetter = letterArr[k2];
          const charHeight = charObj.bbox.bottom - charObj.bbox.top;
          const ascChar = wordObj.style.smallCaps && /[A-Z0-9]/.test(contentStrLetter) || !wordObj.style.smallCaps && ascCharArr.includes(contentStrLetter);
          const xChar = wordObj.style.smallCaps && /[a-z]/.test(contentStrLetter) || !wordObj.style.smallCaps && xCharArr.includes(contentStrLetter);
          lineAllHeightArr.push(charHeight);
          if (ascChar) {
            lineAscHeightArr.push(charHeight);
          } else if (xChar) {
            lineXHeightArr.push(charHeight);
          }
        }
      }
      wordObj.text = letterArr.join("");
    }
    const lineAllHeight = Math.max(...lineAllHeightArr);
    const lineAscHeight = quantile(lineAscHeightArr, 0.5);
    const lineXHeight = quantile(lineXHeightArr, 0.5);
    if (lineAscHeight) lineObj.ascHeight = lineAscHeight;
    if (lineXHeight) lineObj.xHeight = lineXHeight;
    if (lineObj.ascHeight && lineObj.xHeight && lineObj.xHeight >= lineObj.ascHeight * 0.9) {
      if (lineAscHeightArr.length > lineXHeightArr.length) {
        lineObj.xHeight = null;
      } else {
        lineObj.ascHeight = null;
      }
    }
    if (!lineAscHeight && !lineXHeight && lineAllHeight && Number.isFinite(lineAllHeight)) lineObj.ascHeight = lineAllHeight;
    for (const wordObj of lineObj.words) {
      if (wordObj.chars && wordObj.chars.length !== wordObj.text.length) continue;
      const letterArr = wordObj.text.split("");
      const charObjArr = wordObj.chars;
      if (!charObjArr || !wordObj.line.xHeight) continue;
      for (let k2 = 0; k2 < letterArr.length; k2++) {
        const enoughInfo = letterArr.length > 2 || wordObj.line.words.length > 2;
        if (["-", "\u2013", "\u2014", "\xAC"].includes(letterArr[k2]) && enoughInfo) {
          let charWidth = charObjArr[k2].bbox.right - charObjArr[k2].bbox.left;
          if (charObjArr[k2 - 1]) {
            const rightBound = charObjArr[k2 + 1] ? charObjArr[k2 + 1].bbox.left : charObjArr[k2].bbox.right;
            const charWidth2 = rightBound - charObjArr[k2 - 1].bbox.right;
            charWidth = Math.min(charWidth, charWidth2);
          }
          const charWidthNorm = charWidth / wordObj.line.xHeight;
          if (charWidthNorm > 1.5) {
            letterArr[k2] = "\u2014";
            if (charObjArr) charObjArr[k2].text = "\u2014";
          } else if (charWidthNorm > 0.9) {
            letterArr[k2] = "\u2013";
            if (charObjArr) charObjArr[k2].text = "\u2013";
          } else {
            letterArr[k2] = "-";
            if (charObjArr) charObjArr[k2].text = "-";
          }
        }
      }
      wordObj.text = ocrObjects_default.replaceLigatures(letterArr.join(""));
    }
  }
  return langSet;
}

// node_modules/scribe.js-ocr/js/import/convertPageAbbyy.js
var abbyyDropCapRegex = /<par dropCapCharsCount=['"](\d*)/i;
var abbyyLineBoxRegex = /<line baseline=['"](\d*)['"] l=['"](\d*)['"] t=['"](\d*)['"] r=['"](\d*)['"] b=['"](\d*)['"]>/i;
var abbyySplitRegex = /(?:<charParams[^>]*>\s*<\/charParams>)|(?:<\/formatting>\s*(?=<formatting))/ig;
var abbyyCharRegex = /(<formatting[^>]+>\s*)?<charParams l=['"](\d*)['"] t=['"](\d*)['"] r=['"](\d*)['"] b=['"](\d*)['"](?: suspicious=['"](\w*)['"])?[^>]*>([^<]*)<\/charParams>/ig;
var debugMode = false;
async function convertPageAbbyy({ ocrStr, n: n2 }) {
  const pageAttrStr = ocrStr.match(/<page[^>]*>/);
  const widthStr = pageAttrStr?.[0].match(/width=['"](\d+)['"]/)?.[1];
  const heightStr = pageAttrStr?.[0].match(/height=['"](\d+)['"]/)?.[1];
  const rotationStr = pageAttrStr?.[0].match(/rotation=['"](\w+)['"]/)?.[1];
  if (!widthStr || !heightStr) throw new Error("Failed to parse page dimensions.");
  let pageOrientation = 0;
  if (rotationStr === "RotatedClockwise") {
    pageOrientation = 3;
  } else if (rotationStr === "RotatedUpsidedown") {
    pageOrientation = 2;
  } else if (rotationStr === "RotatedCounterclockwise") {
    pageOrientation = 1;
  }
  const pageDims = { height: parseInt(heightStr), width: parseInt(widthStr) };
  const pageObj = new ocrObjects_default.OcrPage(n2, pageDims);
  pageObj.textSource = "abbyy";
  if (!/<charParams/i.test(ocrStr)) {
    const warn = { char: "char_error" };
    return {
      pageObj,
      charMetricsObj: {},
      dataTables: new LayoutDataTablePage(n2),
      warn
    };
  }
  const tablesPage = convertTableLayoutAbbyy(n2, ocrStr);
  const angleRisePage = [];
  function convertTextAbbyy(xmlText) {
    const textAttrStr = xmlText.match(/<text[^>]*>/);
    const textOrientationStr = textAttrStr?.[0].match(/orientation=['"](\w+)['"]/)?.[1];
    let textOrientation = 0;
    if (textOrientationStr === "RotatedClockwise") {
      textOrientation = 1;
    } else if (textOrientationStr === "RotatedUpsidedown") {
      textOrientation = 2;
    } else if (textOrientationStr === "RotatedCounterclockwise") {
      textOrientation = 3;
    }
    const textOrientationFinal = (pageOrientation + textOrientation) % 4;
    function convertParAbbyy(xmlPar) {
      const parLineArr = [];
      function convertLineAbbyy(xmlLine) {
        const baselineSlopeArr = (
          /** @type {Array<Number>} */
          []
        );
        const baselineFirst = (
          /** @type {Array<Number>} */
          []
        );
        const xmlLinePreChar = xmlLine.match(/^[\s\S]*?(?=<charParams)/)?.[0];
        const xmlLineFormatting = xmlLinePreChar?.match(/<formatting[^>]+/)?.[0];
        const fontName = xmlLineFormatting?.match(/ff=['"]([^'"]*)/)?.[1];
        let dropCap = false;
        const dropCapMatch = xmlLine.match(abbyyDropCapRegex);
        if (dropCapMatch != null && parseInt(dropCapMatch[1]) > 0) {
          dropCap = true;
        }
        let lineBoxArr = xmlLine.match(abbyyLineBoxRegex);
        if (lineBoxArr == null) return;
        lineBoxArr = [...lineBoxArr].map((x2) => parseInt(x2));
        xmlLine = xmlLine.replaceAll(/isTab=['"](?:1|true)['"][^>]*>[^<]+/ig, "> ");
        xmlLine = xmlLine.replaceAll(/(<\/formatting><formatting[^>]*>\s*)<charParams[^>]*>\s*<\/charParams>/ig, "$1");
        xmlLine = xmlLine.replaceAll(/<charParams[^>]*>\s*<\/charParams>(\s*<\/formatting><formatting[^>]*>\s*)/ig, "$1");
        const wordStrArr1 = xmlLine.split(abbyySplitRegex);
        const wordStrArr = [];
        for (let i2 = 0; i2 < wordStrArr1.length; i2++) {
          const wordStrArrI = wordStrArr1[i2];
          const wordMatch = wordStrArrI.match(/>([^<>]+?)(?=<\/charParams>)/g)?.map((x2) => x2.substring(1));
          if (!wordMatch) {
            continue;
          } else if (wordMatch.length === 1) {
            if (wordMatch[0] === ".") {
              if (wordStrArr.length > 0 && !/superscript=['"](1|true)/i.test(wordStrArr[wordStrArr.length - 1])) {
                wordStrArr[wordStrArr.length - 1] = wordStrArr[wordStrArr.length - 1] + wordStrArrI.replace(/(<formatting[^>]+>\s*)/i, "");
                continue;
              }
            }
          }
          wordStrArr.push(wordStrArrI);
        }
        if (wordStrArr.length === 0) return;
        const bboxes = Array(wordStrArr.length);
        let text = Array(wordStrArr.length);
        const charObjArrLine = Array(wordStrArr.length);
        text = text.fill("");
        const italicArr = Array(wordStrArr.length).fill(false);
        const boldArr = Array(wordStrArr.length).fill(false);
        const underlineArr = Array(wordStrArr.length).fill(false);
        const supArr = Array(wordStrArr.length).fill(false);
        const dropcapArr = Array(wordStrArr.length).fill(false);
        const smallCapsArr = Array(wordStrArr.length).fill(false);
        const wordSusp = Array(wordStrArr.length).fill(false);
        for (let i2 = 0; i2 < wordStrArr.length; i2++) {
          const wordStr = wordStrArr[i2];
          const letterArr = [...wordStr.matchAll(abbyyCharRegex)];
          if (typeof letterArr[0][1] !== "undefined") {
            if (dropCap && i2 === 0) {
              dropcapArr[i2] = true;
            } else if (/superscript=['"](1|true)/i.test(letterArr[0][1])) {
              supArr[i2] = true;
            } else {
              if (/italic=['"](1|true)/i.test(letterArr[0][1])) {
                italicArr[i2] = true;
              }
              if (/bold=['"](1|true)/i.test(letterArr[0][1])) {
                boldArr[i2] = true;
              }
              if (/underline=['"](1|true)/i.test(letterArr[0][1])) {
                underlineArr[i2] = true;
              }
            }
            if (/smallcaps=['"](1|true)/i.test(letterArr[0][1])) {
              smallCapsArr[i2] = true;
            }
          } else if (i2 > 0 && !dropcapArr[i2 - 1]) {
            italicArr[i2] = italicArr[i2 - 1];
            boldArr[i2] = boldArr[i2 - 1];
            underlineArr[i2] = underlineArr[i2 - 1];
            supArr[i2] = supArr[i2 - 1];
            smallCapsArr[i2] = smallCapsArr[i2 - 1];
          }
          let dropCapFix = false;
          if (dropCap && i2 === 1 && smallCapsArr[i2]) {
            smallCapsArr[i2] = false;
            dropCapFix = true;
          }
          bboxes[i2] = [];
          charObjArrLine[i2] = [];
          for (let j2 = 0; j2 < letterArr.length; j2++) {
            if (letterArr[j2][2] === "0") {
              continue;
            }
            const bboxRaw = {
              l: parseInt(letterArr[j2][2]),
              t: parseInt(letterArr[j2][3]),
              r: parseInt(letterArr[j2][4]),
              b: parseInt(letterArr[j2][5])
            };
            let bbox2;
            if (textOrientationFinal === 1) {
              bbox2 = {
                left: Math.round(bboxRaw.t),
                top: Math.round(pageDims.width - Math.max(bboxRaw.r, bboxRaw.l)),
                right: Math.round(bboxRaw.b),
                bottom: Math.round(pageDims.width - Math.min(bboxRaw.l, bboxRaw.l))
              };
            } else if (textOrientationFinal === 2) {
              bbox2 = {
                left: Math.round(pageDims.width - bboxRaw.r),
                top: Math.round(pageDims.height - bboxRaw.b),
                right: Math.round(pageDims.width - bboxRaw.l),
                bottom: Math.round(pageDims.height - bboxRaw.t)
              };
            } else if (textOrientationFinal === 3) {
              bbox2 = {
                left: Math.round(pageDims.height - bboxRaw.b),
                top: Math.round(Math.min(bboxRaw.l, bboxRaw.l)),
                right: Math.round(pageDims.height - bboxRaw.t),
                bottom: Math.round(Math.max(bboxRaw.r, bboxRaw.r))
              };
            } else {
              bbox2 = {
                left: Math.round(bboxRaw.l),
                top: Math.round(bboxRaw.t),
                right: Math.round(bboxRaw.r),
                bottom: Math.round(bboxRaw.b)
              };
            }
            bboxes[i2][j2] = bbox2;
            let letterSusp = false;
            if (letterArr[j2][6] === "1" || letterArr[j2][6] === "true") {
              wordSusp[i2] = true;
              letterSusp = true;
            }
            if (dropCapFix) {
              letterArr[j2][7] = letterArr[j2][7].toUpperCase();
            }
            letterArr[j2][7] = unescapeXml(letterArr[j2][7]);
            const contentStrLetter = letterArr[j2][7];
            const ascChar = ascCharArr.includes(contentStrLetter);
            const xChar = xCharArr.includes(contentStrLetter);
            if ((ascChar || xChar) && !letterSusp && !dropCapFix && !(dropCap && i2 === 0)) {
              if (baselineFirst.length === 0) {
                baselineFirst.push(bboxes[i2][j2].left, bboxes[i2][j2].bottom);
              } else {
                const baselineSlope2 = (bboxes[i2][j2].bottom - baselineFirst[1]) / (bboxes[i2][j2].left - baselineFirst[0]);
                if (Number.isFinite(baselineSlope2)) baselineSlopeArr.push(baselineSlope2);
              }
            }
            text[i2] += contentStrLetter;
            const charObj = new ocrObjects_default.OcrChar(contentStrLetter, bbox2);
            charObjArrLine[i2].push(charObj);
          }
        }
        const lineBoxArrCalc = new Array(4);
        lineBoxArrCalc[0] = Math.min(...bboxes.reduce((acc, val) => acc.concat(val), []).map((x2) => x2.left).filter((x2) => x2 > 0));
        lineBoxArrCalc[1] = Math.min(...bboxes.reduce((acc, val) => acc.concat(val), []).map((x2) => x2.top).filter((x2) => x2 > 0));
        lineBoxArrCalc[2] = Math.max(...bboxes.reduce((acc, val) => acc.concat(val), []).map((x2) => x2.right).filter((x2) => x2 > 0));
        lineBoxArrCalc[3] = Math.max(...bboxes.reduce((acc, val) => acc.concat(val), []).map((x2) => x2.bottom).filter((x2) => x2 > 0));
        const baselineSlope = quantile(baselineSlopeArr, 0.5) || 0;
        let baselinePoint = baselineFirst[1] - lineBoxArrCalc[3];
        if (baselineSlope < 0) {
          baselinePoint -= baselineSlope * (baselineFirst[0] - lineBoxArrCalc[0]);
        }
        baselinePoint = baselinePoint || 0;
        const lineBoxArrOut = Number.isFinite(lineBoxArrCalc[0]) && Number.isFinite(lineBoxArrCalc[1]) && Number.isFinite(lineBoxArrCalc[2]) && Number.isFinite(lineBoxArrCalc[3]) ? lineBoxArrCalc : lineBoxArr.slice(2, 6);
        const baselineOut = [round6(baselineSlope), Math.round(baselinePoint)];
        const bbox = {
          left: lineBoxArrOut[0],
          top: lineBoxArrOut[1],
          right: lineBoxArrOut[2],
          bottom: lineBoxArrOut[3]
        };
        const lineObj = new ocrObjects_default.OcrLine(pageObj, bbox, baselineOut);
        lineObj.orientation = textOrientationFinal;
        if (debugMode) lineObj.raw = xmlText;
        let lettersKept = 0;
        for (let i2 = 0; i2 < text.length; i2++) {
          if (text[i2].trim() === "") continue;
          const bboxesI = bboxes[i2];
          const bboxesILeft = Math.min(...bboxesI.map((x2) => x2.left).filter((x2) => x2 > 0));
          const bboxesIRight = Math.max(...bboxesI.map((x2) => x2.right).filter((x2) => x2 > 0));
          const bboxesITop = Math.min(...bboxesI.map((x2) => x2.top).filter((x2) => x2 > 0));
          const bboxesIBottom = Math.max(...bboxesI.map((x2) => x2.bottom).filter((x2) => x2 > 0));
          if (!Number.isFinite(bboxesITop) || !Number.isFinite(bboxesIBottom) || !Number.isFinite(bboxesILeft) || !Number.isFinite(bboxesIRight)) {
            continue;
          }
          const bboxWord = {
            left: bboxesILeft,
            top: bboxesITop,
            right: bboxesIRight,
            bottom: bboxesIBottom
          };
          const id = `word_${n2 + 1}_${pageObj.lines.length + 1}_${i2 + 1}`;
          const wordObj = new ocrObjects_default.OcrWord(lineObj, id, text[i2], bboxWord);
          wordObj.chars = charObjArrLine[i2];
          wordObj.conf = wordSusp[i2] ? 0 : 100;
          console.assert(wordObj.chars.length === text[i2].length, `Likely parsing error for word: ${id}. Number of letters in text does not match number of \`ocrChar\` objects.`);
          if (italicArr[i2]) {
            wordObj.style.italic = true;
          }
          if (boldArr[i2]) {
            wordObj.style.bold = true;
          }
          if (underlineArr[i2]) {
            wordObj.style.underline = true;
          }
          wordObj.style.smallCaps = smallCapsArr[i2];
          if (fontName) wordObj.style.font = fontName;
          if (supArr[i2]) {
            wordObj.style.sup = true;
          } else if (dropcapArr[i2]) {
            wordObj.style.dropcap = true;
          }
          lineObj.words.push(wordObj);
          lettersKept++;
        }
        if (lettersKept === 0) return;
        pageObj.lines.push(lineObj);
        parLineArr.push(lineObj);
        return baselineSlope;
      }
      const lineStrArr = xmlPar.split(/<\/line>/);
      for (let i2 = 0; i2 < lineStrArr.length; i2++) {
        const angle = convertLineAbbyy(lineStrArr[i2]);
        if (typeof angle === "number" && !Number.isNaN(angle)) angleRisePage.push(angle);
      }
      if (parLineArr.length === 0) return;
      const parbox = calcBboxUnion(parLineArr.map((x2) => x2.bbox));
      const parObj = new ocrObjects_default.OcrPar(pageObj, parbox);
      parLineArr.forEach((x2) => {
        x2.par = parObj;
      });
      parObj.lines = parLineArr;
      pageObj.pars.push(parObj);
    }
    const parStrArr = xmlText.split(/<\/par>/);
    for (let i2 = 0; i2 < parStrArr.length; i2++) {
      convertParAbbyy(parStrArr[i2]);
    }
  }
  const textStrArr = ocrStr.split(/<\/text>/);
  for (let i2 = 0; i2 < textStrArr.length; i2++) {
    convertTextAbbyy(textStrArr[i2]);
  }
  const angleRiseMedian = mean50(angleRisePage) || 0;
  const angleOut = Math.asin(angleRiseMedian) * (180 / Math.PI);
  pageObj.angle = angleOut;
  const langSet = pass3(pageObj);
  return { pageObj, dataTables: tablesPage, langSet };
}
function convertTableLayoutAbbyy(n2, ocrStr) {
  const tableRegex = /<block blockType=["']Table[\s\S]+?(?:<\/block>\s*)/ig;
  const tablesStrArr = ocrStr.match(tableRegex);
  const tablesPage = new LayoutDataTablePage(n2);
  if (!tablesStrArr) return tablesPage;
  for (let i2 = 0; i2 < tablesStrArr.length; i2++) {
    const tableBoxes = [];
    const tableStr = tablesStrArr[i2];
    const tableCoords = tableStr.match(/<block blockType=['"]Table['"][^>]*?l=['"](\d+)['"] t=['"](\d+)['"] r=['"](\d+)['"] b=['"](\d+)['"]/i)?.slice(1, 5).map((x2) => parseInt(x2));
    if (!tableCoords || tableCoords[0] === void 0 || tableCoords[1] === void 0 || tableCoords[2] === void 0 || tableCoords[3] === void 0) {
      console.log("Failed to parse table");
      continue;
    }
    let leftLast = tableCoords?.[0];
    const rows = tableStr.match(/<row[\s\S]+?(?:<\/row>\s*)/g);
    const firstRow = rows?.[1] && /colSpan/.test(rows[0]) ? rows[1] : rows?.[0];
    const firstRowCells = firstRow?.match(/<cell[\s\S]+?(?:<\/cell>\s*)/ig);
    if (leftLast === null || leftLast === void 0 || !firstRowCells || !rows) {
      console.warn("Failed to parse table:");
      console.warn(tableStr);
      continue;
    }
    const table = new LayoutDataTable(tablesPage);
    for (let j2 = 0; j2 < firstRowCells.length; j2++) {
      const cell = firstRowCells[j2];
      const cellWidth = parseInt(cell.match(/width=['"](\d+)['"]/)?.[1]);
      const cellLeft = leftLast;
      const cellRight = leftLast + cellWidth;
      leftLast = cellRight;
      tableBoxes.push(new LayoutDataColumn({
        left: cellLeft,
        top: tableCoords[1],
        right: cellRight,
        bottom: tableCoords[3]
      }, table));
    }
    if (Math.abs(leftLast - tableCoords[2]) > 10) {
      let colLeftArr = [];
      let colRightArr = [];
      for (let j2 = 0; j2 < rows.length; j2++) {
        const cells = rows[j2].match(/<cell[\s\S]+?(?:<\/cell>\s*)/ig);
        if (!cells) {
          console.warn("Failed to parse rows:");
          continue;
        }
        for (let k2 = 0; k2 < cells.length; k2++) {
          const coordsArrStr = cells[k2].match(/l=['"](\d+)['"] t=['"](\d+)['"] r=['"](\d+)['"] b=['"](\d+)['"]/ig);
          if (!coordsArrStr) continue;
          const coordsArr = coordsArrStr.map((x2) => x2.match(/\d+/g).map((y2) => parseInt(y2)));
          const cellLeft = Math.min(...coordsArr.map((x2) => x2[0]));
          const cellRight = Math.max(...coordsArr.map((x2) => x2[2]));
          if (!colLeftArr[k2]) {
            colLeftArr[k2] = [];
            colRightArr[k2] = [];
          }
          colLeftArr[k2].push(cellLeft);
          colRightArr[k2].push(cellRight);
        }
      }
      colLeftArr = colLeftArr.filter((x2) => x2);
      colRightArr = colRightArr.filter((x2) => x2);
      const colLeftMin = colLeftArr.map((x2) => Math.min(...x2));
      const colRightMax = [];
      for (let j2 = 0; j2 < colRightArr.length; j2++) {
        const colRightArrJ = j2 + 1 === colRightArr.length ? colRightArr[j2] : colRightArr[j2].filter((x2) => x2 < colLeftMin[j2 + 1]);
        colRightMax.push(Math.max(...colRightArrJ));
      }
      tableBoxes.length = 0;
      for (let j2 = 0; j2 < colLeftArr.length; j2++) {
        let cellLeft;
        if (j2 === 0) {
          cellLeft = tableCoords[0];
        } else if (!Number.isFinite(colRightMax[j2 - 1])) {
          cellLeft = Math.round(colLeftMin[j2]);
        } else {
          cellLeft = Math.round((colLeftMin[j2] + colRightMax[j2 - 1]) / 2);
        }
        let cellRight;
        if (j2 + 1 === colLeftArr.length) {
          cellRight = tableCoords[2];
        } else if (!Number.isFinite(colRightMax[j2])) {
          cellRight = colLeftMin[j2 + 1];
        } else {
          cellRight = Math.round((colLeftMin[j2 + 1] + colRightMax[j2]) / 2);
        }
        tableBoxes.push(new LayoutDataColumn({
          left: cellLeft,
          top: tableCoords[1],
          right: cellRight,
          bottom: tableCoords[3]
        }, table));
      }
      if (debugMode) console.log(`Table width does not match sum of rows (${String(tableCoords[2])} vs ${String(leftLast)}), calculated new layout boxes using column contents.`);
    }
    table.boxes = tableBoxes;
    tablesPage.tables.push(table);
  }
  return tablesPage;
}

// node_modules/scribe.js-ocr/js/import/convertPageBlocks.js
var baselineCharArr = [...xCharArr, ...ascCharArr];
async function convertPageBlocks({
  ocrBlocks,
  n: n2,
  pageDims,
  keepItalic,
  rotateAngle,
  upscale = false
}) {
  rotateAngle = rotateAngle || 0;
  if (upscale) {
    pageDims.height *= 2;
    pageDims.width *= 2;
  }
  const currentLang = "eng";
  const pageObj = new ocrObjects_default.OcrPage(n2, pageDims);
  let wordCount = 0;
  for (let i2 = 0; i2 < ocrBlocks.length; i2++) {
    const block = ocrBlocks[i2];
    for (let j2 = 0; j2 < block.paragraphs.length; j2++) {
      const paragraph = block.paragraphs[j2];
      const parbox = {
        left: paragraph.bbox.x0,
        top: paragraph.bbox.y0,
        right: paragraph.bbox.x1,
        bottom: paragraph.bbox.y1
      };
      const parObj = new ocrObjects_default.OcrPar(pageObj, parbox);
      for (let k2 = 0; k2 < paragraph.lines.length; k2++) {
        const line = paragraph.lines[k2];
        const linebox = {
          left: line.bbox.x0,
          top: line.bbox.y0,
          right: line.bbox.x1,
          bottom: line.bbox.y1
        };
        const x0 = line.baseline.x0 - linebox.left;
        const x1 = line.baseline.x1 - linebox.left;
        const y0 = line.baseline.y0 - linebox.bottom;
        const y1 = line.baseline.y1 - linebox.bottom;
        const baselineSlope = (y1 - y0) / (x1 - x0);
        const baselinePoint = y0 - baselineSlope * x0;
        const baseline = [baselineSlope, baselinePoint];
        if (!Number.isFinite(baselineSlope) || !Number.isFinite(baselinePoint)) {
          baseline[0] = 0;
          baseline[1] = 0;
        }
        const ascHeight = line.rowAttributes.rowHeight - line.rowAttributes.descenders;
        const xHeight = line.rowAttributes.rowHeight - line.rowAttributes.descenders - line.rowAttributes.ascenders;
        const lineObj = new ocrObjects_default.OcrLine(pageObj, linebox, baseline, ascHeight, xHeight);
        lineObj.par = parObj;
        for (let l2 = 0; l2 < line.words.length; l2++) {
          const word = line.words[l2];
          const wordbox = {
            left: word.bbox.x0,
            top: word.bbox.y0,
            right: word.bbox.x1,
            bottom: word.bbox.y1
          };
          const id = `word_${n2 + 1}_${wordCount}`;
          wordCount++;
          if (word.text.trim() === "") continue;
          let wordLang = word.language || currentLang;
          if (["chi_sim", "chi_tra"].includes(wordLang)) {
            const { han: hanChars, latin: latinChars } = getTextScript(word.text);
            if (hanChars === 0) {
              if (!["chi_sim", "chi_tra"].includes(currentLang)) {
                wordLang = currentLang;
              } else if (latinChars > 0) {
                wordLang = "eng";
              }
            }
          }
          if (["chi_sim", "chi_tra"].includes(wordLang)) {
            for (let m2 = 0; m2 < word.symbols.length; m2++) {
              const symbol = word.symbols[m2];
              const symbolbox = {
                left: symbol.bbox.x0,
                top: symbol.bbox.y0,
                right: symbol.bbox.x1,
                bottom: symbol.bbox.y1
              };
              const wordObj2 = new ocrObjects_default.OcrWord(lineObj, `${id}_${m2}`, symbol.text, symbolbox);
              wordObj2.conf = symbol.confidence;
              wordObj2.lang = wordLang;
              lineObj.words.push(wordObj2);
            }
            continue;
          }
          const wordObj = new ocrObjects_default.OcrWord(lineObj, id, word.text.trim(), wordbox);
          wordObj.lang = word.language;
          wordObj.conf = word.confidence;
          if (word.choices.length > 0) {
            word.choices.sort((a2, b2) => b2.confidence - a2.confidence);
            if (word.choices[0].text !== word.text) {
              wordObj.textAlt = word.choices[0].text;
            }
          }
          if (keepItalic && /italic/i.test(word.font_name)) wordObj.style.italic = true;
          wordObj.style.font = word.font_name;
          wordObj.chars = [];
          for (let m2 = 0; m2 < word.symbols.length; m2++) {
            const symbol = word.symbols[m2];
            if (!symbol.text?.trim()) continue;
            const symbolbox = {
              left: symbol.bbox.x0,
              top: symbol.bbox.y0,
              right: symbol.bbox.x1,
              bottom: symbol.bbox.y1
            };
            const charObj = new ocrObjects_default.OcrChar(symbol.text, symbolbox);
            wordObj.chars.push(charObj);
          }
          lineObj.words.push(wordObj);
        }
        if (lineObj.words.length > 0) {
          if (lineObj.words.length === 1 && keepItalic && lineObj.words[0].chars) {
            const baselineBottomArr = lineObj.words[0].chars.filter((char) => baselineCharArr.includes(char.text)).map((char) => char.bbox.bottom);
            if (baselineBottomArr.length * 2 > lineObj.words[0].chars.length) {
              const baselineBottom = mean50(baselineBottomArr);
              lineObj.baseline[1] = baselineBottom - lineObj.bbox.bottom;
            }
          }
          pageObj.lines.push(lineObj);
          parObj.lines.push(lineObj);
        }
      }
      if (parObj.lines.length > 0) {
        pageObj.pars.push(parObj);
      }
    }
  }
  pageObj.angle = rotateAngle;
  if (upscale) ocrObjects_default.scalePage(pageObj, 0.5);
  pass2(pageObj, rotateAngle);
  const langSet = pass3(pageObj);
  return {
    pageObj,
    dataTables: new LayoutDataTablePage(n2),
    warn: { char: "" },
    langSet
  };
}

// node_modules/scribe.js-ocr/js/containers/app.js
var opt = class {
  static ligatures = false;
  static kerning = true;
  static omitNativeText = false;
  static extractText = false;
  static enableUpscale = false;
  static ignorePunct = false;
  static ignoreCap = false;
  static ignoreExtra = false;
  static confThreshHigh = 85;
  static confThreshMed = 75;
  static addOverlay = true;
  static standardizePageSize = false;
  static humanReadablePDF = false;
  static intermediatePDF = false;
  static reflow = true;
  static removeMargins = false;
  static includeImages = false;
  static pageBreaks = true;
  /** @type {("invis"|"ebook"|"eval"|"proof")} */
  static displayMode = "proof";
  /** @type {('color'|'gray'|'binary')} */
  static colorMode = "color";
  static overlayOpacity = 80;
  static autoRotate = true;
  static enableLayout = false;
  static xlsxFilenameColumn = true;
  static xlsxPageNumberColumn = true;
  static saveDebugImages = false;
  static warningHandler = (x2) => console.warn(x2);
  static errorHandler = (x2) => console.error(x2);
  /** @param {ProgressMessage} x */
  // eslint-disable-next-line no-unused-vars
  static progressHandler = (x2) => {
  };
  /** Generate debug visualizations when running OCR. */
  static debugVis = false;
  static extractPDFFonts = false;
  static calcSuppFontInfo = false;
  /**
   * How to use PDF text data extracted from input PDFs (if any).
   * The `native` option controls how native text data is used (i.e. visible text rendered by the PDF viewer),
   * while the `ocr` option controls how OCR text data is used (i.e. invisible text printed over an image).
   * If `main` is true, then the data will be used as the primary data source.
   * If `supp` is true, then the data will be used as a supplemental data source (may be used to correct errors in the primary data source).
   */
  static usePDFText = {
    native: {
      supp: true,
      main: true
    },
    ocr: {
      supp: true,
      main: false
    }
  };
  /**
   * Always convert and retain existing PDF text data.
   * By default (`false`), if the existing PDF text data will not be used (per the `usePDFText` settings),
   * it is discarded and never converted into the internal OCR format.
   * This performance/memory optimization can be disabled by setting this option to `true`,
   * resulting in the PDF text being converted and retained even if (for example) it is corrupted.
   */
  static keepPDFTextAlways = false;
  /**
   * Number of workers to use. Must be set prior to initialization.
   * If set to `null` (default), the number of workers will be set up to 6 (browser) or 8 (node),
   * if the system has enough resources.
   * @type {?number}
   */
  static workerN = null;
};

// node_modules/scribe.js-ocr/lib/opentype.module.js
var e;
var t;
String.prototype.codePointAt || (e = function() {
  try {
    var e2 = {}, t2 = Object.defineProperty, r2 = t2(e2, e2, e2) && t2;
  } catch (e3) {
  }
  return r2;
}(), t = function(e2) {
  if (null == this) throw TypeError();
  var t2 = String(this), r2 = t2.length, n2 = e2 ? Number(e2) : 0;
  if (n2 != n2 && (n2 = 0), !(n2 < 0 || n2 >= r2)) {
    var a2, o2 = t2.charCodeAt(n2);
    return o2 >= 55296 && o2 <= 56319 && r2 > n2 + 1 && (a2 = t2.charCodeAt(n2 + 1)) >= 56320 && a2 <= 57343 ? 1024 * (o2 - 55296) + a2 - 56320 + 65536 : o2;
  }
}, e ? e(String.prototype, "codePointAt", { value: t, configurable: true, writable: true }) : String.prototype.codePointAt = t);
var r = 0;
var n = -3;
function a() {
  this.table = new Uint16Array(16), this.trans = new Uint16Array(288);
}
function o(e2, t2) {
  this.source = e2, this.sourceIndex = 0, this.tag = 0, this.bitcount = 0, this.dest = t2, this.destLen = 0, this.ltree = new a(), this.dtree = new a();
}
var s = new a();
var i = new a();
var u = new Uint8Array(30);
var l = new Uint16Array(30);
var p = new Uint8Array(30);
var c = new Uint16Array(30);
var h = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var f = new a();
var d = new Uint8Array(320);
function v(e2, t2, r2, n2) {
  var a2, o2;
  for (a2 = 0; a2 < r2; ++a2) e2[a2] = 0;
  for (a2 = 0; a2 < 30 - r2; ++a2) e2[a2 + r2] = a2 / r2 | 0;
  for (o2 = n2, a2 = 0; a2 < 30; ++a2) t2[a2] = o2, o2 += 1 << e2[a2];
}
var g = new Uint16Array(16);
function m(e2, t2, r2, n2) {
  var a2, o2;
  for (a2 = 0; a2 < 16; ++a2) e2.table[a2] = 0;
  for (a2 = 0; a2 < n2; ++a2) e2.table[t2[r2 + a2]]++;
  for (e2.table[0] = 0, o2 = 0, a2 = 0; a2 < 16; ++a2) g[a2] = o2, o2 += e2.table[a2];
  for (a2 = 0; a2 < n2; ++a2) t2[r2 + a2] && (e2.trans[g[t2[r2 + a2]]++] = a2);
}
function y(e2) {
  e2.bitcount-- || (e2.tag = e2.source[e2.sourceIndex++], e2.bitcount = 7);
  var t2 = 1 & e2.tag;
  return e2.tag >>>= 1, t2;
}
function b(e2, t2, r2) {
  if (!t2) return r2;
  for (; e2.bitcount < 24; ) e2.tag |= e2.source[e2.sourceIndex++] << e2.bitcount, e2.bitcount += 8;
  var n2 = e2.tag & 65535 >>> 16 - t2;
  return e2.tag >>>= t2, e2.bitcount -= t2, n2 + r2;
}
function S(e2, t2) {
  for (; e2.bitcount < 24; ) e2.tag |= e2.source[e2.sourceIndex++] << e2.bitcount, e2.bitcount += 8;
  var r2 = 0, n2 = 0, a2 = 0, o2 = e2.tag;
  do {
    n2 = 2 * n2 + (1 & o2), o2 >>>= 1, ++a2, r2 += t2.table[a2], n2 -= t2.table[a2];
  } while (n2 >= 0);
  return e2.tag = o2, e2.bitcount -= a2, t2.trans[r2 + n2];
}
function x(e2, t2, r2) {
  var n2, a2, o2, s2, i2, u2;
  for (n2 = b(e2, 5, 257), a2 = b(e2, 5, 1), o2 = b(e2, 4, 4), s2 = 0; s2 < 19; ++s2) d[s2] = 0;
  for (s2 = 0; s2 < o2; ++s2) {
    var l2 = b(e2, 3, 0);
    d[h[s2]] = l2;
  }
  for (m(f, d, 0, 19), i2 = 0; i2 < n2 + a2; ) {
    var p2 = S(e2, f);
    switch (p2) {
      case 16:
        var c2 = d[i2 - 1];
        for (u2 = b(e2, 2, 3); u2; --u2) d[i2++] = c2;
        break;
      case 17:
        for (u2 = b(e2, 3, 3); u2; --u2) d[i2++] = 0;
        break;
      case 18:
        for (u2 = b(e2, 7, 11); u2; --u2) d[i2++] = 0;
        break;
      default:
        d[i2++] = p2;
    }
  }
  m(t2, d, 0, n2), m(r2, d, n2, a2);
}
function T(e2, t2, n2) {
  for (; ; ) {
    var a2, o2, s2, i2, h2 = S(e2, t2);
    if (256 === h2) return r;
    if (h2 < 256) e2.dest[e2.destLen++] = h2;
    else for (a2 = b(e2, u[h2 -= 257], l[h2]), o2 = S(e2, n2), i2 = s2 = e2.destLen - b(e2, p[o2], c[o2]); i2 < s2 + a2; ++i2) e2.dest[e2.destLen++] = e2.dest[i2];
  }
}
function U(e2) {
  for (var t2, a2; e2.bitcount > 8; ) e2.sourceIndex--, e2.bitcount -= 8;
  if ((t2 = 256 * (t2 = e2.source[e2.sourceIndex + 1]) + e2.source[e2.sourceIndex]) !== (65535 & ~(256 * e2.source[e2.sourceIndex + 3] + e2.source[e2.sourceIndex + 2]))) return n;
  for (e2.sourceIndex += 4, a2 = t2; a2; --a2) e2.dest[e2.destLen++] = e2.source[e2.sourceIndex++];
  return e2.bitcount = 0, r;
}
!function(e2, t2) {
  var r2;
  for (r2 = 0; r2 < 7; ++r2) e2.table[r2] = 0;
  for (e2.table[7] = 24, e2.table[8] = 152, e2.table[9] = 112, r2 = 0; r2 < 24; ++r2) e2.trans[r2] = 256 + r2;
  for (r2 = 0; r2 < 144; ++r2) e2.trans[24 + r2] = r2;
  for (r2 = 0; r2 < 8; ++r2) e2.trans[168 + r2] = 280 + r2;
  for (r2 = 0; r2 < 112; ++r2) e2.trans[176 + r2] = 144 + r2;
  for (r2 = 0; r2 < 5; ++r2) t2.table[r2] = 0;
  for (t2.table[5] = 32, r2 = 0; r2 < 32; ++r2) t2.trans[r2] = r2;
}(s, i), v(u, l, 4, 3), v(p, c, 2, 1), u[28] = 0, l[28] = 258;
var k = function(e2, t2) {
  var a2, u2, l2 = new o(e2, t2);
  do {
    switch (a2 = y(l2), b(l2, 2, 0)) {
      case 0:
        u2 = U(l2);
        break;
      case 1:
        u2 = T(l2, s, i);
        break;
      case 2:
        x(l2, l2.ltree, l2.dtree), u2 = T(l2, l2.ltree, l2.dtree);
        break;
      default:
        u2 = n;
    }
    if (u2 !== r) throw new Error("Data error");
  } while (!a2);
  return l2.destLen < l2.dest.length ? "function" == typeof l2.dest.slice ? l2.dest.slice(0, l2.destLen) : l2.dest.subarray(0, l2.destLen) : l2.dest;
};
function O(e2, t2, r2, n2, a2) {
  return Math.pow(1 - a2, 3) * e2 + 3 * Math.pow(1 - a2, 2) * a2 * t2 + 3 * (1 - a2) * Math.pow(a2, 2) * r2 + Math.pow(a2, 3) * n2;
}
function R() {
  this.x1 = Number.NaN, this.y1 = Number.NaN, this.x2 = Number.NaN, this.y2 = Number.NaN;
}
function E() {
  this.commands = [], this.fill = "black", this.stroke = null, this.strokeWidth = 1;
}
function L(e2) {
  throw new Error(e2);
}
function C(e2, t2) {
  e2 || L(t2);
}
R.prototype.isEmpty = function() {
  return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
}, R.prototype.addPoint = function(e2, t2) {
  "number" == typeof e2 && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = e2, this.x2 = e2), e2 < this.x1 && (this.x1 = e2), e2 > this.x2 && (this.x2 = e2)), "number" == typeof t2 && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = t2, this.y2 = t2), t2 < this.y1 && (this.y1 = t2), t2 > this.y2 && (this.y2 = t2));
}, R.prototype.addX = function(e2) {
  this.addPoint(e2, null);
}, R.prototype.addY = function(e2) {
  this.addPoint(null, e2);
}, R.prototype.addBezier = function(e2, t2, r2, n2, a2, o2, s2, i2) {
  var u2 = [e2, t2], l2 = [r2, n2], p2 = [a2, o2], c2 = [s2, i2];
  this.addPoint(e2, t2), this.addPoint(s2, i2);
  for (var h2 = 0; h2 <= 1; h2++) {
    var f2 = 6 * u2[h2] - 12 * l2[h2] + 6 * p2[h2], d2 = -3 * u2[h2] + 9 * l2[h2] - 9 * p2[h2] + 3 * c2[h2], v2 = 3 * l2[h2] - 3 * u2[h2];
    if (0 !== d2) {
      var g2 = Math.pow(f2, 2) - 4 * v2 * d2;
      if (!(g2 < 0)) {
        var m2 = (-f2 + Math.sqrt(g2)) / (2 * d2);
        0 < m2 && m2 < 1 && (0 === h2 && this.addX(O(u2[h2], l2[h2], p2[h2], c2[h2], m2)), 1 === h2 && this.addY(O(u2[h2], l2[h2], p2[h2], c2[h2], m2)));
        var y2 = (-f2 - Math.sqrt(g2)) / (2 * d2);
        0 < y2 && y2 < 1 && (0 === h2 && this.addX(O(u2[h2], l2[h2], p2[h2], c2[h2], y2)), 1 === h2 && this.addY(O(u2[h2], l2[h2], p2[h2], c2[h2], y2)));
      }
    } else {
      if (0 === f2) continue;
      var b2 = -v2 / f2;
      0 < b2 && b2 < 1 && (0 === h2 && this.addX(O(u2[h2], l2[h2], p2[h2], c2[h2], b2)), 1 === h2 && this.addY(O(u2[h2], l2[h2], p2[h2], c2[h2], b2)));
    }
  }
}, R.prototype.addQuad = function(e2, t2, r2, n2, a2, o2) {
  var s2 = e2 + 2 / 3 * (r2 - e2), i2 = t2 + 2 / 3 * (n2 - t2), u2 = s2 + 1 / 3 * (a2 - e2), l2 = i2 + 1 / 3 * (o2 - t2);
  this.addBezier(e2, t2, s2, i2, u2, l2, a2, o2);
}, E.prototype.moveTo = function(e2, t2) {
  this.commands.push({ type: "M", x: e2, y: t2 });
}, E.prototype.lineTo = function(e2, t2) {
  this.commands.push({ type: "L", x: e2, y: t2 });
}, E.prototype.curveTo = E.prototype.bezierCurveTo = function(e2, t2, r2, n2, a2, o2) {
  this.commands.push({ type: "C", x1: e2, y1: t2, x2: r2, y2: n2, x: a2, y: o2 });
}, E.prototype.quadTo = E.prototype.quadraticCurveTo = function(e2, t2, r2, n2) {
  this.commands.push({ type: "Q", x1: e2, y1: t2, x: r2, y: n2 });
}, E.prototype.close = E.prototype.closePath = function() {
  this.commands.push({ type: "Z" });
}, E.prototype.extend = function(e2) {
  if (e2.commands) e2 = e2.commands;
  else if (e2 instanceof R) {
    var t2 = e2;
    return this.moveTo(t2.x1, t2.y1), this.lineTo(t2.x2, t2.y1), this.lineTo(t2.x2, t2.y2), this.lineTo(t2.x1, t2.y2), void this.close();
  }
  Array.prototype.push.apply(this.commands, e2);
}, E.prototype.getBoundingBox = function() {
  for (var e2 = new R(), t2 = 0, r2 = 0, n2 = 0, a2 = 0, o2 = 0; o2 < this.commands.length; o2++) {
    var s2 = this.commands[o2];
    switch (s2.type) {
      case "M":
        e2.addPoint(s2.x, s2.y), t2 = n2 = s2.x, r2 = a2 = s2.y;
        break;
      case "L":
        e2.addPoint(s2.x, s2.y), n2 = s2.x, a2 = s2.y;
        break;
      case "Q":
        e2.addQuad(n2, a2, s2.x1, s2.y1, s2.x, s2.y), n2 = s2.x, a2 = s2.y;
        break;
      case "C":
        e2.addBezier(n2, a2, s2.x1, s2.y1, s2.x2, s2.y2, s2.x, s2.y), n2 = s2.x, a2 = s2.y;
        break;
      case "Z":
        n2 = t2, a2 = r2;
        break;
      default:
        throw new Error("Unexpected path command " + s2.type);
    }
  }
  return e2.isEmpty() && e2.addPoint(0, 0), e2;
}, E.prototype.draw = function(e2) {
  e2.beginPath();
  for (var t2 = 0; t2 < this.commands.length; t2 += 1) {
    var r2 = this.commands[t2];
    "M" === r2.type ? e2.moveTo(r2.x, r2.y) : "L" === r2.type ? e2.lineTo(r2.x, r2.y) : "C" === r2.type ? e2.bezierCurveTo(r2.x1, r2.y1, r2.x2, r2.y2, r2.x, r2.y) : "Q" === r2.type ? e2.quadraticCurveTo(r2.x1, r2.y1, r2.x, r2.y) : "Z" === r2.type && e2.closePath();
  }
  this.fill && (e2.fillStyle = this.fill, e2.fill()), this.stroke && (e2.strokeStyle = this.stroke, e2.lineWidth = this.strokeWidth, e2.stroke());
}, E.prototype.toPathData = function(e2) {
  function t2(t3) {
    return Math.round(t3) === t3 ? "" + Math.round(t3) : t3.toFixed(e2);
  }
  function r2() {
    for (var e3 = arguments, r3 = "", n3 = 0; n3 < arguments.length; n3 += 1) {
      var a3 = e3[n3];
      a3 >= 0 && n3 > 0 && (r3 += " "), r3 += t2(a3);
    }
    return r3;
  }
  e2 = void 0 !== e2 ? e2 : 2;
  for (var n2 = "", a2 = 0; a2 < this.commands.length; a2 += 1) {
    var o2 = this.commands[a2];
    "M" === o2.type ? n2 += "M" + r2(o2.x, o2.y) : "L" === o2.type ? n2 += "L" + r2(o2.x, o2.y) : "C" === o2.type ? n2 += "C" + r2(o2.x1, o2.y1, o2.x2, o2.y2, o2.x, o2.y) : "Q" === o2.type ? n2 += "Q" + r2(o2.x1, o2.y1, o2.x, o2.y) : "Z" === o2.type && (n2 += "Z");
  }
  return n2;
}, E.prototype.toSVG = function(e2) {
  var t2 = '<path d="';
  return t2 += this.toPathData(e2), t2 += '"', this.fill && "black" !== this.fill && (null === this.fill ? t2 += ' fill="none"' : t2 += ' fill="' + this.fill + '"'), this.stroke && (t2 += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"'), t2 += "/>";
}, E.prototype.toDOMElement = function(e2) {
  var t2 = this.toPathData(e2), r2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
  return r2.setAttribute("d", t2), r2;
};
var w = { fail: L, argument: C, assert: C };
var D = 2147483648;
var I = {};
var G = {};
var M = {};
function B(e2) {
  return function() {
    return e2;
  };
}
G.BYTE = function(e2) {
  return w.argument(e2 >= 0 && e2 <= 255, "Byte value should be between 0 and 255."), [e2];
}, M.BYTE = B(1), G.CHAR = function(e2) {
  return [e2.charCodeAt(0)];
}, M.CHAR = B(1), G.CHARARRAY = function(e2) {
  void 0 === e2 && (e2 = "", console.warn("Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name."));
  for (var t2 = [], r2 = 0; r2 < e2.length; r2 += 1) t2[r2] = e2.charCodeAt(r2);
  return t2;
}, M.CHARARRAY = function(e2) {
  return void 0 === e2 ? 0 : e2.length;
}, G.USHORT = function(e2) {
  return [e2 >> 8 & 255, 255 & e2];
}, M.USHORT = B(2), G.SHORT = function(e2) {
  return e2 >= 32768 && (e2 = -(65536 - e2)), [e2 >> 8 & 255, 255 & e2];
}, M.SHORT = B(2), G.UINT24 = function(e2) {
  return [e2 >> 16 & 255, e2 >> 8 & 255, 255 & e2];
}, M.UINT24 = B(3), G.ULONG = function(e2) {
  return [e2 >> 24 & 255, e2 >> 16 & 255, e2 >> 8 & 255, 255 & e2];
}, M.ULONG = B(4), G.LONG = function(e2) {
  return e2 >= D && (e2 = -(2 * D - e2)), [e2 >> 24 & 255, e2 >> 16 & 255, e2 >> 8 & 255, 255 & e2];
}, M.LONG = B(4), G.FIXED = G.ULONG, M.FIXED = M.ULONG, G.FWORD = G.SHORT, M.FWORD = M.SHORT, G.UFWORD = G.USHORT, M.UFWORD = M.USHORT, G.LONGDATETIME = function(e2) {
  return [0, 0, 0, 0, e2 >> 24 & 255, e2 >> 16 & 255, e2 >> 8 & 255, 255 & e2];
}, M.LONGDATETIME = B(8), G.TAG = function(e2) {
  return w.argument(4 === e2.length, "Tag should be exactly 4 ASCII characters."), [e2.charCodeAt(0), e2.charCodeAt(1), e2.charCodeAt(2), e2.charCodeAt(3)];
}, M.TAG = B(4), G.Card8 = G.BYTE, M.Card8 = M.BYTE, G.Card16 = G.USHORT, M.Card16 = M.USHORT, G.OffSize = G.BYTE, M.OffSize = M.BYTE, G.SID = G.USHORT, M.SID = M.USHORT, G.NUMBER = function(e2) {
  return e2 >= -107 && e2 <= 107 ? [e2 + 139] : e2 >= 108 && e2 <= 1131 ? [247 + ((e2 -= 108) >> 8), 255 & e2] : e2 >= -1131 && e2 <= -108 ? [251 + ((e2 = -e2 - 108) >> 8), 255 & e2] : e2 >= -32768 && e2 <= 32767 ? G.NUMBER16(e2) : G.NUMBER32(e2);
}, M.NUMBER = function(e2) {
  return G.NUMBER(e2).length;
}, G.NUMBER16 = function(e2) {
  return [28, e2 >> 8 & 255, 255 & e2];
}, M.NUMBER16 = B(3), G.NUMBER32 = function(e2) {
  return [29, e2 >> 24 & 255, e2 >> 16 & 255, e2 >> 8 & 255, 255 & e2];
}, M.NUMBER32 = B(5), G.REAL = function(e2) {
  var t2 = e2.toString(), r2 = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(t2);
  if (r2) {
    var n2 = parseFloat("1e" + ((r2[2] ? +r2[2] : 0) + r2[1].length));
    t2 = (Math.round(e2 * n2) / n2).toString();
  }
  for (var a2 = "", o2 = 0, s2 = t2.length; o2 < s2; o2 += 1) {
    var i2 = t2[o2];
    a2 += "e" === i2 ? "-" === t2[++o2] ? "c" : "b" : "." === i2 ? "a" : "-" === i2 ? "e" : i2;
  }
  for (var u2 = [30], l2 = 0, p2 = (a2 += 1 & a2.length ? "f" : "ff").length; l2 < p2; l2 += 2) u2.push(parseInt(a2.substr(l2, 2), 16));
  return u2;
}, M.REAL = function(e2) {
  return G.REAL(e2).length;
}, G.NAME = G.CHARARRAY, M.NAME = M.CHARARRAY, G.STRING = G.CHARARRAY, M.STRING = M.CHARARRAY, I.UTF8 = function(e2, t2, r2) {
  for (var n2 = [], a2 = r2, o2 = 0; o2 < a2; o2++, t2 += 1) n2[o2] = e2.getUint8(t2);
  return String.fromCharCode.apply(null, n2);
}, I.UTF16 = function(e2, t2, r2) {
  for (var n2 = [], a2 = r2 / 2, o2 = 0; o2 < a2; o2++, t2 += 2) n2[o2] = e2.getUint16(t2);
  return String.fromCharCode.apply(null, n2);
}, G.UTF16 = function(e2) {
  for (var t2 = [], r2 = 0; r2 < e2.length; r2 += 1) {
    var n2 = e2.charCodeAt(r2);
    t2[t2.length] = n2 >> 8 & 255, t2[t2.length] = 255 & n2;
  }
  return t2;
}, M.UTF16 = function(e2) {
  return 2 * e2.length;
};
var F = { "x-mac-croatian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u03A9\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uF8FF\xA9\u2044\u20AC\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7", "x-mac-cyrillic": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\u0490\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E", "x-mac-gaelic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u1E02\xB1\u2264\u2265\u1E03\u010A\u010B\u1E0A\u1E0B\u1E1E\u1E1F\u0120\u0121\u1E40\xE6\xF8\u1E41\u1E56\u1E57\u027C\u0192\u017F\u1E60\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\u1E61\u1E9B\xFF\u0178\u1E6A\u20AC\u2039\u203A\u0176\u0177\u1E6B\xB7\u1EF2\u1EF3\u204A\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u2663\xD2\xDA\xDB\xD9\u0131\xDD\xFD\u0174\u0175\u1E84\u1E85\u1E80\u1E81\u1E82\u1E83", "x-mac-greek": "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\u20AC\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\xB7\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\xAD", "x-mac-icelandic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7", "x-mac-inuit": "\u1403\u1404\u1405\u1406\u140A\u140B\u1431\u1432\u1433\u1434\u1438\u1439\u1449\u144E\u144F\u1450\u1451\u1455\u1456\u1466\u146D\u146E\u146F\u1470\u1472\u1473\u1483\u148B\u148C\u148D\u148E\u1490\u1491\xB0\u14A1\u14A5\u14A6\u2022\xB6\u14A7\xAE\xA9\u2122\u14A8\u14AA\u14AB\u14BB\u14C2\u14C3\u14C4\u14C5\u14C7\u14C8\u14D0\u14EF\u14F0\u14F1\u14F2\u14F4\u14F5\u1505\u14D5\u14D6\u14D7\u14D8\u14DA\u14DB\u14EA\u1528\u1529\u152A\u152B\u152D\u2026\xA0\u152E\u153E\u1555\u1556\u1557\u2013\u2014\u201C\u201D\u2018\u2019\u1558\u1559\u155A\u155D\u1546\u1547\u1548\u1549\u154B\u154C\u1550\u157F\u1580\u1581\u1582\u1583\u1584\u1585\u158F\u1590\u1591\u1592\u1593\u1594\u1595\u1671\u1672\u1673\u1674\u1675\u1676\u1596\u15A0\u15A1\u15A2\u15A3\u15A4\u15A5\u15A6\u157C\u0141\u0142", "x-mac-ce": "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026\xA0\u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7", macintosh: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7", "x-mac-romanian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u0218\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\u0103\u0219\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\u021A\u021B\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7", "x-mac-turkish": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\uF8A0\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7" };
I.MACSTRING = function(e2, t2, r2, n2) {
  var a2 = F[n2];
  if (void 0 !== a2) {
    for (var o2 = "", s2 = 0; s2 < r2; s2++) {
      var i2 = e2.getUint8(t2 + s2);
      o2 += i2 <= 127 ? String.fromCharCode(i2) : a2[127 & i2];
    }
    return o2;
  }
};
var P;
var A = "function" == typeof WeakMap && /* @__PURE__ */ new WeakMap();
function N(e2) {
  return e2 >= -128 && e2 <= 127;
}
function H(e2, t2, r2) {
  for (var n2 = 0, a2 = e2.length; t2 < a2 && n2 < 64 && 0 === e2[t2]; ) ++t2, ++n2;
  return r2.push(128 | n2 - 1), t2;
}
function z(e2, t2, r2) {
  for (var n2 = 0, a2 = e2.length, o2 = t2; o2 < a2 && n2 < 64; ) {
    var s2 = e2[o2];
    if (!N(s2)) break;
    if (0 === s2 && o2 + 1 < a2 && 0 === e2[o2 + 1]) break;
    ++o2, ++n2;
  }
  r2.push(n2 - 1);
  for (var i2 = t2; i2 < o2; ++i2) r2.push(e2[i2] + 256 & 255);
  return o2;
}
function W(e2, t2, r2) {
  for (var n2 = 0, a2 = e2.length, o2 = t2; o2 < a2 && n2 < 64; ) {
    var s2 = e2[o2];
    if (0 === s2) break;
    if (N(s2) && o2 + 1 < a2 && N(e2[o2 + 1])) break;
    ++o2, ++n2;
  }
  r2.push(64 | n2 - 1);
  for (var i2 = t2; i2 < o2; ++i2) {
    var u2 = e2[i2];
    r2.push(u2 + 65536 >> 8 & 255, u2 + 256 & 255);
  }
  return o2;
}
G.MACSTRING = function(e2, t2) {
  var r2 = function(e3) {
    if (!P) for (var t3 in P = {}, F) P[t3] = new String(t3);
    var r3 = P[e3];
    if (void 0 !== r3) {
      if (A) {
        var n3 = A.get(r3);
        if (void 0 !== n3) return n3;
      }
      var a3 = F[e3];
      if (void 0 !== a3) {
        for (var o3 = {}, s2 = 0; s2 < a3.length; s2++) o3[a3.charCodeAt(s2)] = s2 + 128;
        return A && A.set(r3, o3), o3;
      }
    }
  }(t2);
  if (void 0 !== r2) {
    for (var n2 = [], a2 = 0; a2 < e2.length; a2++) {
      var o2 = e2.charCodeAt(a2);
      if (o2 >= 128 && void 0 === (o2 = r2[o2])) return;
      n2[a2] = o2;
    }
    return n2;
  }
}, M.MACSTRING = function(e2, t2) {
  var r2 = G.MACSTRING(e2, t2);
  return void 0 !== r2 ? r2.length : 0;
}, G.VARDELTAS = function(e2) {
  for (var t2 = 0, r2 = []; t2 < e2.length; ) {
    var n2 = e2[t2];
    t2 = 0 === n2 ? H(e2, t2, r2) : n2 >= -128 && n2 <= 127 ? z(e2, t2, r2) : W(e2, t2, r2);
  }
  return r2;
}, G.INDEX = function(e2) {
  for (var t2 = 1, r2 = [t2], n2 = [], a2 = 0; a2 < e2.length; a2 += 1) {
    var o2 = G.OBJECT(e2[a2]);
    Array.prototype.push.apply(n2, o2), t2 += o2.length, r2.push(t2);
  }
  if (0 === n2.length) return [0, 0];
  for (var s2 = [], i2 = 1 + Math.floor(Math.log(t2) / Math.log(2)) / 8 | 0, u2 = [void 0, G.BYTE, G.USHORT, G.UINT24, G.ULONG][i2], l2 = 0; l2 < r2.length; l2 += 1) {
    var p2 = u2(r2[l2]);
    Array.prototype.push.apply(s2, p2);
  }
  return Array.prototype.concat(G.Card16(e2.length), G.OffSize(i2), s2, n2);
}, M.INDEX = function(e2) {
  return G.INDEX(e2).length;
}, G.DICT = function(e2) {
  for (var t2 = [], r2 = Object.keys(e2), n2 = r2.length, a2 = 0; a2 < n2; a2 += 1) {
    for (var o2 = parseInt(r2[a2], 0), s2 = e2[o2], i2 = G.OPERAND(s2.value, s2.type), u2 = G.OPERATOR(o2), l2 = 0; l2 < i2.length; l2++) t2.push(i2[l2]);
    for (var p2 = 0; p2 < u2.length; p2++) t2.push(u2[p2]);
  }
  return t2;
}, M.DICT = function(e2) {
  return G.DICT(e2).length;
}, G.OPERATOR = function(e2) {
  return e2 < 1200 ? [e2] : [12, e2 - 1200];
}, G.OPERAND = function(e2, t2) {
  var r2 = [];
  if (Array.isArray(t2)) for (var n2 = 0; n2 < t2.length; n2 += 1) {
    w.argument(e2.length === t2.length, "Not enough arguments given for type" + t2);
    for (var a2 = G.OPERAND(e2[n2], t2[n2]), o2 = 0; o2 < a2.length; o2++) r2.push(a2[o2]);
  }
  else if ("SID" === t2) for (var s2 = G.NUMBER(e2), i2 = 0; i2 < s2.length; i2++) r2.push(s2[i2]);
  else if ("offset" === t2) for (var u2 = G.NUMBER32(e2), l2 = 0; l2 < u2.length; l2++) r2.push(u2[l2]);
  else if ("number" === t2) for (var p2 = G.NUMBER(e2), c2 = 0; c2 < p2.length; c2++) r2.push(p2[c2]);
  else {
    if ("real" !== t2) throw new Error("Unknown operand type " + t2);
    for (var h2 = G.REAL(e2), f2 = 0; f2 < h2.length; f2++) r2.push(h2[f2]);
  }
  return r2;
}, G.OP = G.BYTE, M.OP = M.BYTE;
var q = "function" == typeof WeakMap && /* @__PURE__ */ new WeakMap();
function _(e2, t2, r2) {
  if (t2.length && ("coverageFormat" !== t2[0].name || 1 === t2[0].value)) for (var n2 = 0; n2 < t2.length; n2 += 1) {
    var a2 = t2[n2];
    this[a2.name] = a2.value;
  }
  if (this.tableName = e2, this.fields = t2, r2) for (var o2 = Object.keys(r2), s2 = 0; s2 < o2.length; s2 += 1) {
    var i2 = o2[s2], u2 = r2[i2];
    void 0 !== this[i2] && (this[i2] = u2);
  }
}
function X(e2, t2, r2) {
  void 0 === r2 && (r2 = t2.length);
  var n2 = new Array(t2.length + 1);
  n2[0] = { name: e2 + "Count", type: "USHORT", value: r2 };
  for (var a2 = 0; a2 < t2.length; a2++) n2[a2 + 1] = { name: e2 + a2, type: "USHORT", value: t2[a2] };
  return n2;
}
function V(e2, t2, r2) {
  var n2 = t2.length, a2 = new Array(n2 + 1);
  a2[0] = { name: e2 + "Count", type: "USHORT", value: n2 };
  for (var o2 = 0; o2 < n2; o2++) a2[o2 + 1] = { name: e2 + o2, type: "TABLE", value: r2(t2[o2], o2) };
  return a2;
}
function j(e2, t2, r2) {
  var n2 = t2.length, a2 = [];
  a2[0] = { name: e2 + "Count", type: "USHORT", value: n2 };
  for (var o2 = 0; o2 < n2; o2++) a2 = a2.concat(r2(t2[o2], o2));
  return a2;
}
function Y(e2) {
  1 === e2.format ? _.call(this, "coverageTable", [{ name: "coverageFormat", type: "USHORT", value: 1 }].concat(X("glyph", e2.glyphs))) : 2 === e2.format ? _.call(this, "coverageTable", [{ name: "coverageFormat", type: "USHORT", value: 2 }].concat(j("rangeRecord", e2.ranges, function(e3) {
    return [{ name: "startGlyphID", type: "USHORT", value: e3.start }, { name: "endGlyphID", type: "USHORT", value: e3.end }, { name: "startCoverageIndex", type: "USHORT", value: e3.index }];
  }))) : w.assert(false, "Coverage format must be 1 or 2.");
}
function Z(e2) {
  _.call(this, "scriptListTable", j("scriptRecord", e2, function(e3, t2) {
    var r2 = e3.script, n2 = r2.defaultLangSys;
    return w.assert(!!n2, "Unable to write GSUB: script " + e3.tag + " has no default language system."), [{ name: "scriptTag" + t2, type: "TAG", value: e3.tag }, { name: "script" + t2, type: "TABLE", value: new _("scriptTable", [{ name: "defaultLangSys", type: "TABLE", value: new _("defaultLangSys", [{ name: "lookupOrder", type: "USHORT", value: 0 }, { name: "reqFeatureIndex", type: "USHORT", value: n2.reqFeatureIndex }].concat(X("featureIndex", n2.featureIndexes))) }].concat(j("langSys", r2.langSysRecords, function(e4, t3) {
      var r3 = e4.langSys;
      return [{ name: "langSysTag" + t3, type: "TAG", value: e4.tag }, { name: "langSys" + t3, type: "TABLE", value: new _("langSys", [{ name: "lookupOrder", type: "USHORT", value: 0 }, { name: "reqFeatureIndex", type: "USHORT", value: r3.reqFeatureIndex }].concat(X("featureIndex", r3.featureIndexes))) }];
    }))) }];
  }));
}
function Q(e2) {
  _.call(this, "featureListTable", j("featureRecord", e2, function(e3, t2) {
    var r2 = e3.feature;
    return [{ name: "featureTag" + t2, type: "TAG", value: e3.tag }, { name: "feature" + t2, type: "TABLE", value: new _("featureTable", [{ name: "featureParams", type: "USHORT", value: r2.featureParams }].concat(X("lookupListIndex", r2.lookupListIndexes))) }];
  }));
}
function K(e2, t2) {
  _.call(this, "lookupListTable", V("lookup", e2, function(e3) {
    var r2 = t2[e3.lookupType];
    return w.assert(!!r2, "Unable to write GSUB lookup type " + e3.lookupType + " tables."), new _("lookupTable", [{ name: "lookupType", type: "USHORT", value: e3.lookupType }, { name: "lookupFlag", type: "USHORT", value: e3.lookupFlag }].concat(V("subtable", e3.subtables, r2)));
  }));
}
G.CHARSTRING = function(e2) {
  if (q) {
    var t2 = q.get(e2);
    if (void 0 !== t2) return t2;
  }
  for (var r2 = [], n2 = e2.length, a2 = 0; a2 < n2; a2 += 1) for (var o2 = e2[a2], s2 = G[o2.type](o2.value), i2 = 0; i2 < s2.length; i2++) r2.push(s2[i2]);
  return q && q.set(e2, r2), r2;
}, M.CHARSTRING = function(e2) {
  return G.CHARSTRING(e2).length;
}, G.OBJECT = function(e2) {
  var t2 = G[e2.type];
  return w.argument(void 0 !== t2, "No encoding function for type " + e2.type), t2(e2.value);
}, M.OBJECT = function(e2) {
  var t2 = M[e2.type];
  return w.argument(void 0 !== t2, "No sizeOf function for type " + e2.type), t2(e2.value);
}, G.TABLE = function(e2) {
  for (var t2 = [], r2 = e2.fields.length, n2 = [], a2 = [], o2 = 0; o2 < r2; o2 += 1) {
    var s2 = e2.fields[o2], i2 = G[s2.type];
    w.argument(void 0 !== i2, "No encoding function for field type " + s2.type + " (" + s2.name + ")");
    var u2 = e2[s2.name];
    void 0 === u2 && (u2 = s2.value);
    var l2 = i2(u2);
    if ("TABLE" === s2.type) a2.push(t2.length), t2.push(0, 0), n2.push(l2);
    else for (var p2 = 0; p2 < l2.length; p2++) t2.push(l2[p2]);
  }
  for (var c2 = 0; c2 < n2.length; c2 += 1) {
    var h2 = a2[c2], f2 = t2.length;
    w.argument(f2 < 65536, "Table " + e2.tableName + " too big."), t2[h2] = f2 >> 8, t2[h2 + 1] = 255 & f2;
    for (var d2 = 0; d2 < n2[c2].length; d2++) t2.push(n2[c2][d2]);
  }
  return t2;
}, M.TABLE = function(e2) {
  for (var t2 = 0, r2 = e2.fields.length, n2 = 0; n2 < r2; n2 += 1) {
    var a2 = e2.fields[n2], o2 = M[a2.type];
    w.argument(void 0 !== o2, "No sizeOf function for field type " + a2.type + " (" + a2.name + ")");
    var s2 = e2[a2.name];
    void 0 === s2 && (s2 = a2.value), t2 += o2(s2), "TABLE" === a2.type && (t2 += 2);
  }
  return t2;
}, G.RECORD = G.TABLE, M.RECORD = M.TABLE, G.LITERAL = function(e2) {
  return e2;
}, M.LITERAL = function(e2) {
  return e2.length;
}, _.prototype.encode = function() {
  return G.TABLE(this);
}, _.prototype.sizeOf = function() {
  return M.TABLE(this);
}, Y.prototype = Object.create(_.prototype), Y.prototype.constructor = Y, Z.prototype = Object.create(_.prototype), Z.prototype.constructor = Z, Q.prototype = Object.create(_.prototype), Q.prototype.constructor = Q, K.prototype = Object.create(_.prototype), K.prototype.constructor = K;
var J = { Table: _, Record: _, Coverage: Y, ScriptList: Z, FeatureList: Q, LookupList: K, ushortList: X, tableList: V, recordList: j };
function $(e2, t2) {
  return e2.getUint8(t2);
}
function ee(e2, t2) {
  return e2.getUint16(t2, false);
}
function te(e2, t2) {
  return e2.getUint32(t2, false);
}
function re(e2, t2) {
  return e2.getInt16(t2, false) + e2.getUint16(t2 + 2, false) / 65535;
}
var ne = { byte: 1, uShort: 2, short: 2, uLong: 4, fixed: 4, longDateTime: 8, tag: 4 };
function ae(e2, t2) {
  this.data = e2, this.offset = t2, this.relativeOffset = 0;
}
ae.prototype.parseByte = function() {
  var e2 = this.data.getUint8(this.offset + this.relativeOffset);
  return this.relativeOffset += 1, e2;
}, ae.prototype.parseChar = function() {
  var e2 = this.data.getInt8(this.offset + this.relativeOffset);
  return this.relativeOffset += 1, e2;
}, ae.prototype.parseCard8 = ae.prototype.parseByte, ae.prototype.parseUShort = function() {
  var e2 = this.data.getUint16(this.offset + this.relativeOffset);
  return this.relativeOffset += 2, e2;
}, ae.prototype.parseCard16 = ae.prototype.parseUShort, ae.prototype.parseSID = ae.prototype.parseUShort, ae.prototype.parseOffset16 = ae.prototype.parseUShort, ae.prototype.parseShort = function() {
  var e2 = this.data.getInt16(this.offset + this.relativeOffset);
  return this.relativeOffset += 2, e2;
}, ae.prototype.parseF2Dot14 = function() {
  var e2 = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
  return this.relativeOffset += 2, e2;
}, ae.prototype.parseULong = function() {
  var e2 = te(this.data, this.offset + this.relativeOffset);
  return this.relativeOffset += 4, e2;
}, ae.prototype.parseOffset32 = ae.prototype.parseULong, ae.prototype.parseFixed = function() {
  var e2 = re(this.data, this.offset + this.relativeOffset);
  return this.relativeOffset += 4, e2;
}, ae.prototype.parseString = function(e2) {
  var t2 = this.data, r2 = this.offset + this.relativeOffset, n2 = "";
  this.relativeOffset += e2;
  for (var a2 = 0; a2 < e2; a2++) n2 += String.fromCharCode(t2.getUint8(r2 + a2));
  return n2;
}, ae.prototype.parseTag = function() {
  return this.parseString(4);
}, ae.prototype.parseLongDateTime = function() {
  var e2 = te(this.data, this.offset + this.relativeOffset + 4);
  return e2 -= 2082844800, this.relativeOffset += 8, e2;
}, ae.prototype.parseVersion = function(e2) {
  var t2 = ee(this.data, this.offset + this.relativeOffset), r2 = ee(this.data, this.offset + this.relativeOffset + 2);
  return this.relativeOffset += 4, void 0 === e2 && (e2 = 4096), t2 + r2 / e2 / 10;
}, ae.prototype.skip = function(e2, t2) {
  void 0 === t2 && (t2 = 1), this.relativeOffset += ne[e2] * t2;
}, ae.prototype.parseULongList = function(e2) {
  void 0 === e2 && (e2 = this.parseULong());
  for (var t2 = new Array(e2), r2 = this.data, n2 = this.offset + this.relativeOffset, a2 = 0; a2 < e2; a2++) t2[a2] = r2.getUint32(n2), n2 += 4;
  return this.relativeOffset += 4 * e2, t2;
}, ae.prototype.parseOffset16List = ae.prototype.parseUShortList = function(e2) {
  void 0 === e2 && (e2 = this.parseUShort());
  for (var t2 = new Array(e2), r2 = this.data, n2 = this.offset + this.relativeOffset, a2 = 0; a2 < e2; a2++) t2[a2] = r2.getUint16(n2), n2 += 2;
  return this.relativeOffset += 2 * e2, t2;
}, ae.prototype.parseShortList = function(e2) {
  for (var t2 = new Array(e2), r2 = this.data, n2 = this.offset + this.relativeOffset, a2 = 0; a2 < e2; a2++) t2[a2] = r2.getInt16(n2), n2 += 2;
  return this.relativeOffset += 2 * e2, t2;
}, ae.prototype.parseByteList = function(e2) {
  for (var t2 = new Array(e2), r2 = this.data, n2 = this.offset + this.relativeOffset, a2 = 0; a2 < e2; a2++) t2[a2] = r2.getUint8(n2++);
  return this.relativeOffset += e2, t2;
}, ae.prototype.parseList = function(e2, t2) {
  t2 || (t2 = e2, e2 = this.parseUShort());
  for (var r2 = new Array(e2), n2 = 0; n2 < e2; n2++) r2[n2] = t2.call(this);
  return r2;
}, ae.prototype.parseList32 = function(e2, t2) {
  t2 || (t2 = e2, e2 = this.parseULong());
  for (var r2 = new Array(e2), n2 = 0; n2 < e2; n2++) r2[n2] = t2.call(this);
  return r2;
}, ae.prototype.parseRecordList = function(e2, t2) {
  t2 || (t2 = e2, e2 = this.parseUShort());
  for (var r2 = new Array(e2), n2 = Object.keys(t2), a2 = 0; a2 < e2; a2++) {
    for (var o2 = {}, s2 = 0; s2 < n2.length; s2++) {
      var i2 = n2[s2], u2 = t2[i2];
      o2[i2] = u2.call(this);
    }
    r2[a2] = o2;
  }
  return r2;
}, ae.prototype.parseRecordList32 = function(e2, t2) {
  t2 || (t2 = e2, e2 = this.parseULong());
  for (var r2 = new Array(e2), n2 = Object.keys(t2), a2 = 0; a2 < e2; a2++) {
    for (var o2 = {}, s2 = 0; s2 < n2.length; s2++) {
      var i2 = n2[s2], u2 = t2[i2];
      o2[i2] = u2.call(this);
    }
    r2[a2] = o2;
  }
  return r2;
}, ae.prototype.parseStruct = function(e2) {
  if ("function" == typeof e2) return e2.call(this);
  for (var t2 = Object.keys(e2), r2 = {}, n2 = 0; n2 < t2.length; n2++) {
    var a2 = t2[n2], o2 = e2[a2];
    r2[a2] = o2.call(this);
  }
  return r2;
}, ae.prototype.parseValueRecord = function(e2) {
  if (void 0 === e2 && (e2 = this.parseUShort()), 0 !== e2) {
    var t2 = {};
    return 1 & e2 && (t2.xPlacement = this.parseShort()), 2 & e2 && (t2.yPlacement = this.parseShort()), 4 & e2 && (t2.xAdvance = this.parseShort()), 8 & e2 && (t2.yAdvance = this.parseShort()), 16 & e2 && (t2.xPlaDevice = void 0, this.parseShort()), 32 & e2 && (t2.yPlaDevice = void 0, this.parseShort()), 64 & e2 && (t2.xAdvDevice = void 0, this.parseShort()), 128 & e2 && (t2.yAdvDevice = void 0, this.parseShort()), t2;
  }
}, ae.prototype.parseValueRecordList = function() {
  for (var e2 = this.parseUShort(), t2 = this.parseUShort(), r2 = new Array(t2), n2 = 0; n2 < t2; n2++) r2[n2] = this.parseValueRecord(e2);
  return r2;
}, ae.prototype.parsePointer = function(e2) {
  var t2 = this.parseOffset16();
  if (t2 > 0) return new ae(this.data, this.offset + t2).parseStruct(e2);
}, ae.prototype.parsePointer32 = function(e2) {
  var t2 = this.parseOffset32();
  if (t2 > 0) return new ae(this.data, this.offset + t2).parseStruct(e2);
}, ae.prototype.parseListOfLists = function(e2) {
  for (var t2 = this.parseOffset16List(), r2 = t2.length, n2 = this.relativeOffset, a2 = new Array(r2), o2 = 0; o2 < r2; o2++) {
    var s2 = t2[o2];
    if (0 !== s2) if (this.relativeOffset = s2, e2) {
      for (var i2 = this.parseOffset16List(), u2 = new Array(i2.length), l2 = 0; l2 < i2.length; l2++) this.relativeOffset = s2 + i2[l2], u2[l2] = e2.call(this);
      a2[o2] = u2;
    } else a2[o2] = this.parseUShortList();
    else a2[o2] = void 0;
  }
  return this.relativeOffset = n2, a2;
}, ae.prototype.parseCoverage = function() {
  var e2 = this.offset + this.relativeOffset, t2 = this.parseUShort(), r2 = this.parseUShort();
  if (1 === t2) return { format: 1, glyphs: this.parseUShortList(r2) };
  if (2 === t2) {
    for (var n2 = new Array(r2), a2 = 0; a2 < r2; a2++) n2[a2] = { start: this.parseUShort(), end: this.parseUShort(), index: this.parseUShort() };
    return { format: 2, ranges: n2 };
  }
  throw new Error("0x" + e2.toString(16) + ": Coverage format must be 1 or 2.");
}, ae.prototype.parseClassDef = function() {
  var e2 = this.offset + this.relativeOffset, t2 = this.parseUShort();
  if (1 === t2) return { format: 1, startGlyph: this.parseUShort(), classes: this.parseUShortList() };
  if (2 === t2) return { format: 2, ranges: this.parseRecordList({ start: ae.uShort, end: ae.uShort, classId: ae.uShort }) };
  throw new Error("0x" + e2.toString(16) + ": ClassDef format must be 1 or 2.");
}, ae.list = function(e2, t2) {
  return function() {
    return this.parseList(e2, t2);
  };
}, ae.list32 = function(e2, t2) {
  return function() {
    return this.parseList32(e2, t2);
  };
}, ae.recordList = function(e2, t2) {
  return function() {
    return this.parseRecordList(e2, t2);
  };
}, ae.recordList32 = function(e2, t2) {
  return function() {
    return this.parseRecordList32(e2, t2);
  };
}, ae.pointer = function(e2) {
  return function() {
    return this.parsePointer(e2);
  };
}, ae.pointer32 = function(e2) {
  return function() {
    return this.parsePointer32(e2);
  };
}, ae.tag = ae.prototype.parseTag, ae.byte = ae.prototype.parseByte, ae.uShort = ae.offset16 = ae.prototype.parseUShort, ae.uShortList = ae.prototype.parseUShortList, ae.uLong = ae.offset32 = ae.prototype.parseULong, ae.uLongList = ae.prototype.parseULongList, ae.struct = ae.prototype.parseStruct, ae.coverage = ae.prototype.parseCoverage, ae.classDef = ae.prototype.parseClassDef;
var oe = { reserved: ae.uShort, reqFeatureIndex: ae.uShort, featureIndexes: ae.uShortList };
ae.prototype.parseScriptList = function() {
  return this.parsePointer(ae.recordList({ tag: ae.tag, script: ae.pointer({ defaultLangSys: ae.pointer(oe), langSysRecords: ae.recordList({ tag: ae.tag, langSys: ae.pointer(oe) }) }) })) || [];
}, ae.prototype.parseFeatureList = function() {
  return this.parsePointer(ae.recordList({ tag: ae.tag, feature: ae.pointer({ featureParams: ae.offset16, lookupListIndexes: ae.uShortList }) })) || [];
}, ae.prototype.parseLookupList = function(e2) {
  return this.parsePointer(ae.list(ae.pointer(function() {
    var t2 = this.parseUShort();
    w.argument(1 <= t2 && t2 <= 9, "GPOS/GSUB lookup type " + t2 + " unknown.");
    var r2 = this.parseUShort(), n2 = 16 & r2;
    return { lookupType: t2, lookupFlag: r2, subtables: this.parseList(ae.pointer(e2[t2])), markFilteringSet: n2 ? this.parseUShort() : void 0 };
  }))) || [];
}, ae.prototype.parseFeatureVariationsList = function() {
  return this.parsePointer32(function() {
    var e2 = this.parseUShort(), t2 = this.parseUShort();
    return w.argument(1 === e2 && t2 < 1, "GPOS/GSUB feature variations table unknown."), this.parseRecordList32({ conditionSetOffset: ae.offset32, featureTableSubstitutionOffset: ae.offset32 });
  }) || [];
};
var se = { getByte: $, getCard8: $, getUShort: ee, getCard16: ee, getShort: function(e2, t2) {
  return e2.getInt16(t2, false);
}, getULong: te, getFixed: re, getTag: function(e2, t2) {
  for (var r2 = "", n2 = t2; n2 < t2 + 4; n2 += 1) r2 += String.fromCharCode(e2.getInt8(n2));
  return r2;
}, getOffset: function(e2, t2, r2) {
  for (var n2 = 0, a2 = 0; a2 < r2; a2 += 1) n2 <<= 8, n2 += e2.getUint8(t2 + a2);
  return n2;
}, getBytes: function(e2, t2, r2) {
  for (var n2 = [], a2 = t2; a2 < r2; a2 += 1) n2.push(e2.getUint8(a2));
  return n2;
}, bytesToString: function(e2) {
  for (var t2 = "", r2 = 0; r2 < e2.length; r2 += 1) t2 += String.fromCharCode(e2[r2]);
  return t2;
}, Parser: ae };
var ie = ["copyright", "fontFamily", "fontSubfamily", "uniqueID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "manufacturerURL", "designerURL", "license", "licenseURL", "reserved", "preferredFamily", "preferredSubfamily", "compatibleFullName", "sampleText", "postScriptFindFontName", "wwsFamily", "wwsSubfamily"];
var ue = { 0: "en", 1: "fr", 2: "de", 3: "it", 4: "nl", 5: "sv", 6: "es", 7: "da", 8: "pt", 9: "no", 10: "he", 11: "ja", 12: "ar", 13: "fi", 14: "el", 15: "is", 16: "mt", 17: "tr", 18: "hr", 19: "zh-Hant", 20: "ur", 21: "hi", 22: "th", 23: "ko", 24: "lt", 25: "pl", 26: "hu", 27: "es", 28: "lv", 29: "se", 30: "fo", 31: "fa", 32: "ru", 33: "zh", 34: "nl-BE", 35: "ga", 36: "sq", 37: "ro", 38: "cz", 39: "sk", 40: "si", 41: "yi", 42: "sr", 43: "mk", 44: "bg", 45: "uk", 46: "be", 47: "uz", 48: "kk", 49: "az-Cyrl", 50: "az-Arab", 51: "hy", 52: "ka", 53: "mo", 54: "ky", 55: "tg", 56: "tk", 57: "mn-CN", 58: "mn", 59: "ps", 60: "ks", 61: "ku", 62: "sd", 63: "bo", 64: "ne", 65: "sa", 66: "mr", 67: "bn", 68: "as", 69: "gu", 70: "pa", 71: "or", 72: "ml", 73: "kn", 74: "ta", 75: "te", 76: "si", 77: "my", 78: "km", 79: "lo", 80: "vi", 81: "id", 82: "tl", 83: "ms", 84: "ms-Arab", 85: "am", 86: "ti", 87: "om", 88: "so", 89: "sw", 90: "rw", 91: "rn", 92: "ny", 93: "mg", 94: "eo", 128: "cy", 129: "eu", 130: "ca", 131: "la", 132: "qu", 133: "gn", 134: "ay", 135: "tt", 136: "ug", 137: "dz", 138: "jv", 139: "su", 140: "gl", 141: "af", 142: "br", 143: "iu", 144: "gd", 145: "gv", 146: "ga", 147: "to", 148: "el-polyton", 149: "kl", 150: "az", 151: "nn" };
var le = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 5, 11: 1, 12: 4, 13: 0, 14: 6, 15: 0, 16: 0, 17: 0, 18: 0, 19: 2, 20: 4, 21: 9, 22: 21, 23: 3, 24: 29, 25: 29, 26: 29, 27: 29, 28: 29, 29: 0, 30: 0, 31: 4, 32: 7, 33: 25, 34: 0, 35: 0, 36: 0, 37: 0, 38: 29, 39: 29, 40: 0, 41: 5, 42: 7, 43: 7, 44: 7, 45: 7, 46: 7, 47: 7, 48: 7, 49: 7, 50: 4, 51: 24, 52: 23, 53: 7, 54: 7, 55: 7, 56: 7, 57: 27, 58: 7, 59: 4, 60: 4, 61: 4, 62: 4, 63: 26, 64: 9, 65: 9, 66: 9, 67: 13, 68: 13, 69: 11, 70: 10, 71: 12, 72: 17, 73: 16, 74: 14, 75: 15, 76: 18, 77: 19, 78: 20, 79: 22, 80: 30, 81: 0, 82: 0, 83: 0, 84: 4, 85: 28, 86: 28, 87: 28, 88: 0, 89: 0, 90: 0, 91: 0, 92: 0, 93: 0, 94: 0, 128: 0, 129: 0, 130: 0, 131: 0, 132: 0, 133: 0, 134: 0, 135: 7, 136: 4, 137: 26, 138: 0, 139: 0, 140: 0, 141: 0, 142: 0, 143: 28, 144: 0, 145: 0, 146: 0, 147: 0, 148: 6, 149: 0, 150: 0, 151: 0 };
var pe = { 1078: "af", 1052: "sq", 1156: "gsw", 1118: "am", 5121: "ar-DZ", 15361: "ar-BH", 3073: "ar", 2049: "ar-IQ", 11265: "ar-JO", 13313: "ar-KW", 12289: "ar-LB", 4097: "ar-LY", 6145: "ary", 8193: "ar-OM", 16385: "ar-QA", 1025: "ar-SA", 10241: "ar-SY", 7169: "aeb", 14337: "ar-AE", 9217: "ar-YE", 1067: "hy", 1101: "as", 2092: "az-Cyrl", 1068: "az", 1133: "ba", 1069: "eu", 1059: "be", 2117: "bn", 1093: "bn-IN", 8218: "bs-Cyrl", 5146: "bs", 1150: "br", 1026: "bg", 1027: "ca", 3076: "zh-HK", 5124: "zh-MO", 2052: "zh", 4100: "zh-SG", 1028: "zh-TW", 1155: "co", 1050: "hr", 4122: "hr-BA", 1029: "cs", 1030: "da", 1164: "prs", 1125: "dv", 2067: "nl-BE", 1043: "nl", 3081: "en-AU", 10249: "en-BZ", 4105: "en-CA", 9225: "en-029", 16393: "en-IN", 6153: "en-IE", 8201: "en-JM", 17417: "en-MY", 5129: "en-NZ", 13321: "en-PH", 18441: "en-SG", 7177: "en-ZA", 11273: "en-TT", 2057: "en-GB", 1033: "en", 12297: "en-ZW", 1061: "et", 1080: "fo", 1124: "fil", 1035: "fi", 2060: "fr-BE", 3084: "fr-CA", 1036: "fr", 5132: "fr-LU", 6156: "fr-MC", 4108: "fr-CH", 1122: "fy", 1110: "gl", 1079: "ka", 3079: "de-AT", 1031: "de", 5127: "de-LI", 4103: "de-LU", 2055: "de-CH", 1032: "el", 1135: "kl", 1095: "gu", 1128: "ha", 1037: "he", 1081: "hi", 1038: "hu", 1039: "is", 1136: "ig", 1057: "id", 1117: "iu", 2141: "iu-Latn", 2108: "ga", 1076: "xh", 1077: "zu", 1040: "it", 2064: "it-CH", 1041: "ja", 1099: "kn", 1087: "kk", 1107: "km", 1158: "quc", 1159: "rw", 1089: "sw", 1111: "kok", 1042: "ko", 1088: "ky", 1108: "lo", 1062: "lv", 1063: "lt", 2094: "dsb", 1134: "lb", 1071: "mk", 2110: "ms-BN", 1086: "ms", 1100: "ml", 1082: "mt", 1153: "mi", 1146: "arn", 1102: "mr", 1148: "moh", 1104: "mn", 2128: "mn-CN", 1121: "ne", 1044: "nb", 2068: "nn", 1154: "oc", 1096: "or", 1123: "ps", 1045: "pl", 1046: "pt", 2070: "pt-PT", 1094: "pa", 1131: "qu-BO", 2155: "qu-EC", 3179: "qu", 1048: "ro", 1047: "rm", 1049: "ru", 9275: "smn", 4155: "smj-NO", 5179: "smj", 3131: "se-FI", 1083: "se", 2107: "se-SE", 8251: "sms", 6203: "sma-NO", 7227: "sms", 1103: "sa", 7194: "sr-Cyrl-BA", 3098: "sr", 6170: "sr-Latn-BA", 2074: "sr-Latn", 1132: "nso", 1074: "tn", 1115: "si", 1051: "sk", 1060: "sl", 11274: "es-AR", 16394: "es-BO", 13322: "es-CL", 9226: "es-CO", 5130: "es-CR", 7178: "es-DO", 12298: "es-EC", 17418: "es-SV", 4106: "es-GT", 18442: "es-HN", 2058: "es-MX", 19466: "es-NI", 6154: "es-PA", 15370: "es-PY", 10250: "es-PE", 20490: "es-PR", 3082: "es", 1034: "es", 21514: "es-US", 14346: "es-UY", 8202: "es-VE", 2077: "sv-FI", 1053: "sv", 1114: "syr", 1064: "tg", 2143: "tzm", 1097: "ta", 1092: "tt", 1098: "te", 1054: "th", 1105: "bo", 1055: "tr", 1090: "tk", 1152: "ug", 1058: "uk", 1070: "hsb", 1056: "ur", 2115: "uz-Cyrl", 1091: "uz", 1066: "vi", 1106: "cy", 1160: "wo", 1157: "sah", 1144: "ii", 1130: "yo" };
function ce(e2, t2, r2) {
  switch (e2) {
    case 0:
      if (65535 === t2) return "und";
      if (r2) return r2[t2];
      break;
    case 1:
      return ue[t2];
    case 3:
      return pe[t2];
  }
}
var he = "utf-16";
var fe = { 0: "macintosh", 1: "x-mac-japanese", 2: "x-mac-chinesetrad", 3: "x-mac-korean", 6: "x-mac-greek", 7: "x-mac-cyrillic", 9: "x-mac-devanagai", 10: "x-mac-gurmukhi", 11: "x-mac-gujarati", 12: "x-mac-oriya", 13: "x-mac-bengali", 14: "x-mac-tamil", 15: "x-mac-telugu", 16: "x-mac-kannada", 17: "x-mac-malayalam", 18: "x-mac-sinhalese", 19: "x-mac-burmese", 20: "x-mac-khmer", 21: "x-mac-thai", 22: "x-mac-lao", 23: "x-mac-georgian", 24: "x-mac-armenian", 25: "x-mac-chinesesimp", 26: "x-mac-tibetan", 27: "x-mac-mongolian", 28: "x-mac-ethiopic", 29: "x-mac-ce", 30: "x-mac-vietnamese", 31: "x-mac-extarabic" };
var de = { 15: "x-mac-icelandic", 17: "x-mac-turkish", 18: "x-mac-croatian", 24: "x-mac-ce", 25: "x-mac-ce", 26: "x-mac-ce", 27: "x-mac-ce", 28: "x-mac-ce", 30: "x-mac-icelandic", 37: "x-mac-romanian", 38: "x-mac-ce", 39: "x-mac-ce", 40: "x-mac-ce", 143: "x-mac-inuit", 146: "x-mac-gaelic" };
function ve(e2, t2, r2) {
  switch (e2) {
    case 0:
      return he;
    case 1:
      return de[r2] || fe[t2];
    case 3:
      if (1 === t2 || 10 === t2) return he;
  }
}
function ge(e2) {
  var t2 = {};
  for (var r2 in e2) t2[e2[r2]] = parseInt(r2);
  return t2;
}
function me(e2, t2, r2, n2, a2, o2) {
  return new J.Record("NameRecord", [{ name: "platformID", type: "USHORT", value: e2 }, { name: "encodingID", type: "USHORT", value: t2 }, { name: "languageID", type: "USHORT", value: r2 }, { name: "nameID", type: "USHORT", value: n2 }, { name: "length", type: "USHORT", value: a2 }, { name: "offset", type: "USHORT", value: o2 }]);
}
function ye(e2, t2) {
  var r2 = function(e3, t3) {
    var r3 = e3.length, n3 = t3.length - r3 + 1;
    e: for (var a3 = 0; a3 < n3; a3++) for (; a3 < n3; a3++) {
      for (var o2 = 0; o2 < r3; o2++) if (t3[a3 + o2] !== e3[o2]) continue e;
      return a3;
    }
    return -1;
  }(e2, t2);
  if (r2 < 0) {
    r2 = t2.length;
    for (var n2 = 0, a2 = e2.length; n2 < a2; ++n2) t2.push(e2[n2]);
  }
  return r2;
}
var be = { parse: function(e2, t2, r2) {
  for (var n2 = {}, a2 = new se.Parser(e2, t2), o2 = a2.parseUShort(), s2 = a2.parseUShort(), i2 = a2.offset + a2.parseUShort(), u2 = 0; u2 < s2; u2++) {
    var l2 = a2.parseUShort(), p2 = a2.parseUShort(), c2 = a2.parseUShort(), h2 = a2.parseUShort(), f2 = ie[h2] || h2, d2 = a2.parseUShort(), v2 = a2.parseUShort(), g2 = ce(l2, c2, r2), m2 = ve(l2, p2, c2);
    if (void 0 !== m2 && void 0 !== g2) {
      var y2 = void 0;
      if (y2 = m2 === he ? I.UTF16(e2, i2 + v2, d2) : I.MACSTRING(e2, i2 + v2, d2, m2)) {
        var b2 = n2[f2];
        void 0 === b2 && (b2 = n2[f2] = {}), b2[g2] = y2;
      }
    }
  }
  return 1 === o2 && a2.parseUShort(), n2;
}, make: function(e2, t2) {
  var r2, n2 = [], a2 = {}, o2 = ge(ie);
  for (var s2 in e2) {
    var i2 = o2[s2];
    if (void 0 === i2 && (i2 = s2), r2 = parseInt(i2), isNaN(r2)) throw new Error('Name table entry "' + s2 + '" does not exist, see nameTableNames for complete list.');
    a2[r2] = e2[s2], n2.push(r2);
  }
  for (var u2 = ge(ue), l2 = ge(pe), p2 = [], c2 = [], h2 = 0; h2 < n2.length; h2++) {
    var f2 = a2[r2 = n2[h2]];
    for (var d2 in f2) {
      var v2 = f2[d2], g2 = 1, m2 = u2[d2], y2 = le[m2], b2 = ve(g2, y2, m2), S2 = G.MACSTRING(v2, b2);
      void 0 === S2 && (g2 = 0, (m2 = t2.indexOf(d2)) < 0 && (m2 = t2.length, t2.push(d2)), y2 = 4, S2 = G.UTF16(v2));
      var x2 = ye(S2, c2);
      p2.push(me(g2, y2, m2, r2, S2.length, x2));
      var T2 = l2[d2];
      if (void 0 !== T2) {
        var U2 = G.UTF16(v2), k2 = ye(U2, c2);
        p2.push(me(3, 1, T2, r2, U2.length, k2));
      }
    }
  }
  p2.sort(function(e3, t3) {
    return e3.platformID - t3.platformID || e3.encodingID - t3.encodingID || e3.languageID - t3.languageID || e3.nameID - t3.nameID;
  });
  for (var O2 = new J.Table("name", [{ name: "format", type: "USHORT", value: 0 }, { name: "count", type: "USHORT", value: p2.length }, { name: "stringOffset", type: "USHORT", value: 6 + 12 * p2.length }]), R2 = 0; R2 < p2.length; R2++) O2.fields.push({ name: "record_" + R2, type: "RECORD", value: p2[R2] });
  return O2.fields.push({ name: "strings", type: "LITERAL", value: c2 }), O2;
} };
function Se(e2, t2, r2) {
  e2.segments.push({ end: t2, start: t2, delta: -(t2 - r2), offset: 0, glyphIndex: r2 });
}
var xe = { parse: function(e2, t2) {
  var r2 = {};
  r2.version = se.getUShort(e2, t2), w.argument(0 === r2.version, "cmap table version should be 0."), r2.numTables = se.getUShort(e2, t2 + 2);
  for (var n2 = null, a2 = -1, o2 = -1, s2 = null, i2 = null, u2 = [0, 1, 2, 3, 4, 6], l2 = [0, 1, 10], p2 = r2.numTables - 1; p2 >= 0; p2 -= 1) if (s2 = se.getUShort(e2, t2 + 4 + 8 * p2), i2 = se.getUShort(e2, t2 + 4 + 8 * p2 + 2), 3 === s2 && l2.includes(i2) || 0 === s2 && u2.includes(i2) || 1 === s2 && 0 === i2) {
    if (o2 > 0) continue;
    if (o2 = se.getULong(e2, t2 + 4 + 8 * p2 + 4), n2) break;
  } else if (0 === s2 && 5 === i2) {
    if (a2 = se.getULong(e2, t2 + 4 + 8 * p2 + 4), 14 !== (n2 = new se.Parser(e2, t2 + a2)).parseUShort()) a2 = -1, n2 = null;
    else if (o2 > 0) break;
  }
  if (-1 === o2) throw new Error("No valid cmap sub-tables found.");
  var c2 = new se.Parser(e2, t2 + o2);
  if (r2.format = c2.parseUShort(), 0 === r2.format) !function(e3, t3, r3, n3) {
    e3.length = t3.parseUShort(), e3.language = t3.parseUShort() - 1;
    for (var a3 = t3.parseByteList(e3.length), o3 = Object.assign({}, a3), s3 = ve(r3, n3, e3.language), i3 = F[s3], u3 = 0; u3 < i3.length; u3++) o3[i3.charCodeAt(u3)] = a3[128 + u3];
    e3.glyphIndexMap = o3;
  }(r2, c2, s2, i2);
  else if (12 === r2.format || 13 === r2.format) !function(e3, t3, r3) {
    var n3;
    t3.parseUShort(), e3.length = t3.parseULong(), e3.language = t3.parseULong(), e3.groupCount = n3 = t3.parseULong(), e3.glyphIndexMap = {};
    for (var a3 = 0; a3 < n3; a3 += 1) for (var o3 = t3.parseULong(), s3 = t3.parseULong(), i3 = t3.parseULong(), u3 = o3; u3 <= s3; u3 += 1) e3.glyphIndexMap[u3] = i3, 12 === r3 && i3++;
  }(r2, c2, r2.format);
  else {
    if (4 !== r2.format) throw new Error("Only format 0 (platformId 1, encodingId 0), 4, 12 and 14 cmap tables are supported (found format " + r2.format + ", platformId " + s2 + ", encodingId " + i2 + ").");
    !function(e3, t3, r3, n3, a3) {
      var o3;
      e3.length = t3.parseUShort(), e3.language = t3.parseUShort(), e3.segCount = o3 = t3.parseUShort() >> 1, t3.skip("uShort", 3), e3.glyphIndexMap = {};
      for (var s3 = new se.Parser(r3, n3 + a3 + 14), i3 = new se.Parser(r3, n3 + a3 + 16 + 2 * o3), u3 = new se.Parser(r3, n3 + a3 + 16 + 4 * o3), l3 = new se.Parser(r3, n3 + a3 + 16 + 6 * o3), p3 = n3 + a3 + 16 + 8 * o3, c3 = 0; c3 < o3 - 1; c3 += 1) for (var h2 = void 0, f2 = s3.parseUShort(), d2 = i3.parseUShort(), v2 = u3.parseShort(), g2 = l3.parseUShort(), m2 = d2; m2 <= f2; m2 += 1) 0 !== g2 ? (p3 = l3.offset + l3.relativeOffset - 2, p3 += g2, p3 += 2 * (m2 - d2), 0 !== (h2 = se.getUShort(r3, p3)) && (h2 = h2 + v2 & 65535)) : h2 = m2 + v2 & 65535, e3.glyphIndexMap[m2] = h2;
    }(r2, c2, e2, t2, o2);
  }
  return r2;
}, make: function(e2) {
  var t2, r2 = true;
  for (t2 = e2.length - 1; t2 > 0; t2 -= 1) {
    if (e2.get(t2).unicode > 65535) {
      console.log("Adding CMAP format 12 (needed!)"), r2 = false;
      break;
    }
  }
  var n2 = [{ name: "version", type: "USHORT", value: 0 }, { name: "numTables", type: "USHORT", value: r2 ? 1 : 2 }, { name: "platformID", type: "USHORT", value: 3 }, { name: "encodingID", type: "USHORT", value: 1 }, { name: "offset", type: "ULONG", value: r2 ? 12 : 20 }];
  r2 || n2.push({ name: "cmap12PlatformID", type: "USHORT", value: 3 }, { name: "cmap12EncodingID", type: "USHORT", value: 10 }, { name: "cmap12Offset", type: "ULONG", value: 0 }), n2.push({ name: "format", type: "USHORT", value: 4 }, { name: "cmap4Length", type: "USHORT", value: 0 }, { name: "language", type: "USHORT", value: 0 }, { name: "segCountX2", type: "USHORT", value: 0 }, { name: "searchRange", type: "USHORT", value: 0 }, { name: "entrySelector", type: "USHORT", value: 0 }, { name: "rangeShift", type: "USHORT", value: 0 });
  var a2 = new J.Table("cmap", n2);
  for (a2.segments = [], t2 = 0; t2 < e2.length; t2 += 1) for (var o2 = e2.get(t2), s2 = 0; s2 < o2.unicodes.length; s2 += 1) Se(a2, o2.unicodes[s2], t2);
  a2.segments.sort(function(e3, t3) {
    return e3.start - t3.start;
  }), function(e3) {
    e3.segments.push({ end: 65535, start: 65535, delta: 1, offset: 0 });
  }(a2);
  var i2 = a2.segments.length, u2 = 0, l2 = [], p2 = [], c2 = [], h2 = [], f2 = [], d2 = [];
  for (t2 = 0; t2 < i2; t2 += 1) {
    var v2 = a2.segments[t2];
    v2.end <= 65535 && v2.start <= 65535 ? (l2.push({ name: "end_" + t2, type: "USHORT", value: v2.end }), p2.push({ name: "start_" + t2, type: "USHORT", value: v2.start }), c2.push({ name: "idDelta_" + t2, type: "SHORT", value: v2.delta }), h2.push({ name: "idRangeOffset_" + t2, type: "USHORT", value: v2.offset }), void 0 !== v2.glyphId && f2.push({ name: "glyph_" + t2, type: "USHORT", value: v2.glyphId })) : u2 += 1, r2 || void 0 === v2.glyphIndex || (d2.push({ name: "cmap12Start_" + t2, type: "ULONG", value: v2.start }), d2.push({ name: "cmap12End_" + t2, type: "ULONG", value: v2.end }), d2.push({ name: "cmap12Glyph_" + t2, type: "ULONG", value: v2.glyphIndex }));
  }
  a2.segCountX2 = 2 * (i2 - u2), a2.searchRange = 2 * Math.pow(2, Math.floor(Math.log(i2 - u2) / Math.log(2))), a2.entrySelector = Math.log(a2.searchRange / 2) / Math.log(2), a2.rangeShift = a2.segCountX2 - a2.searchRange;
  for (var g2 = 0; g2 < l2.length; g2++) a2.fields.push(l2[g2]);
  a2.fields.push({ name: "reservedPad", type: "USHORT", value: 0 });
  for (var m2 = 0; m2 < p2.length; m2++) a2.fields.push(p2[m2]);
  for (var y2 = 0; y2 < c2.length; y2++) a2.fields.push(c2[y2]);
  for (var b2 = 0; b2 < h2.length; b2++) a2.fields.push(h2[b2]);
  for (var S2 = 0; S2 < f2.length; S2++) a2.fields.push(f2[S2]);
  if (a2.cmap4Length = 14 + 2 * l2.length + 2 + 2 * p2.length + 2 * c2.length + 2 * h2.length + 2 * f2.length, !r2) {
    var x2 = 16 + 4 * d2.length;
    a2.cmap12Offset = 20 + a2.cmap4Length, a2.fields.push({ name: "cmap12Format", type: "USHORT", value: 12 }, { name: "cmap12Reserved", type: "USHORT", value: 0 }, { name: "cmap12Length", type: "ULONG", value: x2 }, { name: "cmap12Language", type: "ULONG", value: 0 }, { name: "cmap12nGroups", type: "ULONG", value: d2.length / 3 });
    for (var T2 = 0; T2 < d2.length; T2++) a2.fields.push(d2[T2]);
  }
  return a2;
} };
var Te = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "266 ff", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
var Ue = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls"];
var ke = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
var Oe = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
function Re(e2) {
  this.font = e2;
}
function Ee(e2) {
  this.cmap = e2;
}
function Le(e2, t2) {
  this.encoding = e2, this.charset = t2;
}
function Ce(e2) {
  switch (e2.version) {
    case 1:
      this.names = Oe.slice();
      break;
    case 2:
      this.names = new Array(e2.numberOfGlyphs);
      for (var t2 = 0; t2 < e2.numberOfGlyphs; t2++) e2.glyphNameIndex[t2] < Oe.length ? this.names[t2] = Oe[e2.glyphNameIndex[t2]] : this.names[t2] = e2.names[e2.glyphNameIndex[t2] - Oe.length];
      break;
    case 2.5:
      this.names = new Array(e2.numberOfGlyphs);
      for (var r2 = 0; r2 < e2.numberOfGlyphs; r2++) this.names[r2] = Oe[r2 + e2.glyphNameIndex[r2]];
      break;
    default:
      this.names = [];
  }
}
function we(e2, t2) {
  t2.lowMemory ? function(e3) {
    e3._IndexToUnicodeMap = {};
    for (var t3 = e3.tables.cmap.glyphIndexMap, r2 = Object.keys(t3), n2 = 0; n2 < r2.length; n2 += 1) {
      var a2 = r2[n2], o2 = t3[a2];
      void 0 === e3._IndexToUnicodeMap[o2] ? e3._IndexToUnicodeMap[o2] = { unicodes: [parseInt(a2)] } : e3._IndexToUnicodeMap[o2].unicodes.push(parseInt(a2));
    }
  }(e2) : function(e3) {
    for (var t3, r2 = e3.tables.cmap.glyphIndexMap, n2 = Object.keys(r2), a2 = 0; a2 < n2.length; a2 += 1) {
      var o2 = n2[a2], s2 = r2[o2];
      (t3 = e3.glyphs.get(s2)).addUnicode(parseInt(o2));
    }
    for (var i2 = 0; i2 < e3.glyphs.length; i2 += 1) t3 = e3.glyphs.get(i2), e3.cffEncoding ? e3.isCIDFont ? t3.name = "gid" + i2 : t3.name = e3.cffEncoding.charset[i2] : e3.glyphNames.names && (t3.name = e3.glyphNames.glyphIndexToName(i2));
  }(e2);
}
Re.prototype.charToGlyphIndex = function(e2) {
  var t2 = e2.codePointAt(0), r2 = this.font.glyphs;
  if (r2) {
    for (var n2 = 0; n2 < r2.length; n2 += 1) for (var a2 = r2.get(n2), o2 = 0; o2 < a2.unicodes.length; o2 += 1) if (a2.unicodes[o2] === t2) return n2;
  }
  return null;
}, Ee.prototype.charToGlyphIndex = function(e2) {
  return this.cmap.glyphIndexMap[e2.codePointAt(0)] || 0;
}, Le.prototype.charToGlyphIndex = function(e2) {
  var t2 = e2.codePointAt(0), r2 = this.encoding[t2];
  return this.charset.indexOf(r2);
}, Ce.prototype.nameToGlyphIndex = function(e2) {
  return this.names.indexOf(e2);
}, Ce.prototype.glyphIndexToName = function(e2) {
  return this.names[e2];
};
var De = { line: function(e2, t2, r2, n2, a2) {
  e2.beginPath(), e2.moveTo(t2, r2), e2.lineTo(n2, a2), e2.stroke();
} };
function Ie(e2) {
  this.bindConstructorValues(e2);
}
function Ge(e2, t2, r2) {
  Object.defineProperty(e2, t2, { get: function() {
    return e2.path, e2[r2];
  }, set: function(t3) {
    e2[r2] = t3;
  }, enumerable: true, configurable: true });
}
function Me(e2, t2) {
  if (this.font = e2, this.glyphs = {}, Array.isArray(t2)) for (var r2 = 0; r2 < t2.length; r2++) {
    var n2 = t2[r2];
    n2.path.unitsPerEm = e2.unitsPerEm, this.glyphs[r2] = n2;
  }
  this.length = t2 && t2.length || 0;
}
Ie.prototype.bindConstructorValues = function(e2) {
  var t2, r2;
  this.index = e2.index || 0, this.name = e2.name || null, this.unicode = e2.unicode || void 0, this.unicodes = e2.unicodes || void 0 !== e2.unicode ? [e2.unicode] : [], "xMin" in e2 && (this.xMin = e2.xMin), "yMin" in e2 && (this.yMin = e2.yMin), "xMax" in e2 && (this.xMax = e2.xMax), "yMax" in e2 && (this.yMax = e2.yMax), "advanceWidth" in e2 && (this.advanceWidth = e2.advanceWidth), Object.defineProperty(this, "path", (t2 = e2.path, r2 = t2 || new E(), { configurable: true, get: function() {
    return "function" == typeof r2 && (r2 = r2()), r2;
  }, set: function(e3) {
    r2 = e3;
  } }));
}, Ie.prototype.addUnicode = function(e2) {
  0 === this.unicodes.length && (this.unicode = e2), this.unicodes.push(e2);
}, Ie.prototype.getBoundingBox = function() {
  return this.path.getBoundingBox();
}, Ie.prototype.getPath = function(e2, t2, r2, n2, a2) {
  var o2, s2;
  e2 = void 0 !== e2 ? e2 : 0, t2 = void 0 !== t2 ? t2 : 0, r2 = void 0 !== r2 ? r2 : 72, n2 || (n2 = {});
  var i2 = n2.xScale, u2 = n2.yScale;
  if (n2.hinting && a2 && a2.hinting && (s2 = this.path && a2.hinting.exec(this, r2)), s2) o2 = a2.hinting.getCommands(s2), e2 = Math.round(e2), t2 = Math.round(t2), i2 = u2 = 1;
  else {
    o2 = this.path.commands;
    var l2 = 1 / (this.path.unitsPerEm || 1e3) * r2;
    void 0 === i2 && (i2 = l2), void 0 === u2 && (u2 = l2);
  }
  for (var p2 = new E(), c2 = 0; c2 < o2.length; c2 += 1) {
    var h2 = o2[c2];
    "M" === h2.type ? p2.moveTo(e2 + h2.x * i2, t2 + -h2.y * u2) : "L" === h2.type ? p2.lineTo(e2 + h2.x * i2, t2 + -h2.y * u2) : "Q" === h2.type ? p2.quadraticCurveTo(e2 + h2.x1 * i2, t2 + -h2.y1 * u2, e2 + h2.x * i2, t2 + -h2.y * u2) : "C" === h2.type ? p2.curveTo(e2 + h2.x1 * i2, t2 + -h2.y1 * u2, e2 + h2.x2 * i2, t2 + -h2.y2 * u2, e2 + h2.x * i2, t2 + -h2.y * u2) : "Z" === h2.type && p2.closePath();
  }
  return p2;
}, Ie.prototype.getContours = function() {
  if (void 0 === this.points) return [];
  for (var e2 = [], t2 = [], r2 = 0; r2 < this.points.length; r2 += 1) {
    var n2 = this.points[r2];
    t2.push(n2), n2.lastPointOfContour && (e2.push(t2), t2 = []);
  }
  return w.argument(0 === t2.length, "There are still points left in the current contour."), e2;
}, Ie.prototype.getMetrics = function() {
  for (var e2 = this.path.commands, t2 = [], r2 = [], n2 = 0; n2 < e2.length; n2 += 1) {
    var a2 = e2[n2];
    "Z" !== a2.type && (t2.push(a2.x), r2.push(a2.y)), "Q" !== a2.type && "C" !== a2.type || (t2.push(a2.x1), r2.push(a2.y1)), "C" === a2.type && (t2.push(a2.x2), r2.push(a2.y2));
  }
  var o2 = { xMin: Math.min.apply(null, t2), yMin: Math.min.apply(null, r2), xMax: Math.max.apply(null, t2), yMax: Math.max.apply(null, r2), leftSideBearing: this.leftSideBearing };
  return isFinite(o2.xMin) || (o2.xMin = 0), isFinite(o2.xMax) || (o2.xMax = this.advanceWidth), isFinite(o2.yMin) || (o2.yMin = 0), isFinite(o2.yMax) || (o2.yMax = 0), o2.rightSideBearing = this.advanceWidth - o2.leftSideBearing - (o2.xMax - o2.xMin), o2;
}, Ie.prototype.draw = function(e2, t2, r2, n2, a2) {
  this.getPath(t2, r2, n2, a2).draw(e2);
}, Ie.prototype.drawPoints = function(e2, t2, r2, n2) {
  function a2(t3, r3, n3, a3) {
    e2.beginPath();
    for (var o3 = 0; o3 < t3.length; o3 += 1) e2.moveTo(r3 + t3[o3].x * a3, n3 + t3[o3].y * a3), e2.arc(r3 + t3[o3].x * a3, n3 + t3[o3].y * a3, 2, 0, 2 * Math.PI, false);
    e2.closePath(), e2.fill();
  }
  t2 = void 0 !== t2 ? t2 : 0, r2 = void 0 !== r2 ? r2 : 0, n2 = void 0 !== n2 ? n2 : 24;
  for (var o2 = 1 / this.path.unitsPerEm * n2, s2 = [], i2 = [], u2 = this.path, l2 = 0; l2 < u2.commands.length; l2 += 1) {
    var p2 = u2.commands[l2];
    void 0 !== p2.x && s2.push({ x: p2.x, y: -p2.y }), void 0 !== p2.x1 && i2.push({ x: p2.x1, y: -p2.y1 }), void 0 !== p2.x2 && i2.push({ x: p2.x2, y: -p2.y2 });
  }
  e2.fillStyle = "blue", a2(s2, t2, r2, o2), e2.fillStyle = "red", a2(i2, t2, r2, o2);
}, Ie.prototype.drawMetrics = function(e2, t2, r2, n2) {
  var a2;
  t2 = void 0 !== t2 ? t2 : 0, r2 = void 0 !== r2 ? r2 : 0, n2 = void 0 !== n2 ? n2 : 24, a2 = 1 / this.path.unitsPerEm * n2, e2.lineWidth = 1, e2.strokeStyle = "black", De.line(e2, t2, -1e4, t2, 1e4), De.line(e2, -1e4, r2, 1e4, r2);
  var o2 = this.xMin || 0, s2 = this.yMin || 0, i2 = this.xMax || 0, u2 = this.yMax || 0, l2 = this.advanceWidth || 0;
  e2.strokeStyle = "blue", De.line(e2, t2 + o2 * a2, -1e4, t2 + o2 * a2, 1e4), De.line(e2, t2 + i2 * a2, -1e4, t2 + i2 * a2, 1e4), De.line(e2, -1e4, r2 + -s2 * a2, 1e4, r2 + -s2 * a2), De.line(e2, -1e4, r2 + -u2 * a2, 1e4, r2 + -u2 * a2), e2.strokeStyle = "green", De.line(e2, t2 + l2 * a2, -1e4, t2 + l2 * a2, 1e4);
}, Me.prototype.get = function(e2) {
  if (void 0 === this.glyphs[e2] && "number" == typeof e2) {
    this.font._push(e2), "function" == typeof this.glyphs[e2] && (this.glyphs[e2] = this.glyphs[e2]());
    var t2 = this.glyphs[e2], r2 = this.font._IndexToUnicodeMap[e2];
    if (r2) for (var n2 = 0; n2 < r2.unicodes.length; n2++) t2.addUnicode(r2.unicodes[n2]);
    this.font.cffEncoding ? this.font.isCIDFont ? t2.name = "gid" + e2 : t2.name = this.font.cffEncoding.charset[e2] : this.font.glyphNames.names && (t2.name = this.font.glyphNames.glyphIndexToName(e2)), this.glyphs[e2].advanceWidth = this.font._hmtxTableData[e2].advanceWidth, this.glyphs[e2].leftSideBearing = this.font._hmtxTableData[e2].leftSideBearing;
  } else "function" == typeof this.glyphs[e2] && (this.glyphs[e2] = this.glyphs[e2]());
  return this.glyphs[e2];
}, Me.prototype.push = function(e2, t2) {
  this.glyphs[e2] = t2, this.length++;
};
var Be = { GlyphSet: Me, glyphLoader: function(e2, t2) {
  return new Ie({ index: t2, font: e2 });
}, ttfGlyphLoader: function(e2, t2, r2, n2, a2, o2) {
  return function() {
    var s2 = new Ie({ index: t2, font: e2 });
    return s2.path = function() {
      r2(s2, n2, a2);
      var t3 = o2(e2.glyphs, s2);
      return t3.unitsPerEm = e2.unitsPerEm, t3;
    }, Ge(s2, "xMin", "_xMin"), Ge(s2, "xMax", "_xMax"), Ge(s2, "yMin", "_yMin"), Ge(s2, "yMax", "_yMax"), s2;
  };
}, cffGlyphLoader: function(e2, t2, r2, n2) {
  return function() {
    var a2 = new Ie({ index: t2, font: e2 });
    return a2.path = function() {
      var t3 = r2(e2, a2, n2);
      return t3.unitsPerEm = e2.unitsPerEm, t3;
    }, a2;
  };
} };
function Fe(e2, t2) {
  if (e2 === t2) return true;
  if (Array.isArray(e2) && Array.isArray(t2)) {
    if (e2.length !== t2.length) return false;
    for (var r2 = 0; r2 < e2.length; r2 += 1) if (!Fe(e2[r2], t2[r2])) return false;
    return true;
  }
  return false;
}
function Pe(e2) {
  return e2.length < 1240 ? 107 : e2.length < 33900 ? 1131 : 32768;
}
function Ae(e2, t2, r2) {
  var n2, a2, o2 = [], s2 = [], i2 = se.getCard16(e2, t2);
  if (0 !== i2) {
    var u2 = se.getByte(e2, t2 + 2);
    n2 = t2 + (i2 + 1) * u2 + 2;
    for (var l2 = t2 + 3, p2 = 0; p2 < i2 + 1; p2 += 1) o2.push(se.getOffset(e2, l2, u2)), l2 += u2;
    a2 = n2 + o2[i2];
  } else a2 = t2 + 2;
  for (var c2 = 0; c2 < o2.length - 1; c2 += 1) {
    var h2 = se.getBytes(e2, n2 + o2[c2], n2 + o2[c2 + 1]);
    r2 && (h2 = r2(h2)), s2.push(h2);
  }
  return { objects: s2, startOffset: t2, endOffset: a2 };
}
function Ne(e2, t2) {
  if (28 === t2) return e2.parseByte() << 8 | e2.parseByte();
  if (29 === t2) return e2.parseByte() << 24 | e2.parseByte() << 16 | e2.parseByte() << 8 | e2.parseByte();
  if (30 === t2) return function(e3) {
    for (var t3 = "", r2 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"]; ; ) {
      var n2 = e3.parseByte(), a2 = n2 >> 4, o2 = 15 & n2;
      if (15 === a2) break;
      if (t3 += r2[a2], 15 === o2) break;
      t3 += r2[o2];
    }
    return parseFloat(t3);
  }(e2);
  if (t2 >= 32 && t2 <= 246) return t2 - 139;
  if (t2 >= 247 && t2 <= 250) return 256 * (t2 - 247) + e2.parseByte() + 108;
  if (t2 >= 251 && t2 <= 254) return 256 * -(t2 - 251) - e2.parseByte() - 108;
  throw new Error("Invalid b0 " + t2);
}
function He(e2, t2, r2) {
  t2 = void 0 !== t2 ? t2 : 0;
  var n2 = new se.Parser(e2, t2), a2 = [], o2 = [];
  for (r2 = void 0 !== r2 ? r2 : e2.length; n2.relativeOffset < r2; ) {
    var s2 = n2.parseByte();
    s2 <= 21 ? (12 === s2 && (s2 = 1200 + n2.parseByte()), a2.push([s2, o2]), o2 = []) : o2.push(Ne(n2, s2));
  }
  return function(e3) {
    for (var t3 = {}, r3 = 0; r3 < e3.length; r3 += 1) {
      var n3 = e3[r3][0], a3 = e3[r3][1], o3 = void 0;
      if (o3 = 1 === a3.length ? a3[0] : a3, t3.hasOwnProperty(n3) && !isNaN(t3[n3])) throw new Error("Object " + t3 + " already has key " + n3);
      t3[n3] = o3;
    }
    return t3;
  }(a2);
}
function ze(e2, t2) {
  return t2 = t2 <= 390 ? Te[t2] : e2[t2 - 391];
}
function We(e2, t2, r2) {
  for (var n2, a2 = {}, o2 = 0; o2 < t2.length; o2 += 1) {
    var s2 = t2[o2];
    if (Array.isArray(s2.type)) {
      var i2 = [];
      i2.length = s2.type.length;
      for (var u2 = 0; u2 < s2.type.length; u2++) void 0 === (n2 = void 0 !== e2[s2.op] ? e2[s2.op][u2] : void 0) && (n2 = void 0 !== s2.value && void 0 !== s2.value[u2] ? s2.value[u2] : null), "SID" === s2.type[u2] && (n2 = ze(r2, n2)), i2[u2] = n2;
      a2[s2.name] = i2;
    } else void 0 === (n2 = e2[s2.op]) && (n2 = void 0 !== s2.value ? s2.value : null), "SID" === s2.type && (n2 = ze(r2, n2)), a2[s2.name] = n2;
  }
  return a2;
}
var qe = [{ name: "version", op: 0, type: "SID" }, { name: "notice", op: 1, type: "SID" }, { name: "copyright", op: 1200, type: "SID" }, { name: "fullName", op: 2, type: "SID" }, { name: "familyName", op: 3, type: "SID" }, { name: "weight", op: 4, type: "SID" }, { name: "isFixedPitch", op: 1201, type: "number", value: 0 }, { name: "italicAngle", op: 1202, type: "number", value: 0 }, { name: "underlinePosition", op: 1203, type: "number", value: -100 }, { name: "underlineThickness", op: 1204, type: "number", value: 50 }, { name: "paintType", op: 1205, type: "number", value: 0 }, { name: "charstringType", op: 1206, type: "number", value: 2 }, { name: "fontMatrix", op: 1207, type: ["real", "real", "real", "real", "real", "real"], value: [1e-3, 0, 0, 1e-3, 0, 0] }, { name: "uniqueId", op: 13, type: "number" }, { name: "fontBBox", op: 5, type: ["number", "number", "number", "number"], value: [0, 0, 0, 0] }, { name: "strokeWidth", op: 1208, type: "number", value: 0 }, { name: "xuid", op: 14, type: [], value: null }, { name: "charset", op: 15, type: "offset", value: 0 }, { name: "encoding", op: 16, type: "offset", value: 0 }, { name: "charStrings", op: 17, type: "offset", value: 0 }, { name: "private", op: 18, type: ["number", "offset"], value: [0, 0] }, { name: "ros", op: 1230, type: ["SID", "SID", "number"] }, { name: "cidFontVersion", op: 1231, type: "number", value: 0 }, { name: "cidFontRevision", op: 1232, type: "number", value: 0 }, { name: "cidFontType", op: 1233, type: "number", value: 0 }, { name: "cidCount", op: 1234, type: "number", value: 8720 }, { name: "uidBase", op: 1235, type: "number" }, { name: "fdArray", op: 1236, type: "offset" }, { name: "fdSelect", op: 1237, type: "offset" }, { name: "fontName", op: 1238, type: "SID" }];
var _e = [{ name: "subrs", op: 19, type: "offset", value: 0 }, { name: "defaultWidthX", op: 20, type: "number", value: 0 }, { name: "nominalWidthX", op: 21, type: "number", value: 0 }];
function Xe(e2, t2) {
  return We(He(e2, 0, e2.byteLength), qe, t2);
}
function Ve(e2, t2, r2, n2) {
  return We(He(e2, t2, r2), _e, n2);
}
function je(e2, t2, r2, n2) {
  for (var a2 = [], o2 = 0; o2 < r2.length; o2 += 1) {
    var s2 = Xe(new DataView(new Uint8Array(r2[o2]).buffer), n2);
    s2._subrs = [], s2._subrsBias = 0, s2._defaultWidthX = 0, s2._nominalWidthX = 0;
    var i2 = s2.private[0], u2 = s2.private[1];
    if (0 !== i2 && 0 !== u2) {
      var l2 = Ve(e2, u2 + t2, i2, n2);
      if (s2._defaultWidthX = l2.defaultWidthX, s2._nominalWidthX = l2.nominalWidthX, 0 !== l2.subrs) {
        var p2 = Ae(e2, u2 + l2.subrs + t2);
        s2._subrs = p2.objects, s2._subrsBias = Pe(s2._subrs);
      }
      s2._privateDict = l2;
    }
    a2.push(s2);
  }
  return a2;
}
function Ye(e2, t2, r2) {
  var n2, a2, o2, s2, i2, u2, l2, p2, c2 = new E(), h2 = [], f2 = 0, d2 = false, v2 = false, g2 = 0, m2 = 0;
  if (e2.isCIDFont) {
    var y2 = e2.tables.cff.topDict._fdSelect[t2.index], b2 = e2.tables.cff.topDict._fdArray[y2];
    i2 = b2._subrs, u2 = b2._subrsBias, l2 = b2._defaultWidthX, p2 = b2._nominalWidthX;
  } else i2 = e2.tables.cff.topDict._subrs, u2 = e2.tables.cff.topDict._subrsBias, l2 = e2.tables.cff.topDict._defaultWidthX, p2 = e2.tables.cff.topDict._nominalWidthX;
  var S2 = l2;
  function x2(e3, t3) {
    v2 && c2.closePath(), c2.moveTo(e3, t3), v2 = true;
  }
  function T2() {
    h2.length % 2 != 0 && !d2 && (S2 = h2.shift() + p2), f2 += h2.length >> 1, h2.length = 0, d2 = true;
  }
  return function r3(l3) {
    for (var y3, b3, U2, k2, O2, R2, E2, L2, C2, w2, D2, I2, G2 = 0; G2 < l3.length; ) {
      var M2 = l3[G2];
      switch (G2 += 1, M2) {
        case 1:
        case 3:
        case 18:
        case 23:
          T2();
          break;
        case 4:
          h2.length > 1 && !d2 && (S2 = h2.shift() + p2, d2 = true), m2 += h2.pop(), x2(g2, m2);
          break;
        case 5:
          for (; h2.length > 0; ) g2 += h2.shift(), m2 += h2.shift(), c2.lineTo(g2, m2);
          break;
        case 6:
          for (; h2.length > 0 && (g2 += h2.shift(), c2.lineTo(g2, m2), 0 !== h2.length); ) m2 += h2.shift(), c2.lineTo(g2, m2);
          break;
        case 7:
          for (; h2.length > 0 && (m2 += h2.shift(), c2.lineTo(g2, m2), 0 !== h2.length); ) g2 += h2.shift(), c2.lineTo(g2, m2);
          break;
        case 8:
          for (; h2.length > 0; ) n2 = g2 + h2.shift(), a2 = m2 + h2.shift(), o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), g2 = o2 + h2.shift(), m2 = s2 + h2.shift(), c2.curveTo(n2, a2, o2, s2, g2, m2);
          break;
        case 10:
          O2 = h2.pop() + u2, (R2 = i2[O2]) && r3(R2);
          break;
        case 11:
          return;
        case 12:
          switch (M2 = l3[G2], G2 += 1, M2) {
            case 35:
              n2 = g2 + h2.shift(), a2 = m2 + h2.shift(), o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), E2 = o2 + h2.shift(), L2 = s2 + h2.shift(), C2 = E2 + h2.shift(), w2 = L2 + h2.shift(), D2 = C2 + h2.shift(), I2 = w2 + h2.shift(), g2 = D2 + h2.shift(), m2 = I2 + h2.shift(), h2.shift(), c2.curveTo(n2, a2, o2, s2, E2, L2), c2.curveTo(C2, w2, D2, I2, g2, m2);
              break;
            case 34:
              n2 = g2 + h2.shift(), a2 = m2, o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), E2 = o2 + h2.shift(), L2 = s2, C2 = E2 + h2.shift(), w2 = s2, D2 = C2 + h2.shift(), I2 = m2, g2 = D2 + h2.shift(), c2.curveTo(n2, a2, o2, s2, E2, L2), c2.curveTo(C2, w2, D2, I2, g2, m2);
              break;
            case 36:
              n2 = g2 + h2.shift(), a2 = m2 + h2.shift(), o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), E2 = o2 + h2.shift(), L2 = s2, C2 = E2 + h2.shift(), w2 = s2, D2 = C2 + h2.shift(), I2 = w2 + h2.shift(), g2 = D2 + h2.shift(), c2.curveTo(n2, a2, o2, s2, E2, L2), c2.curveTo(C2, w2, D2, I2, g2, m2);
              break;
            case 37:
              n2 = g2 + h2.shift(), a2 = m2 + h2.shift(), o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), E2 = o2 + h2.shift(), L2 = s2 + h2.shift(), C2 = E2 + h2.shift(), w2 = L2 + h2.shift(), D2 = C2 + h2.shift(), I2 = w2 + h2.shift(), Math.abs(D2 - g2) > Math.abs(I2 - m2) ? g2 = D2 + h2.shift() : m2 = I2 + h2.shift(), c2.curveTo(n2, a2, o2, s2, E2, L2), c2.curveTo(C2, w2, D2, I2, g2, m2);
              break;
            default:
              console.log("Glyph " + t2.index + ": unknown operator 1200" + M2), h2.length = 0;
          }
          break;
        case 14:
          h2.length > 0 && !d2 && (S2 = h2.shift() + p2, d2 = true), v2 && (c2.closePath(), v2 = false);
          break;
        case 19:
        case 20:
          T2(), G2 += f2 + 7 >> 3;
          break;
        case 21:
          h2.length > 2 && !d2 && (S2 = h2.shift() + p2, d2 = true), m2 += h2.pop(), x2(g2 += h2.pop(), m2);
          break;
        case 22:
          h2.length > 1 && !d2 && (S2 = h2.shift() + p2, d2 = true), x2(g2 += h2.pop(), m2);
          break;
        case 24:
          for (; h2.length > 2; ) n2 = g2 + h2.shift(), a2 = m2 + h2.shift(), o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), g2 = o2 + h2.shift(), m2 = s2 + h2.shift(), c2.curveTo(n2, a2, o2, s2, g2, m2);
          g2 += h2.shift(), m2 += h2.shift(), c2.lineTo(g2, m2);
          break;
        case 25:
          for (; h2.length > 6; ) g2 += h2.shift(), m2 += h2.shift(), c2.lineTo(g2, m2);
          n2 = g2 + h2.shift(), a2 = m2 + h2.shift(), o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), g2 = o2 + h2.shift(), m2 = s2 + h2.shift(), c2.curveTo(n2, a2, o2, s2, g2, m2);
          break;
        case 26:
          for (h2.length % 2 && (g2 += h2.shift()); h2.length > 0; ) n2 = g2, a2 = m2 + h2.shift(), o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), g2 = o2, m2 = s2 + h2.shift(), c2.curveTo(n2, a2, o2, s2, g2, m2);
          break;
        case 27:
          for (h2.length % 2 && (m2 += h2.shift()); h2.length > 0; ) n2 = g2 + h2.shift(), a2 = m2, o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), g2 = o2 + h2.shift(), m2 = s2, c2.curveTo(n2, a2, o2, s2, g2, m2);
          break;
        case 28:
          y3 = l3[G2], b3 = l3[G2 + 1], h2.push((y3 << 24 | b3 << 16) >> 16), G2 += 2;
          break;
        case 29:
          O2 = h2.pop() + e2.gsubrsBias, (R2 = e2.gsubrs[O2]) && r3(R2);
          break;
        case 30:
          for (; h2.length > 0 && (n2 = g2, a2 = m2 + h2.shift(), o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), g2 = o2 + h2.shift(), m2 = s2 + (1 === h2.length ? h2.shift() : 0), c2.curveTo(n2, a2, o2, s2, g2, m2), 0 !== h2.length); ) n2 = g2 + h2.shift(), a2 = m2, o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), m2 = s2 + h2.shift(), g2 = o2 + (1 === h2.length ? h2.shift() : 0), c2.curveTo(n2, a2, o2, s2, g2, m2);
          break;
        case 31:
          for (; h2.length > 0 && (n2 = g2 + h2.shift(), a2 = m2, o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), m2 = s2 + h2.shift(), g2 = o2 + (1 === h2.length ? h2.shift() : 0), c2.curveTo(n2, a2, o2, s2, g2, m2), 0 !== h2.length); ) n2 = g2, a2 = m2 + h2.shift(), o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), g2 = o2 + h2.shift(), m2 = s2 + (1 === h2.length ? h2.shift() : 0), c2.curveTo(n2, a2, o2, s2, g2, m2);
          break;
        default:
          M2 < 32 ? console.log("Glyph " + t2.index + ": unknown operator " + M2) : M2 < 247 ? h2.push(M2 - 139) : M2 < 251 ? (y3 = l3[G2], G2 += 1, h2.push(256 * (M2 - 247) + y3 + 108)) : M2 < 255 ? (y3 = l3[G2], G2 += 1, h2.push(256 * -(M2 - 251) - y3 - 108)) : (y3 = l3[G2], b3 = l3[G2 + 1], U2 = l3[G2 + 2], k2 = l3[G2 + 3], G2 += 4, h2.push((y3 << 24 | b3 << 16 | U2 << 8 | k2) / 65536));
      }
    }
  }(r2), t2.advanceWidth = S2, c2;
}
function Ze(e2, t2) {
  var r2, n2 = Te.indexOf(e2);
  return n2 >= 0 && (r2 = n2), (n2 = t2.indexOf(e2)) >= 0 ? r2 = n2 + Te.length : (r2 = Te.length + t2.length, t2.push(e2)), r2;
}
function Qe(e2, t2, r2) {
  for (var n2 = {}, a2 = 0; a2 < e2.length; a2 += 1) {
    var o2 = e2[a2], s2 = t2[o2.name];
    void 0 === s2 || Fe(s2, o2.value) || ("SID" === o2.type && (s2 = Ze(s2, r2)), n2[o2.op] = { name: o2.name, type: o2.type, value: s2 });
  }
  return n2;
}
function Ke(e2, t2) {
  var r2 = new J.Record("Top DICT", [{ name: "dict", type: "DICT", value: {} }]);
  return r2.dict = Qe(qe, e2, t2), r2;
}
function Je(e2) {
  var t2 = new J.Record("Top DICT INDEX", [{ name: "topDicts", type: "INDEX", value: [] }]);
  return t2.topDicts = [{ name: "topDict_0", type: "TABLE", value: e2 }], t2;
}
function $e(e2) {
  var t2 = [], r2 = e2.path;
  t2.push({ name: "width", type: "NUMBER", value: e2.advanceWidth });
  for (var n2 = 0, a2 = 0, o2 = 0; o2 < r2.commands.length; o2 += 1) {
    var s2 = void 0, i2 = void 0, u2 = r2.commands[o2];
    if ("Q" === u2.type) {
      var l2 = 1 / 3, p2 = 2 / 3;
      u2 = { type: "C", x: u2.x, y: u2.y, x1: Math.round(l2 * n2 + p2 * u2.x1), y1: Math.round(l2 * a2 + p2 * u2.y1), x2: Math.round(l2 * u2.x + p2 * u2.x1), y2: Math.round(l2 * u2.y + p2 * u2.y1) };
    }
    if ("M" === u2.type) s2 = Math.round(u2.x - n2), i2 = Math.round(u2.y - a2), t2.push({ name: "dx", type: "NUMBER", value: s2 }), t2.push({ name: "dy", type: "NUMBER", value: i2 }), t2.push({ name: "rmoveto", type: "OP", value: 21 }), n2 = Math.round(u2.x), a2 = Math.round(u2.y);
    else if ("L" === u2.type) s2 = Math.round(u2.x - n2), i2 = Math.round(u2.y - a2), t2.push({ name: "dx", type: "NUMBER", value: s2 }), t2.push({ name: "dy", type: "NUMBER", value: i2 }), t2.push({ name: "rlineto", type: "OP", value: 5 }), n2 = Math.round(u2.x), a2 = Math.round(u2.y);
    else if ("C" === u2.type) {
      var c2 = Math.round(u2.x1 - n2), h2 = Math.round(u2.y1 - a2), f2 = Math.round(u2.x2 - u2.x1), d2 = Math.round(u2.y2 - u2.y1);
      s2 = Math.round(u2.x - u2.x2), i2 = Math.round(u2.y - u2.y2), t2.push({ name: "dx1", type: "NUMBER", value: c2 }), t2.push({ name: "dy1", type: "NUMBER", value: h2 }), t2.push({ name: "dx2", type: "NUMBER", value: f2 }), t2.push({ name: "dy2", type: "NUMBER", value: d2 }), t2.push({ name: "dx", type: "NUMBER", value: s2 }), t2.push({ name: "dy", type: "NUMBER", value: i2 }), t2.push({ name: "rrcurveto", type: "OP", value: 8 }), n2 = Math.round(u2.x), a2 = Math.round(u2.y);
    }
  }
  return t2.push({ name: "endchar", type: "OP", value: 14 }), t2;
}
var et = { parse: function(e2, t2, r2, n2) {
  r2.tables.cff = {};
  var a2 = function(e3, t3) {
    var r3 = {};
    return r3.formatMajor = se.getCard8(e3, t3), r3.formatMinor = se.getCard8(e3, t3 + 1), r3.size = se.getCard8(e3, t3 + 2), r3.offsetSize = se.getCard8(e3, t3 + 3), r3.startOffset = t3, r3.endOffset = t3 + 4, r3;
  }(e2, t2), o2 = Ae(e2, a2.endOffset, se.bytesToString), s2 = Ae(e2, o2.endOffset), i2 = Ae(e2, s2.endOffset, se.bytesToString), u2 = Ae(e2, i2.endOffset);
  r2.gsubrs = u2.objects, r2.gsubrsBias = Pe(r2.gsubrs);
  var l2 = je(e2, t2, s2.objects, i2.objects);
  if (1 !== l2.length) throw new Error("CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = " + l2.length);
  var p2 = l2[0];
  if (r2.tables.cff.topDict = p2, p2._privateDict && (r2.defaultWidthX = p2._privateDict.defaultWidthX, r2.nominalWidthX = p2._privateDict.nominalWidthX), void 0 !== p2.ros[0] && void 0 !== p2.ros[1] && (r2.isCIDFont = true), r2.isCIDFont) {
    var c2 = p2.fdArray, h2 = p2.fdSelect;
    if (0 === c2 || 0 === h2) throw new Error("Font is marked as a CID font, but FDArray and/or FDSelect information is missing");
    var f2 = Ae(e2, c2 += t2), d2 = je(e2, t2, f2.objects, i2.objects);
    p2._fdArray = d2, h2 += t2, p2._fdSelect = function(e3, t3, r3, n3) {
      var a3, o3 = [], s3 = new se.Parser(e3, t3), i3 = s3.parseCard8();
      if (0 === i3) for (var u3 = 0; u3 < r3; u3++) {
        if ((a3 = s3.parseCard8()) >= n3) throw new Error("CFF table CID Font FDSelect has bad FD index value " + a3 + " (FD count " + n3 + ")");
        o3.push(a3);
      }
      else {
        if (3 !== i3) throw new Error("CFF Table CID Font FDSelect table has unsupported format " + i3);
        var l3, p3 = s3.parseCard16(), c3 = s3.parseCard16();
        if (0 !== c3) throw new Error("CFF Table CID Font FDSelect format 3 range has bad initial GID " + c3);
        for (var h3 = 0; h3 < p3; h3++) {
          if (a3 = s3.parseCard8(), l3 = s3.parseCard16(), a3 >= n3) throw new Error("CFF table CID Font FDSelect has bad FD index value " + a3 + " (FD count " + n3 + ")");
          if (l3 > r3) throw new Error("CFF Table CID Font FDSelect format 3 range has bad GID " + l3);
          for (; c3 < l3; c3++) o3.push(a3);
          c3 = l3;
        }
        if (l3 !== r3) throw new Error("CFF Table CID Font FDSelect format 3 range has bad final GID " + l3);
      }
      return o3;
    }(e2, h2, r2.numGlyphs, d2.length);
  }
  var v2, g2 = t2 + p2.private[1], m2 = Ve(e2, g2, p2.private[0], i2.objects);
  if (r2.defaultWidthX = m2.defaultWidthX, r2.nominalWidthX = m2.nominalWidthX, 0 !== m2.subrs) {
    var y2 = g2 + m2.subrs, b2 = Ae(e2, y2);
    r2.subrs = b2.objects, r2.subrsBias = Pe(r2.subrs);
  } else r2.subrs = [], r2.subrsBias = 0;
  n2.lowMemory ? (v2 = function(e3, t3) {
    var r3, n3, a3 = [], o3 = se.getCard16(e3, t3);
    if (0 !== o3) {
      var s3 = se.getByte(e3, t3 + 2);
      r3 = t3 + (o3 + 1) * s3 + 2;
      for (var i3 = t3 + 3, u3 = 0; u3 < o3 + 1; u3 += 1) a3.push(se.getOffset(e3, i3, s3)), i3 += s3;
      n3 = r3 + a3[o3];
    } else n3 = t3 + 2;
    return { offsets: a3, startOffset: t3, endOffset: n3 };
  }(e2, t2 + p2.charStrings), r2.nGlyphs = v2.offsets.length) : (v2 = Ae(e2, t2 + p2.charStrings), r2.nGlyphs = v2.objects.length);
  var S2 = function(e3, t3, r3, n3) {
    var a3, o3, s3 = new se.Parser(e3, t3);
    r3 -= 1;
    var i3 = [".notdef"], u3 = s3.parseCard8();
    if (0 === u3) for (var l3 = 0; l3 < r3; l3 += 1) a3 = s3.parseSID(), i3.push(ze(n3, a3));
    else if (1 === u3) for (; i3.length <= r3; ) {
      a3 = s3.parseSID(), o3 = s3.parseCard8();
      for (var p3 = 0; p3 <= o3; p3 += 1) i3.push(ze(n3, a3)), a3 += 1;
    }
    else {
      if (2 !== u3) throw new Error("Unknown charset format " + u3);
      for (; i3.length <= r3; ) {
        a3 = s3.parseSID(), o3 = s3.parseCard16();
        for (var c3 = 0; c3 <= o3; c3 += 1) i3.push(ze(n3, a3)), a3 += 1;
      }
    }
    return i3;
  }(e2, t2 + p2.charset, r2.nGlyphs, i2.objects);
  if (0 === p2.encoding ? r2.cffEncoding = new Le(Ue, S2) : 1 === p2.encoding ? r2.cffEncoding = new Le(ke, S2) : r2.cffEncoding = function(e3, t3, r3) {
    var n3, a3 = {}, o3 = new se.Parser(e3, t3), s3 = o3.parseCard8();
    if (0 === s3) for (var i3 = o3.parseCard8(), u3 = 0; u3 < i3; u3 += 1) a3[n3 = o3.parseCard8()] = u3;
    else {
      if (1 !== s3) throw new Error("Unknown encoding format " + s3);
      var l3 = o3.parseCard8();
      n3 = 1;
      for (var p3 = 0; p3 < l3; p3 += 1) for (var c3 = o3.parseCard8(), h3 = o3.parseCard8(), f3 = c3; f3 <= c3 + h3; f3 += 1) a3[f3] = n3, n3 += 1;
    }
    return new Le(a3, r3);
  }(e2, t2 + p2.encoding, S2), r2.encoding = r2.encoding || r2.cffEncoding, r2.glyphs = new Be.GlyphSet(r2), n2.lowMemory) r2._push = function(n3) {
    var a3 = function(e3, t3, r3, n4, a4) {
      var o3 = se.getCard16(r3, n4), s3 = 0;
      0 !== o3 && (s3 = n4 + (o3 + 1) * se.getByte(r3, n4 + 2) + 2);
      var i3 = se.getBytes(r3, s3 + t3[e3], s3 + t3[e3 + 1]);
      return a4 && (i3 = a4(i3)), i3;
    }(n3, v2.offsets, e2, t2 + p2.charStrings);
    r2.glyphs.push(n3, Be.cffGlyphLoader(r2, n3, Ye, a3));
  };
  else for (var x2 = 0; x2 < r2.nGlyphs; x2 += 1) {
    var T2 = v2.objects[x2];
    r2.glyphs.push(x2, Be.cffGlyphLoader(r2, x2, Ye, T2));
  }
}, make: function(e2, t2) {
  for (var r2, n2 = new J.Table("CFF ", [{ name: "header", type: "RECORD" }, { name: "nameIndex", type: "RECORD" }, { name: "topDictIndex", type: "RECORD" }, { name: "stringIndex", type: "RECORD" }, { name: "globalSubrIndex", type: "RECORD" }, { name: "charsets", type: "RECORD" }, { name: "charStringsIndex", type: "RECORD" }, { name: "privateDict", type: "RECORD" }]), a2 = 1 / t2.unitsPerEm, o2 = { version: t2.version, fullName: t2.fullName, familyName: t2.familyName, weight: t2.weightName, fontBBox: t2.fontBBox || [0, 0, 0, 0], fontMatrix: [a2, 0, 0, a2, 0, 0], charset: 999, encoding: 0, charStrings: 999, private: [0, 999] }, s2 = [], i2 = 1; i2 < e2.length; i2 += 1) r2 = e2.get(i2), s2.push(r2.name);
  var u2 = [];
  n2.header = new J.Record("Header", [{ name: "major", type: "Card8", value: 1 }, { name: "minor", type: "Card8", value: 0 }, { name: "hdrSize", type: "Card8", value: 4 }, { name: "major", type: "Card8", value: 1 }]), n2.nameIndex = function(e3) {
    var t3 = new J.Record("Name INDEX", [{ name: "names", type: "INDEX", value: [] }]);
    t3.names = [];
    for (var r3 = 0; r3 < e3.length; r3 += 1) t3.names.push({ name: "name_" + r3, type: "NAME", value: e3[r3] });
    return t3;
  }([t2.postScriptName]);
  var l2 = Ke(o2, u2);
  n2.topDictIndex = Je(l2), n2.globalSubrIndex = new J.Record("Global Subr INDEX", [{ name: "subrs", type: "INDEX", value: [] }]), n2.charsets = function(e3, t3) {
    for (var r3 = new J.Record("Charsets", [{ name: "format", type: "Card8", value: 0 }]), n3 = 0; n3 < e3.length; n3 += 1) {
      var a3 = Ze(e3[n3], t3);
      r3.fields.push({ name: "glyph_" + n3, type: "SID", value: a3 });
    }
    return r3;
  }(s2, u2), n2.charStringsIndex = function(e3) {
    for (var t3 = new J.Record("CharStrings INDEX", [{ name: "charStrings", type: "INDEX", value: [] }]), r3 = 0; r3 < e3.length; r3 += 1) {
      var n3 = e3.get(r3), a3 = $e(n3);
      t3.charStrings.push({ name: n3.name, type: "CHARSTRING", value: a3 });
    }
    return t3;
  }(e2), n2.privateDict = function(e3, t3) {
    var r3 = new J.Record("Private DICT", [{ name: "dict", type: "DICT", value: {} }]);
    return r3.dict = Qe(_e, e3, t3), r3;
  }({}, u2), n2.stringIndex = function(e3) {
    var t3 = new J.Record("String INDEX", [{ name: "strings", type: "INDEX", value: [] }]);
    t3.strings = [];
    for (var r3 = 0; r3 < e3.length; r3 += 1) t3.strings.push({ name: "string_" + r3, type: "STRING", value: e3[r3] });
    return t3;
  }(u2);
  var p2 = n2.header.sizeOf() + n2.nameIndex.sizeOf() + n2.topDictIndex.sizeOf() + n2.stringIndex.sizeOf() + n2.globalSubrIndex.sizeOf();
  return o2.charset = p2, o2.encoding = 0, o2.charStrings = o2.charset + n2.charsets.sizeOf(), o2.private[1] = o2.charStrings + n2.charStringsIndex.sizeOf(), l2 = Ke(o2, u2), n2.topDictIndex = Je(l2), n2;
} };
var tt = { parse: function(e2, t2) {
  var r2 = {}, n2 = new se.Parser(e2, t2);
  return r2.version = n2.parseVersion(), r2.fontRevision = Math.round(1e3 * n2.parseFixed()) / 1e3, r2.checkSumAdjustment = n2.parseULong(), r2.magicNumber = n2.parseULong(), w.argument(1594834165 === r2.magicNumber, "Font header has wrong magic number."), r2.flags = n2.parseUShort(), r2.unitsPerEm = n2.parseUShort(), r2.created = n2.parseLongDateTime(), r2.modified = n2.parseLongDateTime(), r2.xMin = n2.parseShort(), r2.yMin = n2.parseShort(), r2.xMax = n2.parseShort(), r2.yMax = n2.parseShort(), r2.macStyle = n2.parseUShort(), r2.lowestRecPPEM = n2.parseUShort(), r2.fontDirectionHint = n2.parseShort(), r2.indexToLocFormat = n2.parseShort(), r2.glyphDataFormat = n2.parseShort(), r2;
}, make: function(e2) {
  var t2 = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) + 2082844800, r2 = t2;
  return e2.createdTimestamp && (r2 = e2.createdTimestamp + 2082844800), new J.Table("head", [{ name: "version", type: "FIXED", value: 65536 }, { name: "fontRevision", type: "FIXED", value: 65536 }, { name: "checkSumAdjustment", type: "ULONG", value: 0 }, { name: "magicNumber", type: "ULONG", value: 1594834165 }, { name: "flags", type: "USHORT", value: 0 }, { name: "unitsPerEm", type: "USHORT", value: 1e3 }, { name: "created", type: "LONGDATETIME", value: r2 }, { name: "modified", type: "LONGDATETIME", value: t2 }, { name: "xMin", type: "SHORT", value: 0 }, { name: "yMin", type: "SHORT", value: 0 }, { name: "xMax", type: "SHORT", value: 0 }, { name: "yMax", type: "SHORT", value: 0 }, { name: "macStyle", type: "USHORT", value: 0 }, { name: "lowestRecPPEM", type: "USHORT", value: 0 }, { name: "fontDirectionHint", type: "SHORT", value: 2 }, { name: "indexToLocFormat", type: "SHORT", value: 0 }, { name: "glyphDataFormat", type: "SHORT", value: 0 }], e2);
} };
var rt = { parse: function(e2, t2) {
  var r2 = {}, n2 = new se.Parser(e2, t2);
  return r2.version = n2.parseVersion(), r2.ascender = n2.parseShort(), r2.descender = n2.parseShort(), r2.lineGap = n2.parseShort(), r2.advanceWidthMax = n2.parseUShort(), r2.minLeftSideBearing = n2.parseShort(), r2.minRightSideBearing = n2.parseShort(), r2.xMaxExtent = n2.parseShort(), r2.caretSlopeRise = n2.parseShort(), r2.caretSlopeRun = n2.parseShort(), r2.caretOffset = n2.parseShort(), n2.relativeOffset += 8, r2.metricDataFormat = n2.parseShort(), r2.numberOfHMetrics = n2.parseUShort(), r2;
}, make: function(e2) {
  return new J.Table("hhea", [{ name: "version", type: "FIXED", value: 65536 }, { name: "ascender", type: "FWORD", value: 0 }, { name: "descender", type: "FWORD", value: 0 }, { name: "lineGap", type: "FWORD", value: 0 }, { name: "advanceWidthMax", type: "UFWORD", value: 0 }, { name: "minLeftSideBearing", type: "FWORD", value: 0 }, { name: "minRightSideBearing", type: "FWORD", value: 0 }, { name: "xMaxExtent", type: "FWORD", value: 0 }, { name: "caretSlopeRise", type: "SHORT", value: 1 }, { name: "caretSlopeRun", type: "SHORT", value: 0 }, { name: "caretOffset", type: "SHORT", value: 0 }, { name: "reserved1", type: "SHORT", value: 0 }, { name: "reserved2", type: "SHORT", value: 0 }, { name: "reserved3", type: "SHORT", value: 0 }, { name: "reserved4", type: "SHORT", value: 0 }, { name: "metricDataFormat", type: "SHORT", value: 0 }, { name: "numberOfHMetrics", type: "USHORT", value: 0 }], e2);
} };
var nt = { parse: function(e2, t2, r2, n2, a2, o2, s2) {
  s2.lowMemory ? function(e3, t3, r3, n3, a3) {
    var o3, s3;
    e3._hmtxTableData = {};
    for (var i2 = new se.Parser(t3, r3), u2 = 0; u2 < a3; u2 += 1) u2 < n3 && (o3 = i2.parseUShort(), s3 = i2.parseShort()), e3._hmtxTableData[u2] = { advanceWidth: o3, leftSideBearing: s3 };
  }(e2, t2, r2, n2, a2) : function(e3, t3, r3, n3, a3) {
    for (var o3, s3, i2 = new se.Parser(e3, t3), u2 = 0; u2 < n3; u2 += 1) {
      u2 < r3 && (o3 = i2.parseUShort(), s3 = i2.parseShort());
      var l2 = a3.get(u2);
      l2.advanceWidth = o3, l2.leftSideBearing = s3;
    }
  }(t2, r2, n2, a2, o2);
}, make: function(e2) {
  for (var t2 = new J.Table("hmtx", []), r2 = 0; r2 < e2.length; r2 += 1) {
    var n2 = e2.get(r2), a2 = n2.advanceWidth || 0, o2 = n2.leftSideBearing || 0;
    t2.fields.push({ name: "advanceWidth_" + r2, type: "USHORT", value: a2 }), t2.fields.push({ name: "leftSideBearing_" + r2, type: "SHORT", value: o2 });
  }
  return t2;
} };
var at = { make: function(e2) {
  for (var t2 = new J.Table("ltag", [{ name: "version", type: "ULONG", value: 1 }, { name: "flags", type: "ULONG", value: 0 }, { name: "numTags", type: "ULONG", value: e2.length }]), r2 = "", n2 = 12 + 4 * e2.length, a2 = 0; a2 < e2.length; ++a2) {
    var o2 = r2.indexOf(e2[a2]);
    o2 < 0 && (o2 = r2.length, r2 += e2[a2]), t2.fields.push({ name: "offset " + a2, type: "USHORT", value: n2 + o2 }), t2.fields.push({ name: "length " + a2, type: "USHORT", value: e2[a2].length });
  }
  return t2.fields.push({ name: "stringPool", type: "CHARARRAY", value: r2 }), t2;
}, parse: function(e2, t2) {
  var r2 = new se.Parser(e2, t2), n2 = r2.parseULong();
  w.argument(1 === n2, "Unsupported ltag table version."), r2.skip("uLong", 1);
  for (var a2 = r2.parseULong(), o2 = [], s2 = 0; s2 < a2; s2++) {
    for (var i2 = "", u2 = t2 + r2.parseUShort(), l2 = r2.parseUShort(), p2 = u2; p2 < u2 + l2; ++p2) i2 += String.fromCharCode(e2.getInt8(p2));
    o2.push(i2);
  }
  return o2;
} };
var ot = { parse: function(e2, t2) {
  var r2 = {}, n2 = new se.Parser(e2, t2);
  return r2.version = n2.parseVersion(), r2.numGlyphs = n2.parseUShort(), 1 === r2.version && (r2.maxPoints = n2.parseUShort(), r2.maxContours = n2.parseUShort(), r2.maxCompositePoints = n2.parseUShort(), r2.maxCompositeContours = n2.parseUShort(), r2.maxZones = n2.parseUShort(), r2.maxTwilightPoints = n2.parseUShort(), r2.maxStorage = n2.parseUShort(), r2.maxFunctionDefs = n2.parseUShort(), r2.maxInstructionDefs = n2.parseUShort(), r2.maxStackElements = n2.parseUShort(), r2.maxSizeOfInstructions = n2.parseUShort(), r2.maxComponentElements = n2.parseUShort(), r2.maxComponentDepth = n2.parseUShort()), r2;
}, make: function(e2) {
  return new J.Table("maxp", [{ name: "version", type: "FIXED", value: 20480 }, { name: "numGlyphs", type: "USHORT", value: e2 }]);
} };
var st = [{ begin: 0, end: 127 }, { begin: 128, end: 255 }, { begin: 256, end: 383 }, { begin: 384, end: 591 }, { begin: 592, end: 687 }, { begin: 688, end: 767 }, { begin: 768, end: 879 }, { begin: 880, end: 1023 }, { begin: 11392, end: 11519 }, { begin: 1024, end: 1279 }, { begin: 1328, end: 1423 }, { begin: 1424, end: 1535 }, { begin: 42240, end: 42559 }, { begin: 1536, end: 1791 }, { begin: 1984, end: 2047 }, { begin: 2304, end: 2431 }, { begin: 2432, end: 2559 }, { begin: 2560, end: 2687 }, { begin: 2688, end: 2815 }, { begin: 2816, end: 2943 }, { begin: 2944, end: 3071 }, { begin: 3072, end: 3199 }, { begin: 3200, end: 3327 }, { begin: 3328, end: 3455 }, { begin: 3584, end: 3711 }, { begin: 3712, end: 3839 }, { begin: 4256, end: 4351 }, { begin: 6912, end: 7039 }, { begin: 4352, end: 4607 }, { begin: 7680, end: 7935 }, { begin: 7936, end: 8191 }, { begin: 8192, end: 8303 }, { begin: 8304, end: 8351 }, { begin: 8352, end: 8399 }, { begin: 8400, end: 8447 }, { begin: 8448, end: 8527 }, { begin: 8528, end: 8591 }, { begin: 8592, end: 8703 }, { begin: 8704, end: 8959 }, { begin: 8960, end: 9215 }, { begin: 9216, end: 9279 }, { begin: 9280, end: 9311 }, { begin: 9312, end: 9471 }, { begin: 9472, end: 9599 }, { begin: 9600, end: 9631 }, { begin: 9632, end: 9727 }, { begin: 9728, end: 9983 }, { begin: 9984, end: 10175 }, { begin: 12288, end: 12351 }, { begin: 12352, end: 12447 }, { begin: 12448, end: 12543 }, { begin: 12544, end: 12591 }, { begin: 12592, end: 12687 }, { begin: 43072, end: 43135 }, { begin: 12800, end: 13055 }, { begin: 13056, end: 13311 }, { begin: 44032, end: 55215 }, { begin: 55296, end: 57343 }, { begin: 67840, end: 67871 }, { begin: 19968, end: 40959 }, { begin: 57344, end: 63743 }, { begin: 12736, end: 12783 }, { begin: 64256, end: 64335 }, { begin: 64336, end: 65023 }, { begin: 65056, end: 65071 }, { begin: 65040, end: 65055 }, { begin: 65104, end: 65135 }, { begin: 65136, end: 65279 }, { begin: 65280, end: 65519 }, { begin: 65520, end: 65535 }, { begin: 3840, end: 4095 }, { begin: 1792, end: 1871 }, { begin: 1920, end: 1983 }, { begin: 3456, end: 3583 }, { begin: 4096, end: 4255 }, { begin: 4608, end: 4991 }, { begin: 5024, end: 5119 }, { begin: 5120, end: 5759 }, { begin: 5760, end: 5791 }, { begin: 5792, end: 5887 }, { begin: 6016, end: 6143 }, { begin: 6144, end: 6319 }, { begin: 10240, end: 10495 }, { begin: 40960, end: 42127 }, { begin: 5888, end: 5919 }, { begin: 66304, end: 66351 }, { begin: 66352, end: 66383 }, { begin: 66560, end: 66639 }, { begin: 118784, end: 119039 }, { begin: 119808, end: 120831 }, { begin: 1044480, end: 1048573 }, { begin: 65024, end: 65039 }, { begin: 917504, end: 917631 }, { begin: 6400, end: 6479 }, { begin: 6480, end: 6527 }, { begin: 6528, end: 6623 }, { begin: 6656, end: 6687 }, { begin: 11264, end: 11359 }, { begin: 11568, end: 11647 }, { begin: 19904, end: 19967 }, { begin: 43008, end: 43055 }, { begin: 65536, end: 65663 }, { begin: 65856, end: 65935 }, { begin: 66432, end: 66463 }, { begin: 66464, end: 66527 }, { begin: 66640, end: 66687 }, { begin: 66688, end: 66735 }, { begin: 67584, end: 67647 }, { begin: 68096, end: 68191 }, { begin: 119552, end: 119647 }, { begin: 73728, end: 74751 }, { begin: 119648, end: 119679 }, { begin: 7040, end: 7103 }, { begin: 7168, end: 7247 }, { begin: 7248, end: 7295 }, { begin: 43136, end: 43231 }, { begin: 43264, end: 43311 }, { begin: 43312, end: 43359 }, { begin: 43520, end: 43615 }, { begin: 65936, end: 65999 }, { begin: 66e3, end: 66047 }, { begin: 66208, end: 66271 }, { begin: 127024, end: 127135 }];
var it = { parse: function(e2, t2) {
  var r2 = {}, n2 = new se.Parser(e2, t2);
  r2.version = n2.parseUShort(), r2.xAvgCharWidth = n2.parseShort(), r2.usWeightClass = n2.parseUShort(), r2.usWidthClass = n2.parseUShort(), r2.fsType = n2.parseUShort(), r2.ySubscriptXSize = n2.parseShort(), r2.ySubscriptYSize = n2.parseShort(), r2.ySubscriptXOffset = n2.parseShort(), r2.ySubscriptYOffset = n2.parseShort(), r2.ySuperscriptXSize = n2.parseShort(), r2.ySuperscriptYSize = n2.parseShort(), r2.ySuperscriptXOffset = n2.parseShort(), r2.ySuperscriptYOffset = n2.parseShort(), r2.yStrikeoutSize = n2.parseShort(), r2.yStrikeoutPosition = n2.parseShort(), r2.sFamilyClass = n2.parseShort(), r2.panose = [];
  for (var a2 = 0; a2 < 10; a2++) r2.panose[a2] = n2.parseByte();
  return r2.ulUnicodeRange1 = n2.parseULong(), r2.ulUnicodeRange2 = n2.parseULong(), r2.ulUnicodeRange3 = n2.parseULong(), r2.ulUnicodeRange4 = n2.parseULong(), r2.achVendID = String.fromCharCode(n2.parseByte(), n2.parseByte(), n2.parseByte(), n2.parseByte()), r2.fsSelection = n2.parseUShort(), r2.usFirstCharIndex = n2.parseUShort(), r2.usLastCharIndex = n2.parseUShort(), r2.sTypoAscender = n2.parseShort(), r2.sTypoDescender = n2.parseShort(), r2.sTypoLineGap = n2.parseShort(), r2.usWinAscent = n2.parseUShort(), r2.usWinDescent = n2.parseUShort(), r2.version >= 1 && (r2.ulCodePageRange1 = n2.parseULong(), r2.ulCodePageRange2 = n2.parseULong()), r2.version >= 2 && (r2.sxHeight = n2.parseShort(), r2.sCapHeight = n2.parseShort(), r2.usDefaultChar = n2.parseUShort(), r2.usBreakChar = n2.parseUShort(), r2.usMaxContent = n2.parseUShort()), r2;
}, make: function(e2) {
  return new J.Table("OS/2", [{ name: "version", type: "USHORT", value: 3 }, { name: "xAvgCharWidth", type: "SHORT", value: 0 }, { name: "usWeightClass", type: "USHORT", value: 0 }, { name: "usWidthClass", type: "USHORT", value: 0 }, { name: "fsType", type: "USHORT", value: 0 }, { name: "ySubscriptXSize", type: "SHORT", value: 650 }, { name: "ySubscriptYSize", type: "SHORT", value: 699 }, { name: "ySubscriptXOffset", type: "SHORT", value: 0 }, { name: "ySubscriptYOffset", type: "SHORT", value: 140 }, { name: "ySuperscriptXSize", type: "SHORT", value: 650 }, { name: "ySuperscriptYSize", type: "SHORT", value: 699 }, { name: "ySuperscriptXOffset", type: "SHORT", value: 0 }, { name: "ySuperscriptYOffset", type: "SHORT", value: 479 }, { name: "yStrikeoutSize", type: "SHORT", value: 49 }, { name: "yStrikeoutPosition", type: "SHORT", value: 258 }, { name: "sFamilyClass", type: "SHORT", value: 0 }, { name: "bFamilyType", type: "BYTE", value: 0 }, { name: "bSerifStyle", type: "BYTE", value: 0 }, { name: "bWeight", type: "BYTE", value: 0 }, { name: "bProportion", type: "BYTE", value: 0 }, { name: "bContrast", type: "BYTE", value: 0 }, { name: "bStrokeVariation", type: "BYTE", value: 0 }, { name: "bArmStyle", type: "BYTE", value: 0 }, { name: "bLetterform", type: "BYTE", value: 0 }, { name: "bMidline", type: "BYTE", value: 0 }, { name: "bXHeight", type: "BYTE", value: 0 }, { name: "ulUnicodeRange1", type: "ULONG", value: 0 }, { name: "ulUnicodeRange2", type: "ULONG", value: 0 }, { name: "ulUnicodeRange3", type: "ULONG", value: 0 }, { name: "ulUnicodeRange4", type: "ULONG", value: 0 }, { name: "achVendID", type: "CHARARRAY", value: "XXXX" }, { name: "fsSelection", type: "USHORT", value: 0 }, { name: "usFirstCharIndex", type: "USHORT", value: 0 }, { name: "usLastCharIndex", type: "USHORT", value: 0 }, { name: "sTypoAscender", type: "SHORT", value: 0 }, { name: "sTypoDescender", type: "SHORT", value: 0 }, { name: "sTypoLineGap", type: "SHORT", value: 0 }, { name: "usWinAscent", type: "USHORT", value: 0 }, { name: "usWinDescent", type: "USHORT", value: 0 }, { name: "ulCodePageRange1", type: "ULONG", value: 0 }, { name: "ulCodePageRange2", type: "ULONG", value: 0 }, { name: "sxHeight", type: "SHORT", value: 0 }, { name: "sCapHeight", type: "SHORT", value: 0 }, { name: "usDefaultChar", type: "USHORT", value: 0 }, { name: "usBreakChar", type: "USHORT", value: 0 }, { name: "usMaxContext", type: "USHORT", value: 0 }], e2);
}, unicodeRanges: st, getUnicodeRange: function(e2) {
  for (var t2 = 0; t2 < st.length; t2 += 1) {
    var r2 = st[t2];
    if (e2 >= r2.begin && e2 < r2.end) return t2;
  }
  return -1;
} };
var ut = { parse: function(e2, t2) {
  var r2 = {}, n2 = new se.Parser(e2, t2);
  switch (r2.version = n2.parseVersion(), r2.italicAngle = n2.parseFixed(), r2.underlinePosition = n2.parseShort(), r2.underlineThickness = n2.parseShort(), r2.isFixedPitch = n2.parseULong(), r2.minMemType42 = n2.parseULong(), r2.maxMemType42 = n2.parseULong(), r2.minMemType1 = n2.parseULong(), r2.maxMemType1 = n2.parseULong(), r2.version) {
    case 1:
      r2.names = Oe.slice();
      break;
    case 2:
      r2.numberOfGlyphs = n2.parseUShort(), r2.glyphNameIndex = new Array(r2.numberOfGlyphs);
      for (var a2 = 0; a2 < r2.numberOfGlyphs; a2++) r2.glyphNameIndex[a2] = n2.parseUShort();
      r2.names = [];
      for (var o2 = 0; o2 < r2.numberOfGlyphs; o2++) if (r2.glyphNameIndex[o2] >= Oe.length) {
        var s2 = n2.parseChar();
        r2.names.push(n2.parseString(s2));
      }
      break;
    case 2.5:
      r2.numberOfGlyphs = n2.parseUShort(), r2.offset = new Array(r2.numberOfGlyphs);
      for (var i2 = 0; i2 < r2.numberOfGlyphs; i2++) r2.offset[i2] = n2.parseChar();
  }
  return r2;
}, make: function() {
  return new J.Table("post", [{ name: "version", type: "FIXED", value: 196608 }, { name: "italicAngle", type: "FIXED", value: 0 }, { name: "underlinePosition", type: "FWORD", value: 0 }, { name: "underlineThickness", type: "FWORD", value: 0 }, { name: "isFixedPitch", type: "ULONG", value: 0 }, { name: "minMemType42", type: "ULONG", value: 0 }, { name: "maxMemType42", type: "ULONG", value: 0 }, { name: "minMemType1", type: "ULONG", value: 0 }, { name: "maxMemType1", type: "ULONG", value: 0 }]);
} };
var lt = new Array(9);
lt[1] = function() {
  var e2 = this.offset + this.relativeOffset, t2 = this.parseUShort();
  return 1 === t2 ? { substFormat: 1, coverage: this.parsePointer(ae.coverage), deltaGlyphId: this.parseShort() } : 2 === t2 ? { substFormat: 2, coverage: this.parsePointer(ae.coverage), substitute: this.parseOffset16List() } : void w.assert(false, "0x" + e2.toString(16) + ": lookup type 1 format must be 1 or 2.");
}, lt[2] = function() {
  var e2 = this.parseUShort();
  return w.argument(1 === e2, "GSUB Multiple Substitution Subtable identifier-format must be 1"), { substFormat: e2, coverage: this.parsePointer(ae.coverage), sequences: this.parseListOfLists() };
}, lt[3] = function() {
  var e2 = this.parseUShort();
  return w.argument(1 === e2, "GSUB Alternate Substitution Subtable identifier-format must be 1"), { substFormat: e2, coverage: this.parsePointer(ae.coverage), alternateSets: this.parseListOfLists() };
}, lt[4] = function() {
  var e2 = this.parseUShort();
  return w.argument(1 === e2, "GSUB ligature table identifier-format must be 1"), { substFormat: e2, coverage: this.parsePointer(ae.coverage), ligatureSets: this.parseListOfLists(function() {
    return { ligGlyph: this.parseUShort(), components: this.parseUShortList(this.parseUShort() - 1) };
  }) };
};
var pt = { sequenceIndex: ae.uShort, lookupListIndex: ae.uShort };
lt[5] = function() {
  var e2 = this.offset + this.relativeOffset, t2 = this.parseUShort();
  if (1 === t2) return { substFormat: t2, coverage: this.parsePointer(ae.coverage), ruleSets: this.parseListOfLists(function() {
    var e3 = this.parseUShort(), t3 = this.parseUShort();
    return { input: this.parseUShortList(e3 - 1), lookupRecords: this.parseRecordList(t3, pt) };
  }) };
  if (2 === t2) return { substFormat: t2, coverage: this.parsePointer(ae.coverage), classDef: this.parsePointer(ae.classDef), classSets: this.parseListOfLists(function() {
    var e3 = this.parseUShort(), t3 = this.parseUShort();
    return { classes: this.parseUShortList(e3 - 1), lookupRecords: this.parseRecordList(t3, pt) };
  }) };
  if (3 === t2) {
    var r2 = this.parseUShort(), n2 = this.parseUShort();
    return { substFormat: t2, coverages: this.parseList(r2, ae.pointer(ae.coverage)), lookupRecords: this.parseRecordList(n2, pt) };
  }
  w.assert(false, "0x" + e2.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");
}, lt[6] = function() {
  var e2 = this.offset + this.relativeOffset, t2 = this.parseUShort();
  return 1 === t2 ? { substFormat: 1, coverage: this.parsePointer(ae.coverage), chainRuleSets: this.parseListOfLists(function() {
    return { backtrack: this.parseUShortList(), input: this.parseUShortList(this.parseShort() - 1), lookahead: this.parseUShortList(), lookupRecords: this.parseRecordList(pt) };
  }) } : 2 === t2 ? { substFormat: 2, coverage: this.parsePointer(ae.coverage), backtrackClassDef: this.parsePointer(ae.classDef), inputClassDef: this.parsePointer(ae.classDef), lookaheadClassDef: this.parsePointer(ae.classDef), chainClassSet: this.parseListOfLists(function() {
    return { backtrack: this.parseUShortList(), input: this.parseUShortList(this.parseShort() - 1), lookahead: this.parseUShortList(), lookupRecords: this.parseRecordList(pt) };
  }) } : 3 === t2 ? { substFormat: 3, backtrackCoverage: this.parseList(ae.pointer(ae.coverage)), inputCoverage: this.parseList(ae.pointer(ae.coverage)), lookaheadCoverage: this.parseList(ae.pointer(ae.coverage)), lookupRecords: this.parseRecordList(pt) } : void w.assert(false, "0x" + e2.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");
}, lt[7] = function() {
  var e2 = this.parseUShort();
  w.argument(1 === e2, "GSUB Extension Substitution subtable identifier-format must be 1");
  var t2 = this.parseUShort(), r2 = new ae(this.data, this.offset + this.parseULong());
  return { substFormat: 1, lookupType: t2, extension: lt[t2].call(r2) };
}, lt[8] = function() {
  var e2 = this.parseUShort();
  return w.argument(1 === e2, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1"), { substFormat: e2, coverage: this.parsePointer(ae.coverage), backtrackCoverage: this.parseList(ae.pointer(ae.coverage)), lookaheadCoverage: this.parseList(ae.pointer(ae.coverage)), substitutes: this.parseUShortList() };
};
var ct = new Array(9);
ct[1] = function(e2) {
  return 1 === e2.substFormat ? new J.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 1 }, { name: "coverage", type: "TABLE", value: new J.Coverage(e2.coverage) }, { name: "deltaGlyphID", type: "SHORT", value: e2.deltaGlyphId }]) : new J.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 2 }, { name: "coverage", type: "TABLE", value: new J.Coverage(e2.coverage) }].concat(J.ushortList("substitute", e2.substitute)));
}, ct[2] = function(e2) {
  return w.assert(1 === e2.substFormat, "Lookup type 2 substFormat must be 1."), new J.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 1 }, { name: "coverage", type: "TABLE", value: new J.Coverage(e2.coverage) }].concat(J.tableList("seqSet", e2.sequences, function(e3) {
    return new J.Table("sequenceSetTable", J.ushortList("sequence", e3));
  })));
}, ct[3] = function(e2) {
  return w.assert(1 === e2.substFormat, "Lookup type 3 substFormat must be 1."), new J.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 1 }, { name: "coverage", type: "TABLE", value: new J.Coverage(e2.coverage) }].concat(J.tableList("altSet", e2.alternateSets, function(e3) {
    return new J.Table("alternateSetTable", J.ushortList("alternate", e3));
  })));
}, ct[4] = function(e2) {
  return w.assert(1 === e2.substFormat, "Lookup type 4 substFormat must be 1."), new J.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 1 }, { name: "coverage", type: "TABLE", value: new J.Coverage(e2.coverage) }].concat(J.tableList("ligSet", e2.ligatureSets, function(e3) {
    return new J.Table("ligatureSetTable", J.tableList("ligature", e3, function(e4) {
      return new J.Table("ligatureTable", [{ name: "ligGlyph", type: "USHORT", value: e4.ligGlyph }].concat(J.ushortList("component", e4.components, e4.components.length + 1)));
    }));
  })));
}, ct[6] = function(e2) {
  if (1 === e2.substFormat) {
    var t2 = new J.Table("chainContextTable", [{ name: "substFormat", type: "USHORT", value: e2.substFormat }, { name: "coverage", type: "TABLE", value: new J.Coverage(e2.coverage) }].concat(J.tableList("chainRuleSet", e2.chainRuleSets, function(e3) {
      return new J.Table("chainRuleSetTable", J.tableList("chainRule", e3, function(e4) {
        var t3 = J.ushortList("backtrackGlyph", e4.backtrack, e4.backtrack.length).concat(J.ushortList("inputGlyph", e4.input, e4.input.length + 1)).concat(J.ushortList("lookaheadGlyph", e4.lookahead, e4.lookahead.length)).concat(J.ushortList("substitution", [], e4.lookupRecords.length));
        return e4.lookupRecords.forEach(function(e5, r3) {
          t3 = t3.concat({ name: "sequenceIndex" + r3, type: "USHORT", value: e5.sequenceIndex }).concat({ name: "lookupListIndex" + r3, type: "USHORT", value: e5.lookupListIndex });
        }), new J.Table("chainRuleTable", t3);
      }));
    })));
    return t2;
  }
  if (2 === e2.substFormat) w.assert(false, "lookup type 6 format 2 is not yet supported.");
  else if (3 === e2.substFormat) {
    var r2 = [{ name: "substFormat", type: "USHORT", value: e2.substFormat }];
    return r2.push({ name: "backtrackGlyphCount", type: "USHORT", value: e2.backtrackCoverage.length }), e2.backtrackCoverage.forEach(function(e3, t3) {
      r2.push({ name: "backtrackCoverage" + t3, type: "TABLE", value: new J.Coverage(e3) });
    }), r2.push({ name: "inputGlyphCount", type: "USHORT", value: e2.inputCoverage.length }), e2.inputCoverage.forEach(function(e3, t3) {
      r2.push({ name: "inputCoverage" + t3, type: "TABLE", value: new J.Coverage(e3) });
    }), r2.push({ name: "lookaheadGlyphCount", type: "USHORT", value: e2.lookaheadCoverage.length }), e2.lookaheadCoverage.forEach(function(e3, t3) {
      r2.push({ name: "lookaheadCoverage" + t3, type: "TABLE", value: new J.Coverage(e3) });
    }), r2.push({ name: "substitutionCount", type: "USHORT", value: e2.lookupRecords.length }), e2.lookupRecords.forEach(function(e3, t3) {
      r2 = r2.concat({ name: "sequenceIndex" + t3, type: "USHORT", value: e3.sequenceIndex }).concat({ name: "lookupListIndex" + t3, type: "USHORT", value: e3.lookupListIndex });
    }), new J.Table("chainContextTable", r2);
  }
  w.assert(false, "lookup type 6 format must be 1, 2 or 3.");
};
var ht = { parse: function(e2, t2) {
  var r2 = new ae(e2, t2 = t2 || 0), n2 = r2.parseVersion(1);
  return w.argument(1 === n2 || 1.1 === n2, "Unsupported GSUB table version."), 1 === n2 ? { version: n2, scripts: r2.parseScriptList(), features: r2.parseFeatureList(), lookups: r2.parseLookupList(lt) } : { version: n2, scripts: r2.parseScriptList(), features: r2.parseFeatureList(), lookups: r2.parseLookupList(lt), variations: r2.parseFeatureVariationsList() };
}, make: function(e2) {
  return new J.Table("GSUB", [{ name: "version", type: "ULONG", value: 65536 }, { name: "scripts", type: "TABLE", value: new J.ScriptList(e2.scripts) }, { name: "features", type: "TABLE", value: new J.FeatureList(e2.features) }, { name: "lookups", type: "TABLE", value: new J.LookupList(e2.lookups, ct) }]);
} };
var ft = new Array(10);
ft[1] = function() {
  var e2 = this.offset + this.relativeOffset, t2 = this.parseUShort();
  return 1 === t2 ? { posFormat: 1, coverage: this.parsePointer(ae.coverage), value: this.parseValueRecord() } : 2 === t2 ? { posFormat: 2, coverage: this.parsePointer(ae.coverage), values: this.parseValueRecordList() } : void w.assert(false, "0x" + e2.toString(16) + ": GPOS lookup type 1 format must be 1 or 2.");
}, ft[2] = function() {
  var e2 = this.offset + this.relativeOffset, t2 = this.parseUShort();
  w.assert(1 === t2 || 2 === t2, "0x" + e2.toString(16) + ": GPOS lookup type 2 format must be 1 or 2.");
  var r2 = this.parsePointer(ae.coverage), n2 = this.parseUShort(), a2 = this.parseUShort();
  if (1 === t2) return { posFormat: t2, coverage: r2, valueFormat1: n2, valueFormat2: a2, pairSets: this.parseList(ae.pointer(ae.list(function() {
    return { secondGlyph: this.parseUShort(), value1: this.parseValueRecord(n2), value2: this.parseValueRecord(a2) };
  }))) };
  if (2 === t2) {
    var o2 = this.parsePointer(ae.classDef), s2 = this.parsePointer(ae.classDef), i2 = this.parseUShort(), u2 = this.parseUShort();
    return { posFormat: t2, coverage: r2, valueFormat1: n2, valueFormat2: a2, classDef1: o2, classDef2: s2, class1Count: i2, class2Count: u2, classRecords: this.parseList(i2, ae.list(u2, function() {
      return { value1: this.parseValueRecord(n2), value2: this.parseValueRecord(a2) };
    })) };
  }
}, ft[3] = function() {
  return { error: "GPOS Lookup 3 not supported" };
}, ft[4] = function() {
  return { error: "GPOS Lookup 4 not supported" };
}, ft[5] = function() {
  return { error: "GPOS Lookup 5 not supported" };
}, ft[6] = function() {
  return { error: "GPOS Lookup 6 not supported" };
}, ft[7] = function() {
  return { error: "GPOS Lookup 7 not supported" };
}, ft[8] = function() {
  return { error: "GPOS Lookup 8 not supported" };
}, ft[9] = function() {
  return { error: "GPOS Lookup 9 not supported" };
};
var dt = { parse: function(e2, t2) {
  var r2 = new ae(e2, t2 = t2 || 0), n2 = r2.parseVersion(1);
  return w.argument(1 === n2 || 1.1 === n2, "Unsupported GPOS table version " + n2), 1 === n2 ? { version: n2, scripts: r2.parseScriptList(), features: r2.parseFeatureList(), lookups: r2.parseLookupList(ft) } : { version: n2, scripts: r2.parseScriptList(), features: r2.parseFeatureList(), lookups: r2.parseLookupList(ft), variations: r2.parseFeatureVariationsList() };
}, make: function(e2) {
  var t2 = Object.entries(e2);
  t2.sort(function(e3, t3) {
    var r3 = parseInt(e3[0].match(/\d+/)[0]), n3 = parseInt(e3[0].match(/\d+$/)[0]), a3 = parseInt(t3[0].match(/\d+/)[0]), o3 = parseInt(t3[0].match(/\d+$/)[0]);
    return r3 < a3 ? -1 : r3 > a3 ? 1 : n3 < o3 ? -1 : 1;
  });
  for (var r2 = t2.length, n2 = [], a2 = [], o2 = 0; o2 < r2; o2++) {
    var s2 = parseInt(t2[o2][0].match(/\d+/)[0]), i2 = parseInt(t2[o2][0].match(/\d+$/)[0]);
    s2 !== n2[n2.length - 1] && (n2.push(s2), a2[n2.length - 1] = []), a2[n2.length - 1].push([i2, t2[o2][1]]);
  }
  for (var u2 = new J.Table("GPOS", [{ name: "majorVersion", type: "USHORT", value: 1 }, { name: "minorVersion", type: "USHORT", value: 0 }, { name: "scriptListOffset", type: "USHORT", value: 10 }, { name: "featureListOffset", type: "USHORT", value: 48 }, { name: "lookupListOffset", type: "USHORT", value: 62 }, { name: "scriptCount", type: "USHORT", value: 2 }, { name: "scriptTag", type: "TAG", value: "DFLT" }, { name: "scriptOffset", type: "USHORT", value: 14 }, { name: "scriptTag2", type: "TAG", value: "latn" }, { name: "scriptOffset2", type: "USHORT", value: 26 }, { name: "defaultLangSysOffset", type: "USHORT", value: 4 }, { name: "langSysCount", type: "USHORT", value: 0 }, { name: "lookupOrderOffset", type: "USHORT", value: 0 }, { name: "requiredFeatureIndex", type: "USHORT", value: 65535 }, { name: "featureIndexCount", type: "USHORT", value: 1 }, { name: "featureIndex", type: "USHORT", value: 0 }, { name: "defaultLangSysOffset2", type: "USHORT", value: 4 }, { name: "langSysCount2", type: "USHORT", value: 0 }, { name: "lookupOrderOffset2", type: "USHORT", value: 0 }, { name: "requiredFeatureIndex2", type: "USHORT", value: 65535 }, { name: "featureIndexCount2", type: "USHORT", value: 1 }, { name: "featureIndex2", type: "USHORT", value: 0 }, { name: "featureCount", type: "USHORT", value: 1 }, { name: "featureTag", type: "TAG", value: "kern" }, { name: "featureOffset", type: "USHORT", value: 8 }, { name: "featureParamsOffset", type: "USHORT", value: 0 }, { name: "lookupIndexCount", type: "USHORT", value: 1 }, { name: "lookupListIndices", type: "USHORT", value: 0 }, { name: "lookupCount", type: "USHORT", value: 1 }, { name: "lookupOffset", type: "USHORT", value: 4 }, { name: "lookupType", type: "USHORT", value: 2 }, { name: "lookupFlag", type: "USHORT", value: 0 }, { name: "subTableCount", type: "USHORT", value: 1 }, { name: "lookupOffset2", type: "USHORT", value: 8 }, { name: "posFormat", type: "USHORT", value: 1 }, { name: "coverageOffset", type: "USHORT", value: 10 + 4 * n2.length + 4 * r2 }, { name: "valueFormat1", type: "USHORT", value: 4 }, { name: "valueFormat2", type: "USHORT", value: 0 }, { name: "pairSetCount", type: "USHORT", value: n2.length }]), l2 = 10 + 2 * n2.length, p2 = 0; p2 < n2.length; p2++) u2.fields.push({ name: "pairSetOffsets", type: "USHORT", value: l2 }), l2 = l2 + 2 + 4 * a2[p2].length;
  for (var c2 = 0; c2 < a2.length; c2++) {
    u2.fields.push({ name: "pairValueCount", type: "USHORT", value: a2[c2].length });
    for (var h2 = 0; h2 < a2[c2].length; h2++) u2.fields.push({ name: "secondGlyph", type: "USHORT", value: a2[c2][h2][0] }), u2.fields.push({ name: "valueRecord1", type: "USHORT", value: a2[c2][h2][1] });
  }
  u2.fields.push({ name: "coverageFormat", type: "USHORT", value: 1 }), u2.fields.push({ name: "glyphCount", type: "USHORT", value: n2.length });
  for (var f2 = 0; f2 < n2.length; f2++) u2.fields.push({ name: "UppercasePGlyphID", type: "USHORT", value: n2[f2] });
  return u2;
} };
var vt = { parse: function(e2, t2) {
  var r2 = new se.Parser(e2, t2), n2 = r2.parseULong();
  w.argument(1 === n2, "Unsupported META table version."), r2.parseULong(), r2.parseULong();
  for (var a2 = r2.parseULong(), o2 = {}, s2 = 0; s2 < a2; s2++) {
    var i2 = r2.parseTag(), u2 = r2.parseULong(), l2 = r2.parseULong(), p2 = I.UTF8(e2, t2 + u2, l2);
    o2[i2] = p2;
  }
  return o2;
}, make: function(e2) {
  var t2 = Object.keys(e2).length, r2 = "", n2 = 16 + 12 * t2, a2 = new J.Table("meta", [{ name: "version", type: "ULONG", value: 1 }, { name: "flags", type: "ULONG", value: 0 }, { name: "offset", type: "ULONG", value: n2 }, { name: "numTags", type: "ULONG", value: t2 }]);
  for (var o2 in e2) {
    var s2 = r2.length;
    r2 += e2[o2], a2.fields.push({ name: "tag " + o2, type: "TAG", value: o2 }), a2.fields.push({ name: "offset " + o2, type: "ULONG", value: n2 + s2 }), a2.fields.push({ name: "length " + o2, type: "ULONG", value: e2[o2].length });
  }
  return a2.fields.push({ name: "stringPool", type: "CHARARRAY", value: r2 }), a2;
} };
var gt = { parse: function(e2, t2) {
  var r2 = new ae(e2, t2), n2 = r2.parseUShort();
  w.argument(0 === n2, "Only COLRv0 supported.");
  var a2 = r2.parseUShort(), o2 = r2.parseOffset32(), s2 = r2.parseOffset32(), i2 = r2.parseUShort();
  r2.relativeOffset = o2;
  var u2 = r2.parseRecordList(a2, { glyphID: ae.uShort, firstLayerIndex: ae.uShort, numLayers: ae.uShort });
  return r2.relativeOffset = s2, { version: n2, baseGlyphRecords: u2, layerRecords: r2.parseRecordList(i2, { glyphID: ae.uShort, paletteIndex: ae.uShort }) };
}, make: function(e2) {
  var t2 = e2.version;
  void 0 === t2 && (t2 = 0);
  var r2 = e2.baseGlyphRecords;
  void 0 === r2 && (r2 = []);
  var n2 = e2.layerRecords;
  void 0 === n2 && (n2 = []), w.argument(0 === t2, "Only COLRv0 supported.");
  var a2 = 14, o2 = a2 + 6 * r2.length;
  return new J.Table("COLR", [{ name: "version", type: "USHORT", value: t2 }, { name: "numBaseGlyphRecords", type: "USHORT", value: r2.length }, { name: "baseGlyphRecordsOffset", type: "ULONG", value: a2 }, { name: "layerRecordsOffset", type: "ULONG", value: o2 }, { name: "numLayerRecords", type: "USHORT", value: n2.length }].concat(r2.map(function(e3, t3) {
    return [{ name: "glyphID_" + t3, type: "USHORT", value: e3.glyphID }, { name: "firstLayerIndex_" + t3, type: "USHORT", value: e3.firstLayerIndex }, { name: "numLayers_" + t3, type: "USHORT", value: e3.numLayers }];
  }).flat(), n2.map(function(e3, t3) {
    return [{ name: "LayerGlyphID_" + t3, type: "USHORT", value: e3.glyphID }, { name: "paletteIndex_" + t3, type: "USHORT", value: e3.paletteIndex }];
  }).flat()));
} };
var mt = { parse: function(e2, t2) {
  var r2 = new ae(e2, t2), n2 = r2.parseShort(), a2 = r2.parseShort(), o2 = r2.parseShort(), s2 = r2.parseShort(), i2 = r2.parseOffset32(), u2 = r2.parseUShortList(o2);
  return r2.relativeOffset = i2, { version: n2, numPaletteEntries: a2, colorRecords: r2.parseULongList(s2), colorRecordIndices: u2 };
}, make: function(e2) {
  var t2 = e2.version;
  void 0 === t2 && (t2 = 0);
  var r2 = e2.numPaletteEntries;
  void 0 === r2 && (r2 = 0);
  var n2 = e2.colorRecords;
  void 0 === n2 && (n2 = []);
  var a2 = e2.colorRecordIndices;
  return void 0 === a2 && (a2 = [0]), w.argument(0 === t2, "Only CPALv0 are supported."), w.argument(n2.length, "No colorRecords given."), w.argument(a2.length, "No colorRecordIndices given."), a2.length > 1 && w.argument(r2, "Can't infer numPaletteEntries on multiple colorRecordIndices"), new J.Table("CPAL", [{ name: "version", type: "USHORT", value: t2 }, { name: "numPaletteEntries", type: "USHORT", value: r2 || n2.length }, { name: "numPalettes", type: "USHORT", value: a2.length }, { name: "numColorRecords", type: "USHORT", value: n2.length }, { name: "colorRecordsArrayOffset", type: "ULONG", value: 12 + 2 * a2.length }].concat(a2.map(function(e3, t3) {
    return { name: "colorRecordIndices_" + t3, type: "USHORT", value: e3 };
  }), n2.map(function(e3, t3) {
    return { name: "colorRecords_" + t3, type: "ULONG", value: e3 };
  })));
} };
function yt(e2) {
  return Math.log(e2) / Math.log(2) | 0;
}
function bt(e2) {
  for (; e2.length % 4 != 0; ) e2.push(0);
  for (var t2 = 0, r2 = 0; r2 < e2.length; r2 += 4) t2 += (e2[r2] << 24) + (e2[r2 + 1] << 16) + (e2[r2 + 2] << 8) + e2[r2 + 3];
  return t2 %= Math.pow(2, 32);
}
function St(e2, t2, r2, n2) {
  return new J.Record("Table Record", [{ name: "tag", type: "TAG", value: void 0 !== e2 ? e2 : "" }, { name: "checkSum", type: "ULONG", value: void 0 !== t2 ? t2 : 0 }, { name: "offset", type: "ULONG", value: void 0 !== r2 ? r2 : 0 }, { name: "length", type: "ULONG", value: void 0 !== n2 ? n2 : 0 }]);
}
function xt(e2) {
  var t2 = new J.Table("sfnt", [{ name: "version", type: "TAG", value: "OTTO" }, { name: "numTables", type: "USHORT", value: 0 }, { name: "searchRange", type: "USHORT", value: 0 }, { name: "entrySelector", type: "USHORT", value: 0 }, { name: "rangeShift", type: "USHORT", value: 0 }]);
  t2.tables = e2, t2.numTables = e2.length;
  var r2 = Math.pow(2, yt(t2.numTables));
  t2.searchRange = 16 * r2, t2.entrySelector = yt(r2), t2.rangeShift = 16 * t2.numTables - t2.searchRange;
  for (var n2 = [], a2 = [], o2 = t2.sizeOf() + St().sizeOf() * t2.numTables; o2 % 4 != 0; ) o2 += 1, a2.push({ name: "padding", type: "BYTE", value: 0 });
  for (var s2 = 0; s2 < e2.length; s2 += 1) {
    var i2 = e2[s2];
    w.argument(4 === i2.tableName.length, "Table name" + i2.tableName + " is invalid.");
    var u2 = i2.sizeOf(), l2 = St(i2.tableName, bt(i2.encode()), o2, u2);
    for (n2.push({ name: l2.tag + " Table Record", type: "RECORD", value: l2 }), a2.push({ name: i2.tableName + " table", type: "RECORD", value: i2 }), o2 += u2, w.argument(!isNaN(o2), "Something went wrong calculating the offset."); o2 % 4 != 0; ) o2 += 1, a2.push({ name: "padding", type: "BYTE", value: 0 });
  }
  return n2.sort(function(e3, t3) {
    return e3.value.tag > t3.value.tag ? 1 : -1;
  }), t2.fields = t2.fields.concat(n2), t2.fields = t2.fields.concat(a2), t2;
}
function Tt(e2, t2, r2) {
  for (var n2 = 0; n2 < t2.length; n2 += 1) {
    var a2 = e2.charToGlyphIndex(t2[n2]);
    if (a2 > 0) return e2.glyphs.get(a2).getMetrics();
  }
  return r2;
}
function Ut(e2) {
  for (var t2 = 0, r2 = 0; r2 < e2.length; r2 += 1) t2 += e2[r2];
  return t2 / e2.length;
}
var kt = { make: xt, fontToTable: function(e2) {
  for (var t2, r2 = [], n2 = [], a2 = [], o2 = [], s2 = [], i2 = [], u2 = [], l2 = 0, p2 = 0, c2 = 0, h2 = 0, f2 = 0, d2 = 0; d2 < e2.glyphs.length; d2 += 1) {
    var v2 = e2.glyphs.get(d2), g2 = 0 | v2.unicode;
    if (isNaN(v2.advanceWidth)) throw new Error("Glyph " + v2.name + " (" + d2 + "): advanceWidth is not a number.");
    (t2 > g2 || void 0 === t2) && g2 > 0 && (t2 = g2), l2 < g2 && (l2 = g2);
    var m2 = it.getUnicodeRange(g2);
    if (m2 < 32) p2 |= 1 << m2;
    else if (m2 < 64) c2 |= 1 << m2 - 32;
    else if (m2 < 96) h2 |= 1 << m2 - 64;
    else {
      if (!(m2 < 123)) throw new Error("Unicode ranges bits > 123 are reserved for internal usage");
      f2 |= 1 << m2 - 96;
    }
    if (".notdef" !== v2.name) {
      var y2 = v2.getMetrics();
      r2.push(y2.xMin), n2.push(y2.yMin), a2.push(y2.xMax), o2.push(y2.yMax), i2.push(y2.leftSideBearing), u2.push(y2.rightSideBearing), s2.push(v2.advanceWidth);
    }
  }
  var b2 = { xMin: Math.min.apply(null, r2), yMin: Math.min.apply(null, n2), xMax: Math.max.apply(null, a2), yMax: Math.max.apply(null, o2), advanceWidthMax: Math.max.apply(null, s2), advanceWidthAvg: Ut(s2), minLeftSideBearing: Math.min.apply(null, i2), maxLeftSideBearing: Math.max.apply(null, i2), minRightSideBearing: Math.min.apply(null, u2) };
  b2.ascender = e2.ascender, b2.descender = e2.descender;
  var S2 = tt.make({ flags: 3, unitsPerEm: e2.unitsPerEm, xMin: b2.xMin, yMin: b2.yMin, xMax: b2.xMax, yMax: b2.yMax, lowestRecPPEM: 3, createdTimestamp: e2.createdTimestamp }), x2 = rt.make({ ascender: b2.ascender, descender: b2.descender, advanceWidthMax: b2.advanceWidthMax, minLeftSideBearing: b2.minLeftSideBearing, minRightSideBearing: b2.minRightSideBearing, xMaxExtent: b2.maxLeftSideBearing + (b2.xMax - b2.xMin), numberOfHMetrics: e2.glyphs.length }), T2 = ot.make(e2.glyphs.length), U2 = it.make(Object.assign({ xAvgCharWidth: Math.round(b2.advanceWidthAvg), usFirstCharIndex: t2, usLastCharIndex: l2, ulUnicodeRange1: p2, ulUnicodeRange2: c2, ulUnicodeRange3: h2, ulUnicodeRange4: f2, sTypoAscender: b2.ascender, sTypoDescender: b2.descender, sTypoLineGap: 0, usWinAscent: b2.yMax, usWinDescent: Math.abs(b2.yMin), ulCodePageRange1: 1, sxHeight: Tt(e2, "xyvw", { yMax: Math.round(b2.ascender / 2) }).yMax, sCapHeight: Tt(e2, "HIKLEFJMNTZBDPRAGOQSUVWXY", b2).yMax, usDefaultChar: e2.hasChar(" ") ? 32 : 0, usBreakChar: e2.hasChar(" ") ? 32 : 0 }, e2.tables.os2)), k2 = nt.make(e2.glyphs), O2 = xe.make(e2.glyphs), R2 = e2.getEnglishName("fontFamily"), E2 = e2.getEnglishName("fontSubfamily"), L2 = R2 + " " + E2, C2 = e2.getEnglishName("postScriptName");
  C2 || (C2 = R2.replace(/\s/g, "") + "-" + E2);
  var w2 = {};
  for (var D2 in e2.names) w2[D2] = e2.names[D2];
  w2.uniqueID || (w2.uniqueID = { en: e2.getEnglishName("manufacturer") + ":" + L2 }), w2.postScriptName || (w2.postScriptName = { en: C2 }), w2.preferredFamily || (w2.preferredFamily = e2.names.fontFamily), w2.preferredSubfamily || (w2.preferredSubfamily = e2.names.fontSubfamily);
  var I2 = [], G2 = be.make(w2, I2), M2 = I2.length > 0 ? at.make(I2) : void 0, B2 = ut.make(), F2 = et.make(e2.glyphs, { version: e2.getEnglishName("version"), fullName: L2, familyName: R2, weightName: E2, postScriptName: C2, unitsPerEm: e2.unitsPerEm, fontBBox: [0, b2.yMin, b2.ascender, b2.advanceWidthMax] }), P2 = e2.metas && Object.keys(e2.metas).length > 0 ? vt.make(e2.metas) : void 0, A2 = [S2, x2, T2, U2, G2, O2, B2, F2, k2];
  M2 && A2.push(M2), e2.tables.gsub && A2.push(ht.make(e2.tables.gsub)), e2.kerningPairs && Object.keys(e2.kerningPairs).length > 0 && A2.push(dt.make(e2.kerningPairs)), e2.tables.cpal && A2.push(mt.make(e2.tables.cpal)), e2.tables.colr && A2.push(gt.make(e2.tables.colr)), P2 && A2.push(P2);
  for (var N2 = xt(A2), H2 = bt(N2.encode()), z2 = N2.fields, W2 = false, q2 = 0; q2 < z2.length; q2 += 1) if ("head table" === z2[q2].name) {
    z2[q2].value.checkSumAdjustment = 2981146554 - H2, W2 = true;
    break;
  }
  if (!W2) throw new Error("Could not find head table with checkSum to adjust.");
  return N2;
}, computeCheckSum: bt };
function Ot(e2, t2) {
  for (var r2 = 0, n2 = e2.length - 1; r2 <= n2; ) {
    var a2 = r2 + n2 >>> 1, o2 = e2[a2].tag;
    if (o2 === t2) return a2;
    o2 < t2 ? r2 = a2 + 1 : n2 = a2 - 1;
  }
  return -r2 - 1;
}
function Rt(e2, t2) {
  for (var r2 = 0, n2 = e2.length - 1; r2 <= n2; ) {
    var a2 = r2 + n2 >>> 1, o2 = e2[a2];
    if (o2 === t2) return a2;
    o2 < t2 ? r2 = a2 + 1 : n2 = a2 - 1;
  }
  return -r2 - 1;
}
function Et(e2, t2) {
  for (var r2, n2 = 0, a2 = e2.length - 1; n2 <= a2; ) {
    var o2 = n2 + a2 >>> 1, s2 = (r2 = e2[o2]).start;
    if (s2 === t2) return r2;
    s2 < t2 ? n2 = o2 + 1 : a2 = o2 - 1;
  }
  if (n2 > 0) return t2 > (r2 = e2[n2 - 1]).end ? 0 : r2;
}
function Lt(e2, t2) {
  this.font = e2, this.tableName = t2;
}
function Ct(e2) {
  Lt.call(this, e2, "gpos");
}
function wt(e2) {
  Lt.call(this, e2, "gsub");
}
function Dt(e2, t2) {
  var r2 = e2.length;
  if (r2 !== t2.length) return false;
  for (var n2 = 0; n2 < r2; n2++) if (e2[n2] !== t2[n2]) return false;
  return true;
}
function It(e2, t2, r2) {
  for (var n2 = e2.subtables, a2 = 0; a2 < n2.length; a2++) {
    var o2 = n2[a2];
    if (o2.substFormat === t2) return o2;
  }
  if (r2) return n2.push(r2), r2;
}
function Gt(e2) {
  for (var t2 = new ArrayBuffer(e2.length), r2 = new Uint8Array(t2), n2 = 0; n2 < e2.length; ++n2) r2[n2] = e2[n2];
  return t2;
}
function Mt(e2, t2) {
  if (!e2) throw t2;
}
function Bt(e2, t2, r2, n2, a2) {
  var o2;
  return (t2 & n2) > 0 ? (o2 = e2.parseByte(), t2 & a2 || (o2 = -o2), o2 = r2 + o2) : o2 = (t2 & a2) > 0 ? r2 : r2 + e2.parseShort(), o2;
}
function Ft(e2, t2, r2) {
  var n2, a2, o2 = new se.Parser(t2, r2);
  if (e2.numberOfContours = o2.parseShort(), e2._xMin = o2.parseShort(), e2._yMin = o2.parseShort(), e2._xMax = o2.parseShort(), e2._yMax = o2.parseShort(), e2.numberOfContours > 0) {
    for (var s2 = e2.endPointIndices = [], i2 = 0; i2 < e2.numberOfContours; i2 += 1) s2.push(o2.parseUShort());
    e2.instructionLength = o2.parseUShort(), e2.instructions = [];
    for (var u2 = 0; u2 < e2.instructionLength; u2 += 1) e2.instructions.push(o2.parseByte());
    var l2 = s2[s2.length - 1] + 1;
    n2 = [];
    for (var p2 = 0; p2 < l2; p2 += 1) if (a2 = o2.parseByte(), n2.push(a2), (8 & a2) > 0) for (var c2 = o2.parseByte(), h2 = 0; h2 < c2; h2 += 1) n2.push(a2), p2 += 1;
    if (w.argument(n2.length === l2, "Bad flags."), s2.length > 0) {
      var f2, d2 = [];
      if (l2 > 0) {
        for (var v2 = 0; v2 < l2; v2 += 1) a2 = n2[v2], (f2 = {}).onCurve = !!(1 & a2), f2.lastPointOfContour = s2.indexOf(v2) >= 0, d2.push(f2);
        for (var g2 = 0, m2 = 0; m2 < l2; m2 += 1) a2 = n2[m2], (f2 = d2[m2]).x = Bt(o2, a2, g2, 2, 16), g2 = f2.x;
        for (var y2 = 0, b2 = 0; b2 < l2; b2 += 1) a2 = n2[b2], (f2 = d2[b2]).y = Bt(o2, a2, y2, 4, 32), y2 = f2.y;
      }
      e2.points = d2;
    } else e2.points = [];
  } else if (0 === e2.numberOfContours) e2.points = [];
  else {
    e2.isComposite = true, e2.points = [], e2.components = [];
    for (var S2 = true; S2; ) {
      n2 = o2.parseUShort();
      var x2 = { glyphIndex: o2.parseUShort(), xScale: 1, scale01: 0, scale10: 0, yScale: 1, dx: 0, dy: 0 };
      (1 & n2) > 0 ? (2 & n2) > 0 ? (x2.dx = o2.parseShort(), x2.dy = o2.parseShort()) : x2.matchedPoints = [o2.parseUShort(), o2.parseUShort()] : (2 & n2) > 0 ? (x2.dx = o2.parseChar(), x2.dy = o2.parseChar()) : x2.matchedPoints = [o2.parseByte(), o2.parseByte()], (8 & n2) > 0 ? x2.xScale = x2.yScale = o2.parseF2Dot14() : (64 & n2) > 0 ? (x2.xScale = o2.parseF2Dot14(), x2.yScale = o2.parseF2Dot14()) : (128 & n2) > 0 && (x2.xScale = o2.parseF2Dot14(), x2.scale01 = o2.parseF2Dot14(), x2.scale10 = o2.parseF2Dot14(), x2.yScale = o2.parseF2Dot14()), e2.components.push(x2), S2 = !!(32 & n2);
    }
    if (256 & n2) {
      e2.instructionLength = o2.parseUShort(), e2.instructions = [];
      for (var T2 = 0; T2 < e2.instructionLength; T2 += 1) e2.instructions.push(o2.parseByte());
    }
  }
}
function Pt(e2, t2) {
  for (var r2 = [], n2 = 0; n2 < e2.length; n2 += 1) {
    var a2 = e2[n2], o2 = { x: t2.xScale * a2.x + t2.scale01 * a2.y + t2.dx, y: t2.scale10 * a2.x + t2.yScale * a2.y + t2.dy, onCurve: a2.onCurve, lastPointOfContour: a2.lastPointOfContour };
    r2.push(o2);
  }
  return r2;
}
function At(e2) {
  var t2 = new E();
  if (!e2) return t2;
  for (var r2 = function(e3) {
    for (var t3 = [], r3 = [], n3 = 0; n3 < e3.length; n3 += 1) {
      var a3 = e3[n3];
      r3.push(a3), a3.lastPointOfContour && (t3.push(r3), r3 = []);
    }
    return w.argument(0 === r3.length, "There are still points left in the current contour."), t3;
  }(e2), n2 = 0; n2 < r2.length; ++n2) {
    var a2 = r2[n2], o2 = null, s2 = a2[a2.length - 1], i2 = a2[0];
    if (s2.onCurve) t2.moveTo(s2.x, s2.y);
    else if (i2.onCurve) t2.moveTo(i2.x, i2.y);
    else {
      var u2 = { x: 0.5 * (s2.x + i2.x), y: 0.5 * (s2.y + i2.y) };
      t2.moveTo(u2.x, u2.y);
    }
    for (var l2 = 0; l2 < a2.length; ++l2) if (o2 = s2, s2 = i2, i2 = a2[(l2 + 1) % a2.length], s2.onCurve) t2.lineTo(s2.x, s2.y);
    else {
      var p2 = i2;
      o2.onCurve || (s2.x, o2.x, s2.y, o2.y), i2.onCurve || (p2 = { x: 0.5 * (s2.x + i2.x), y: 0.5 * (s2.y + i2.y) }), t2.quadraticCurveTo(s2.x, s2.y, p2.x, p2.y);
    }
    t2.closePath();
  }
  return t2;
}
function Nt(e2, t2) {
  if (t2.isComposite) for (var r2 = 0; r2 < t2.components.length; r2 += 1) {
    var n2 = t2.components[r2], a2 = e2.get(n2.glyphIndex);
    if (a2.getPath(), a2.points) {
      var o2 = void 0;
      if (void 0 === n2.matchedPoints) o2 = Pt(a2.points, n2);
      else {
        if (n2.matchedPoints[0] > t2.points.length - 1 || n2.matchedPoints[1] > a2.points.length - 1) throw Error("Matched points out of range in " + t2.name);
        var s2 = t2.points[n2.matchedPoints[0]], i2 = a2.points[n2.matchedPoints[1]], u2 = { xScale: n2.xScale, scale01: n2.scale01, scale10: n2.scale10, yScale: n2.yScale, dx: 0, dy: 0 };
        i2 = Pt([i2], u2)[0], u2.dx = s2.x - i2.x, u2.dy = s2.y - i2.y, o2 = Pt(a2.points, u2);
      }
      t2.points = t2.points.concat(o2);
    }
  }
  return At(t2.points);
}
Lt.prototype = { searchTag: Ot, binSearch: Rt, getTable: function(e2) {
  var t2 = this.font.tables[this.tableName];
  return !t2 && e2 && (t2 = this.font.tables[this.tableName] = this.createDefaultTable()), t2;
}, getScriptNames: function() {
  var e2 = this.getTable();
  return e2 ? e2.scripts.map(function(e3) {
    return e3.tag;
  }) : [];
}, getDefaultScriptName: function() {
  var e2 = this.getTable();
  if (e2) {
    for (var t2 = false, r2 = 0; r2 < e2.scripts.length; r2++) {
      var n2 = e2.scripts[r2].tag;
      if ("DFLT" === n2) return n2;
      "latn" === n2 && (t2 = true);
    }
    return t2 ? "latn" : void 0;
  }
}, getScriptTable: function(e2, t2) {
  var r2 = this.getTable(t2);
  if (r2) {
    e2 = e2 || "DFLT";
    var n2 = r2.scripts, a2 = Ot(r2.scripts, e2);
    if (a2 >= 0) return n2[a2].script;
    if (t2) {
      var o2 = { tag: e2, script: { defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }, langSysRecords: [] } };
      return n2.splice(-1 - a2, 0, o2), o2.script;
    }
  }
}, getLangSysTable: function(e2, t2, r2) {
  var n2 = this.getScriptTable(e2, r2);
  if (n2) {
    if (!t2 || "dflt" === t2 || "DFLT" === t2) return n2.defaultLangSys;
    var a2 = Ot(n2.langSysRecords, t2);
    if (a2 >= 0) return n2.langSysRecords[a2].langSys;
    if (r2) {
      var o2 = { tag: t2, langSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] } };
      return n2.langSysRecords.splice(-1 - a2, 0, o2), o2.langSys;
    }
  }
}, getFeatureTable: function(e2, t2, r2, n2) {
  var a2 = this.getLangSysTable(e2, t2, n2);
  if (a2) {
    for (var o2, s2 = a2.featureIndexes, i2 = this.font.tables[this.tableName].features, u2 = 0; u2 < s2.length; u2++) if ((o2 = i2[s2[u2]]).tag === r2) return o2.feature;
    if (n2) {
      var l2 = i2.length;
      return w.assert(0 === l2 || r2 >= i2[l2 - 1].tag, "Features must be added in alphabetical order."), o2 = { tag: r2, feature: { params: 0, lookupListIndexes: [] } }, i2.push(o2), s2.push(l2), o2.feature;
    }
  }
}, getLookupTables: function(e2, t2, r2, n2, a2) {
  var o2 = this.getFeatureTable(e2, t2, r2, a2), s2 = [];
  if (o2) {
    for (var i2, u2 = o2.lookupListIndexes, l2 = this.font.tables[this.tableName].lookups, p2 = 0; p2 < u2.length; p2++) (i2 = l2[u2[p2]]).lookupType === n2 && s2.push(i2);
    if (0 === s2.length && a2) {
      i2 = { lookupType: n2, lookupFlag: 0, subtables: [], markFilteringSet: void 0 };
      var c2 = l2.length;
      return l2.push(i2), u2.push(c2), [i2];
    }
  }
  return s2;
}, getGlyphClass: function(e2, t2) {
  switch (e2.format) {
    case 1:
      return e2.startGlyph <= t2 && t2 < e2.startGlyph + e2.classes.length ? e2.classes[t2 - e2.startGlyph] : 0;
    case 2:
      var r2 = Et(e2.ranges, t2);
      return r2 ? r2.classId : 0;
  }
}, getCoverageIndex: function(e2, t2) {
  switch (e2.format) {
    case 1:
      var r2 = Rt(e2.glyphs, t2);
      return r2 >= 0 ? r2 : -1;
    case 2:
      var n2 = Et(e2.ranges, t2);
      return n2 ? n2.index + t2 - n2.start : -1;
  }
}, expandCoverage: function(e2) {
  if (1 === e2.format) return e2.glyphs;
  for (var t2 = [], r2 = e2.ranges, n2 = 0; n2 < r2.length; n2++) for (var a2 = r2[n2], o2 = a2.start, s2 = a2.end, i2 = o2; i2 <= s2; i2++) t2.push(i2);
  return t2;
} }, Ct.prototype = Lt.prototype, Ct.prototype.init = function() {
  var e2 = this.getDefaultScriptName();
  this.defaultKerningTables = this.getKerningTables(e2);
}, Ct.prototype.getKerningValue = function(e2, t2, r2) {
  for (var n2 = 0; n2 < e2.length; n2++) for (var a2 = e2[n2].subtables, o2 = 0; o2 < a2.length; o2++) {
    var s2 = a2[o2], i2 = this.getCoverageIndex(s2.coverage, t2);
    if (!(i2 < 0)) switch (s2.posFormat) {
      case 1:
        for (var u2 = s2.pairSets[i2], l2 = 0; l2 < u2.length; l2++) {
          var p2 = u2[l2];
          if (p2.secondGlyph === r2) return p2.value1 && p2.value1.xAdvance || 0;
        }
        break;
      case 2:
        var c2 = this.getGlyphClass(s2.classDef1, t2), h2 = this.getGlyphClass(s2.classDef2, r2), f2 = s2.classRecords[c2][h2];
        return f2.value1 && f2.value1.xAdvance || 0;
    }
  }
  return 0;
}, Ct.prototype.getKerningTables = function(e2, t2) {
  if (this.font.tables.gpos) return this.getLookupTables(e2, t2, "kern", 2);
}, wt.prototype = Lt.prototype, wt.prototype.createDefaultTable = function() {
  return { version: 1, scripts: [{ tag: "DFLT", script: { defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }, langSysRecords: [] } }], features: [], lookups: [] };
}, wt.prototype.getSingle = function(e2, t2, r2) {
  for (var n2 = [], a2 = this.getLookupTables(t2, r2, e2, 1), o2 = 0; o2 < a2.length; o2++) for (var s2 = a2[o2].subtables, i2 = 0; i2 < s2.length; i2++) {
    var u2 = s2[i2], l2 = this.expandCoverage(u2.coverage), p2 = void 0;
    if (1 === u2.substFormat) {
      var c2 = u2.deltaGlyphId;
      for (p2 = 0; p2 < l2.length; p2++) {
        var h2 = l2[p2];
        n2.push({ sub: h2, by: h2 + c2 });
      }
    } else {
      var f2 = u2.substitute;
      for (p2 = 0; p2 < l2.length; p2++) n2.push({ sub: l2[p2], by: f2[p2] });
    }
  }
  return n2;
}, wt.prototype.getMultiple = function(e2, t2, r2) {
  for (var n2 = [], a2 = this.getLookupTables(t2, r2, e2, 2), o2 = 0; o2 < a2.length; o2++) for (var s2 = a2[o2].subtables, i2 = 0; i2 < s2.length; i2++) {
    var u2 = s2[i2], l2 = this.expandCoverage(u2.coverage), p2 = void 0;
    for (p2 = 0; p2 < l2.length; p2++) {
      var c2 = l2[p2], h2 = u2.sequences[p2];
      n2.push({ sub: c2, by: h2 });
    }
  }
  return n2;
}, wt.prototype.getAlternates = function(e2, t2, r2) {
  for (var n2 = [], a2 = this.getLookupTables(t2, r2, e2, 3), o2 = 0; o2 < a2.length; o2++) for (var s2 = a2[o2].subtables, i2 = 0; i2 < s2.length; i2++) for (var u2 = s2[i2], l2 = this.expandCoverage(u2.coverage), p2 = u2.alternateSets, c2 = 0; c2 < l2.length; c2++) n2.push({ sub: l2[c2], by: p2[c2] });
  return n2;
}, wt.prototype.getLigatures = function(e2, t2, r2) {
  for (var n2 = [], a2 = this.getLookupTables(t2, r2, e2, 4), o2 = 0; o2 < a2.length; o2++) for (var s2 = a2[o2].subtables, i2 = 0; i2 < s2.length; i2++) for (var u2 = s2[i2], l2 = this.expandCoverage(u2.coverage), p2 = u2.ligatureSets, c2 = 0; c2 < l2.length; c2++) for (var h2 = l2[c2], f2 = p2[c2], d2 = 0; d2 < f2.length; d2++) {
    var v2 = f2[d2];
    n2.push({ sub: [h2].concat(v2.components), by: v2.ligGlyph });
  }
  return n2;
}, wt.prototype.addSingle = function(e2, t2, r2, n2) {
  var a2 = It(this.getLookupTables(r2, n2, e2, 1, true)[0], 2, { substFormat: 2, coverage: { format: 1, glyphs: [] }, substitute: [] });
  w.assert(1 === a2.coverage.format, "Single: unable to modify coverage table format " + a2.coverage.format);
  var o2 = t2.sub, s2 = this.binSearch(a2.coverage.glyphs, o2);
  s2 < 0 && (s2 = -1 - s2, a2.coverage.glyphs.splice(s2, 0, o2), a2.substitute.splice(s2, 0, 0)), a2.substitute[s2] = t2.by;
}, wt.prototype.addMultiple = function(e2, t2, r2, n2) {
  w.assert(t2.by instanceof Array && t2.by.length > 1, 'Multiple: "by" must be an array of two or more ids');
  var a2 = It(this.getLookupTables(r2, n2, e2, 2, true)[0], 1, { substFormat: 1, coverage: { format: 1, glyphs: [] }, sequences: [] });
  w.assert(1 === a2.coverage.format, "Multiple: unable to modify coverage table format " + a2.coverage.format);
  var o2 = t2.sub, s2 = this.binSearch(a2.coverage.glyphs, o2);
  s2 < 0 && (s2 = -1 - s2, a2.coverage.glyphs.splice(s2, 0, o2), a2.sequences.splice(s2, 0, 0)), a2.sequences[s2] = t2.by;
}, wt.prototype.addAlternate = function(e2, t2, r2, n2) {
  var a2 = It(this.getLookupTables(r2, n2, e2, 3, true)[0], 1, { substFormat: 1, coverage: { format: 1, glyphs: [] }, alternateSets: [] });
  w.assert(1 === a2.coverage.format, "Alternate: unable to modify coverage table format " + a2.coverage.format);
  var o2 = t2.sub, s2 = this.binSearch(a2.coverage.glyphs, o2);
  s2 < 0 && (s2 = -1 - s2, a2.coverage.glyphs.splice(s2, 0, o2), a2.alternateSets.splice(s2, 0, 0)), a2.alternateSets[s2] = t2.by;
}, wt.prototype.addLigature = function(e2, t2, r2, n2) {
  var a2 = this.getLookupTables(r2, n2, e2, 4, true)[0], o2 = a2.subtables[0];
  o2 || (o2 = { substFormat: 1, coverage: { format: 1, glyphs: [] }, ligatureSets: [] }, a2.subtables[0] = o2), w.assert(1 === o2.coverage.format, "Ligature: unable to modify coverage table format " + o2.coverage.format);
  var s2 = t2.sub[0], i2 = t2.sub.slice(1), u2 = { ligGlyph: t2.by, components: i2 }, l2 = this.binSearch(o2.coverage.glyphs, s2);
  if (l2 >= 0) {
    for (var p2 = o2.ligatureSets[l2], c2 = 0; c2 < p2.length; c2++) if (Dt(p2[c2].components, i2)) return;
    p2.push(u2);
  } else l2 = -1 - l2, o2.coverage.glyphs.splice(l2, 0, s2), o2.ligatureSets.splice(l2, 0, [u2]);
}, wt.prototype.getFeature = function(e2, t2, r2) {
  if (/ss\d\d/.test(e2)) return this.getSingle(e2, t2, r2);
  switch (e2) {
    case "aalt":
    case "salt":
      return this.getSingle(e2, t2, r2).concat(this.getAlternates(e2, t2, r2));
    case "dlig":
    case "liga":
    case "rlig":
      return this.getLigatures(e2, t2, r2);
    case "ccmp":
      return this.getMultiple(e2, t2, r2).concat(this.getLigatures(e2, t2, r2));
    case "stch":
      return this.getMultiple(e2, t2, r2);
  }
}, wt.prototype.add = function(e2, t2, r2, n2) {
  if (/ss\d\d/.test(e2)) return this.addSingle(e2, t2, r2, n2);
  switch (e2) {
    case "aalt":
    case "salt":
      return "number" == typeof t2.by ? this.addSingle(e2, t2, r2, n2) : this.addAlternate(e2, t2, r2, n2);
    case "dlig":
    case "liga":
    case "rlig":
      return this.addLigature(e2, t2, r2, n2);
    case "ccmp":
      return t2.by instanceof Array ? this.addMultiple(e2, t2, r2, n2) : this.addLigature(e2, t2, r2, n2);
  }
};
var Ht;
var zt;
var Wt;
var qt;
var _t = { getPath: At, parse: function(e2, t2, r2, n2, a2) {
  return a2.lowMemory ? function(e3, t3, r3, n3) {
    var a3 = new Be.GlyphSet(n3);
    return n3._push = function(o2) {
      var s2 = r3[o2];
      s2 !== r3[o2 + 1] ? a3.push(o2, Be.ttfGlyphLoader(n3, o2, Ft, e3, t3 + s2, Nt)) : a3.push(o2, Be.glyphLoader(n3, o2));
    }, a3;
  }(e2, t2, r2, n2) : function(e3, t3, r3, n3) {
    for (var a3 = new Be.GlyphSet(n3), o2 = 0; o2 < r3.length - 1; o2 += 1) {
      var s2 = r3[o2];
      s2 !== r3[o2 + 1] ? a3.push(o2, Be.ttfGlyphLoader(n3, o2, Ft, e3, t3 + s2, Nt)) : a3.push(o2, Be.glyphLoader(n3, o2));
    }
    return a3;
  }(e2, t2, r2, n2);
} };
function Xt(e2) {
  this.font = e2, this.getCommands = function(e3) {
    return _t.getPath(e3).commands;
  }, this._fpgmState = this._prepState = void 0, this._errorState = 0;
}
function Vt(e2) {
  return e2;
}
function jt(e2) {
  return Math.sign(e2) * Math.round(Math.abs(e2));
}
function Yt(e2) {
  return Math.sign(e2) * Math.round(Math.abs(2 * e2)) / 2;
}
function Zt(e2) {
  return Math.sign(e2) * (Math.round(Math.abs(e2) + 0.5) - 0.5);
}
function Qt(e2) {
  return Math.sign(e2) * Math.ceil(Math.abs(e2));
}
function Kt(e2) {
  return Math.sign(e2) * Math.floor(Math.abs(e2));
}
var Jt = function(e2) {
  var t2 = this.srPeriod, r2 = this.srPhase, n2 = 1;
  return e2 < 0 && (e2 = -e2, n2 = -1), e2 += this.srThreshold - r2, e2 = Math.trunc(e2 / t2) * t2, (e2 += r2) < 0 ? r2 * n2 : e2 * n2;
};
var $t = { x: 1, y: 0, axis: "x", distance: function(e2, t2, r2, n2) {
  return (r2 ? e2.xo : e2.x) - (n2 ? t2.xo : t2.x);
}, interpolate: function(e2, t2, r2, n2) {
  var a2, o2, s2, i2, u2, l2, p2;
  if (!n2 || n2 === this) return a2 = e2.xo - t2.xo, o2 = e2.xo - r2.xo, u2 = t2.x - t2.xo, l2 = r2.x - r2.xo, 0 === (p2 = (s2 = Math.abs(a2)) + (i2 = Math.abs(o2))) ? void (e2.x = e2.xo + (u2 + l2) / 2) : void (e2.x = e2.xo + (u2 * i2 + l2 * s2) / p2);
  a2 = n2.distance(e2, t2, true, true), o2 = n2.distance(e2, r2, true, true), u2 = n2.distance(t2, t2, false, true), l2 = n2.distance(r2, r2, false, true), 0 !== (p2 = (s2 = Math.abs(a2)) + (i2 = Math.abs(o2))) ? $t.setRelative(e2, e2, (u2 * i2 + l2 * s2) / p2, n2, true) : $t.setRelative(e2, e2, (u2 + l2) / 2, n2, true);
}, normalSlope: Number.NEGATIVE_INFINITY, setRelative: function(e2, t2, r2, n2, a2) {
  if (n2 && n2 !== this) {
    var o2 = a2 ? t2.xo : t2.x, s2 = a2 ? t2.yo : t2.y, i2 = o2 + r2 * n2.x, u2 = s2 + r2 * n2.y;
    e2.x = i2 + (e2.y - u2) / n2.normalSlope;
  } else e2.x = (a2 ? t2.xo : t2.x) + r2;
}, slope: 0, touch: function(e2) {
  e2.xTouched = true;
}, touched: function(e2) {
  return e2.xTouched;
}, untouch: function(e2) {
  e2.xTouched = false;
} };
var er = { x: 0, y: 1, axis: "y", distance: function(e2, t2, r2, n2) {
  return (r2 ? e2.yo : e2.y) - (n2 ? t2.yo : t2.y);
}, interpolate: function(e2, t2, r2, n2) {
  var a2, o2, s2, i2, u2, l2, p2;
  if (!n2 || n2 === this) return a2 = e2.yo - t2.yo, o2 = e2.yo - r2.yo, u2 = t2.y - t2.yo, l2 = r2.y - r2.yo, 0 === (p2 = (s2 = Math.abs(a2)) + (i2 = Math.abs(o2))) ? void (e2.y = e2.yo + (u2 + l2) / 2) : void (e2.y = e2.yo + (u2 * i2 + l2 * s2) / p2);
  a2 = n2.distance(e2, t2, true, true), o2 = n2.distance(e2, r2, true, true), u2 = n2.distance(t2, t2, false, true), l2 = n2.distance(r2, r2, false, true), 0 !== (p2 = (s2 = Math.abs(a2)) + (i2 = Math.abs(o2))) ? er.setRelative(e2, e2, (u2 * i2 + l2 * s2) / p2, n2, true) : er.setRelative(e2, e2, (u2 + l2) / 2, n2, true);
}, normalSlope: 0, setRelative: function(e2, t2, r2, n2, a2) {
  if (n2 && n2 !== this) {
    var o2 = a2 ? t2.xo : t2.x, s2 = a2 ? t2.yo : t2.y, i2 = o2 + r2 * n2.x, u2 = s2 + r2 * n2.y;
    e2.y = u2 + n2.normalSlope * (e2.x - i2);
  } else e2.y = (a2 ? t2.yo : t2.y) + r2;
}, slope: Number.POSITIVE_INFINITY, touch: function(e2) {
  e2.yTouched = true;
}, touched: function(e2) {
  return e2.yTouched;
}, untouch: function(e2) {
  e2.yTouched = false;
} };
function tr(e2, t2) {
  this.x = e2, this.y = t2, this.axis = void 0, this.slope = t2 / e2, this.normalSlope = -e2 / t2, Object.freeze(this);
}
function rr(e2, t2) {
  var r2 = Math.sqrt(e2 * e2 + t2 * t2);
  return t2 /= r2, 1 === (e2 /= r2) && 0 === t2 ? $t : 0 === e2 && 1 === t2 ? er : new tr(e2, t2);
}
function nr(e2, t2, r2, n2) {
  this.x = this.xo = Math.round(64 * e2) / 64, this.y = this.yo = Math.round(64 * t2) / 64, this.lastPointOfContour = r2, this.onCurve = n2, this.prevPointOnContour = void 0, this.nextPointOnContour = void 0, this.xTouched = false, this.yTouched = false, Object.preventExtensions(this);
}
Object.freeze($t), Object.freeze(er), tr.prototype.distance = function(e2, t2, r2, n2) {
  return this.x * $t.distance(e2, t2, r2, n2) + this.y * er.distance(e2, t2, r2, n2);
}, tr.prototype.interpolate = function(e2, t2, r2, n2) {
  var a2, o2, s2, i2, u2, l2, p2;
  s2 = n2.distance(e2, t2, true, true), i2 = n2.distance(e2, r2, true, true), a2 = n2.distance(t2, t2, false, true), o2 = n2.distance(r2, r2, false, true), 0 !== (p2 = (u2 = Math.abs(s2)) + (l2 = Math.abs(i2))) ? this.setRelative(e2, e2, (a2 * l2 + o2 * u2) / p2, n2, true) : this.setRelative(e2, e2, (a2 + o2) / 2, n2, true);
}, tr.prototype.setRelative = function(e2, t2, r2, n2, a2) {
  n2 = n2 || this;
  var o2 = a2 ? t2.xo : t2.x, s2 = a2 ? t2.yo : t2.y, i2 = o2 + r2 * n2.x, u2 = s2 + r2 * n2.y, l2 = n2.normalSlope, p2 = this.slope, c2 = e2.x, h2 = e2.y;
  e2.x = (p2 * c2 - l2 * i2 + u2 - h2) / (p2 - l2), e2.y = p2 * (e2.x - c2) + h2;
}, tr.prototype.touch = function(e2) {
  e2.xTouched = true, e2.yTouched = true;
}, nr.prototype.nextTouched = function(e2) {
  for (var t2 = this.nextPointOnContour; !e2.touched(t2) && t2 !== this; ) t2 = t2.nextPointOnContour;
  return t2;
}, nr.prototype.prevTouched = function(e2) {
  for (var t2 = this.prevPointOnContour; !e2.touched(t2) && t2 !== this; ) t2 = t2.prevPointOnContour;
  return t2;
};
var ar = Object.freeze(new nr(0, 0));
var or = { cvCutIn: 17 / 16, deltaBase: 9, deltaShift: 0.125, loop: 1, minDis: 1, autoFlip: true };
function sr(e2, t2) {
  switch (this.env = e2, this.stack = [], this.prog = t2, e2) {
    case "glyf":
      this.zp0 = this.zp1 = this.zp2 = 1, this.rp0 = this.rp1 = this.rp2 = 0;
    case "prep":
      this.fv = this.pv = this.dpv = $t, this.round = jt;
  }
}
function ir(e2) {
  for (var t2 = e2.tZone = new Array(e2.gZone.length), r2 = 0; r2 < t2.length; r2++) t2[r2] = new nr(0, 0);
}
function ur(e2, t2) {
  var r2, n2 = e2.prog, a2 = e2.ip, o2 = 1;
  do {
    if (88 === (r2 = n2[++a2])) o2++;
    else if (89 === r2) o2--;
    else if (64 === r2) a2 += n2[a2 + 1] + 1;
    else if (65 === r2) a2 += 2 * n2[a2 + 1] + 1;
    else if (r2 >= 176 && r2 <= 183) a2 += r2 - 176 + 1;
    else if (r2 >= 184 && r2 <= 191) a2 += 2 * (r2 - 184 + 1);
    else if (t2 && 1 === o2 && 27 === r2) break;
  } while (o2 > 0);
  e2.ip = a2;
}
function lr(e2, t2) {
  exports.DEBUG && console.log(t2.step, "SVTCA[" + e2.axis + "]"), t2.fv = t2.pv = t2.dpv = e2;
}
function pr(e2, t2) {
  exports.DEBUG && console.log(t2.step, "SPVTCA[" + e2.axis + "]"), t2.pv = t2.dpv = e2;
}
function cr(e2, t2) {
  exports.DEBUG && console.log(t2.step, "SFVTCA[" + e2.axis + "]"), t2.fv = e2;
}
function hr(e2, t2) {
  var r2, n2, a2 = t2.stack, o2 = a2.pop(), s2 = a2.pop(), i2 = t2.z2[o2], u2 = t2.z1[s2];
  exports.DEBUG && console.log("SPVTL[" + e2 + "]", o2, s2), e2 ? (r2 = i2.y - u2.y, n2 = u2.x - i2.x) : (r2 = u2.x - i2.x, n2 = u2.y - i2.y), t2.pv = t2.dpv = rr(r2, n2);
}
function fr(e2, t2) {
  var r2, n2, a2 = t2.stack, o2 = a2.pop(), s2 = a2.pop(), i2 = t2.z2[o2], u2 = t2.z1[s2];
  exports.DEBUG && console.log("SFVTL[" + e2 + "]", o2, s2), e2 ? (r2 = i2.y - u2.y, n2 = u2.x - i2.x) : (r2 = u2.x - i2.x, n2 = u2.y - i2.y), t2.fv = rr(r2, n2);
}
function dr(e2) {
  exports.DEBUG && console.log(e2.step, "POP[]"), e2.stack.pop();
}
function vr(e2, t2) {
  var r2 = t2.stack.pop(), n2 = t2.z0[r2], a2 = t2.fv, o2 = t2.pv;
  exports.DEBUG && console.log(t2.step, "MDAP[" + e2 + "]", r2);
  var s2 = o2.distance(n2, ar);
  e2 && (s2 = t2.round(s2)), a2.setRelative(n2, ar, s2, o2), a2.touch(n2), t2.rp0 = t2.rp1 = r2;
}
function gr(e2, t2) {
  var r2, n2, a2, o2 = t2.z2, s2 = o2.length - 2;
  exports.DEBUG && console.log(t2.step, "IUP[" + e2.axis + "]");
  for (var i2 = 0; i2 < s2; i2++) r2 = o2[i2], e2.touched(r2) || (n2 = r2.prevTouched(e2)) !== r2 && (n2 === (a2 = r2.nextTouched(e2)) && e2.setRelative(r2, r2, e2.distance(n2, n2, false, true), e2, true), e2.interpolate(r2, n2, a2, e2));
}
function mr(e2, t2) {
  for (var r2 = t2.stack, n2 = e2 ? t2.rp1 : t2.rp2, a2 = (e2 ? t2.z0 : t2.z1)[n2], o2 = t2.fv, s2 = t2.pv, i2 = t2.loop, u2 = t2.z2; i2--; ) {
    var l2 = r2.pop(), p2 = u2[l2], c2 = s2.distance(a2, a2, false, true);
    o2.setRelative(p2, p2, c2, s2), o2.touch(p2), exports.DEBUG && console.log(t2.step, (t2.loop > 1 ? "loop " + (t2.loop - i2) + ": " : "") + "SHP[" + (e2 ? "rp1" : "rp2") + "]", l2);
  }
  t2.loop = 1;
}
function yr(e2, t2) {
  var r2 = t2.stack, n2 = e2 ? t2.rp1 : t2.rp2, a2 = (e2 ? t2.z0 : t2.z1)[n2], o2 = t2.fv, s2 = t2.pv, i2 = r2.pop(), u2 = t2.z2[t2.contours[i2]], l2 = u2;
  exports.DEBUG && console.log(t2.step, "SHC[" + e2 + "]", i2);
  var p2 = s2.distance(a2, a2, false, true);
  do {
    l2 !== a2 && o2.setRelative(l2, l2, p2, s2), l2 = l2.nextPointOnContour;
  } while (l2 !== u2);
}
function br(e2, t2) {
  var r2, n2, a2 = t2.stack, o2 = e2 ? t2.rp1 : t2.rp2, s2 = (e2 ? t2.z0 : t2.z1)[o2], i2 = t2.fv, u2 = t2.pv, l2 = a2.pop();
  switch (exports.DEBUG && console.log(t2.step, "SHZ[" + e2 + "]", l2), l2) {
    case 0:
      r2 = t2.tZone;
      break;
    case 1:
      r2 = t2.gZone;
      break;
    default:
      throw new Error("Invalid zone");
  }
  for (var p2 = u2.distance(s2, s2, false, true), c2 = r2.length - 2, h2 = 0; h2 < c2; h2++) n2 = r2[h2], i2.setRelative(n2, n2, p2, u2);
}
function Sr(e2, t2) {
  var r2 = t2.stack, n2 = r2.pop() / 64, a2 = r2.pop(), o2 = t2.z1[a2], s2 = t2.z0[t2.rp0], i2 = t2.fv, u2 = t2.pv;
  i2.setRelative(o2, s2, n2, u2), i2.touch(o2), exports.DEBUG && console.log(t2.step, "MSIRP[" + e2 + "]", n2, a2), t2.rp1 = t2.rp0, t2.rp2 = a2, e2 && (t2.rp0 = a2);
}
function xr(e2, t2) {
  var r2 = t2.stack, n2 = r2.pop(), a2 = r2.pop(), o2 = t2.z0[a2], s2 = t2.fv, i2 = t2.pv, u2 = t2.cvt[n2];
  exports.DEBUG && console.log(t2.step, "MIAP[" + e2 + "]", n2, "(", u2, ")", a2);
  var l2 = i2.distance(o2, ar);
  e2 && (Math.abs(l2 - u2) < t2.cvCutIn && (l2 = u2), l2 = t2.round(l2)), s2.setRelative(o2, ar, l2, i2), 0 === t2.zp0 && (o2.xo = o2.x, o2.yo = o2.y), s2.touch(o2), t2.rp0 = t2.rp1 = a2;
}
function Tr(e2, t2) {
  var r2 = t2.stack, n2 = r2.pop(), a2 = t2.z2[n2];
  exports.DEBUG && console.log(t2.step, "GC[" + e2 + "]", n2), r2.push(64 * t2.dpv.distance(a2, ar, e2, false));
}
function Ur(e2, t2) {
  var r2 = t2.stack, n2 = r2.pop(), a2 = r2.pop(), o2 = t2.z1[n2], s2 = t2.z0[a2], i2 = t2.dpv.distance(s2, o2, e2, e2);
  exports.DEBUG && console.log(t2.step, "MD[" + e2 + "]", n2, a2, "->", i2), t2.stack.push(Math.round(64 * i2));
}
function kr(e2, t2) {
  var r2 = t2.stack, n2 = r2.pop(), a2 = t2.fv, o2 = t2.pv, s2 = t2.ppem, i2 = t2.deltaBase + 16 * (e2 - 1), u2 = t2.deltaShift, l2 = t2.z0;
  exports.DEBUG && console.log(t2.step, "DELTAP[" + e2 + "]", n2, r2);
  for (var p2 = 0; p2 < n2; p2++) {
    var c2 = r2.pop(), h2 = r2.pop();
    if (i2 + ((240 & h2) >> 4) === s2) {
      var f2 = (15 & h2) - 8;
      f2 >= 0 && f2++, exports.DEBUG && console.log(t2.step, "DELTAPFIX", c2, "by", f2 * u2);
      var d2 = l2[c2];
      a2.setRelative(d2, d2, f2 * u2, o2);
    }
  }
}
function Or(e2, t2) {
  var r2 = t2.stack, n2 = r2.pop();
  exports.DEBUG && console.log(t2.step, "ROUND[]"), r2.push(64 * t2.round(n2 / 64));
}
function Rr(e2, t2) {
  var r2 = t2.stack, n2 = r2.pop(), a2 = t2.ppem, o2 = t2.deltaBase + 16 * (e2 - 1), s2 = t2.deltaShift;
  exports.DEBUG && console.log(t2.step, "DELTAC[" + e2 + "]", n2, r2);
  for (var i2 = 0; i2 < n2; i2++) {
    var u2 = r2.pop(), l2 = r2.pop();
    if (o2 + ((240 & l2) >> 4) === a2) {
      var p2 = (15 & l2) - 8;
      p2 >= 0 && p2++;
      var c2 = p2 * s2;
      exports.DEBUG && console.log(t2.step, "DELTACFIX", u2, "by", c2), t2.cvt[u2] += c2;
    }
  }
}
function Er(e2, t2) {
  var r2, n2, a2 = t2.stack, o2 = a2.pop(), s2 = a2.pop(), i2 = t2.z2[o2], u2 = t2.z1[s2];
  exports.DEBUG && console.log(t2.step, "SDPVTL[" + e2 + "]", o2, s2), e2 ? (r2 = i2.y - u2.y, n2 = u2.x - i2.x) : (r2 = u2.x - i2.x, n2 = u2.y - i2.y), t2.dpv = rr(r2, n2);
}
function Lr(e2, t2) {
  var r2 = t2.stack, n2 = t2.prog, a2 = t2.ip;
  exports.DEBUG && console.log(t2.step, "PUSHB[" + e2 + "]");
  for (var o2 = 0; o2 < e2; o2++) r2.push(n2[++a2]);
  t2.ip = a2;
}
function Cr(e2, t2) {
  var r2 = t2.ip, n2 = t2.prog, a2 = t2.stack;
  exports.DEBUG && console.log(t2.ip, "PUSHW[" + e2 + "]");
  for (var o2 = 0; o2 < e2; o2++) {
    var s2 = n2[++r2] << 8 | n2[++r2];
    32768 & s2 && (s2 = -(1 + (65535 ^ s2))), a2.push(s2);
  }
  t2.ip = r2;
}
function wr(e2, t2, r2, n2, a2, o2) {
  var s2, i2, u2, l2, p2 = o2.stack, c2 = e2 && p2.pop(), h2 = p2.pop(), f2 = o2.rp0, d2 = o2.z0[f2], v2 = o2.z1[h2], g2 = o2.minDis, m2 = o2.fv, y2 = o2.dpv;
  u2 = (i2 = s2 = y2.distance(v2, d2, true, true)) >= 0 ? 1 : -1, i2 = Math.abs(i2), e2 && (l2 = o2.cvt[c2], n2 && Math.abs(i2 - l2) < o2.cvCutIn && (i2 = l2)), r2 && i2 < g2 && (i2 = g2), n2 && (i2 = o2.round(i2)), m2.setRelative(v2, d2, u2 * i2, y2), m2.touch(v2), exports.DEBUG && console.log(o2.step, (e2 ? "MIRP[" : "MDRP[") + (t2 ? "M" : "m") + (r2 ? ">" : "_") + (n2 ? "R" : "_") + (0 === a2 ? "Gr" : 1 === a2 ? "Bl" : 2 === a2 ? "Wh" : "") + "]", e2 ? c2 + "(" + o2.cvt[c2] + "," + l2 + ")" : "", h2, "(d =", s2, "->", u2 * i2, ")"), o2.rp1 = o2.rp0, o2.rp2 = h2, t2 && (o2.rp0 = h2);
}
function Dr(e2) {
  this.char = e2, this.state = {}, this.activeState = null;
}
function Ir(e2, t2, r2) {
  this.contextName = r2, this.startIndex = e2, this.endOffset = t2;
}
function Gr(e2, t2, r2) {
  this.contextName = e2, this.openRange = null, this.ranges = [], this.checkStart = t2, this.checkEnd = r2;
}
function Mr(e2, t2) {
  this.context = e2, this.index = t2, this.length = e2.length, this.current = e2[t2], this.backtrack = e2.slice(0, t2), this.lookahead = e2.slice(t2 + 1);
}
function Br(e2) {
  this.eventId = e2, this.subscribers = [];
}
function Fr(e2) {
  var t2 = this, r2 = ["start", "end", "next", "newToken", "contextStart", "contextEnd", "insertToken", "removeToken", "removeRange", "replaceToken", "replaceRange", "composeRUD", "updateContextsRanges"];
  r2.forEach(function(e3) {
    Object.defineProperty(t2.events, e3, { value: new Br(e3) });
  }), e2 && r2.forEach(function(r3) {
    var n2 = e2[r3];
    "function" == typeof n2 && t2.events[r3].subscribe(n2);
  });
  ["insertToken", "removeToken", "removeRange", "replaceToken", "replaceRange", "composeRUD"].forEach(function(e3) {
    t2.events[e3].subscribe(t2.updateContextsRanges);
  });
}
function Pr(e2) {
  this.tokens = [], this.registeredContexts = {}, this.contextCheckers = [], this.events = {}, this.registeredModifiers = [], Fr.call(this, e2);
}
function Ar(e2) {
  return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(e2);
}
function Nr(e2) {
  return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(e2);
}
function Hr(e2) {
  return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(e2);
}
function zr(e2) {
  return /[A-z]/.test(e2);
}
function Wr(e2) {
  this.font = e2, this.features = {};
}
function qr(e2) {
  this.id = e2.id, this.tag = e2.tag, this.substitution = e2.substitution;
}
function _r(e2, t2) {
  if (!e2) return -1;
  switch (t2.format) {
    case 1:
      return t2.glyphs.indexOf(e2);
    case 2:
      for (var r2 = t2.ranges, n2 = 0; n2 < r2.length; n2++) {
        var a2 = r2[n2];
        if (e2 >= a2.start && e2 <= a2.end) {
          var o2 = e2 - a2.start;
          return a2.index + o2;
        }
      }
      break;
    default:
      return -1;
  }
  return -1;
}
function Xr(e2, t2) {
  return -1 === _r(e2, t2.coverage) ? null : e2 + t2.deltaGlyphId;
}
function Vr(e2, t2) {
  var r2 = _r(e2, t2.coverage);
  return -1 === r2 ? null : t2.substitute[r2];
}
function jr(e2, t2) {
  for (var r2 = [], n2 = 0; n2 < e2.length; n2++) {
    var a2 = e2[n2], o2 = t2.current, s2 = _r(o2 = Array.isArray(o2) ? o2[0] : o2, a2);
    -1 !== s2 && r2.push(s2);
  }
  return r2.length !== e2.length ? -1 : r2;
}
function Yr(e2, t2) {
  var r2 = t2.inputCoverage.length + t2.lookaheadCoverage.length + t2.backtrackCoverage.length;
  if (e2.context.length < r2) return [];
  var n2 = jr(t2.inputCoverage, e2);
  if (-1 === n2) return [];
  var a2 = t2.inputCoverage.length - 1;
  if (e2.lookahead.length < t2.lookaheadCoverage.length) return [];
  for (var o2 = e2.lookahead.slice(a2); o2.length && Hr(o2[0].char); ) o2.shift();
  var s2 = new Mr(o2, 0), i2 = jr(t2.lookaheadCoverage, s2), u2 = [].concat(e2.backtrack);
  for (u2.reverse(); u2.length && Hr(u2[0].char); ) u2.shift();
  if (u2.length < t2.backtrackCoverage.length) return [];
  var l2 = new Mr(u2, 0), p2 = jr(t2.backtrackCoverage, l2), c2 = [];
  if (n2.length === t2.inputCoverage.length && i2.length === t2.lookaheadCoverage.length && p2.length === t2.backtrackCoverage.length) for (var h2 = 0; h2 < t2.lookupRecords.length; h2++) for (var f2 = t2.lookupRecords[h2].lookupListIndex, d2 = this.getLookupByIndex(f2), v2 = 0; v2 < d2.subtables.length; v2++) {
    var g2 = d2.subtables[v2], m2 = this.getLookupMethod(d2, g2);
    if ("12" === this.getSubstitutionType(d2, g2)) for (var y2 = 0; y2 < n2.length; y2++) {
      var b2 = m2(e2.get(y2));
      b2 && c2.push(b2);
    }
  }
  return c2;
}
function Zr(e2, t2) {
  var r2, n2 = _r(e2.current, t2.coverage);
  if (-1 === n2) return null;
  for (var a2 = t2.ligatureSets[n2], o2 = 0; o2 < a2.length; o2++) {
    r2 = a2[o2];
    for (var s2 = 0; s2 < r2.components.length; s2++) {
      if (e2.lookahead[s2] !== r2.components[s2]) break;
      if (s2 === r2.components.length - 1) return r2;
    }
  }
  return null;
}
function Qr(e2, t2) {
  var r2 = _r(e2, t2.coverage);
  return -1 === r2 ? null : t2.sequences[r2];
}
Xt.prototype.exec = function(e2, t2) {
  if ("number" != typeof t2) throw new Error("Point size is not a number!");
  if (!(this._errorState > 2)) {
    var r2 = this.font, n2 = this._prepState;
    if (!n2 || n2.ppem !== t2) {
      var a2 = this._fpgmState;
      if (!a2) {
        sr.prototype = or, (a2 = this._fpgmState = new sr("fpgm", r2.tables.fpgm)).funcs = [], a2.font = r2, exports.DEBUG && (console.log("---EXEC FPGM---"), a2.step = -1);
        try {
          zt(a2);
        } catch (e3) {
          return console.log("Hinting error in FPGM:" + e3), void (this._errorState = 3);
        }
      }
      sr.prototype = a2, (n2 = this._prepState = new sr("prep", r2.tables.prep)).ppem = t2;
      var o2 = r2.tables.cvt;
      if (o2) for (var s2 = n2.cvt = new Array(o2.length), i2 = t2 / r2.unitsPerEm, u2 = 0; u2 < o2.length; u2++) s2[u2] = o2[u2] * i2;
      else n2.cvt = [];
      exports.DEBUG && (console.log("---EXEC PREP---"), n2.step = -1);
      try {
        zt(n2);
      } catch (e3) {
        this._errorState < 2 && console.log("Hinting error in PREP:" + e3), this._errorState = 2;
      }
    }
    if (!(this._errorState > 1)) try {
      return Wt(e2, n2);
    } catch (e3) {
      return this._errorState < 1 && (console.log("Hinting error:" + e3), console.log("Note: further hinting errors are silenced")), void (this._errorState = 1);
    }
  }
}, Wt = function(e2, t2) {
  var r2, n2, a2, o2 = t2.ppem / t2.font.unitsPerEm, s2 = o2, i2 = e2.components;
  if (sr.prototype = t2, i2) {
    var u2 = t2.font;
    n2 = [], r2 = [];
    for (var l2 = 0; l2 < i2.length; l2++) {
      var p2 = i2[l2], c2 = u2.glyphs.get(p2.glyphIndex);
      a2 = new sr("glyf", c2.instructions), exports.DEBUG && (console.log("---EXEC COMP " + l2 + "---"), a2.step = -1), qt(c2, a2, o2, s2);
      for (var h2 = Math.round(p2.dx * o2), f2 = Math.round(p2.dy * s2), d2 = a2.gZone, v2 = a2.contours, g2 = 0; g2 < d2.length; g2++) {
        var m2 = d2[g2];
        m2.xTouched = m2.yTouched = false, m2.xo = m2.x = m2.x + h2, m2.yo = m2.y = m2.y + f2;
      }
      var y2 = n2.length;
      n2.push.apply(n2, d2);
      for (var b2 = 0; b2 < v2.length; b2++) r2.push(v2[b2] + y2);
    }
    e2.instructions && !a2.inhibitGridFit && ((a2 = new sr("glyf", e2.instructions)).gZone = a2.z0 = a2.z1 = a2.z2 = n2, a2.contours = r2, n2.push(new nr(0, 0), new nr(Math.round(e2.advanceWidth * o2), 0)), exports.DEBUG && (console.log("---EXEC COMPOSITE---"), a2.step = -1), zt(a2), n2.length -= 2);
  } else a2 = new sr("glyf", e2.instructions), exports.DEBUG && (console.log("---EXEC GLYPH---"), a2.step = -1), qt(e2, a2, o2, s2), n2 = a2.gZone;
  return n2;
}, qt = function(e2, t2, r2, n2) {
  for (var a2, o2, s2, i2 = e2.points || [], u2 = i2.length, l2 = t2.gZone = t2.z0 = t2.z1 = t2.z2 = [], p2 = t2.contours = [], c2 = 0; c2 < u2; c2++) a2 = i2[c2], l2[c2] = new nr(a2.x * r2, a2.y * n2, a2.lastPointOfContour, a2.onCurve);
  for (var h2 = 0; h2 < u2; h2++) a2 = l2[h2], o2 || (o2 = a2, p2.push(h2)), a2.lastPointOfContour ? (a2.nextPointOnContour = o2, o2.prevPointOnContour = a2, o2 = void 0) : (s2 = l2[h2 + 1], a2.nextPointOnContour = s2, s2.prevPointOnContour = a2);
  if (!t2.inhibitGridFit) {
    if (exports.DEBUG) {
      console.log("PROCESSING GLYPH", t2.stack);
      for (var f2 = 0; f2 < u2; f2++) console.log(f2, l2[f2].x, l2[f2].y);
    }
    if (l2.push(new nr(0, 0), new nr(Math.round(e2.advanceWidth * r2), 0)), zt(t2), l2.length -= 2, exports.DEBUG) {
      console.log("FINISHED GLYPH", t2.stack);
      for (var d2 = 0; d2 < u2; d2++) console.log(d2, l2[d2].x, l2[d2].y);
    }
  }
}, zt = function(e2) {
  var t2 = e2.prog;
  if (t2) {
    var r2, n2 = t2.length;
    for (e2.ip = 0; e2.ip < n2; e2.ip++) {
      if (exports.DEBUG && e2.step++, !(r2 = Ht[t2[e2.ip]])) throw new Error("unknown instruction: 0x" + Number(t2[e2.ip]).toString(16));
      r2(e2);
    }
  }
}, Ht = [lr.bind(void 0, er), lr.bind(void 0, $t), pr.bind(void 0, er), pr.bind(void 0, $t), cr.bind(void 0, er), cr.bind(void 0, $t), hr.bind(void 0, 0), hr.bind(void 0, 1), fr.bind(void 0, 0), fr.bind(void 0, 1), function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "SPVFS[]", r2, n2), e2.pv = e2.dpv = rr(n2, r2);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "SPVFS[]", r2, n2), e2.fv = rr(n2, r2);
}, function(e2) {
  var t2 = e2.stack, r2 = e2.pv;
  exports.DEBUG && console.log(e2.step, "GPV[]"), t2.push(16384 * r2.x), t2.push(16384 * r2.y);
}, function(e2) {
  var t2 = e2.stack, r2 = e2.fv;
  exports.DEBUG && console.log(e2.step, "GFV[]"), t2.push(16384 * r2.x), t2.push(16384 * r2.y);
}, function(e2) {
  e2.fv = e2.pv, exports.DEBUG && console.log(e2.step, "SFVTPV[]");
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop(), a2 = t2.pop(), o2 = t2.pop(), s2 = t2.pop(), i2 = e2.z0, u2 = e2.z1, l2 = i2[r2], p2 = i2[n2], c2 = u2[a2], h2 = u2[o2], f2 = e2.z2[s2];
  exports.DEBUG && console.log("ISECT[], ", r2, n2, a2, o2, s2);
  var d2 = l2.x, v2 = l2.y, g2 = p2.x, m2 = p2.y, y2 = c2.x, b2 = c2.y, S2 = h2.x, x2 = h2.y, T2 = (d2 - g2) * (b2 - x2) - (v2 - m2) * (y2 - S2), U2 = d2 * m2 - v2 * g2, k2 = y2 * x2 - b2 * S2;
  f2.x = (U2 * (y2 - S2) - k2 * (d2 - g2)) / T2, f2.y = (U2 * (b2 - x2) - k2 * (v2 - m2)) / T2;
}, function(e2) {
  e2.rp0 = e2.stack.pop(), exports.DEBUG && console.log(e2.step, "SRP0[]", e2.rp0);
}, function(e2) {
  e2.rp1 = e2.stack.pop(), exports.DEBUG && console.log(e2.step, "SRP1[]", e2.rp1);
}, function(e2) {
  e2.rp2 = e2.stack.pop(), exports.DEBUG && console.log(e2.step, "SRP2[]", e2.rp2);
}, function(e2) {
  var t2 = e2.stack.pop();
  switch (exports.DEBUG && console.log(e2.step, "SZP0[]", t2), e2.zp0 = t2, t2) {
    case 0:
      e2.tZone || ir(e2), e2.z0 = e2.tZone;
      break;
    case 1:
      e2.z0 = e2.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}, function(e2) {
  var t2 = e2.stack.pop();
  switch (exports.DEBUG && console.log(e2.step, "SZP1[]", t2), e2.zp1 = t2, t2) {
    case 0:
      e2.tZone || ir(e2), e2.z1 = e2.tZone;
      break;
    case 1:
      e2.z1 = e2.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}, function(e2) {
  var t2 = e2.stack.pop();
  switch (exports.DEBUG && console.log(e2.step, "SZP2[]", t2), e2.zp2 = t2, t2) {
    case 0:
      e2.tZone || ir(e2), e2.z2 = e2.tZone;
      break;
    case 1:
      e2.z2 = e2.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}, function(e2) {
  var t2 = e2.stack.pop();
  switch (exports.DEBUG && console.log(e2.step, "SZPS[]", t2), e2.zp0 = e2.zp1 = e2.zp2 = t2, t2) {
    case 0:
      e2.tZone || ir(e2), e2.z0 = e2.z1 = e2.z2 = e2.tZone;
      break;
    case 1:
      e2.z0 = e2.z1 = e2.z2 = e2.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}, function(e2) {
  e2.loop = e2.stack.pop(), exports.DEBUG && console.log(e2.step, "SLOOP[]", e2.loop);
}, function(e2) {
  exports.DEBUG && console.log(e2.step, "RTG[]"), e2.round = jt;
}, function(e2) {
  exports.DEBUG && console.log(e2.step, "RTHG[]"), e2.round = Zt;
}, function(e2) {
  var t2 = e2.stack.pop();
  exports.DEBUG && console.log(e2.step, "SMD[]", t2), e2.minDis = t2 / 64;
}, function(e2) {
  exports.DEBUG && console.log(e2.step, "ELSE[]"), ur(e2, false);
}, function(e2) {
  var t2 = e2.stack.pop();
  exports.DEBUG && console.log(e2.step, "JMPR[]", t2), e2.ip += t2 - 1;
}, function(e2) {
  var t2 = e2.stack.pop();
  exports.DEBUG && console.log(e2.step, "SCVTCI[]", t2), e2.cvCutIn = t2 / 64;
}, void 0, void 0, function(e2) {
  var t2 = e2.stack;
  exports.DEBUG && console.log(e2.step, "DUP[]"), t2.push(t2[t2.length - 1]);
}, dr, function(e2) {
  exports.DEBUG && console.log(e2.step, "CLEAR[]"), e2.stack.length = 0;
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "SWAP[]"), t2.push(r2), t2.push(n2);
}, function(e2) {
  var t2 = e2.stack;
  exports.DEBUG && console.log(e2.step, "DEPTH[]"), t2.push(t2.length);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "CINDEX[]", r2), t2.push(t2[t2.length - r2]);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "MINDEX[]", r2), t2.push(t2.splice(t2.length - r2, 1)[0]);
}, void 0, void 0, void 0, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "LOOPCALL[]", r2, n2);
  var a2 = e2.ip, o2 = e2.prog;
  e2.prog = e2.funcs[r2];
  for (var s2 = 0; s2 < n2; s2++) zt(e2), exports.DEBUG && console.log(++e2.step, s2 + 1 < n2 ? "next loopcall" : "done loopcall", s2);
  e2.ip = a2, e2.prog = o2;
}, function(e2) {
  var t2 = e2.stack.pop();
  exports.DEBUG && console.log(e2.step, "CALL[]", t2);
  var r2 = e2.ip, n2 = e2.prog;
  e2.prog = e2.funcs[t2], zt(e2), e2.ip = r2, e2.prog = n2, exports.DEBUG && console.log(++e2.step, "returning from", t2);
}, function(e2) {
  if ("fpgm" !== e2.env) throw new Error("FDEF not allowed here");
  var t2 = e2.stack, r2 = e2.prog, n2 = e2.ip, a2 = t2.pop(), o2 = n2;
  for (exports.DEBUG && console.log(e2.step, "FDEF[]", a2); 45 !== r2[++n2]; ) ;
  e2.ip = n2, e2.funcs[a2] = r2.slice(o2 + 1, n2);
}, void 0, vr.bind(void 0, 0), vr.bind(void 0, 1), gr.bind(void 0, er), gr.bind(void 0, $t), mr.bind(void 0, 0), mr.bind(void 0, 1), yr.bind(void 0, 0), yr.bind(void 0, 1), br.bind(void 0, 0), br.bind(void 0, 1), function(e2) {
  for (var t2 = e2.stack, r2 = e2.loop, n2 = e2.fv, a2 = t2.pop() / 64, o2 = e2.z2; r2--; ) {
    var s2 = t2.pop(), i2 = o2[s2];
    exports.DEBUG && console.log(e2.step, (e2.loop > 1 ? "loop " + (e2.loop - r2) + ": " : "") + "SHPIX[]", s2, a2), n2.setRelative(i2, i2, a2), n2.touch(i2);
  }
  e2.loop = 1;
}, function(e2) {
  for (var t2 = e2.stack, r2 = e2.rp1, n2 = e2.rp2, a2 = e2.loop, o2 = e2.z0[r2], s2 = e2.z1[n2], i2 = e2.fv, u2 = e2.dpv, l2 = e2.z2; a2--; ) {
    var p2 = t2.pop(), c2 = l2[p2];
    exports.DEBUG && console.log(e2.step, (e2.loop > 1 ? "loop " + (e2.loop - a2) + ": " : "") + "IP[]", p2, r2, "<->", n2), i2.interpolate(c2, o2, s2, u2), i2.touch(c2);
  }
  e2.loop = 1;
}, Sr.bind(void 0, 0), Sr.bind(void 0, 1), function(e2) {
  for (var t2 = e2.stack, r2 = e2.rp0, n2 = e2.z0[r2], a2 = e2.loop, o2 = e2.fv, s2 = e2.pv, i2 = e2.z1; a2--; ) {
    var u2 = t2.pop(), l2 = i2[u2];
    exports.DEBUG && console.log(e2.step, (e2.loop > 1 ? "loop " + (e2.loop - a2) + ": " : "") + "ALIGNRP[]", u2), o2.setRelative(l2, n2, 0, s2), o2.touch(l2);
  }
  e2.loop = 1;
}, function(e2) {
  exports.DEBUG && console.log(e2.step, "RTDG[]"), e2.round = Yt;
}, xr.bind(void 0, 0), xr.bind(void 0, 1), function(e2) {
  var t2 = e2.prog, r2 = e2.ip, n2 = e2.stack, a2 = t2[++r2];
  exports.DEBUG && console.log(e2.step, "NPUSHB[]", a2);
  for (var o2 = 0; o2 < a2; o2++) n2.push(t2[++r2]);
  e2.ip = r2;
}, function(e2) {
  var t2 = e2.ip, r2 = e2.prog, n2 = e2.stack, a2 = r2[++t2];
  exports.DEBUG && console.log(e2.step, "NPUSHW[]", a2);
  for (var o2 = 0; o2 < a2; o2++) {
    var s2 = r2[++t2] << 8 | r2[++t2];
    32768 & s2 && (s2 = -(1 + (65535 ^ s2))), n2.push(s2);
  }
  e2.ip = t2;
}, function(e2) {
  var t2 = e2.stack, r2 = e2.store;
  r2 || (r2 = e2.store = []);
  var n2 = t2.pop(), a2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "WS", n2, a2), r2[a2] = n2;
}, function(e2) {
  var t2 = e2.stack, r2 = e2.store, n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "RS", n2);
  var a2 = r2 && r2[n2] || 0;
  t2.push(a2);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "WCVTP", r2, n2), e2.cvt[n2] = r2 / 64;
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "RCVT", r2), t2.push(64 * e2.cvt[r2]);
}, Tr.bind(void 0, 0), Tr.bind(void 0, 1), void 0, Ur.bind(void 0, 0), Ur.bind(void 0, 1), function(e2) {
  exports.DEBUG && console.log(e2.step, "MPPEM[]"), e2.stack.push(e2.ppem);
}, void 0, function(e2) {
  exports.DEBUG && console.log(e2.step, "FLIPON[]"), e2.autoFlip = true;
}, void 0, void 0, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "LT[]", r2, n2), t2.push(n2 < r2 ? 1 : 0);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "LTEQ[]", r2, n2), t2.push(n2 <= r2 ? 1 : 0);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "GT[]", r2, n2), t2.push(n2 > r2 ? 1 : 0);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "GTEQ[]", r2, n2), t2.push(n2 >= r2 ? 1 : 0);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "EQ[]", r2, n2), t2.push(r2 === n2 ? 1 : 0);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "NEQ[]", r2, n2), t2.push(r2 !== n2 ? 1 : 0);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "ODD[]", r2), t2.push(Math.trunc(r2) % 2 ? 1 : 0);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "EVEN[]", r2), t2.push(Math.trunc(r2) % 2 ? 0 : 1);
}, function(e2) {
  var t2 = e2.stack.pop();
  exports.DEBUG && console.log(e2.step, "IF[]", t2), t2 || (ur(e2, true), exports.DEBUG && console.log(e2.step, "EIF[]"));
}, function(e2) {
  exports.DEBUG && console.log(e2.step, "EIF[]");
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "AND[]", r2, n2), t2.push(r2 && n2 ? 1 : 0);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "OR[]", r2, n2), t2.push(r2 || n2 ? 1 : 0);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "NOT[]", r2), t2.push(r2 ? 0 : 1);
}, kr.bind(void 0, 1), function(e2) {
  var t2 = e2.stack.pop();
  exports.DEBUG && console.log(e2.step, "SDB[]", t2), e2.deltaBase = t2;
}, function(e2) {
  var t2 = e2.stack.pop();
  exports.DEBUG && console.log(e2.step, "SDS[]", t2), e2.deltaShift = Math.pow(0.5, t2);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "ADD[]", r2, n2), t2.push(n2 + r2);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "SUB[]", r2, n2), t2.push(n2 - r2);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "DIV[]", r2, n2), t2.push(64 * n2 / r2);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "MUL[]", r2, n2), t2.push(n2 * r2 / 64);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "ABS[]", r2), t2.push(Math.abs(r2));
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "NEG[]", r2), t2.push(-r2);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "FLOOR[]", r2), t2.push(64 * Math.floor(r2 / 64));
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "CEILING[]", r2), t2.push(64 * Math.ceil(r2 / 64));
}, Or.bind(void 0, 0), Or.bind(void 0, 1), Or.bind(void 0, 2), Or.bind(void 0, 3), void 0, void 0, void 0, void 0, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "WCVTF[]", r2, n2), e2.cvt[n2] = r2 * e2.ppem / e2.font.unitsPerEm;
}, kr.bind(void 0, 2), kr.bind(void 0, 3), Rr.bind(void 0, 1), Rr.bind(void 0, 2), Rr.bind(void 0, 3), function(e2) {
  var t2, r2 = e2.stack.pop();
  switch (exports.DEBUG && console.log(e2.step, "SROUND[]", r2), e2.round = Jt, 192 & r2) {
    case 0:
      t2 = 0.5;
      break;
    case 64:
      t2 = 1;
      break;
    case 128:
      t2 = 2;
      break;
    default:
      throw new Error("invalid SROUND value");
  }
  switch (e2.srPeriod = t2, 48 & r2) {
    case 0:
      e2.srPhase = 0;
      break;
    case 16:
      e2.srPhase = 0.25 * t2;
      break;
    case 32:
      e2.srPhase = 0.5 * t2;
      break;
    case 48:
      e2.srPhase = 0.75 * t2;
      break;
    default:
      throw new Error("invalid SROUND value");
  }
  r2 &= 15, e2.srThreshold = 0 === r2 ? 0 : (r2 / 8 - 0.5) * t2;
}, function(e2) {
  var t2, r2 = e2.stack.pop();
  switch (exports.DEBUG && console.log(e2.step, "S45ROUND[]", r2), e2.round = Jt, 192 & r2) {
    case 0:
      t2 = Math.sqrt(2) / 2;
      break;
    case 64:
      t2 = Math.sqrt(2);
      break;
    case 128:
      t2 = 2 * Math.sqrt(2);
      break;
    default:
      throw new Error("invalid S45ROUND value");
  }
  switch (e2.srPeriod = t2, 48 & r2) {
    case 0:
      e2.srPhase = 0;
      break;
    case 16:
      e2.srPhase = 0.25 * t2;
      break;
    case 32:
      e2.srPhase = 0.5 * t2;
      break;
    case 48:
      e2.srPhase = 0.75 * t2;
      break;
    default:
      throw new Error("invalid S45ROUND value");
  }
  r2 &= 15, e2.srThreshold = 0 === r2 ? 0 : (r2 / 8 - 0.5) * t2;
}, void 0, void 0, function(e2) {
  exports.DEBUG && console.log(e2.step, "ROFF[]"), e2.round = Vt;
}, void 0, function(e2) {
  exports.DEBUG && console.log(e2.step, "RUTG[]"), e2.round = Qt;
}, function(e2) {
  exports.DEBUG && console.log(e2.step, "RDTG[]"), e2.round = Kt;
}, dr, dr, void 0, void 0, void 0, void 0, void 0, function(e2) {
  var t2 = e2.stack.pop();
  exports.DEBUG && console.log(e2.step, "SCANCTRL[]", t2);
}, Er.bind(void 0, 0), Er.bind(void 0, 1), function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = 0;
  exports.DEBUG && console.log(e2.step, "GETINFO[]", r2), 1 & r2 && (n2 = 35), 32 & r2 && (n2 |= 4096), t2.push(n2);
}, void 0, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop(), a2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "ROLL[]"), t2.push(n2), t2.push(r2), t2.push(a2);
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "MAX[]", r2, n2), t2.push(Math.max(n2, r2));
}, function(e2) {
  var t2 = e2.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e2.step, "MIN[]", r2, n2), t2.push(Math.min(n2, r2));
}, function(e2) {
  var t2 = e2.stack.pop();
  exports.DEBUG && console.log(e2.step, "SCANTYPE[]", t2);
}, function(e2) {
  var t2 = e2.stack.pop(), r2 = e2.stack.pop();
  switch (exports.DEBUG && console.log(e2.step, "INSTCTRL[]", t2, r2), t2) {
    case 1:
      return void (e2.inhibitGridFit = !!r2);
    case 2:
      return void (e2.ignoreCvt = !!r2);
    default:
      throw new Error("invalid INSTCTRL[] selector");
  }
}, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, Lr.bind(void 0, 1), Lr.bind(void 0, 2), Lr.bind(void 0, 3), Lr.bind(void 0, 4), Lr.bind(void 0, 5), Lr.bind(void 0, 6), Lr.bind(void 0, 7), Lr.bind(void 0, 8), Cr.bind(void 0, 1), Cr.bind(void 0, 2), Cr.bind(void 0, 3), Cr.bind(void 0, 4), Cr.bind(void 0, 5), Cr.bind(void 0, 6), Cr.bind(void 0, 7), Cr.bind(void 0, 8), wr.bind(void 0, 0, 0, 0, 0, 0), wr.bind(void 0, 0, 0, 0, 0, 1), wr.bind(void 0, 0, 0, 0, 0, 2), wr.bind(void 0, 0, 0, 0, 0, 3), wr.bind(void 0, 0, 0, 0, 1, 0), wr.bind(void 0, 0, 0, 0, 1, 1), wr.bind(void 0, 0, 0, 0, 1, 2), wr.bind(void 0, 0, 0, 0, 1, 3), wr.bind(void 0, 0, 0, 1, 0, 0), wr.bind(void 0, 0, 0, 1, 0, 1), wr.bind(void 0, 0, 0, 1, 0, 2), wr.bind(void 0, 0, 0, 1, 0, 3), wr.bind(void 0, 0, 0, 1, 1, 0), wr.bind(void 0, 0, 0, 1, 1, 1), wr.bind(void 0, 0, 0, 1, 1, 2), wr.bind(void 0, 0, 0, 1, 1, 3), wr.bind(void 0, 0, 1, 0, 0, 0), wr.bind(void 0, 0, 1, 0, 0, 1), wr.bind(void 0, 0, 1, 0, 0, 2), wr.bind(void 0, 0, 1, 0, 0, 3), wr.bind(void 0, 0, 1, 0, 1, 0), wr.bind(void 0, 0, 1, 0, 1, 1), wr.bind(void 0, 0, 1, 0, 1, 2), wr.bind(void 0, 0, 1, 0, 1, 3), wr.bind(void 0, 0, 1, 1, 0, 0), wr.bind(void 0, 0, 1, 1, 0, 1), wr.bind(void 0, 0, 1, 1, 0, 2), wr.bind(void 0, 0, 1, 1, 0, 3), wr.bind(void 0, 0, 1, 1, 1, 0), wr.bind(void 0, 0, 1, 1, 1, 1), wr.bind(void 0, 0, 1, 1, 1, 2), wr.bind(void 0, 0, 1, 1, 1, 3), wr.bind(void 0, 1, 0, 0, 0, 0), wr.bind(void 0, 1, 0, 0, 0, 1), wr.bind(void 0, 1, 0, 0, 0, 2), wr.bind(void 0, 1, 0, 0, 0, 3), wr.bind(void 0, 1, 0, 0, 1, 0), wr.bind(void 0, 1, 0, 0, 1, 1), wr.bind(void 0, 1, 0, 0, 1, 2), wr.bind(void 0, 1, 0, 0, 1, 3), wr.bind(void 0, 1, 0, 1, 0, 0), wr.bind(void 0, 1, 0, 1, 0, 1), wr.bind(void 0, 1, 0, 1, 0, 2), wr.bind(void 0, 1, 0, 1, 0, 3), wr.bind(void 0, 1, 0, 1, 1, 0), wr.bind(void 0, 1, 0, 1, 1, 1), wr.bind(void 0, 1, 0, 1, 1, 2), wr.bind(void 0, 1, 0, 1, 1, 3), wr.bind(void 0, 1, 1, 0, 0, 0), wr.bind(void 0, 1, 1, 0, 0, 1), wr.bind(void 0, 1, 1, 0, 0, 2), wr.bind(void 0, 1, 1, 0, 0, 3), wr.bind(void 0, 1, 1, 0, 1, 0), wr.bind(void 0, 1, 1, 0, 1, 1), wr.bind(void 0, 1, 1, 0, 1, 2), wr.bind(void 0, 1, 1, 0, 1, 3), wr.bind(void 0, 1, 1, 1, 0, 0), wr.bind(void 0, 1, 1, 1, 0, 1), wr.bind(void 0, 1, 1, 1, 0, 2), wr.bind(void 0, 1, 1, 1, 0, 3), wr.bind(void 0, 1, 1, 1, 1, 0), wr.bind(void 0, 1, 1, 1, 1, 1), wr.bind(void 0, 1, 1, 1, 1, 2), wr.bind(void 0, 1, 1, 1, 1, 3)], Dr.prototype.setState = function(e2, t2) {
  return this.state[e2] = t2, this.activeState = { key: e2, value: this.state[e2] }, this.activeState;
}, Dr.prototype.getState = function(e2) {
  return this.state[e2] || null;
}, Pr.prototype.inboundIndex = function(e2) {
  return e2 >= 0 && e2 < this.tokens.length;
}, Pr.prototype.composeRUD = function(e2) {
  var t2 = this, r2 = e2.map(function(e3) {
    return t2[e3[0]].apply(t2, e3.slice(1).concat(true));
  }), n2 = function(e3) {
    return "object" == typeof e3 && e3.hasOwnProperty("FAIL");
  };
  if (r2.every(n2)) return { FAIL: "composeRUD: one or more operations hasn't completed successfully", report: r2.filter(n2) };
  this.dispatch("composeRUD", [r2.filter(function(e3) {
    return !n2(e3);
  })]);
}, Pr.prototype.replaceRange = function(e2, t2, r2, n2) {
  t2 = null !== t2 ? t2 : this.tokens.length;
  var a2 = r2.every(function(e3) {
    return e3 instanceof Dr;
  });
  if (!isNaN(e2) && this.inboundIndex(e2) && a2) {
    var o2 = this.tokens.splice.apply(this.tokens, [e2, t2].concat(r2));
    return n2 || this.dispatch("replaceToken", [e2, t2, r2]), [o2, r2];
  }
  return { FAIL: "replaceRange: invalid tokens or startIndex." };
}, Pr.prototype.replaceToken = function(e2, t2, r2) {
  if (!isNaN(e2) && this.inboundIndex(e2) && t2 instanceof Dr) {
    var n2 = this.tokens.splice(e2, 1, t2);
    return r2 || this.dispatch("replaceToken", [e2, t2]), [n2[0], t2];
  }
  return { FAIL: "replaceToken: invalid token or index." };
}, Pr.prototype.removeRange = function(e2, t2, r2) {
  t2 = isNaN(t2) ? this.tokens.length : t2;
  var n2 = this.tokens.splice(e2, t2);
  return r2 || this.dispatch("removeRange", [n2, e2, t2]), n2;
}, Pr.prototype.removeToken = function(e2, t2) {
  if (!isNaN(e2) && this.inboundIndex(e2)) {
    var r2 = this.tokens.splice(e2, 1);
    return t2 || this.dispatch("removeToken", [r2, e2]), r2;
  }
  return { FAIL: "removeToken: invalid token index." };
}, Pr.prototype.insertToken = function(e2, t2, r2) {
  return e2.every(function(e3) {
    return e3 instanceof Dr;
  }) ? (this.tokens.splice.apply(this.tokens, [t2, 0].concat(e2)), r2 || this.dispatch("insertToken", [e2, t2]), e2) : { FAIL: "insertToken: invalid token(s)." };
}, Pr.prototype.registerModifier = function(e2, t2, r2) {
  this.events.newToken.subscribe(function(n2, a2) {
    var o2 = [n2, a2], s2 = [n2, a2];
    if (null === t2 || true === t2.apply(this, o2)) {
      var i2 = r2.apply(this, s2);
      n2.setState(e2, i2);
    }
  }), this.registeredModifiers.push(e2);
}, Br.prototype.subscribe = function(e2) {
  return "function" == typeof e2 ? this.subscribers.push(e2) - 1 : { FAIL: "invalid '" + this.eventId + "' event handler" };
}, Br.prototype.unsubscribe = function(e2) {
  this.subscribers.splice(e2, 1);
}, Mr.prototype.setCurrentIndex = function(e2) {
  this.index = e2, this.current = this.context[e2], this.backtrack = this.context.slice(0, e2), this.lookahead = this.context.slice(e2 + 1);
}, Mr.prototype.get = function(e2) {
  switch (true) {
    case 0 === e2:
      return this.current;
    case (e2 < 0 && Math.abs(e2) <= this.backtrack.length):
      return this.backtrack.slice(e2)[0];
    case (e2 > 0 && e2 <= this.lookahead.length):
      return this.lookahead[e2 - 1];
    default:
      return null;
  }
}, Pr.prototype.rangeToText = function(e2) {
  if (e2 instanceof Ir) return this.getRangeTokens(e2).map(function(e3) {
    return e3.char;
  }).join("");
}, Pr.prototype.getText = function() {
  return this.tokens.map(function(e2) {
    return e2.char;
  }).join("");
}, Pr.prototype.getContext = function(e2) {
  var t2 = this.registeredContexts[e2];
  return t2 || null;
}, Pr.prototype.on = function(e2, t2) {
  var r2 = this.events[e2];
  return r2 ? r2.subscribe(t2) : null;
}, Pr.prototype.dispatch = function(e2, t2) {
  var r2 = this, n2 = this.events[e2];
  n2 instanceof Br && n2.subscribers.forEach(function(e3) {
    e3.apply(r2, t2 || []);
  });
}, Pr.prototype.registerContextChecker = function(e2, t2, r2) {
  if (this.getContext(e2)) return { FAIL: "context name '" + e2 + "' is already registered." };
  if ("function" != typeof t2) return { FAIL: "missing context start check." };
  if ("function" != typeof r2) return { FAIL: "missing context end check." };
  var n2 = new Gr(e2, t2, r2);
  return this.registeredContexts[e2] = n2, this.contextCheckers.push(n2), n2;
}, Pr.prototype.getRangeTokens = function(e2) {
  var t2 = e2.startIndex + e2.endOffset;
  return [].concat(this.tokens.slice(e2.startIndex, t2));
}, Pr.prototype.getContextRanges = function(e2) {
  var t2 = this.getContext(e2);
  return t2 ? t2.ranges : { FAIL: "context checker '" + e2 + "' is not registered." };
}, Pr.prototype.resetContextsRanges = function() {
  var e2 = this.registeredContexts;
  for (var t2 in e2) {
    if (e2.hasOwnProperty(t2)) e2[t2].ranges = [];
  }
}, Pr.prototype.updateContextsRanges = function() {
  this.resetContextsRanges();
  for (var e2 = this.tokens.map(function(e3) {
    return e3.char;
  }), t2 = 0; t2 < e2.length; t2++) {
    var r2 = new Mr(e2, t2);
    this.runContextCheck(r2);
  }
  this.dispatch("updateContextsRanges", [this.registeredContexts]);
}, Pr.prototype.setEndOffset = function(e2, t2) {
  var r2 = new Ir(this.getContext(t2).openRange.startIndex, e2, t2), n2 = this.getContext(t2).ranges;
  return r2.rangeId = t2 + "." + n2.length, n2.push(r2), this.getContext(t2).openRange = null, r2;
}, Pr.prototype.runContextCheck = function(e2) {
  var t2 = this, r2 = e2.index;
  this.contextCheckers.forEach(function(n2) {
    var a2 = n2.contextName, o2 = t2.getContext(a2).openRange;
    if (!o2 && n2.checkStart(e2) && (o2 = new Ir(r2, null, a2), t2.getContext(a2).openRange = o2, t2.dispatch("contextStart", [a2, r2])), o2 && n2.checkEnd(e2)) {
      var s2 = r2 - o2.startIndex + 1, i2 = t2.setEndOffset(s2, a2);
      t2.dispatch("contextEnd", [a2, i2]);
    }
  });
}, Pr.prototype.tokenize = function(e2) {
  this.tokens = [], this.resetContextsRanges();
  var t2 = Array.from(e2);
  this.dispatch("start");
  for (var r2 = 0; r2 < t2.length; r2++) {
    var n2 = t2[r2], a2 = new Mr(t2, r2);
    this.dispatch("next", [a2]), this.runContextCheck(a2);
    var o2 = new Dr(n2);
    this.tokens.push(o2), this.dispatch("newToken", [o2, a2]);
  }
  return this.dispatch("end", [this.tokens]), this.tokens;
}, Wr.prototype.getDefaultScriptFeaturesIndexes = function() {
  for (var e2 = this.font.tables.gsub.scripts, t2 = 0; t2 < e2.length; t2++) {
    var r2 = e2[t2];
    if ("DFLT" === r2.tag) return r2.script.defaultLangSys.featureIndexes;
  }
  return [];
}, Wr.prototype.getScriptFeaturesIndexes = function(e2) {
  if (!this.font.tables.gsub) return [];
  if (!e2) return this.getDefaultScriptFeaturesIndexes();
  for (var t2 = this.font.tables.gsub.scripts, r2 = 0; r2 < t2.length; r2++) {
    var n2 = t2[r2];
    if (n2.tag === e2 && n2.script.defaultLangSys) return n2.script.defaultLangSys.featureIndexes;
    var a2 = n2.langSysRecords;
    if (a2) for (var o2 = 0; o2 < a2.length; o2++) {
      var s2 = a2[o2];
      if (s2.tag === e2) return s2.langSys.featureIndexes;
    }
  }
  return this.getDefaultScriptFeaturesIndexes();
}, Wr.prototype.mapTagsToFeatures = function(e2, t2) {
  for (var r2 = {}, n2 = 0; n2 < e2.length; n2++) {
    var a2 = e2[n2].tag, o2 = e2[n2].feature;
    r2[a2] = o2;
  }
  this.features[t2].tags = r2;
}, Wr.prototype.getScriptFeatures = function(e2) {
  var t2 = this.features[e2];
  if (this.features.hasOwnProperty(e2)) return t2;
  var r2 = this.getScriptFeaturesIndexes(e2);
  if (!r2) return null;
  var n2 = this.font.tables.gsub;
  return t2 = r2.map(function(e3) {
    return n2.features[e3];
  }), this.features[e2] = t2, this.mapTagsToFeatures(t2, e2), t2;
}, Wr.prototype.getSubstitutionType = function(e2, t2) {
  return e2.lookupType.toString() + t2.substFormat.toString();
}, Wr.prototype.getLookupMethod = function(e2, t2) {
  var r2 = this;
  switch (this.getSubstitutionType(e2, t2)) {
    case "11":
      return function(e3) {
        return Xr.apply(r2, [e3, t2]);
      };
    case "12":
      return function(e3) {
        return Vr.apply(r2, [e3, t2]);
      };
    case "63":
      return function(e3) {
        return Yr.apply(r2, [e3, t2]);
      };
    case "41":
      return function(e3) {
        return Zr.apply(r2, [e3, t2]);
      };
    case "21":
      return function(e3) {
        return Qr.apply(r2, [e3, t2]);
      };
    default:
      throw new Error("lookupType: " + e2.lookupType + " - substFormat: " + t2.substFormat + " is not yet supported");
  }
}, Wr.prototype.lookupFeature = function(e2) {
  var t2 = e2.contextParams, r2 = t2.index, n2 = this.getFeature({ tag: e2.tag, script: e2.script });
  if (!n2) return new Error("font '" + this.font.names.fullName.en + "' doesn't support feature '" + e2.tag + "' for script '" + e2.script + "'.");
  for (var a2 = this.getFeatureLookups(n2), o2 = [].concat(t2.context), s2 = 0; s2 < a2.length; s2++) for (var i2 = a2[s2], u2 = this.getLookupSubtables(i2), l2 = 0; l2 < u2.length; l2++) {
    var p2 = u2[l2], c2 = this.getSubstitutionType(i2, p2), h2 = this.getLookupMethod(i2, p2), f2 = void 0;
    switch (c2) {
      case "11":
        (f2 = h2(t2.current)) && o2.splice(r2, 1, new qr({ id: 11, tag: e2.tag, substitution: f2 }));
        break;
      case "12":
        (f2 = h2(t2.current)) && o2.splice(r2, 1, new qr({ id: 12, tag: e2.tag, substitution: f2 }));
        break;
      case "63":
        f2 = h2(t2), Array.isArray(f2) && f2.length && o2.splice(r2, 1, new qr({ id: 63, tag: e2.tag, substitution: f2 }));
        break;
      case "41":
        (f2 = h2(t2)) && o2.splice(r2, 1, new qr({ id: 41, tag: e2.tag, substitution: f2 }));
        break;
      case "21":
        (f2 = h2(t2.current)) && o2.splice(r2, 1, new qr({ id: 21, tag: e2.tag, substitution: f2 }));
    }
    t2 = new Mr(o2, r2), Array.isArray(f2) && !f2.length || (f2 = null);
  }
  return o2.length ? o2 : null;
}, Wr.prototype.supports = function(e2) {
  if (!e2.script) return false;
  this.getScriptFeatures(e2.script);
  var t2 = this.features.hasOwnProperty(e2.script);
  if (!e2.tag) return t2;
  var r2 = this.features[e2.script].some(function(t3) {
    return t3.tag === e2.tag;
  });
  return t2 && r2;
}, Wr.prototype.getLookupSubtables = function(e2) {
  return e2.subtables || null;
}, Wr.prototype.getLookupByIndex = function(e2) {
  return this.font.tables.gsub.lookups[e2] || null;
}, Wr.prototype.getFeatureLookups = function(e2) {
  return e2.lookupListIndexes.map(this.getLookupByIndex.bind(this));
}, Wr.prototype.getFeature = function(e2) {
  if (!this.font) return { FAIL: "No font was found" };
  this.features.hasOwnProperty(e2.script) || this.getScriptFeatures(e2.script);
  var t2 = this.features[e2.script];
  return t2 ? t2.tags[e2.tag] ? this.features[e2.script].tags[e2.tag] : null : { FAIL: "No feature for script " + e2.script };
};
var Kr = { startCheck: function(e2) {
  var t2 = e2.current, r2 = e2.get(-1);
  return null === r2 && Ar(t2) || !Ar(r2) && Ar(t2);
}, endCheck: function(e2) {
  var t2 = e2.get(1);
  return null === t2 || !Ar(t2);
} };
var Jr = { startCheck: function(e2) {
  var t2 = e2.current, r2 = e2.get(-1);
  return (Ar(t2) || Hr(t2)) && !Ar(r2);
}, endCheck: function(e2) {
  var t2 = e2.get(1);
  switch (true) {
    case null === t2:
      return true;
    case (!Ar(t2) && !Hr(t2)):
      var r2 = /\s/.test(t2);
      if (!r2) return true;
      if (r2) {
        var n2;
        if (n2 = e2.lookahead.some(function(e3) {
          return Ar(e3) || Hr(e3);
        }), !n2) return true;
      }
      break;
    default:
      return false;
  }
} };
var $r = { 11: function(e2, t2, r2) {
  t2[r2].setState(e2.tag, e2.substitution);
}, 12: function(e2, t2, r2) {
  t2[r2].setState(e2.tag, e2.substitution);
}, 63: function(e2, t2, r2) {
  e2.substitution.forEach(function(n2, a2) {
    t2[r2 + a2].setState(e2.tag, n2);
  });
}, 41: function(e2, t2, r2) {
  var n2 = t2[r2];
  n2.setState(e2.tag, e2.substitution.ligGlyph);
  for (var a2 = e2.substitution.components.length, o2 = 0; o2 < a2; o2++) (n2 = t2[r2 + o2 + 1]).setState("deleted", true);
} };
function en(e2, t2, r2) {
  e2 instanceof qr && $r[e2.id] && $r[e2.id](e2, t2, r2);
}
function tn(e2) {
  var t2 = this, r2 = "arab", n2 = this.featuresTags[r2], a2 = this.tokenizer.getRangeTokens(e2);
  if (1 !== a2.length) {
    var o2 = new Mr(a2.map(function(e3) {
      return e3.getState("glyphIndex");
    }), 0), s2 = new Mr(a2.map(function(e3) {
      return e3.char;
    }), 0);
    a2.forEach(function(e3, i2) {
      if (!Hr(e3.char)) {
        o2.setCurrentIndex(i2), s2.setCurrentIndex(i2);
        var u2, l2 = 0;
        switch (function(e4) {
          for (var t3 = [].concat(e4.backtrack), r3 = t3.length - 1; r3 >= 0; r3--) {
            var n3 = t3[r3], a3 = Nr(n3), o3 = Hr(n3);
            if (!a3 && !o3) return true;
            if (a3) return false;
          }
          return false;
        }(s2) && (l2 |= 1), function(e4) {
          if (Nr(e4.current)) return false;
          for (var t3 = 0; t3 < e4.lookahead.length; t3++) if (!Hr(e4.lookahead[t3])) return true;
          return false;
        }(s2) && (l2 |= 2), l2) {
          case 1:
            u2 = "fina";
            break;
          case 2:
            u2 = "init";
            break;
          case 3:
            u2 = "medi";
        }
        if (-1 !== n2.indexOf(u2)) {
          var p2 = t2.query.lookupFeature({ tag: u2, script: r2, contextParams: o2 });
          if (p2 instanceof Error) return console.info(p2.message);
          p2.forEach(function(e4, t3) {
            e4 instanceof qr && (en(e4, a2, t3), o2.context[t3] = e4.substitution);
          });
        }
      }
    });
  }
}
function rn(e2, t2) {
  return new Mr(e2.map(function(e3) {
    return e3.activeState.value;
  }), t2 || 0);
}
function nn(e2) {
  var t2 = this, r2 = this.tokenizer.getRangeTokens(e2), n2 = rn(r2);
  n2.context.forEach(function(e3, a2) {
    n2.setCurrentIndex(a2);
    var o2 = t2.query.lookupFeature({ tag: "rlig", script: "arab", contextParams: n2 });
    o2.length && (o2.forEach(function(e4) {
      return en(e4, r2, a2);
    }), n2 = rn(r2));
  });
}
var an = { startCheck: function(e2) {
  var t2 = e2.current, r2 = e2.get(-1);
  return null === r2 && zr(t2) || !zr(r2) && zr(t2);
}, endCheck: function(e2) {
  var t2 = e2.get(1);
  return null === t2 || !zr(t2);
} };
function on(e2, t2) {
  return new Mr(e2.map(function(e3) {
    return e3.activeState.value;
  }), t2 || 0);
}
function sn(e2) {
  var t2 = this, r2 = this.tokenizer.getRangeTokens(e2), n2 = on(r2);
  n2.context.forEach(function(e3, a2) {
    n2.setCurrentIndex(a2);
    var o2 = t2.query.lookupFeature({ tag: "liga", script: "latn", contextParams: n2 });
    o2.length && (o2.forEach(function(e4) {
      return en(e4, r2, a2);
    }), n2 = on(r2));
  });
}
function un(e2) {
  this.baseDir = e2 || "ltr", this.tokenizer = new Pr(), this.featuresTags = {};
}
function ln(e2) {
  var t2 = this.contextChecks[e2 + "Check"];
  return this.tokenizer.registerContextChecker(e2, t2.startCheck, t2.endCheck);
}
function pn() {
  return ln.call(this, "latinWord"), ln.call(this, "arabicWord"), ln.call(this, "arabicSentence"), this.tokenizer.tokenize(this.text);
}
function cn() {
  var e2 = this;
  this.tokenizer.getContextRanges("arabicSentence").forEach(function(t2) {
    var r2 = e2.tokenizer.getRangeTokens(t2);
    e2.tokenizer.replaceRange(t2.startIndex, t2.endOffset, r2.reverse());
  });
}
function hn() {
  if (-1 === this.tokenizer.registeredModifiers.indexOf("glyphIndex")) throw new Error("glyphIndex modifier is required to apply arabic presentation features.");
}
function fn() {
  var e2 = this;
  this.featuresTags.hasOwnProperty("arab") && (hn.call(this), this.tokenizer.getContextRanges("arabicWord").forEach(function(t2) {
    tn.call(e2, t2);
  }));
}
function dn() {
  var e2 = this, t2 = "arab";
  this.featuresTags.hasOwnProperty(t2) && (-1 !== this.featuresTags[t2].indexOf("rlig") && (hn.call(this), this.tokenizer.getContextRanges("arabicWord").forEach(function(t3) {
    nn.call(e2, t3);
  })));
}
function vn() {
  var e2 = this, t2 = "latn";
  this.featuresTags.hasOwnProperty(t2) && (-1 !== this.featuresTags[t2].indexOf("liga") && (hn.call(this), this.tokenizer.getContextRanges("latinWord").forEach(function(t3) {
    sn.call(e2, t3);
  })));
}
function gn(e2) {
  (e2 = e2 || {}).tables = e2.tables || {}, e2.empty || (Mt(e2.familyName, "When creating a new Font object, familyName is required."), Mt(e2.styleName, "When creating a new Font object, styleName is required."), Mt(e2.unitsPerEm, "When creating a new Font object, unitsPerEm is required."), Mt(e2.ascender, "When creating a new Font object, ascender is required."), Mt(e2.descender <= 0, "When creating a new Font object, negative descender value is required."), this.names = { fontFamily: { en: e2.familyName || " " }, fontSubfamily: { en: e2.styleName || " " }, fullName: { en: e2.fullName || e2.familyName + " " + e2.styleName }, postScriptName: { en: e2.postScriptName || (e2.familyName + e2.styleName).replace(/\s/g, "") }, designer: { en: e2.designer || " " }, designerURL: { en: e2.designerURL || " " }, manufacturer: { en: e2.manufacturer || " " }, manufacturerURL: { en: e2.manufacturerURL || " " }, license: { en: e2.license || " " }, licenseURL: { en: e2.licenseURL || " " }, version: { en: e2.version || "Version 0.1" }, description: { en: e2.description || " " }, copyright: { en: e2.copyright || " " }, trademark: { en: e2.trademark || " " } }, this.unitsPerEm = e2.unitsPerEm || 1e3, this.ascender = e2.ascender, this.descender = e2.descender, this.createdTimestamp = e2.createdTimestamp, this.tables = Object.assign(e2.tables, { os2: Object.assign({ usWeightClass: e2.weightClass || this.usWeightClasses.MEDIUM, usWidthClass: e2.widthClass || this.usWidthClasses.MEDIUM, fsSelection: e2.fsSelection || this.fsSelectionValues.REGULAR }, e2.tables.os2) })), this.supported = true, this.glyphs = new Be.GlyphSet(this, e2.glyphs || []), this.encoding = new Re(this), this.position = new Ct(this), this.substitution = new wt(this), this.tables = this.tables || {}, this._push = null, this._hmtxTableData = {}, Object.defineProperty(this, "hinting", { get: function() {
    return this._hinting ? this._hinting : "truetype" === this.outlinesFormat ? this._hinting = new Xt(this) : void 0;
  } });
}
function mn(e2, t2) {
  var r2 = JSON.stringify(e2), n2 = 256;
  for (var a2 in t2) {
    var o2 = parseInt(a2);
    if (o2 && !(o2 < 256)) {
      if (JSON.stringify(t2[a2]) === r2) return o2;
      n2 <= o2 && (n2 = o2 + 1);
    }
  }
  return t2[n2] = e2, n2;
}
function yn(e2, t2, r2) {
  var n2 = mn(t2.name, r2);
  return [{ name: "tag_" + e2, type: "TAG", value: t2.tag }, { name: "minValue_" + e2, type: "FIXED", value: t2.minValue << 16 }, { name: "defaultValue_" + e2, type: "FIXED", value: t2.defaultValue << 16 }, { name: "maxValue_" + e2, type: "FIXED", value: t2.maxValue << 16 }, { name: "flags_" + e2, type: "USHORT", value: 0 }, { name: "nameID_" + e2, type: "USHORT", value: n2 }];
}
function bn(e2, t2, r2) {
  var n2 = {}, a2 = new se.Parser(e2, t2);
  return n2.tag = a2.parseTag(), n2.minValue = a2.parseFixed(), n2.defaultValue = a2.parseFixed(), n2.maxValue = a2.parseFixed(), a2.skip("uShort", 1), n2.name = r2[a2.parseUShort()] || {}, n2;
}
function Sn(e2, t2, r2, n2) {
  for (var a2 = [{ name: "nameID_" + e2, type: "USHORT", value: mn(t2.name, n2) }, { name: "flags_" + e2, type: "USHORT", value: 0 }], o2 = 0; o2 < r2.length; ++o2) {
    var s2 = r2[o2].tag;
    a2.push({ name: "axis_" + e2 + " " + s2, type: "FIXED", value: t2.coordinates[s2] << 16 });
  }
  return a2;
}
function xn(e2, t2, r2, n2) {
  var a2 = {}, o2 = new se.Parser(e2, t2);
  a2.name = n2[o2.parseUShort()] || {}, o2.skip("uShort", 1), a2.coordinates = {};
  for (var s2 = 0; s2 < r2.length; ++s2) a2.coordinates[r2[s2].tag] = o2.parseFixed();
  return a2;
}
un.prototype.setText = function(e2) {
  this.text = e2;
}, un.prototype.contextChecks = { latinWordCheck: an, arabicWordCheck: Kr, arabicSentenceCheck: Jr }, un.prototype.registerFeatures = function(e2, t2) {
  var r2 = this, n2 = t2.filter(function(t3) {
    return r2.query.supports({ script: e2, tag: t3 });
  });
  this.featuresTags.hasOwnProperty(e2) ? this.featuresTags[e2] = this.featuresTags[e2].concat(n2) : this.featuresTags[e2] = n2;
}, un.prototype.applyFeatures = function(e2, t2) {
  if (!e2) throw new Error("No valid font was provided to apply features");
  this.query || (this.query = new Wr(e2));
  for (var r2 = 0; r2 < t2.length; r2++) {
    var n2 = t2[r2];
    this.query.supports({ script: n2.script }) && this.registerFeatures(n2.script, n2.tags);
  }
}, un.prototype.registerModifier = function(e2, t2, r2) {
  this.tokenizer.registerModifier(e2, t2, r2);
}, un.prototype.checkContextReady = function(e2) {
  return !!this.tokenizer.getContext(e2);
}, un.prototype.applyFeaturesToContexts = function() {
  this.checkContextReady("arabicWord") && (fn.call(this), dn.call(this)), this.checkContextReady("latinWord") && vn.call(this), this.checkContextReady("arabicSentence") && cn.call(this);
}, un.prototype.processText = function(e2) {
  this.text && this.text === e2 || (this.setText(e2), pn.call(this), this.applyFeaturesToContexts());
}, un.prototype.getBidiText = function(e2) {
  return this.processText(e2), this.tokenizer.getText();
}, un.prototype.getTextGlyphs = function(e2) {
  this.processText(e2);
  for (var t2 = [], r2 = 0; r2 < this.tokenizer.tokens.length; r2++) {
    var n2 = this.tokenizer.tokens[r2];
    if (!n2.state.deleted) {
      var a2 = n2.activeState.value;
      t2.push(Array.isArray(a2) ? a2[0] : a2);
    }
  }
  return t2;
}, gn.prototype.hasChar = function(e2) {
  return null !== this.encoding.charToGlyphIndex(e2);
}, gn.prototype.charToGlyphIndex = function(e2) {
  return this.encoding.charToGlyphIndex(e2);
}, gn.prototype.charToGlyph = function(e2) {
  var t2 = this.charToGlyphIndex(e2), r2 = this.glyphs.get(t2);
  return r2 || (r2 = this.glyphs.get(0)), r2;
}, gn.prototype.updateFeatures = function(e2) {
  return this.defaultRenderOptions.features.map(function(t2) {
    return "latn" === t2.script ? { script: "latn", tags: t2.tags.filter(function(t3) {
      return e2[t3];
    }) } : t2;
  });
}, gn.prototype.stringToGlyphs = function(e2, t2) {
  var r2 = this, n2 = new un();
  n2.registerModifier("glyphIndex", null, function(e3) {
    return r2.charToGlyphIndex(e3.char);
  });
  var a2 = t2 ? this.updateFeatures(t2.features) : this.defaultRenderOptions.features;
  n2.applyFeatures(this, a2);
  for (var o2 = n2.getTextGlyphs(e2), s2 = o2.length, i2 = new Array(s2), u2 = this.glyphs.get(0), l2 = 0; l2 < s2; l2 += 1) i2[l2] = this.glyphs.get(o2[l2]) || u2;
  return i2;
}, gn.prototype.nameToGlyphIndex = function(e2) {
  return this.glyphNames.nameToGlyphIndex(e2);
}, gn.prototype.nameToGlyph = function(e2) {
  var t2 = this.nameToGlyphIndex(e2), r2 = this.glyphs.get(t2);
  return r2 || (r2 = this.glyphs.get(0)), r2;
}, gn.prototype.glyphIndexToName = function(e2) {
  return this.glyphNames.glyphIndexToName ? this.glyphNames.glyphIndexToName(e2) : "";
}, gn.prototype.getKerningValue = function(e2, t2) {
  e2 = e2.index || e2, t2 = t2.index || t2;
  var r2 = this.position.defaultKerningTables;
  return r2 ? this.position.getKerningValue(r2, e2, t2) : this.kerningPairs && this.kerningPairs[e2 + "," + t2] || 0;
}, gn.prototype.defaultRenderOptions = { kerning: true, features: [{ script: "arab", tags: ["init", "medi", "fina", "rlig"] }, { script: "latn", tags: ["liga", "rlig"] }] }, gn.prototype.forEachGlyph = function(e2, t2, r2, n2, a2, o2) {
  t2 = void 0 !== t2 ? t2 : 0, r2 = void 0 !== r2 ? r2 : 0, n2 = void 0 !== n2 ? n2 : 72, a2 = Object.assign({}, this.defaultRenderOptions, a2);
  var s2, i2 = 1 / this.unitsPerEm * n2, u2 = this.stringToGlyphs(e2, a2);
  if (a2.kerning) {
    var l2 = a2.script || this.position.getDefaultScriptName();
    s2 = this.position.getKerningTables(l2, a2.language);
  }
  for (var p2 = 0; p2 < u2.length; p2 += 1) {
    var c2 = u2[p2];
    if (o2.call(this, c2, t2, r2, n2, a2), c2.advanceWidth && (t2 += c2.advanceWidth * i2), a2.kerning && p2 < u2.length - 1) t2 += (s2 ? this.position.getKerningValue(s2, c2.index, u2[p2 + 1].index) : this.getKerningValue(c2, u2[p2 + 1])) * i2;
    a2.letterSpacing ? t2 += a2.letterSpacing * n2 : a2.tracking && (t2 += a2.tracking / 1e3 * n2);
  }
  return t2;
}, gn.prototype.getPath = function(e2, t2, r2, n2, a2) {
  var o2 = new E();
  return this.forEachGlyph(e2, t2, r2, n2, a2, function(e3, t3, r3, n3) {
    var s2 = e3.getPath(t3, r3, n3, a2, this);
    o2.extend(s2);
  }), o2;
}, gn.prototype.getPaths = function(e2, t2, r2, n2, a2) {
  var o2 = [];
  return this.forEachGlyph(e2, t2, r2, n2, a2, function(e3, t3, r3, n3) {
    var s2 = e3.getPath(t3, r3, n3, a2, this);
    o2.push(s2);
  }), o2;
}, gn.prototype.getAdvanceWidth = function(e2, t2, r2) {
  return this.forEachGlyph(e2, 0, 0, t2, r2, function() {
  });
}, gn.prototype.draw = function(e2, t2, r2, n2, a2, o2) {
  this.getPath(t2, r2, n2, a2, o2).draw(e2);
}, gn.prototype.drawPoints = function(e2, t2, r2, n2, a2, o2) {
  this.forEachGlyph(t2, r2, n2, a2, o2, function(t3, r3, n3, a3) {
    t3.drawPoints(e2, r3, n3, a3);
  });
}, gn.prototype.drawMetrics = function(e2, t2, r2, n2, a2, o2) {
  this.forEachGlyph(t2, r2, n2, a2, o2, function(t3, r3, n3, a3) {
    t3.drawMetrics(e2, r3, n3, a3);
  });
}, gn.prototype.getEnglishName = function(e2) {
  var t2 = this.names[e2];
  if (t2) return t2.en;
}, gn.prototype.validate = function() {
  var e2 = this;
  function t2(t3) {
    var r2 = e2.getEnglishName(t3);
    r2 && r2.trim().length;
  }
  t2("fontFamily"), t2("weightName"), t2("manufacturer"), t2("copyright"), t2("version"), this.unitsPerEm;
}, gn.prototype.toTables = function() {
  return kt.fontToTable(this);
}, gn.prototype.toBuffer = function() {
  return console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead."), this.toArrayBuffer();
}, gn.prototype.toArrayBuffer = function() {
  for (var e2 = this.toTables().encode(), t2 = new ArrayBuffer(e2.length), r2 = new Uint8Array(t2), n2 = 0; n2 < e2.length; n2++) r2[n2] = e2[n2];
  return t2;
}, gn.prototype.download = function(e2) {
  var t2 = this.getEnglishName("fontFamily"), r2 = this.getEnglishName("fontSubfamily");
  e2 = e2 || t2.replace(/\s/g, "") + "-" + r2 + ".otf";
  var n2 = this.toArrayBuffer();
  if ("undefined" != typeof window) if (window.URL = window.URL || window.webkitURL, window.URL) {
    var a2 = new DataView(n2), o2 = new Blob([a2], { type: "font/opentype" }), s2 = document.createElement("a");
    s2.href = window.URL.createObjectURL(o2), s2.download = e2;
    var i2 = document.createEvent("MouseEvents");
    i2.initEvent("click", true, false), s2.dispatchEvent(i2);
  } else console.warn("Font file could not be downloaded. Try using a different browser.");
  else {
    var u2 = __require("fs"), l2 = function(e3) {
      for (var t3 = Buffer.alloc(e3.byteLength), r3 = new Uint8Array(e3), n3 = 0; n3 < t3.length; ++n3) t3[n3] = r3[n3];
      return t3;
    }(n2);
    u2.writeFileSync(e2, l2);
  }
}, gn.prototype.fsSelectionValues = { ITALIC: 1, UNDERSCORE: 2, NEGATIVE: 4, OUTLINED: 8, STRIKEOUT: 16, BOLD: 32, REGULAR: 64, USER_TYPO_METRICS: 128, WWS: 256, OBLIQUE: 512 }, gn.prototype.usWidthClasses = { ULTRA_CONDENSED: 1, EXTRA_CONDENSED: 2, CONDENSED: 3, SEMI_CONDENSED: 4, MEDIUM: 5, SEMI_EXPANDED: 6, EXPANDED: 7, EXTRA_EXPANDED: 8, ULTRA_EXPANDED: 9 }, gn.prototype.usWeightClasses = { THIN: 100, EXTRA_LIGHT: 200, LIGHT: 300, NORMAL: 400, MEDIUM: 500, SEMI_BOLD: 600, BOLD: 700, EXTRA_BOLD: 800, BLACK: 900 };
var Tn = { make: function(e2, t2) {
  var r2 = new J.Table("fvar", [{ name: "version", type: "ULONG", value: 65536 }, { name: "offsetToData", type: "USHORT", value: 0 }, { name: "countSizePairs", type: "USHORT", value: 2 }, { name: "axisCount", type: "USHORT", value: e2.axes.length }, { name: "axisSize", type: "USHORT", value: 20 }, { name: "instanceCount", type: "USHORT", value: e2.instances.length }, { name: "instanceSize", type: "USHORT", value: 4 + 4 * e2.axes.length }]);
  r2.offsetToData = r2.sizeOf();
  for (var n2 = 0; n2 < e2.axes.length; n2++) r2.fields = r2.fields.concat(yn(n2, e2.axes[n2], t2));
  for (var a2 = 0; a2 < e2.instances.length; a2++) r2.fields = r2.fields.concat(Sn(a2, e2.instances[a2], e2.axes, t2));
  return r2;
}, parse: function(e2, t2, r2) {
  var n2 = new se.Parser(e2, t2), a2 = n2.parseULong();
  w.argument(65536 === a2, "Unsupported fvar table version.");
  var o2 = n2.parseOffset16();
  n2.skip("uShort", 1);
  for (var s2 = n2.parseUShort(), i2 = n2.parseUShort(), u2 = n2.parseUShort(), l2 = n2.parseUShort(), p2 = [], c2 = 0; c2 < s2; c2++) p2.push(bn(e2, t2 + o2 + c2 * i2, r2));
  for (var h2 = [], f2 = t2 + o2 + s2 * i2, d2 = 0; d2 < u2; d2++) h2.push(xn(e2, f2 + d2 * l2, p2, r2));
  return { axes: p2, instances: h2 };
} };
var Un = function() {
  return { coverage: this.parsePointer(ae.coverage), attachPoints: this.parseList(ae.pointer(ae.uShortList)) };
};
var kn = function() {
  var e2 = this.parseUShort();
  return w.argument(1 === e2 || 2 === e2 || 3 === e2, "Unsupported CaretValue table version."), 1 === e2 ? { coordinate: this.parseShort() } : 2 === e2 ? { pointindex: this.parseShort() } : 3 === e2 ? { coordinate: this.parseShort() } : void 0;
};
var On = function() {
  return this.parseList(ae.pointer(kn));
};
var Rn = function() {
  return { coverage: this.parsePointer(ae.coverage), ligGlyphs: this.parseList(ae.pointer(On)) };
};
var En = function() {
  return this.parseUShort(), this.parseList(ae.pointer(ae.coverage));
};
var Ln = { parse: function(e2, t2) {
  var r2 = new ae(e2, t2 = t2 || 0), n2 = r2.parseVersion(1);
  w.argument(1 === n2 || 1.2 === n2 || 1.3 === n2, "Unsupported GDEF table version.");
  var a2 = { version: n2, classDef: r2.parsePointer(ae.classDef), attachList: r2.parsePointer(Un), ligCaretList: r2.parsePointer(Rn), markAttachClassDef: r2.parsePointer(ae.classDef) };
  return n2 >= 1.2 && (a2.markGlyphSets = r2.parsePointer(En)), a2;
} };
var Cn = { parse: function(e2, t2) {
  var r2 = new se.Parser(e2, t2), n2 = r2.parseUShort();
  if (0 === n2) return function(e3) {
    var t3 = {};
    e3.skip("uShort");
    var r3 = e3.parseUShort();
    w.argument(0 === r3, "Unsupported kern sub-table version."), e3.skip("uShort", 2);
    var n3 = e3.parseUShort();
    e3.skip("uShort", 3);
    for (var a2 = 0; a2 < n3; a2 += 1) {
      var o2 = e3.parseUShort(), s2 = e3.parseUShort(), i2 = e3.parseShort();
      t3[o2 + "," + s2] = i2;
    }
    return t3;
  }(r2);
  if (1 === n2) return function(e3) {
    var t3 = {};
    e3.skip("uShort"), e3.parseULong() > 1 && console.warn("Only the first kern subtable is supported."), e3.skip("uLong");
    var r3 = 255 & e3.parseUShort();
    if (e3.skip("uShort"), 0 === r3) {
      var n3 = e3.parseUShort();
      e3.skip("uShort", 3);
      for (var a2 = 0; a2 < n3; a2 += 1) {
        var o2 = e3.parseUShort(), s2 = e3.parseUShort(), i2 = e3.parseShort();
        t3[o2 + "," + s2] = i2;
      }
    }
    return t3;
  }(r2);
  throw new Error("Unsupported kern table version (" + n2 + ").");
} };
var wn = { parse: function(e2, t2, r2, n2) {
  for (var a2 = new se.Parser(e2, t2), o2 = n2 ? a2.parseUShort : a2.parseULong, s2 = [], i2 = 0; i2 < r2 + 1; i2 += 1) {
    var u2 = o2.call(a2);
    n2 && (u2 *= 2), s2.push(u2);
  }
  return s2;
} };
function Dn(e2, t2) {
  __require("fs").readFile(e2, function(e3, r2) {
    if (e3) return t2(e3.message);
    t2(null, Gt(r2));
  });
}
function In(e2, t2) {
  var r2 = new XMLHttpRequest();
  r2.open("get", e2, true), r2.responseType = "arraybuffer", r2.onload = function() {
    return r2.response ? t2(null, r2.response) : t2("Font could not be loaded: " + r2.statusText);
  }, r2.onerror = function() {
    t2("Font could not be loaded");
  }, r2.send();
}
function Gn(e2, t2) {
  for (var r2 = [], n2 = 12, a2 = 0; a2 < t2; a2 += 1) {
    var o2 = se.getTag(e2, n2), s2 = se.getULong(e2, n2 + 4), i2 = se.getULong(e2, n2 + 8), u2 = se.getULong(e2, n2 + 12);
    r2.push({ tag: o2, checksum: s2, offset: i2, length: u2, compression: false }), n2 += 16;
  }
  return r2;
}
function Mn(e2, t2) {
  if ("WOFF" === t2.compression) {
    var r2 = new Uint8Array(e2.buffer, t2.offset + 2, t2.compressedLength - 2), n2 = new Uint8Array(t2.length);
    if (k(r2, n2), n2.byteLength !== t2.length) throw new Error("Decompression error: " + t2.tag + " decompressed length doesn't match recorded length");
    return { data: new DataView(n2.buffer, 0), offset: 0 };
  }
  return { data: e2, offset: t2.offset };
}
function Bn(e2, t2) {
  var r2, n2;
  t2 = null == t2 ? {} : t2;
  var a2, o2, s2, i2, u2, l2, p2, c2, h2, f2, d2, v2, g2, m2 = new gn({ empty: true }), y2 = new DataView(e2, 0), b2 = [], S2 = se.getTag(y2, 0);
  if (S2 === String.fromCharCode(0, 1, 0, 0) || "true" === S2 || "typ1" === S2) m2.outlinesFormat = "truetype", b2 = Gn(y2, a2 = se.getUShort(y2, 4));
  else if ("OTTO" === S2) m2.outlinesFormat = "cff", b2 = Gn(y2, a2 = se.getUShort(y2, 4));
  else {
    if ("wOFF" !== S2) throw new Error("Unsupported OpenType signature " + S2);
    var x2 = se.getTag(y2, 4);
    if (x2 === String.fromCharCode(0, 1, 0, 0)) m2.outlinesFormat = "truetype";
    else {
      if ("OTTO" !== x2) throw new Error("Unsupported OpenType flavor " + S2);
      m2.outlinesFormat = "cff";
    }
    b2 = function(e3, t3) {
      for (var r3 = [], n3 = 44, a3 = 0; a3 < t3; a3 += 1) {
        var o3 = se.getTag(e3, n3), s3 = se.getULong(e3, n3 + 4), i3 = se.getULong(e3, n3 + 8), u3 = se.getULong(e3, n3 + 12), l3 = void 0;
        l3 = i3 < u3 && "WOFF", r3.push({ tag: o3, offset: s3, compression: l3, compressedLength: i3, length: u3 }), n3 += 20;
      }
      return r3;
    }(y2, a2 = se.getUShort(y2, 12));
  }
  for (var T2 = 0; T2 < a2; T2 += 1) {
    var U2 = b2[T2], k2 = void 0;
    switch (U2.tag) {
      case "cmap":
        k2 = Mn(y2, U2), m2.tables.cmap = xe.parse(k2.data, k2.offset), m2.encoding = new Ee(m2.tables.cmap);
        break;
      case "cvt ":
        k2 = Mn(y2, U2), g2 = new se.Parser(k2.data, k2.offset), m2.tables.cvt = g2.parseShortList(U2.length / 2);
        break;
      case "fvar":
        s2 = U2;
        break;
      case "fpgm":
        k2 = Mn(y2, U2), g2 = new se.Parser(k2.data, k2.offset), m2.tables.fpgm = g2.parseByteList(U2.length);
        break;
      case "head":
        k2 = Mn(y2, U2), m2.tables.head = tt.parse(k2.data, k2.offset), m2.unitsPerEm = m2.tables.head.unitsPerEm, r2 = m2.tables.head.indexToLocFormat;
        break;
      case "hhea":
        k2 = Mn(y2, U2), m2.tables.hhea = rt.parse(k2.data, k2.offset), m2.ascender = m2.tables.hhea.ascender, m2.descender = m2.tables.hhea.descender, m2.numberOfHMetrics = m2.tables.hhea.numberOfHMetrics;
        break;
      case "hmtx":
        c2 = U2;
        break;
      case "ltag":
        k2 = Mn(y2, U2), n2 = at.parse(k2.data, k2.offset);
        break;
      case "COLR":
        k2 = Mn(y2, U2), m2.tables.colr = gt.parse(k2.data, k2.offset);
        break;
      case "CPAL":
        k2 = Mn(y2, U2), m2.tables.cpal = mt.parse(k2.data, k2.offset);
        break;
      case "maxp":
        k2 = Mn(y2, U2), m2.tables.maxp = ot.parse(k2.data, k2.offset), m2.numGlyphs = m2.tables.maxp.numGlyphs;
        break;
      case "name":
        d2 = U2;
        break;
      case "OS/2":
        k2 = Mn(y2, U2), m2.tables.os2 = it.parse(k2.data, k2.offset);
        break;
      case "post":
        k2 = Mn(y2, U2), m2.tables.post = ut.parse(k2.data, k2.offset), m2.glyphNames = new Ce(m2.tables.post);
        break;
      case "prep":
        k2 = Mn(y2, U2), g2 = new se.Parser(k2.data, k2.offset), m2.tables.prep = g2.parseByteList(U2.length);
        break;
      case "glyf":
        i2 = U2;
        break;
      case "loca":
        f2 = U2;
        break;
      case "CFF ":
        o2 = U2;
        break;
      case "kern":
        h2 = U2;
        break;
      case "GDEF":
        u2 = U2;
        break;
      case "GPOS":
        l2 = U2;
        break;
      case "GSUB":
        p2 = U2;
        break;
      case "meta":
        v2 = U2;
    }
  }
  var O2 = Mn(y2, d2);
  if (m2.tables.name = be.parse(O2.data, O2.offset, n2), m2.names = m2.tables.name, i2 && f2) {
    var R2 = 0 === r2, E2 = Mn(y2, f2), L2 = wn.parse(E2.data, E2.offset, m2.numGlyphs, R2), C2 = Mn(y2, i2);
    m2.glyphs = _t.parse(C2.data, C2.offset, L2, m2, t2);
  } else {
    if (!o2) throw new Error("Font doesn't contain TrueType or CFF outlines.");
    var w2 = Mn(y2, o2);
    et.parse(w2.data, w2.offset, m2, t2);
  }
  var D2 = Mn(y2, c2);
  if (nt.parse(m2, D2.data, D2.offset, m2.numberOfHMetrics, m2.numGlyphs, m2.glyphs, t2), we(m2, t2), h2) {
    var I2 = Mn(y2, h2);
    m2.kerningPairs = Cn.parse(I2.data, I2.offset);
  } else m2.kerningPairs = {};
  if (u2) {
    var G2 = Mn(y2, u2);
    m2.tables.gdef = Ln.parse(G2.data, G2.offset);
  }
  if (l2) {
    var M2 = Mn(y2, l2);
    m2.tables.gpos = dt.parse(M2.data, M2.offset), m2.position.init();
  }
  if (p2) {
    var B2 = Mn(y2, p2);
    m2.tables.gsub = ht.parse(B2.data, B2.offset);
  }
  if (s2) {
    var F2 = Mn(y2, s2);
    m2.tables.fvar = Tn.parse(F2.data, F2.offset, m2.names);
  }
  if (v2) {
    var P2 = Mn(y2, v2);
    m2.tables.meta = vt.parse(P2.data, P2.offset), m2.metas = m2.tables.meta;
  }
  return m2;
}
function Fn(e2, t2, r2) {
  r2 = null == r2 ? {} : r2;
  var n2 = "undefined" == typeof window && !r2.isUrl ? Dn : In;
  return new Promise(function(a2, o2) {
    n2(e2, function(e3, n3) {
      if (e3) {
        if (t2) return t2(e3);
        o2(e3);
      }
      var s2;
      try {
        s2 = Bn(n3, r2);
      } catch (e4) {
        if (t2) return t2(e4, null);
        o2(e4);
      }
      if (t2) return t2(null, s2);
      a2(s2);
    });
  });
}
function Pn(e2, t2) {
  return Bn(Gt(__require("fs").readFileSync(e2)), t2);
}
var An = Object.freeze({ __proto__: null, Font: gn, Glyph: Ie, Path: E, BoundingBox: R, _parse: se, parse: Bn, load: Fn, loadSync: Pn });

// node_modules/scribe.js-ocr/js/utils/imageUtils.js
function imageStrToBlob(imgStr) {
  const imgData = new Uint8Array(atob(imgStr.split(",")[1]).split("").map((c2) => c2.charCodeAt(0)));
  const imgBlob = new Blob([imgData], { type: "application/octet-stream" });
  return imgBlob;
}
function base64ToBytes(base64) {
  const commaIndex = base64.slice(0, 100).indexOf(",");
  if (commaIndex > 0) {
    base64 = base64.slice(commaIndex + 1);
  }
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    bytes[i2] = binaryString.charCodeAt(i2);
  }
  return bytes;
}
function getPngDimensions(base64) {
  const bytes = base64ToBytes(base64.slice(0, 150).split(",")[1].slice(0, 96));
  const width = bytes[16] << 24 | bytes[17] << 16 | bytes[18] << 8 | bytes[19];
  const height = bytes[20] << 24 | bytes[21] << 16 | bytes[22] << 8 | bytes[23];
  return { width, height };
}
function getJpegDimensions(base64) {
  const bytes = base64ToBytes(base64.split(",")[1]);
  let i2 = 0;
  if (bytes[i2] === 255 && bytes[i2 + 1] === 216) {
    i2 += 2;
  }
  while (i2 < bytes.length) {
    if (bytes[i2] === 255) {
      if ([192, 193, 194, 195, 197, 198, 199, 201, 202, 203, 205, 206, 207].includes(bytes[i2 + 1])) {
        const height = bytes[i2 + 5] << 8 | bytes[i2 + 6];
        const width = bytes[i2 + 7] << 8 | bytes[i2 + 8];
        return { width, height };
      }
      const segmentLength = bytes[i2 + 2] << 8 | bytes[i2 + 3];
      i2 += segmentLength + 2;
      continue;
    }
    i2++;
  }
  throw new Error("Could not find dimensions in the JPEG image.");
}

// node_modules/scribe.js-ocr/js/canvasAdapter.js
var ca = class _ca {
  /** @type {import('canvaskit-wasm').CanvasKit} */
  static CanvasKit;
  static getCanvasKit = async () => {
    if (typeof process === "undefined") {
      throw new Error("getCanvasKit is only available in Node.js");
    } else {
      if (!_ca.CanvasKit) {
        const canvasKitImport = await Promise.resolve().then(() => __toESM(require_canvaskit(), 1));
        const CanvasKitInit = canvasKitImport.default;
        _ca.CanvasKit = await CanvasKitInit();
      }
      return _ca.CanvasKit;
    }
  };
  /**
   *
   * @param {number} width
   * @param {number} height
   */
  static createCanvas = async (width, height) => {
    if (typeof process === "undefined") {
      return new OffscreenCanvas(width, height);
    }
    if (!width || !height || width <= 0 || height <= 0) {
      throw new Error(`Invalid canvas size: ${width}x${height}`);
    }
    const canvasKit = await _ca.getCanvasKit();
    return canvasKit.MakeCanvas(width, height);
  };
  /**
   * Handles various image formats, always returns a ImageBitmap.
   *
   * @param {string|ImageBitmap|Promise<string>|Promise<ImageBitmap>} img
   * @returns {Promise<ImageBitmap>}
   */
  static getImageBitmap = async (img) => {
    img = await img;
    if (img === void 0) throw new Error("Input is undefined");
    if (img === null) throw new Error("Input is null");
    if (typeof img === "string") {
      if (typeof process === "undefined") {
        const imgBlob = imageStrToBlob(img);
        const imgBit2 = await createImageBitmap(imgBlob);
        return imgBit2;
      }
      const imgData = new Uint8Array(atob(img.split(",")[1]).split("").map((c2) => c2.charCodeAt(0)));
      const canvasKit = await _ca.getCanvasKit();
      const imgBit = await canvasKit.MakeImageFromEncoded(imgData);
      return imgBit;
    }
    if (!(typeof process === "undefined") && typeof img !== "string" && typeof img !== "number") return img;
    return img;
  };
  static dummyCanvasPromise = _ca.createCanvas(1, 1);
  /**
   *
   * @param {FontContainerFont} fontObj
   */
  static registerFontObj = async (fontObj) => {
    if (typeof process === "undefined") {
      throw new Error("registerFontObj is only available in Node.js");
    } else {
      const dummyCanvas = await _ca.dummyCanvasPromise;
      const fs = await import("node:fs");
      const fontBuffer = typeof fontObj.src === "string" ? fs.readFileSync(fontObj.src) : fontObj.src;
      dummyCanvas.loadFont(fontBuffer, {
        family: fontObj.fontFaceName,
        style: fontObj.fontFaceStyle,
        weight: fontObj.fontFaceWeight
      });
    }
  };
};

// node_modules/scribe.js-ocr/js/containers/fontContainer.js
if (typeof process === "object") {
  globalThis.self = globalThis;
  const { createRequire } = await import("node:module");
  globalThis.require = createRequire(import.meta.url);
  const { fileURLToPath } = await import("node:url");
  const { dirname } = await import("node:path");
  globalThis.__dirname = dirname(fileURLToPath(import.meta.url));
}
async function loadOpentype(src, kerningPairs = null) {
  const font = typeof src === "string" ? await An.load(src) : await An.parse(src, { lowMemory: false });
  font.tables.gsub = null;
  if (kerningPairs) font.kerningPairs = kerningPairs;
  return font;
}
var fontFaceObj = {};
function loadFontFace(fontFamily, fontStyle, fontWeight, src) {
  const src1 = typeof src === "string" ? `url(${src})` : src;
  const fontFace = new FontFace(fontFamily, src1, { style: fontStyle, weight: fontWeight });
  if (fontFace.status === "error") throw new Error(`FontFace failed to load: ${fontFamily} ${fontStyle} ${fontWeight}`);
  const fontSet = globalThis.document ? globalThis.document.fonts : globalThis.fonts;
  if (typeof fontFaceObj[fontFamily] === "undefined") {
    fontFaceObj[fontFamily] = {};
  }
  if (typeof fontFaceObj[fontFamily][fontStyle] === "undefined") {
    fontFaceObj[fontFamily][fontStyle] = {};
  }
  if (typeof fontFaceObj[fontFamily][fontStyle][fontWeight] !== "undefined") {
    fontSet.delete(fontFaceObj[fontFamily][fontStyle][fontWeight]);
  }
  fontFaceObj[fontFamily][fontStyle][fontWeight] = fontFace;
  fontFace.load();
  fontSet.add(fontFace);
  return fontFace;
}
function FontContainerFont(family, styleLookup, src, opt2, opentypeObj) {
  let fontFaceName = family;
  if (opt2) fontFaceName += " Opt";
  this.family = family;
  this.style = styleLookup;
  this.opt = opt2;
  this.src = src;
  this.opentype = opentypeObj;
  this.fontFaceName = fontFaceName;
  this.fontFaceStyle = ["italic", "boldItalic"].includes(this.style) ? "italic" : "normal";
  this.fontFaceWeight = ["bold", "boldItalic"].includes(this.style) ? "bold" : "normal";
  this.type = determineSansSerif(this.family) === "SansDefault" ? "sans" : "serif";
  this.smallCapsMult = 0.75;
  this.disable = false;
  if (typeof FontFace !== "undefined") {
    loadFontFace(this.fontFaceName, this.fontFaceStyle, this.fontFaceWeight, this.src);
  } else {
    ca.registerFontObj(this);
  }
}
async function loadFontContainerFamily(family, src, opt2 = false) {
  const res = {
    normal: null,
    italic: null,
    bold: null,
    boldItalic: null
  };
  const loadType = (styleLookup) => new Promise((resolve) => {
    const srcType = src[styleLookup];
    if (!srcType) {
      resolve(false);
      return;
    }
    loadOpentype(srcType).then((font) => {
      res[styleLookup] = new FontContainerFont(family, styleLookup, srcType, opt2, font);
      resolve(true);
    });
  });
  Promise.allSettled([loadType("normal"), loadType("italic"), loadType("bold"), loadType("boldItalic")]);
  return res;
}
async function loadFontsFromSource(srcObj, opt2 = false) {
  const fontObjPromise = {};
  for (const [family, src] of Object.entries(srcObj)) {
    fontObjPromise[family] = loadFontContainerFamily(family, src, opt2);
  }
  const fontObj = {};
  for (const [key, value] of Object.entries(fontObjPromise)) {
    fontObj[key] = await value;
  }
  return fontObj;
}
var FontCont = class _FontCont {
  /** @type {?FontContainer} */
  static raw = null;
  /** @type {?FontContainer} */
  static opt = null;
  /** @type {?Object<string, FontContainerFamilyUpload>} */
  static doc = null;
  /** @type {?FontContainer} */
  static export = null;
  static supp = {
    /** @type {?FontContainerFont} */
    chi_sim: null
  };
  /**
   * This object contains all data that is saved and restored from intermediate .scribe files.
   * Anything outside of this object is not saved or restored.
   * @type {FontState}
   */
  static state = {
    /** Optimized fonts will be used when believed to improve quality. */
    enableOpt: false,
    /** Optimized fonts will always be used when they exist, even if believed to reduce quality. */
    forceOpt: false,
    /**
     * If `false`, 'Courier' will not be cleaned to Nimbus Mono.
     * This setting is useful because Tesseract sometimes misidentifies fonts as Courier, and when not the document default, Nimbus Mono is almost always incorrect.
     * Even with this setting `false`, Nimbus Mono will still be used when the font is exactly 'NimbusMono' and Nimbus Mono can still be the document default font.
     */
    enableCleanToNimbusMono: false,
    defaultFontName: "SerifDefault",
    serifDefaultName: "NimbusRoman",
    sansDefaultName: "NimbusSans",
    glyphSet: null,
    /** @type {Object.<string, CharMetricsFamily>} */
    charMetrics: {}
  };
  /** @type {?Awaited<ReturnType<import('../fontEval.js').evaluateFonts>>} */
  static rawMetrics = null;
  /** @type {?Awaited<ReturnType<import('../fontEval.js').evaluateFonts>>} */
  static optMetrics = null;
  /**
   * Load fonts from an ArrayBuffer containing arbitrary font data.
   * Supports .ttf, .otf, and .woff formats.
   * This function should only be used for fonts we do not provide, such as user-uploaded fonts.
   * @param {ArrayBuffer} src
   */
  static addFontFromFile = async (src) => {
    let fontObj;
    let fontData;
    try {
      fontObj = await loadOpentype(src);
      fontData = fontObj.toArrayBuffer();
    } catch (error) {
      console.error("Error loading font.");
      console.error(error);
      return;
    }
    const fontNameEmbedded = fontObj.names.postScriptName.en;
    let styleLookup = (
      /** @type {StyleLookup} */
      "normal"
    );
    if (fontNameEmbedded.match(/boldit|bdit/i)) {
      styleLookup = "boldItalic";
    } else if (fontNameEmbedded.match(/italic/i)) {
      styleLookup = "italic";
    } else if (fontNameEmbedded.match(/bold/i)) {
      styleLookup = "bold";
    }
    const fontName = fontNameEmbedded.replace(/[^+]+\+/g, "").replace(/\s/g, "_");
    if (!_FontCont.doc?.[fontName]?.[styleLookup]) {
      try {
        const fontContainer = new FontContainerFont(fontName, styleLookup, fontData, false, fontObj);
        if (!_FontCont.doc) {
          _FontCont.doc = {};
        }
        if (!_FontCont.doc[fontName]) {
          _FontCont.doc[fontName] = {};
        }
        _FontCont.doc[fontName][styleLookup] = fontContainer;
      } catch (error) {
        console.error(`Error loading font ${fontName} ${styleLookup}.`);
      }
    } else {
      console.warn(`Font ${fontName} ${styleLookup} already exists.`);
    }
  };
  /**
   * Decide whether to use the optimized version of a font family.
   * Note that even when this function returns `true`, optimized versions of every style will not exist.
   * @param {string} family - Font family name.
   */
  static useOptFamily = (family) => {
    const raw = _FontCont.raw?.[family]?.normal;
    if (!raw) return false;
    const opt2 = _FontCont.opt?.[family]?.normal;
    if (opt2 && _FontCont.state.forceOpt) {
      return true;
    }
    if (opt2 && _FontCont.state.enableOpt) {
      const defaultFamily = raw.type === "serif" ? _FontCont.state.serifDefaultName : _FontCont.state.sansDefaultName;
      const rawMetricDefault = _FontCont.rawMetrics?.[defaultFamily];
      const optMetricDefault = _FontCont.optMetrics?.[defaultFamily];
      const rawMetric = _FontCont.rawMetrics?.[family];
      const optMetric = _FontCont.optMetrics?.[family];
      if (rawMetric && optMetric && optMetric < rawMetric && optMetricDefault < rawMetricDefault) {
        return true;
      }
    }
    return false;
  };
  /**
   * Gets a font object.  Unlike accessing the font containers directly,
   * this method allows for special values 'Default', 'SansDefault', and 'SerifDefault' to be used.
   *
   * @param {Partial<Style>} style
   * @param {string} [lang='eng']
   * @returns {FontContainerFont}
   */
  static getFont = (style, lang = "eng") => {
    let family = style.font || _FontCont.state.defaultFontName;
    const styleLookup = getStyleLookup(style);
    if (_FontCont.doc?.[family]?.[styleLookup] && !_FontCont.doc?.[family]?.[styleLookup]?.disable) {
      return _FontCont.doc[family][styleLookup];
    }
    if (lang === "chi_sim") {
      if (!_FontCont.supp.chi_sim) throw new Error("chi_sim font does not exist.");
      return _FontCont.supp.chi_sim;
    }
    if (!_FontCont.raw) throw new Error("Raw fonts not yet initialized.");
    if (!_FontCont.raw?.[family]?.[styleLookup]) {
      if (/NimbusRom/i.test(family)) {
        family = "NimbusRoman";
      } else if (/Times/i.test(family)) {
        family = "NimbusRoman";
      } else if (/NimbusSan/i.test(family)) {
        family = "NimbusSans";
      } else if (/Helvetica/i.test(family)) {
        family = "NimbusSans";
      } else if (/Arial/i.test(family)) {
        family = "NimbusSans";
      } else if (/CenturySch/i.test(family)) {
        family = "Century";
      } else if (/Palatino/i.test(family)) {
        family = "Palatino";
      } else if (/Garamond/i.test(family)) {
        family = "Garamond";
      } else if (/CenturyGothic/i.test(family)) {
        family = "Gothic";
      } else if (/AvantGarde/i.test(family)) {
        family = "Gothic";
      } else if (/Carlito/i.test(family)) {
        family = "Carlito";
      } else if (/Calibri/i.test(family)) {
        family = "Carlito";
      } else if (/Courier/i.test(family) && _FontCont.state.enableCleanToNimbusMono) {
        family = "NimbusMono";
      } else if (/NimbusMono/i.test(family) && _FontCont.state.enableCleanToNimbusMono) {
        family = "NimbusMono";
      }
    }
    if (!_FontCont.raw?.[family]?.[styleLookup]) {
      family = determineSansSerif(family);
    }
    if (family === "Default") family = _FontCont.state.defaultFontName;
    if (family === "SerifDefault") family = _FontCont.state.serifDefaultName;
    if (family === "SansDefault") family = _FontCont.state.sansDefaultName;
    let fontRes = _FontCont.raw?.[family]?.[styleLookup];
    if (!fontRes) throw new Error(`Font container does not contain ${family} (${styleLookup}).`);
    const opt2 = _FontCont.opt?.[family]?.[styleLookup];
    const useOpt = _FontCont.useOptFamily(family);
    if (opt2 && useOpt) fontRes = opt2;
    return fontRes;
  };
  /**
   *
   * @param {OcrWord} word
   */
  static getWordFont = (word) => _FontCont.getFont(word.style, word.lang);
  /**
   * Reset font container to original state but do not unload default resources.
   */
  static clear = () => {
    _FontCont.opt = null;
    _FontCont.rawMetrics = null;
    _FontCont.optMetrics = null;
    _FontCont.state.enableCleanToNimbusMono = false;
    _FontCont.state.defaultFontName = "SerifDefault";
    _FontCont.state.serifDefaultName = "NimbusRoman";
    _FontCont.state.sansDefaultName = "NimbusSans";
    clearObjectProperties(_FontCont.state.charMetrics);
  };
  static terminate = () => {
    _FontCont.clear();
    _FontCont.raw = null;
    _FontCont.state.glyphSet = null;
  };
};

// node_modules/scribe.js-ocr/js/utils/fontUtils.js
function getFontSize(fontOpentype2, heightActual, text) {
  const textArr = text.split("");
  const charMetricsFirst = fontOpentype2.charToGlyph(textArr[0]).getMetrics();
  let yMin = charMetricsFirst.yMin;
  let yMax = charMetricsFirst.yMax;
  for (let i2 = 1; i2 < textArr.length; i2++) {
    const charMetrics = fontOpentype2.charToGlyph(textArr[i2]).getMetrics();
    if (charMetrics.yMin < yMin) yMin = charMetrics.yMin;
    if (charMetrics.yMax > yMax) yMax = charMetrics.yMax;
  }
  const textHeight = (yMax - yMin) * (1 / fontOpentype2.unitsPerEm);
  return Math.round(heightActual / textHeight);
}
function calcWordFontSizePrecise(wordArr, fontOpentype2, nonLatin = false) {
  if (wordArr[0].chars && wordArr[0].chars.length > 0) {
    const charArr = wordArr.map((x2) => x2.chars).flat();
    const charArrFiltered = nonLatin ? charArr.filter((x2) => x2 && x2.bbox.bottom - x2.bbox.top > 5) : charArr.filter((x2) => x2 && /[A-Za-z0-9]/.test(x2.text));
    const fontSizeCharArr = charArrFiltered.map((x2) => getFontSize(fontOpentype2, x2.bbox.bottom - x2.bbox.top, x2.text));
    const fontSizeCharMedian = quantile(fontSizeCharArr, 0.5);
    return fontSizeCharMedian;
  }
  const wordArrFiltered = nonLatin ? wordArr.filter((x2) => x2 && x2.bbox.bottom - x2.bbox.top > 5) : wordArr.filter((x2) => x2 && /[A-Za-z0-9]/.test(x2.text));
  const fontSizeWordArr = wordArrFiltered.map((x2) => getFontSize(fontOpentype2, x2.bbox.bottom - x2.bbox.top, x2.text));
  const fontSizeWordMedian = quantile(fontSizeWordArr, 0.5);
  return fontSizeWordMedian;
}
function addLigatures(word) {
  if (word.style.smallCaps || !opt.ligatures) return word.text.split("");
  const fontI = FontCont.getWordFont(word);
  const fontOpentype2 = fontI.opentype;
  return addLigaturesText(word.text, fontOpentype2);
}
function addLigaturesText(wordText, fontOpentype2) {
  const wordTextArr = typeof wordText === "string" ? wordText.split("") : wordText;
  const wordCharArrOut = [];
  for (let i2 = 0; i2 < wordTextArr.length; i2++) {
    const charI = wordTextArr[i2];
    const charJ = wordTextArr[i2 + 1];
    if (charI === "f" && charJ) {
      let charLig;
      if (charJ === "f") {
        charLig = String.fromCharCode(64256);
      } else if (charJ === "i") {
        charLig = String.fromCharCode(64257);
      } else if (charJ === "l") {
        charLig = String.fromCharCode(64258);
      }
      if (charLig) {
        const glyphLig = fontOpentype2.charToGlyph(charLig);
        if (glyphLig && glyphLig.index > 0 && glyphLig.name !== ".notdef" && glyphLig.path.commands.length > 0) {
          wordCharArrOut.push(charLig);
          i2++;
          continue;
        }
      }
    }
    wordCharArrOut.push(charI);
  }
  return wordCharArrOut;
}
var missingGlyphs = {};
function calcWordCharMetrics(wordText, fontOpentype2) {
  const wordTextArr = typeof wordText === "string" ? wordText.split("") : wordText;
  const advanceArr = [];
  const kerningArr = [];
  for (let i2 = 0; i2 < wordTextArr.length; i2++) {
    const charI = wordTextArr[i2];
    const charJ = wordTextArr[i2 + 1];
    const glyphI = fontOpentype2.charToGlyph(charI);
    const fontName = fontOpentype2.tables.name.postScriptName.en;
    if (!glyphI || glyphI.name === ".notdef") {
      if (!missingGlyphs[fontName]) missingGlyphs[fontName] = /* @__PURE__ */ new Set();
      missingGlyphs[fontName].add(charI);
      console.log(`Character ${charI} is not defined in font ${fontName}`);
    }
    advanceArr.push(glyphI.advanceWidth);
    if (charJ) {
      if (opt.kerning) {
        const glyphJ = fontOpentype2.charToGlyph(charJ);
        const kerning = fontOpentype2.getKerningValue(glyphI, glyphJ);
        kerningArr.push(kerning);
      } else {
        kerningArr.push(0);
      }
    }
  }
  return { advanceArr, kerningArr };
}
function calcWordMetrics(word, angle = 0) {
  const fontI = FontCont.getWordFont(word);
  const fontOpentype2 = fontI.opentype;
  const fontSize = calcWordFontSize(word);
  const charArr = addLigatures(word);
  const charArr2 = word.style.smallCaps ? charArr.map((x2) => x2.toUpperCase()) : charArr;
  const { advanceArr, kerningArr } = calcWordCharMetrics(charArr2, fontOpentype2);
  if (word.style.smallCaps) {
    for (let i2 = 0; i2 < charArr2.length; i2++) {
      if (charArr2[i2] !== charArr[i2]) {
        advanceArr[i2] *= fontI.smallCapsMult;
        if (kerningArr[i2]) kerningArr[i2] *= fontI.smallCapsMult;
      }
    }
  }
  const advanceTotal = advanceArr.reduce((a2, b2) => a2 + b2, 0);
  const kerningTotal = kerningArr.reduce((a2, b2) => a2 + b2, 0);
  const wordWidth1 = advanceTotal + kerningTotal;
  const wordLastGlyphMetrics = fontOpentype2.charToGlyph(charArr2.at(-1)).getMetrics();
  const wordFirstGlyphMetrics = fontOpentype2.charToGlyph(charArr2[0]).getMetrics();
  let wordLeftBearing = wordFirstGlyphMetrics.xMin || 0;
  let lastGlyphMax = wordLastGlyphMetrics.xMax || 0;
  if (word.style.smallCaps && charArr2[charArr2.length - 1] !== charArr[charArr2.length - 1]) lastGlyphMax *= fontI.smallCapsMult;
  let wordRightBearing = advanceArr[advanceArr.length - 1] - lastGlyphMax;
  if (word.style.smallCaps && charArr2[0] !== charArr[0]) wordLeftBearing *= fontI.smallCapsMult;
  if (word.style.smallCaps && charArr2[charArr2.length - 1] !== charArr[charArr2.length - 1]) wordRightBearing *= fontI.smallCapsMult;
  const wordWidth = word.visualCoords ? wordWidth1 - wordRightBearing - wordLeftBearing : wordWidth1;
  const wordWidthPx = wordWidth * (fontSize / fontOpentype2.unitsPerEm);
  const wordLeftBearingPx = wordLeftBearing * (fontSize / fontOpentype2.unitsPerEm);
  const wordRightBearingPx = wordRightBearing * (fontSize / fontOpentype2.unitsPerEm);
  const advanceArrPx = advanceArr.map((x2) => x2 * (fontSize / fontOpentype2.unitsPerEm));
  const kerningArrPx = kerningArr.map((x2) => x2 * (fontSize / fontOpentype2.unitsPerEm));
  let charSpacing = 0;
  if (charArr2.length > 1) {
    const cosAngle = Math.cos(angle * (Math.PI / 180));
    const actualWidth = (word.bbox.right - word.bbox.left) / cosAngle;
    charSpacing = Math.round((actualWidth - wordWidthPx) / (charArr2.length - 1) * 1e6) / 1e6;
  }
  return {
    visualWidth: wordWidthPx,
    leftSideBearing: wordLeftBearingPx,
    rightSideBearing: wordRightBearingPx,
    advanceArr: advanceArrPx,
    kerningArr: kerningArrPx,
    charSpacing,
    font: fontI,
    fontSize,
    charArr
  };
}
var calcWordFontSize = (word) => {
  const font = FontCont.getWordFont(word);
  const fontOpentype2 = font.opentype;
  if (word.style.sup || word.style.dropcap) {
    if (word.visualCoords) {
      return getFontSize(fontOpentype2, word.bbox.bottom - word.bbox.top, word.text);
    }
    if (word.style.size) {
      const mult = FontProps.sizeMult[font.family] || 1;
      return word.style.size / mult;
    }
    return (word.bbox.bottom - word.bbox.top) * (fontOpentype2.unitsPerEm / (fontOpentype2.ascender - fontOpentype2.descender));
  }
  if (word.style.size) {
    const mult = FontProps.sizeMult[font.family] || 1;
    return word.style.size / mult;
  }
  const lineFontSize = calcLineFontSize(word.line);
  if (lineFontSize) return lineFontSize;
  return 12;
};
var calcLineFontSize = (line) => {
  if (line._size) return line._size;
  const nonLatin = line.words[0]?.lang === "chi_sim";
  const font = FontCont.getWordFont(line.words[0]);
  if (!font) {
    const linePrev = getPrevLine(line);
    if (linePrev) {
      line._sizeCalc = calcLineFontSize(linePrev);
    } else {
      line._sizeCalc = 15;
    }
    return line._sizeCalc;
  }
  const fontOpentype2 = font.opentype;
  if (line.words.length <= 3 && line.words[0].chars && line.words[0].chars.length > 0 || nonLatin) {
    const fontSizeCalc = calcWordFontSizePrecise(line.words, fontOpentype2, nonLatin);
    if (fontSizeCalc && fontSizeCalc > 0) {
      line._sizeCalc = fontSizeCalc;
      return line._sizeCalc;
    }
  }
  if (line.ascHeight && line.xHeight) {
    const size1 = getFontSize(fontOpentype2, line.ascHeight, "A");
    const size2 = getFontSize(fontOpentype2, line.xHeight, "o");
    let sizeFinal = Math.floor((size1 + size2) / 2);
    if (Math.max(size1, size2) / Math.min(size1, size2) > 1.2) {
      const linePrev = getPrevLine(line);
      if (linePrev) {
        const sizeLast = calcLineFontSize(linePrev);
        if (sizeLast && (Math.max(size1, sizeLast) / Math.min(size1, sizeLast) <= 1.2 || Math.max(sizeLast, size2) / Math.min(sizeLast, size2) <= 1.2)) {
          if (Math.abs(sizeLast - size2) < Math.abs(sizeLast - size1)) {
            sizeFinal = Math.floor((sizeLast + size2) / 2);
          } else {
            sizeFinal = Math.floor((sizeLast + size1) / 2);
          }
        }
      }
    }
    line._sizeCalc = sizeFinal;
  } else if (!line.ascHeight && line.xHeight) {
    line._sizeCalc = getFontSize(fontOpentype2, line.xHeight, "o");
  } else if (line.ascHeight && !line.xHeight) {
    line._sizeCalc = getFontSize(fontOpentype2, line.ascHeight, "A");
  } else {
    const linePrev = getPrevLine(line);
    if (linePrev) {
      line._sizeCalc = calcLineFontSize(linePrev);
    } else {
      line._sizeCalc = 15;
    }
  }
  return line._sizeCalc;
};

// node_modules/scribe.js-ocr/js/utils/ocrUtils.js
var splitLineAgressively = (line) => {
  const linesOut = [];
  const lineHeight = line.bbox.bottom - line.bbox.top;
  let wordPrev = line.words[0];
  let lineCurrent = ocrObjects_default.cloneLine(line);
  lineCurrent.words = [line.words[0]];
  for (let i2 = 1; i2 < line.words.length; i2++) {
    const word = ocrObjects_default.cloneWord(line.words[i2]);
    if (word.bbox.left - wordPrev.bbox.right > lineHeight) {
      linesOut.push(lineCurrent);
      lineCurrent = ocrObjects_default.cloneLine(line);
      word.line = lineCurrent;
      lineCurrent.words = [word];
    } else {
      word.line = lineCurrent;
      lineCurrent.words.push(word);
    }
    wordPrev = word;
  }
  linesOut.push(lineCurrent);
  linesOut.forEach((x2) => {
    ocrObjects_default.updateLineBbox(x2);
  });
  return linesOut;
};

// node_modules/scribe.js-ocr/js/utils/detectTables.js
function calcColumnBounds(boundingBoxes) {
  const tolerance = 5;
  const columnBounds = [];
  boundingBoxes.sort((a2, b2) => a2.left - b2.left);
  boundingBoxes.forEach((box) => {
    let addedToColumn = false;
    for (const column of columnBounds) {
      if (box.left <= column.right + tolerance && box.right >= column.left - tolerance) {
        column.left = Math.min(column.left, box.left);
        column.right = Math.max(column.right, box.right);
        addedToColumn = true;
        break;
      }
    }
    if (!addedToColumn) {
      columnBounds.push({
        left: box.left,
        right: box.right
      });
    }
  });
  for (let i2 = 0; i2 < columnBounds.length - 1; i2++) {
    const boundRight = (columnBounds[i2].right + columnBounds[i2 + 1].left) / 2;
    columnBounds[i2].right = boundRight;
    columnBounds[i2 + 1].left = boundRight;
  }
  return columnBounds;
}
function detectTablesInPage(ocrPage) {
  const lines = ocrObjects_default.clonePage(ocrPage).lines;
  lines.sort((a2, b2) => a2.bbox.top - b2.bbox.top);
  const rows = [];
  const rowThreshold = 10;
  lines.forEach((item) => {
    let addedToRow = false;
    for (const row of rows) {
      if (Math.abs(item.bbox.top - row.avgTop) <= rowThreshold) {
        row.items.push(item);
        row.avgTop = row.items.reduce((sum, itm) => sum + itm.bbox.top, 0) / row.items.length;
        addedToRow = true;
        break;
      }
    }
    if (!addedToRow) {
      rows.push({ avgTop: item.bbox.top, items: [item] });
    }
  });
  rows.forEach((row) => {
    row.items.sort((a2, b2) => a2.bbox.left - b2.bbox.left);
  });
  const containsNumbers = (row) => {
    let wordsNumN = 0;
    row.items.forEach((line) => {
      line.words.forEach((word) => {
        if (/[0-9]/.test(word.text)) wordsNumN++;
      });
    });
    if (wordsNumN < 4) return false;
    return true;
  };
  const splitRowLinesAgressively = (row) => {
    const row2 = { avgTop: row.avgTop, items: (
      /** @type {Array<OcrLine>} */
      []
    ) };
    row.items.forEach((line) => {
      row2.items.push(...splitLineAgressively(line));
    });
    return row2;
  };
  const hasWordOverlap = (linesA, linesB) => {
    for (let i2 = 0; i2 < linesA.length; i2++) {
      const lineI = linesA[i2];
      const lineJOverlapArr = [];
      for (let j2 = 0; j2 < linesB.length; j2++) {
        const lineJ = linesB[j2];
        if (lineI.bbox.right < lineJ.bbox.left) break;
        if (calcHorizontalOverlap(lineI.bbox, lineJ.bbox) > 0) {
          lineJOverlapArr.push(lineJ);
        }
      }
      if (lineJOverlapArr.length > 1) {
        const wordsI = lineI.words;
        const wordsJ = lineJOverlapArr.map((line) => line.words).flat();
        for (const wordI of wordsI) {
          let overlapCount = 0;
          for (const wordJ of wordsJ) {
            if (calcHorizontalOverlap(wordI.bbox, wordJ.bbox) > 0) {
              overlapCount++;
              if (overlapCount >= 2) {
                return true;
              }
            }
          }
        }
      }
    }
    return false;
  };
  const isCompat = (tableRows, row) => {
    if (!tableRows || tableRows.length === 0) return false;
    const expectedColumns = mean50(tableRows.map((x2) => x2.items.length));
    const existingLines = tableRows.map((x2) => x2.items).flat();
    if (Math.abs(expectedColumns - row.items.length) <= 1) {
      return true;
    }
    if (globalThis.testControl) return false;
    if (hasWordOverlap(existingLines, row.items) || hasWordOverlap(row.items, existingLines)) {
      return false;
    }
    return true;
  };
  const minRows = 4;
  const tables = [];
  let currentTable = [];
  let currentTableCompat = [];
  let currentTableStartIndex = 0;
  const rowsSplit = rows.map((row) => splitRowLinesAgressively(row));
  for (let i2 = 0; i2 < rowsSplit.length; i2++) {
    const rowSplit = rowsSplit[i2];
    if (containsNumbers(rowsSplit[i2])) {
      if (currentTable.length > 0) {
        if (isCompat(currentTableCompat, rowSplit)) {
          currentTable.push(rowSplit);
          currentTableCompat.push(rowSplit);
        } else if (currentTable.length >= minRows) {
          const headerRows = [];
          if (rowsSplit[currentTableStartIndex - 1] && (tables.length === 0 || !tables[tables.length - 1].includes(rowsSplit[currentTableStartIndex - 1])) && isCompat(currentTableCompat, rowsSplit[currentTableStartIndex - 1])) {
            headerRows.push(rowsSplit[currentTableStartIndex - 1]);
            if (rowsSplit[currentTableStartIndex - 2] && (tables.length === 0 || !tables[tables.length - 1].includes(rowsSplit[currentTableStartIndex - 2])) && isCompat(currentTableCompat, rowsSplit[currentTableStartIndex - 2])) {
              headerRows.push(rowsSplit[currentTableStartIndex - 2]);
            }
          }
          tables.push([...headerRows, ...currentTable]);
          currentTable = [rowSplit];
          currentTableCompat = [rowSplit];
          currentTableStartIndex = i2;
        } else {
          currentTable = [rowSplit];
          currentTableCompat = [rowSplit];
          currentTableStartIndex = i2;
        }
      } else {
        currentTable.push(rowSplit);
        currentTableCompat.push(rowSplit);
        currentTableStartIndex = i2;
      }
    } else if (currentTable.length > 0) {
      const nextRowSplit = rowsSplit[i2 + 1];
      const nextRowSplit2 = rowsSplit[i2 + 2];
      if (nextRowSplit && nextRowSplit2 && containsNumbers(nextRowSplit) && containsNumbers(nextRowSplit2) && isCompat(currentTableCompat, nextRowSplit) && isCompat(currentTableCompat, nextRowSplit2)) {
        currentTable.push(rowSplit);
        continue;
      }
      if (currentTable.length >= minRows) {
        const headerRows = [];
        if (rowsSplit[currentTableStartIndex - 1] && (tables.length === 0 || !tables[tables.length - 1].includes(rowsSplit[currentTableStartIndex - 1])) && isCompat(currentTableCompat, rowsSplit[currentTableStartIndex - 1])) {
          headerRows.push(rowsSplit[currentTableStartIndex - 1]);
          if (rowsSplit[currentTableStartIndex - 2] && (tables.length === 0 || !tables[tables.length - 1].includes(rowsSplit[currentTableStartIndex - 2])) && isCompat(currentTableCompat, rowsSplit[currentTableStartIndex - 2])) {
            headerRows.push(rowsSplit[currentTableStartIndex - 2]);
          }
        }
        tables.push([...headerRows, ...currentTable]);
      }
      currentTable = [];
      currentTableCompat = [];
    }
  }
  if (currentTable.length >= minRows) {
    tables.push(currentTable);
  }
  const tableLineBboxes = tables.map((table) => calcBboxUnion(table.map((row) => calcBboxUnion(row.items.map((item) => item.bbox)))));
  return tableLineBboxes;
}
var makeTableFromBbox = (page, bbox) => {
  const lines = page.lines.filter((line) => calcBoxOverlap(line.bbox, bbox) > 0.5);
  let columnBboxArr;
  if (lines.length > 0) {
    const lineBoxes = lines.map((line) => line.bbox);
    const columnBoundArr = calcColumnBounds(lineBoxes);
    columnBboxArr = columnBoundArr.map((column) => ({
      left: column.left,
      top: bbox.top,
      right: column.right,
      bottom: bbox.bottom
    }));
    columnBboxArr[0].left = bbox.left;
    columnBboxArr[columnBboxArr.length - 1].right = bbox.right;
    for (let i2 = 0; i2 < columnBboxArr.length - 1; i2++) {
      const boundRight = (columnBboxArr[i2].right + columnBboxArr[i2 + 1].left) / 2;
      columnBboxArr[i2].right = boundRight;
      columnBboxArr[i2 + 1].left = boundRight;
    }
  } else {
    columnBboxArr = [{ ...bbox }];
  }
  const dataTable = new LayoutDataTable();
  columnBboxArr.forEach((columnBbox) => {
    const layoutBox = new LayoutDataColumn(columnBbox, dataTable);
    dataTable.boxes.push(layoutBox);
  });
  return dataTable;
};

// node_modules/scribe.js-ocr/js/import/convertPageHocr.js
var debugMode2 = true;
async function convertPageHocr({
  ocrStr,
  n: n2,
  pageDims = null,
  scribeMode = false
}) {
  let currentLang = "eng";
  const angleRisePage = [];
  const lineLeft = [];
  const lineTop = [];
  if (!pageDims) {
    const pageElement = ocrStr.match(/<div class=["']ocr_page["'][^>]+/i);
    if (pageElement != null) {
      const pageDimsMatch = pageElement[0].match(/bbox \d+ \d+ (\d+) (\d+)/i);
      if (pageDimsMatch != null) {
        pageDims = { height: parseInt(pageDimsMatch[2]), width: parseInt(pageDimsMatch[1]) };
      }
    }
  }
  if (!pageDims) throw new Error("Failed to parse page dimensions.");
  const pageObj = new ocrObjects_default.OcrPage(n2, pageDims);
  const charMode = !!/ocrx_cinfo/.test(ocrStr);
  let lineRegex = /<span class=["']ocr_line[\s\S]+?(?:<\/span>\s*){2}/ig;
  if (charMode) {
    lineRegex = /<span class=["']ocr_line[\s\S]+?(?:<\/span>\s*)(?:<\/em>\s*)?(?:<\/span>\s*){2}/ig;
  }
  const wordRegexCharLevel = /<span class=["']ocrx_word[\s\S]+?(?:<\/span>\s*)(?:<\/em>\s*)?(?:<\/span>\s*){1}/ig;
  const wordRegex = /<span class=["']ocrx_word[\s\S]+?(?:<\/span>\s*)/ig;
  const charRegex = /<span class=["']ocrx_cinfo["'] title='([^'"]+)["']>([^<]*)<\/span>/ig;
  ocrStr = ocrStr.replaceAll(/<\/?strong>/ig, "");
  ocrStr = ocrStr.replaceAll(/<\/?em>/ig, "");
  ocrStr = ocrStr.replace(/<html[^>]*>/i, "<html>");
  ocrStr = ocrStr.replace(/(class=')ocr_caption/ig, "$1ocr_line");
  ocrStr = ocrStr.replace(/(class=')ocr_textfloat/ig, "$1ocr_line");
  ocrStr = ocrStr.replace(/(class=')ocr_header/ig, "$1ocr_line");
  const lstmChoiceMode1 = !!/id='timestep1/.test(ocrStr);
  const lstmChoiceMode2 = !!/id='lstm_choices/.test(ocrStr);
  if (lstmChoiceMode1) {
    ocrStr = ocrStr.replace(/<span class='ocr_symbol'[\s\S]+?(?:<\/span>\s*){3}/ig, "");
  }
  if (lstmChoiceMode2) {
    ocrStr = ocrStr.replace(/<span class='ocrx_cinfo' id='lstm_choices[\s\S]+?(?:<\/span>\s*){2}/ig, "");
  }
  function convertLine(match) {
    const titleStrLine = match.match(/title=['"]([^'"]+)/)?.[1];
    if (!titleStrLine) return "";
    const linebox1 = [...titleStrLine.matchAll(/bbox(?:es)?(\s+[\d.-]+)(\s+[\d.-]+)?(\s+[\d.-]+)?(\s+[\d.-]+)?/g)][0].slice(1, 5).map((x2) => parseInt(x2));
    const linebox = {
      left: linebox1[0],
      top: linebox1[1],
      right: linebox1[2],
      bottom: linebox1[3]
    };
    const baselineMatch = [...titleStrLine.matchAll(/baseline(\s+[\d.-]+)(\s+[\d.-]+)/g)][0];
    if (!baselineMatch) return "";
    const baseline = baselineMatch.slice(1, 5).map((x2) => parseFloat(x2));
    if (linebox.right - linebox.left >= 200) {
      angleRisePage.push(baseline[0]);
      lineLeft.push(linebox.left);
      lineTop.push(linebox.top);
    }
    let lineAscHeightFinal = null;
    let lineXHeightFinal = null;
    if (scribeMode) {
      const lineAscHeightFinalStr = titleStrLine.match(/x_asc_height\s+([\d.-]+)/)?.[1];
      const lineXHeightFinalStr = titleStrLine.match(/x_x_height\s+([\d.-]+)/)?.[1];
      if (lineAscHeightFinalStr) lineAscHeightFinal = parseFloat(lineAscHeightFinalStr);
      if (lineXHeightFinalStr) lineXHeightFinal = parseFloat(lineXHeightFinalStr);
    }
    if (!lineAscHeightFinal && !lineXHeightFinal) {
      const lineAllHeightTessStr = parseFloat(titleStrLine.match(/x_size\s+([\d.-]+)/)?.[1] || "15");
      const lineAscHeightTessStr = parseFloat(titleStrLine.match(/x_ascenders\s+([\d.-]+)/)?.[1] || "0");
      const lineDescHeightTessStr = parseFloat(titleStrLine.match(/x_descenders\s+([\d.-]+)/)?.[1] || "0");
      lineAscHeightFinal = lineAllHeightTessStr - lineDescHeightTessStr;
      if (lineAscHeightTessStr > 0) {
        lineXHeightFinal = lineAllHeightTessStr - lineDescHeightTessStr - lineAscHeightTessStr;
      }
    }
    console.assert(lineAscHeightFinal || lineXHeightFinal, "Line height metrics missing.");
    const lineObj = new ocrObjects_default.OcrLine(pageObj, linebox, baseline, lineAscHeightFinal, lineXHeightFinal);
    if (debugMode2) lineObj.raw = match;
    function convertWordCharLevel(match2) {
      let text = "";
      const titleStrWord = match2.match(/title=['"]([^'"]+)/)?.[1];
      const confMatchStr = titleStrWord?.match(/(?:;|\s)x_wconf\s+(\d+)/)?.[1];
      let wordConf = 0;
      if (confMatchStr) {
        wordConf = parseInt(confMatchStr);
      }
      const italic = /<\/em>\s*<\/span>/.test(match2);
      const wordID = match2.match(/id=['"]([^'"]*)['"]/i)?.[1] || `word_${n2 + 1}_${pageObj.lines.length + 1}_${lineObj.words.length + 1}`;
      const wordLangRaw = match2.match(/lang=['"]([^'"]*)['"]/i)?.[1];
      let fontName = match2.match(/^[^>]+?x_font\s*([^'";]+)/)?.[1];
      if (fontName) fontName = fontName.trim();
      const it2 = match2.matchAll(charRegex);
      const letterArr = [...it2];
      const bboxes = letterArr.map((x2) => x2[1].match(/(\d+) (\d+) (\d+) (\d+)/).slice(1, 5).map((y2) => parseInt(y2)));
      let wordLang = wordLangRaw || currentLang;
      if (["chi_sim", "chi_tra"].includes(wordLang)) {
        const charArr = letterArr.map((x2) => x2[2]);
        const { han: hanChars, latin: latinChars } = getTextScript(charArr);
        if (hanChars === 0) {
          if (!["chi_sim", "chi_tra"].includes(currentLang)) {
            wordLang = currentLang;
          } else if (latinChars > 0) {
            wordLang = "eng";
          }
        }
      }
      const charObjArr = [];
      for (let j2 = 0; j2 < letterArr.length; j2++) {
        let contentStrLetter = letterArr[j2][2];
        contentStrLetter = unescapeXml(contentStrLetter);
        const bbox = {
          left: bboxes[j2][0],
          top: bboxes[j2][1],
          right: bboxes[j2][2],
          bottom: bboxes[j2][3]
        };
        if (wordLang === "chi_sim") {
          const wordObj2 = new ocrObjects_default.OcrWord(lineObj, `${wordID}_${j2}`, contentStrLetter, bbox);
          wordObj2.conf = wordConf;
          wordObj2.lang = wordLang;
          lineObj.words.push(wordObj2);
        } else {
          const charObj = new ocrObjects_default.OcrChar(contentStrLetter, bbox);
          charObjArr.push(charObj);
          text += contentStrLetter;
        }
      }
      if (wordLang === "chi_sim") return "";
      text = text ?? "";
      text = text.trim();
      if (text === "") return "";
      const bboxesCore = letterArr.map((x2) => x2[1].match(/(\d+) (\d+) (\d+) (\d+)/)?.slice(1, 5).map((y2) => parseInt(y2)));
      const wordBoxCore = {
        left: Math.min(...bboxesCore.map((x2) => x2[0])),
        top: Math.min(...bboxesCore.map((x2) => x2[1])),
        right: Math.max(...bboxesCore.map((x2) => x2[2])),
        bottom: Math.max(...bboxesCore.map((x2) => x2[3]))
      };
      const wordObj = new ocrObjects_default.OcrWord(lineObj, wordID, text, wordBoxCore);
      wordObj.lang = wordLang;
      wordObj.chars = charObjArr;
      if (debugMode2) wordObj.raw = match2;
      if (italic) wordObj.style.italic = true;
      if (fontName) wordObj.style.font = fontName;
      wordObj.conf = wordConf;
      lineObj.words.push(wordObj);
      return "";
    }
    function convertWord(match2) {
      const wordID = match2.match(/id=['"]([^'"]*)['"]/i)?.[1] || `word_${n2 + 1}_${pageObj.lines.length + 1}_${lineObj.words.length + 1}`;
      const wordSup = /<sup>/i.test(match2);
      const wordDropCap = /<span class=['"]ocr_dropcap['"]>/i.test(match2);
      let wordText;
      if (wordSup) {
        wordText = match2.replace(/\s*<sup>/i, "").replace(/<\/sup>\s*/i, "").match(/>([^>]*)</)?.[1];
      } else if (wordDropCap) {
        wordText = match2.replace(/\s*<span class=['"]ocr_dropcap['"]>/i, "").match(/>([^>]*)</)?.[1];
      } else {
        wordText = match2.match(/>([^>]*)</)?.[1];
      }
      if (!wordText) return "";
      wordText = unescapeXml(wordText);
      const titleStrWord = match2.match(/title=['"]([^'"]+)/)?.[1];
      const wordLang = match2.match(/lang=['"]([^'"]*)['"]/i)?.[1] || currentLang;
      if (!titleStrWord) {
        console.log(`Unable to process word, skipping: ${match2}`);
        return "";
      }
      const wordBox1 = [...titleStrWord.matchAll(/bbox(?:es)?(\s+[\d-.]+)(\s+[\d-.]+)?(\s+[\d-.]+)?(\s+[\d-.]+)?/g)][0].slice(1, 5).map((x2) => parseFloat(x2));
      const wordBox = {
        left: wordBox1[0],
        top: wordBox1[1],
        right: wordBox1[2],
        bottom: wordBox1[3]
      };
      let fontName = match2.match(/^[^>]+?x_font\s*([^'";]+)/)?.[1];
      if (fontName) fontName = fontName.trim();
      const styleStr = match2.match(/style=['"]([^'"]+)/)?.[1];
      const confMatch = titleStrWord.match(/(?:;|\s)x_wconf\s+(\d+)/)?.[1] || "0";
      const wordConf = parseInt(confMatch) || 0;
      const wordObj = new ocrObjects_default.OcrWord(lineObj, wordID, wordText, wordBox);
      wordObj.lang = wordLang;
      if (scribeMode) {
        const wordFontSizeStr = titleStrWord.match(/(?:;|\s)x_fsize\s+(\d+)/)?.[1];
        if (wordFontSizeStr) {
          const wordFontSize = parseInt(wordFontSizeStr);
          if (wordFontSize) wordObj.style.size = wordFontSize;
        }
      }
      if (styleStr) {
        if (/italic/i.test(styleStr)) wordObj.style.italic = true;
        if (/bold/i.test(styleStr)) wordObj.style.bold = true;
        if (/small-caps/i.test(styleStr)) wordObj.style.smallCaps = true;
      }
      if (wordSup) wordObj.style.sup = true;
      if (fontName) wordObj.style.font = fontName;
      wordObj.conf = wordConf;
      lineObj.words.push(wordObj);
      return "";
    }
    if (charMode) {
      match = match.replaceAll(wordRegexCharLevel, convertWordCharLevel);
    } else {
      match = match.replaceAll(wordRegex, convertWord);
    }
    pageObj.lines.push(lineObj);
    return "";
  }
  const convertPar = (match) => {
    const parLang = match.match(/^.+?lang=['"]([^'"]*)['"]/i)?.[1];
    if (parLang) currentLang = parLang;
    match.replaceAll(lineRegex, convertLine);
    return "";
  };
  ocrStr = ocrStr.replaceAll(/<p class=["']ocr_par[\s\S]+?(?:<\/p>\s*)/ig, convertPar);
  ocrStr = ocrStr.replaceAll(lineRegex, convertLine);
  const warn = { char: charMode ? "" : "char_warning" };
  pass2(pageObj, 0);
  const langSet = pass3(pageObj);
  const autoDetectTables = false;
  const dataTablePage = new LayoutDataTablePage(n2);
  if (autoDetectTables) {
    const tableBboxes = detectTablesInPage(pageObj);
    tableBboxes.forEach((bbox) => {
      const dataTable = makeTableFromBbox(pageObj, bbox);
      dataTable.page = dataTablePage;
      dataTablePage.tables.push(dataTable);
    });
  }
  return {
    pageObj,
    dataTables: dataTablePage,
    warn,
    langSet
  };
}

// node_modules/scribe.js-ocr/js/import/convertPageStext.js
async function convertPageStext({ ocrStr, n: n2 }) {
  const pageDimsMatch = ocrStr.match(/<page .+?width=['"]([\d.-]+)['"] height=['"]([\d.-]+)['"]/);
  if (!pageDimsMatch || !pageDimsMatch[1] || !pageDimsMatch[2]) throw new Error("Page dimensions not found in stext.");
  const pageDims = { height: parseInt(pageDimsMatch[2]), width: parseInt(pageDimsMatch[1]) };
  const pageObj = new ocrObjects_default.OcrPage(n2, pageDims);
  const angleRisePage = [];
  const langSet = /* @__PURE__ */ new Set();
  const fontSet = /* @__PURE__ */ new Set();
  function convertParStext(xmlPar) {
    const parLineArr = [];
    function convertLineStext(xmlLine) {
      xmlLine = xmlLine.replace(/<block[^>]*?>/i, "");
      const xmlLinePreChar = xmlLine.match(/^[\s\S]*?(?=<char)/)?.[0];
      if (!xmlLinePreChar) return;
      const dir = xmlLinePreChar.match(/dir=['"](\s*[\d.-]+)(\s*[\d.-]+)/)?.slice(1, 3).map((x2) => parseFloat(x2));
      let orientation = 0;
      if (dir && Math.abs(dir[0]) < 0.5 && dir[1] >= 0.5) {
        orientation = 1;
      } else if (dir && dir[0] <= -0.5 && Math.abs(dir[1]) < 0.5) {
        orientation = 2;
      } else if (dir && Math.abs(dir[0]) < 0.5 && dir[1] <= -0.5) {
        orientation = 3;
      }
      const xmlLineFormatting = xmlLinePreChar?.match(/<font[^>]+/)?.[0];
      const fontName = xmlLineFormatting?.match(/name=['"]([^'"]*)/)?.[1];
      const fontSizeStr = xmlLineFormatting?.match(/size=['"]([^'"]*)/)?.[1];
      console.assert(fontSizeStr, "Font size not found in stext.");
      const fontSizeLine = fontSizeStr ? parseFloat(fontSizeStr) : 10;
      const fontFamilyLine = fontName?.replace(/-.+/g, "") || "Default";
      const lineBoxArr = [...xmlLinePreChar.matchAll(/bbox(?:es)?=['"](\s*[\d.-]+)(\s*[\d.-]+)?(\s*[\d.-]+)?(\s*[\d.-]+)?/g)][0].slice(1, 5).map((x2) => Math.max(parseFloat(x2), 0));
      const wordStrArr = xmlLine.split(/(?:<char[^>]*?c=['"]\s+['"]\/>)/ig);
      if (wordStrArr[wordStrArr.length - 1] && wordStrArr[wordStrArr.length - 1].trim() === "</font>") wordStrArr.pop();
      for (let i2 = wordStrArr.length - 1; i2 >= 0; i2--) {
        if (wordStrArr[i2].trim() === "") {
          wordStrArr.splice(i2, 1);
        }
      }
      if (wordStrArr.length === 0) return;
      const bboxes = [];
      let baselineFirstDone = false;
      const baselineFirst = (
        /** @type {Array<Number>} */
        []
      );
      let baselineCurrent = 0;
      const textArr = [];
      const wordLetterOrFontArrIndex = [];
      let boldCurrent = false;
      let italicCurrent = false;
      let familyCurrent = "Default";
      let sizeCurrentRaw = 0;
      let sizeCurrent = 0;
      let superCurrent = false;
      let smallCapsCurrent;
      let smallCapsCurrentAlt;
      const boldArr = [];
      const italicArr = [];
      const underlineArr = [];
      const smallCapsArr = [];
      const smallCapsAltArr = [];
      const smallCapsAltTitleCaseArr = [];
      const fontFamilyArr = [];
      const fontSizeArr = [];
      const superArr = [];
      const wordCharOrFontArr = (
        /** @type {Array<Array<StextChar|StextFont>>} */
        []
      );
      for (let i2 = 0; i2 < wordStrArr.length; i2++) {
        const stextCharRegex = /(<font[^>]+>\s*)|<char quad=['"](\s*[\d.-]+)(\s*[\d.-]+)(\s*[\d.-]+)(\s*[\d.-]+)(\s*[\d.-]+)(\s*[\d.-]+)(\s*[\d.-]+)(\s*[\d.-]+)[^>]*?x=['"]([\d.-]+)[^>]*?y=['"]([\d.-]+)['"]([^>]*?c=['"][^'"]+['"])\s*\/>/ig;
        const stextMatches = [...wordStrArr[i2].matchAll(stextCharRegex)];
        wordCharOrFontArr[i2] = [];
        for (let j2 = 0; j2 < stextMatches.length; j2++) {
          const fontStr = stextMatches[j2][1];
          const fontNameStrI = fontStr?.match(/name=['"]([^'"]*)/)?.[1];
          const fontSizeStrI = fontStr?.match(/size=['"]([^'"]*)/)?.[1];
          if (fontNameStrI !== void 0 && fontSizeStrI !== void 0) {
            if (i2 + 1 === wordStrArr.length && j2 + 1 === stextMatches.length) continue;
            wordCharOrFontArr[i2][j2] = {
              name: fontNameStrI,
              size: parseFloat(fontSizeStrI)
            };
            continue;
          }
          let quad;
          if (orientation === 1) {
            quad = {
              ul: { x: parseFloat(stextMatches[j2][6]), y: parseFloat(stextMatches[j2][7]) },
              ur: { x: parseFloat(stextMatches[j2][2]), y: parseFloat(stextMatches[j2][3]) },
              ll: { x: parseFloat(stextMatches[j2][8]), y: parseFloat(stextMatches[j2][9]) },
              lr: { x: parseFloat(stextMatches[j2][4]), y: parseFloat(stextMatches[j2][5]) }
            };
          } else if (orientation === 2) {
            quad = {
              ul: { x: parseFloat(stextMatches[j2][8]), y: parseFloat(stextMatches[j2][9]) },
              ur: { x: parseFloat(stextMatches[j2][6]), y: parseFloat(stextMatches[j2][7]) },
              ll: { x: parseFloat(stextMatches[j2][4]), y: parseFloat(stextMatches[j2][5]) },
              lr: { x: parseFloat(stextMatches[j2][2]), y: parseFloat(stextMatches[j2][3]) }
            };
          } else if (orientation === 3) {
            quad = {
              ul: { x: parseFloat(stextMatches[j2][4]), y: parseFloat(stextMatches[j2][5]) },
              ur: { x: parseFloat(stextMatches[j2][8]), y: parseFloat(stextMatches[j2][9]) },
              ll: { x: parseFloat(stextMatches[j2][2]), y: parseFloat(stextMatches[j2][3]) },
              lr: { x: parseFloat(stextMatches[j2][6]), y: parseFloat(stextMatches[j2][7]) }
            };
          } else {
            quad = {
              ul: { x: parseFloat(stextMatches[j2][2]), y: parseFloat(stextMatches[j2][3]) },
              ur: { x: parseFloat(stextMatches[j2][4]), y: parseFloat(stextMatches[j2][5]) },
              ll: { x: parseFloat(stextMatches[j2][6]), y: parseFloat(stextMatches[j2][7]) },
              lr: { x: parseFloat(stextMatches[j2][8]), y: parseFloat(stextMatches[j2][9]) }
            };
          }
          const flags = parseInt(stextMatches[j2][12]?.match(/flags=['"]([^'"]*)/)?.[1]);
          const text = stextMatches[j2][12]?.match(/c=['"]([^'"]*)/)?.[1];
          wordCharOrFontArr[i2][j2] = {
            quad,
            origin: { x: parseFloat(stextMatches[j2][10]), y: parseFloat(stextMatches[j2][11]) },
            flags,
            text
          };
        }
      }
      for (let i2 = 0; i2 < wordCharOrFontArr.length; i2++) {
        let textWordArr = [];
        let bboxesWordArr = [];
        const underlineWordArr = [];
        let fontFamily = familyCurrent || fontFamilyLine || "Default";
        let fontSizeWord = sizeCurrent || fontSizeLine || 10;
        let smallCapsWord = smallCapsCurrent || false;
        let smallCapsWordAlt = smallCapsCurrentAlt || false;
        let smallCapsWordAltTitleCaseAdj = false;
        let boldWord = false;
        let italicWord = false;
        if (wordCharOrFontArr[i2].length === 0) continue;
        let wordCharN = 0;
        for (let j2 = 0; j2 < wordCharOrFontArr[i2].length; j2++) {
          const charOrFont = wordCharOrFontArr[i2][j2];
          if ("name" in charOrFont) {
            const sizePrevRaw = sizeCurrentRaw;
            sizeCurrentRaw = charOrFont.size;
            const secondLetter = wordCharN > 0 && textWordArr.length === 1 && /[A-Z]/.test(textWordArr[0]);
            let baselineNextLetter;
            const possibleNextLetter1 = wordCharOrFontArr[i2][j2 + 1];
            const possibleNextLetter2 = wordCharOrFontArr[i2 + 1]?.[0];
            const possibleNextLetter3 = wordCharOrFontArr[i2 + 1]?.[1];
            const possibleNextLetter4 = wordCharOrFontArr[i2 + 1]?.[2];
            if (possibleNextLetter1 && "origin" in possibleNextLetter1) {
              baselineNextLetter = possibleNextLetter1.origin.y;
            } else if (possibleNextLetter2 && "origin" in possibleNextLetter2) {
              baselineNextLetter = possibleNextLetter2.origin.y;
            } else if (possibleNextLetter3 && "origin" in possibleNextLetter3) {
              baselineNextLetter = possibleNextLetter3.origin.y;
            } else if (possibleNextLetter4 && "origin" in possibleNextLetter4) {
              baselineNextLetter = possibleNextLetter4.origin.y;
            }
            const fontSizeMin = Math.min(sizeCurrentRaw, sizePrevRaw);
            const baselineDelta = (baselineNextLetter - baselineCurrent) / fontSizeMin;
            const sizeDelta = (sizeCurrentRaw - sizePrevRaw) / fontSizeMin;
            if (secondLetter && sizeCurrentRaw < sizePrevRaw && sizePrevRaw > 0 && baselineNextLetter && Math.abs(baselineDelta) < 0.1) {
              smallCapsCurrentAlt = true;
              smallCapsWordAlt = true;
              smallCapsWordAltTitleCaseAdj = true;
            } else if (Number.isFinite(baselineDelta) && Number.isFinite(sizeDelta) && (baselineDelta < -0.25 && sizeDelta < -0.05 || baselineDelta > 0.25 && sizeDelta > 0.05)) {
              if (textWordArr.length > 0) {
                textArr.push(textWordArr);
                bboxes.push(bboxesWordArr);
                boldArr.push(boldWord);
                italicArr.push(italicWord);
                underlineArr.push(underlineWordArr.reduce((a2, b2) => Number(a2) + Number(b2), 0) / underlineWordArr.length > 0.5);
                fontFamilyArr.push(fontFamily);
                if (sizeDelta > 0) {
                  fontSizeArr.push(sizePrevRaw);
                } else {
                  fontSizeArr.push(fontSizeWord);
                }
                smallCapsArr.push(smallCapsWord);
                smallCapsAltArr.push(smallCapsWordAlt);
                smallCapsAltTitleCaseArr.push(smallCapsWordAltTitleCaseAdj);
                superArr.push(sizeDelta > 0);
                textWordArr = [];
                bboxesWordArr = [];
              }
              if (sizeDelta > 0) {
                if (!baselineFirstDone) baselineFirst.length = 0;
                familyCurrent = charOrFont.name || familyCurrent;
                sizeCurrent = sizeCurrentRaw || sizeCurrent;
                fontSizeWord = sizeCurrent;
                fontFamily = familyCurrent;
                superArr[superArr.length - 1] = true;
              }
              if (superArr.length > 0 && !superArr[superArr.length - 1] && baselineFirst.length > 0) {
                baselineFirstDone = true;
              }
              superCurrent = sizeDelta < 0;
            } else {
              sizeCurrent = sizeCurrentRaw || sizeCurrent;
              familyCurrent = charOrFont.name || familyCurrent;
              if (textWordArr.length === 0) {
                fontSizeWord = sizeCurrent;
                fontFamily = familyCurrent;
              }
              if (Number.isFinite(sizeDelta) && Math.abs(sizeDelta) > 0.05) {
                smallCapsCurrentAlt = false;
                if (textWordArr.length === 0) {
                  superCurrent = false;
                  smallCapsWordAlt = false;
                  smallCapsWordAltTitleCaseAdj = false;
                }
              }
            }
            smallCapsCurrentAlt = smallCapsCurrentAlt ?? smallCapsAltArr[smallCapsAltArr.length - 1];
            smallCapsCurrent = /(small\W?cap)|(sc$)|(caps$)/i.test(charOrFont.name);
            smallCapsWord = smallCapsCurrent;
            if (/italic/i.test(charOrFont.name) || /-\w*ital/i.test(charOrFont.name) || /-it$/i.test(charOrFont.name) || /oblique/i.test(charOrFont.name)) {
              italicCurrent = true;
            } else {
              italicCurrent = false;
            }
            if (/bold|black/i.test(charOrFont.name)) {
              boldCurrent = true;
            } else {
              boldCurrent = false;
            }
            continue;
          } else {
            baselineCurrent = charOrFont.origin.y;
          }
          if (wordCharN === 0 || wordCharN < 3 && /[A-Z\d]/i.test(charOrFont.text)) {
            boldWord = boldCurrent;
            italicWord = italicCurrent;
            wordCharN++;
          }
          let bbox;
          if (orientation === 1) {
            bbox = {
              left: Math.round(charOrFont.origin.y),
              top: Math.round(pageDims.width - Math.max(charOrFont.quad.ur.x, charOrFont.quad.lr.x)),
              right: Math.round(charOrFont.origin.y + (charOrFont.quad.lr.y - charOrFont.quad.ur.y)),
              bottom: Math.round(pageDims.width - Math.min(charOrFont.quad.ul.x, charOrFont.quad.ll.x))
            };
          } else if (orientation === 2) {
            bbox = {
              left: Math.round(pageDims.width - charOrFont.origin.x),
              top: Math.round(pageDims.height - Math.max(charOrFont.quad.ll.y, charOrFont.quad.lr.y)),
              right: Math.round(pageDims.width - (charOrFont.origin.x - (charOrFont.quad.ur.x - charOrFont.quad.ul.x))),
              bottom: Math.round(pageDims.height - Math.min(charOrFont.quad.ul.y, charOrFont.quad.ur.y))
            };
          } else if (orientation === 3) {
            bbox = {
              left: Math.round(pageDims.height - charOrFont.origin.y),
              top: Math.round(Math.min(charOrFont.quad.ul.x, charOrFont.quad.ll.x)),
              right: Math.round(pageDims.height - charOrFont.origin.y + (charOrFont.quad.lr.y - charOrFont.quad.ur.y)),
              bottom: Math.round(Math.max(charOrFont.quad.ur.x, charOrFont.quad.lr.x))
            };
          } else {
            bbox = {
              left: Math.round(charOrFont.origin.x),
              top: Math.round(Math.min(charOrFont.quad.ul.y, charOrFont.quad.ur.y)),
              right: Math.round(charOrFont.origin.x + (charOrFont.quad.ur.x - charOrFont.quad.ul.x)),
              bottom: Math.round(Math.max(charOrFont.quad.ll.y, charOrFont.quad.lr.y))
            };
          }
          if (!superCurrent) {
            if (baselineFirst.length === 0) {
              let originY;
              if (orientation === 1) {
                originY = pageDims.width - charOrFont.origin.x;
              } else if (orientation === 2) {
                originY = pageDims.height - charOrFont.origin.y;
              } else if (orientation === 3) {
                originY = charOrFont.origin.x;
              } else {
                originY = charOrFont.origin.y;
              }
              baselineFirst.push(bbox.left, originY);
            }
          }
          smallCapsCurrentAlt = smallCapsCurrentAlt ?? smallCapsAltArr[smallCapsAltArr.length - 1];
          textWordArr.push(charOrFont.text);
          underlineWordArr.push(charOrFont.flags === 2);
          bboxesWordArr.push(bbox);
        }
        if (textWordArr.length === 0) continue;
        const underlineWord = underlineWordArr.reduce((a2, b2) => Number(a2) + Number(b2), 0) / underlineWordArr.length > 0.5;
        underlineArr.push(underlineWord);
        wordLetterOrFontArrIndex.push(i2);
        textArr.push(textWordArr);
        bboxes.push(bboxesWordArr);
        boldArr.push(boldWord);
        italicArr.push(italicWord);
        fontFamilyArr.push(fontFamily);
        fontSizeArr.push(fontSizeWord);
        smallCapsAltArr.push(smallCapsWordAlt);
        smallCapsArr.push(smallCapsWord);
        smallCapsAltTitleCaseArr.push(smallCapsWordAltTitleCaseAdj);
        if (superCurrent && superArr[superArr.length - 1]) {
          superArr[superArr.length - 1] = false;
          superCurrent = false;
        }
        superArr.push(superCurrent);
        if (superCurrent) fontSizeArr[fontSizeArr.length - 1] = sizeCurrentRaw;
      }
      if (bboxes.length === 0) return;
      let baselineSlope = 0;
      if (dir && dir[0] !== void 0 && !Number.isNaN(dir[0]) && dir[1] !== void 0 && !Number.isNaN(dir[1])) {
        if (orientation === 1) {
          baselineSlope = -dir[0];
        } else if (orientation === 2) {
          baselineSlope = -dir[1];
        } else if (orientation === 3) {
          baselineSlope = dir[0];
        } else {
          baselineSlope = dir[1];
        }
      } else {
        console.log("Unable to parse slope.");
      }
      const lineBbox = {
        left: lineBoxArr[0],
        top: lineBoxArr[1],
        right: lineBoxArr[2],
        bottom: lineBoxArr[3]
      };
      let baselinePoint = baselineFirst[1] - lineBbox.bottom;
      baselinePoint = baselinePoint || 0;
      const baselineOut = [round6(baselineSlope), Math.round(baselinePoint)];
      const letterHeightOut = fontSizeLine * 0.6;
      const lineObj = new ocrObjects_default.OcrLine(pageObj, lineBbox, baselineOut, letterHeightOut, null);
      lineObj.orientation = orientation;
      lineObj.raw = xmlLine;
      let lettersKept = 0;
      for (let i2 = 0; i2 < textArr.length; i2++) {
        const wordText = unescapeXml(textArr[i2].join(""));
        if (wordText.trim() === "") continue;
        const wordLang = calcLang(wordText);
        langSet.add(wordLang);
        const wordID = `word_${n2 + 1}_${pageObj.lines.length + 1}_${i2 + 1}`;
        const bboxesI = bboxes[i2];
        const charObjArr = [];
        for (let j2 = 0; j2 < textArr[i2].length; j2++) {
          const letter = unescapeXml(textArr[i2][j2]);
          const bbox2 = bboxesI[j2];
          if (wordLang === "chi_sim") {
            const wordObj2 = new ocrObjects_default.OcrWord(lineObj, `${wordID}_${j2}`, letter, bbox2);
            wordObj2.conf = 100;
            wordObj2.lang = wordLang;
            wordObj2.visualCoords = false;
            lineObj.words.push(wordObj2);
            lettersKept++;
          } else {
            const charObj = new ocrObjects_default.OcrChar(letter, bbox2);
            charObjArr.push(charObj);
          }
        }
        if (wordLang === "chi_sim") continue;
        const bboxesILeft = Math.min(...bboxesI.map((x2) => x2.left));
        const bboxesIRight = Math.max(...bboxesI.map((x2) => x2.right));
        const bboxesITop = Math.min(...bboxesI.map((x2) => x2.top));
        const bboxesIBottom = Math.max(...bboxesI.map((x2) => x2.bottom));
        const bbox = {
          left: bboxesILeft,
          top: bboxesITop,
          right: bboxesIRight,
          bottom: bboxesIBottom
        };
        if (bbox.left < 0 && bbox.right < 0) continue;
        const wordObj = new ocrObjects_default.OcrWord(lineObj, wordID, wordText, bbox);
        wordObj.style.size = fontSizeArr[i2];
        wordObj.lang = wordLang;
        wordObj.chars = charObjArr;
        wordObj.visualCoords = false;
        wordObj.conf = 100;
        if (smallCapsAltArr[i2] && !/[a-z]/.test(wordObj.text) && /[A-Z].?[A-Z]/.test(wordObj.text)) {
          wordObj.style.smallCaps = true;
          if (smallCapsAltTitleCaseArr[i2]) {
            wordObj.chars.slice(1).forEach((x2) => {
              x2.text = x2.text.toLowerCase();
            });
          } else {
            wordObj.chars.forEach((x2) => {
              x2.text = x2.text.toLowerCase();
            });
          }
          wordObj.text = wordObj.chars.map((x2) => x2.text).join("");
        } else if (smallCapsArr[i2]) {
          wordObj.style.smallCaps = true;
        }
        if (italicArr[i2]) {
          wordObj.style.italic = true;
        }
        if (boldArr[i2]) {
          wordObj.style.bold = true;
        }
        wordObj.raw = wordStrArr[wordLetterOrFontArrIndex[i2]];
        wordObj.style.font = fontFamilyArr[i2];
        fontSet.add(cleanFamilyName(wordObj.style.font));
        wordObj.style.sup = superArr[i2];
        wordObj.style.underline = underlineArr[i2];
        lineObj.words.push(wordObj);
        lettersKept++;
      }
      if (lettersKept === 0) return;
      ocrObjects_default.updateLineBbox(lineObj);
      pageObj.lines.push(lineObj);
      parLineArr.push(lineObj);
      return baselineSlope;
    }
    const lineStrArr = xmlPar.split(/<\/line>/);
    for (let i2 = 0; i2 < lineStrArr.length; i2++) {
      const angle = convertLineStext(lineStrArr[i2]);
      if (typeof angle === "number" && !Number.isNaN(angle) && Math.abs(angle) < 0.3) angleRisePage.push(angle);
    }
    if (parLineArr.length === 0) return;
    const parbox = calcBboxUnion(parLineArr.map((x2) => x2.bbox));
    const parObj = new ocrObjects_default.OcrPar(pageObj, parbox);
    parLineArr.forEach((x2) => {
      x2.par = parObj;
    });
    parObj.lines = parLineArr;
    pageObj.pars.push(parObj);
  }
  const parStrArr = ocrStr.split(/<\/block>/);
  for (let i2 = 0; i2 < parStrArr.length; i2++) {
    convertParStext(parStrArr[i2]);
  }
  const angleRiseMedian = mean50(angleRisePage) || 0;
  const angleOut = Math.asin(angleRiseMedian) * (180 / Math.PI);
  pageObj.angle = angleOut;
  const autoDetectTables = false;
  const dataTablePage = new LayoutDataTablePage(n2);
  if (autoDetectTables) {
    const tableBboxes = detectTablesInPage(pageObj);
    for (let i2 = 0; i2 < pageObj.lines.length; i2++) {
      const line = pageObj.lines[i2];
      let inTable = false;
      for (let j2 = 0; j2 < tableBboxes.length; j2++) {
        if (calcBoxOverlap(line.bbox, tableBboxes[j2]) > 0.25) {
          inTable = true;
          break;
        }
      }
      if (inTable) {
        const newLines = splitLineAgressively(line);
        pageObj.lines.splice(i2, 1, ...newLines);
      }
    }
    tableBboxes.forEach((bbox) => {
      const dataTable = makeTableFromBbox(pageObj, bbox);
      dataTable.page = dataTablePage;
      dataTablePage.tables.push(dataTable);
    });
  }
  return {
    pageObj,
    dataTables: dataTablePage,
    langSet,
    fontSet
  };
}

// node_modules/scribe.js-ocr/js/import/convertDocTextract.js
var detectPolyOrientation = (poly) => {
  if (poly[0].X > poly[2].X && poly[0].Y < poly[2].Y) {
    return 1;
  }
  if (poly[0].X > poly[2].X && poly[0].Y > poly[2].Y) {
    return 2;
  }
  if (poly[0].X < poly[2].X && poly[1].X < poly[3].X && poly[0].Y > poly[2].Y) {
    return 3;
  }
  return 0;
};
async function convertDocTextract({ ocrStr, pageDims }) {
  const blocks = (
    /** @type {TextractBlock[]} */
    []
  );
  try {
    if (typeof ocrStr === "string") {
      ocrStr = [ocrStr];
    }
    for (let i2 = 0; i2 < ocrStr.length; i2++) {
      const textractData = JSON.parse(ocrStr[i2]);
      if (!textractData || !Array.isArray(textractData.Blocks)) {
        console.warn(`Invalid Textract JSON data at index ${i2}. Expected an array of blocks.`);
        continue;
      }
      blocks.push(...textractData.Blocks);
    }
  } catch (error) {
    throw new Error("Failed to parse Textract JSON.");
  }
  const pageBlocks = blocks.filter((block) => block.BlockType === "PAGE");
  const resArr = [];
  for (let n2 = 0; n2 < pageBlocks.length; n2++) {
    const pageBlock = pageBlocks[n2];
    const pageDimsN = pageDims[n2];
    if (!pageDimsN) {
      throw new Error(`No page dimensions provided for page ${n2 + 1}.`);
    }
    const pagePoly = pageBlock.Geometry && pageBlock.Geometry.Polygon ? pageBlock.Geometry.Polygon : null;
    if (!pagePoly) throw new Error(`No page polygon data for page ${n2 + 1}.`);
    const pageOrientation = detectPolyOrientation(pagePoly);
    console.log(`Page ${n2 + 1} orientation: ${pageOrientation * 90} degrees`);
    const pageObj = new ocrObjects_default.OcrPage(n2, pageDimsN);
    const lineBlocks = blocks.filter((block) => block.BlockType === "LINE" && (!block.Page && n2 === 0 || block.Page === n2 + 1));
    if (lineBlocks.length === 0) {
      const warn = { char: "char_error" };
      return {
        pageObj,
        charMetricsObj: {},
        dataTables: new LayoutDataTablePage(n2),
        warn
      };
    }
    const tablesPage = convertTableLayoutTextract(n2, blocks, pageDimsN);
    const relationshipMap = /* @__PURE__ */ new Map();
    blocks.forEach((block) => {
      if (block.Relationships) {
        block.Relationships.forEach((rel) => {
          if (rel.Type === "CHILD") {
            relationshipMap.set(block.Id, rel.Ids || []);
          }
        });
      }
    });
    const blockMap = /* @__PURE__ */ new Map();
    blocks.forEach((block) => {
      blockMap.set(block.Id, block);
    });
    const layoutBlocks = blocks.filter(
      (block) => block.BlockType && block.BlockType.startsWith("LAYOUT_")
    );
    const lineToLayoutMap = /* @__PURE__ */ new Map();
    layoutBlocks.forEach((layoutBlock) => {
      const childIds = relationshipMap.get(layoutBlock.Id) || [];
      childIds.forEach((childId) => {
        const childBlock = blockMap.get(childId);
        if (childBlock && childBlock.BlockType === "LINE") {
          lineToLayoutMap.set(childId, layoutBlock);
        }
      });
    });
    const lineObjMap = /* @__PURE__ */ new Map();
    lineBlocks.forEach((lineBlock, lineIndex) => {
      const lineObj = convertLineTextract(lineBlock, blockMap, relationshipMap, pageObj, n2, lineIndex, pageDimsN, pageOrientation);
      if (lineObj) {
        pageObj.lines.push(lineObj);
        lineObjMap.set(lineBlock.Id, lineObj);
      }
    });
    pageObj.textSource = "textract";
    createParagraphsFromLayout(pageObj, layoutBlocks, relationshipMap, blockMap, lineObjMap);
    const lines2 = (
      /** @type {OcrLine[]} */
      []
    );
    pageObj.pars.forEach((par) => {
      lines2.push(...par.lines);
    });
    if (lines2.length !== pageObj.lines.length) {
      console.warn(`Warning: Mismatch in number of lines (${lines2.length}) and lines in paragraphs (${pageObj.lines.length}) on page ${n2 + 1}. Lines will not be reordered.`);
    } else {
      pageObj.lines = lines2;
    }
    const langSet = pass3(pageObj);
    resArr.push({ pageObj, dataTables: tablesPage, langSet });
  }
  return resArr;
}
function convertLineTextract(lineBlock, blockMap, relationshipMap, pageObj, pageNum, lineIndex, pageDims, pageOrientation) {
  if (!lineBlock.Text || !lineBlock.Geometry || (lineBlock.Page || 1) - 1 !== pageNum) return null;
  const bboxLine = convertBoundingBox(lineBlock.Geometry.BoundingBox, pageDims);
  const polyLine0 = convertPolygon(lineBlock.Geometry.Polygon, pageDims, pageOrientation);
  let polyLine = (
    /** @type {Polygon} */
    JSON.parse(JSON.stringify(polyLine0))
  );
  const baseline = [0, 0];
  const lineObj = new ocrObjects_default.OcrLine(pageObj, bboxLine, baseline);
  const childIds = relationshipMap.get(lineBlock.Id) || [];
  const wordBlocks = (
    /** @type {TextractBlock[]} */
    childIds.map((wordId) => blockMap.get(wordId)).filter((block) => block && block.BlockType === "WORD")
  );
  wordBlocks.forEach((wordBlock, wordIndex) => {
    const bboxWord = convertBoundingBox(wordBlock.Geometry.BoundingBox, pageDims);
    const id = `word_${pageNum + 1}_${lineIndex + 1}_${wordIndex + 1}`;
    const poly = convertPolygon(wordBlock.Geometry.Polygon, pageDims, pageOrientation);
    const wordObj = new ocrObjects_default.OcrWord(lineObj, id, wordBlock.Text, bboxWord, poly);
    wordObj.conf = wordBlock.Confidence || 100;
    lineObj.words.push(wordObj);
  });
  if (!wordBlocks.length || !lineObj.words.length) {
    console.warn(`Warning: Line with no words on page ${pageNum + 1}, line index ${lineIndex + 1}. Skipping line.`);
    return null;
  }
  const lineOrientation = (wordBlocks[0].Geometry.RotationAngle || 0) / 90;
  lineObj.orientation = pageOrientation - lineOrientation;
  if (lineObj.orientation < 0) {
    lineObj.orientation += 4;
  }
  if (lineObj.orientation === 1) {
    const lineBox = { ...lineObj.bbox };
    lineObj.bbox.left = lineBox.top;
    lineObj.bbox.top = pageDims.width - lineBox.right;
    lineObj.bbox.right = lineBox.bottom;
    lineObj.bbox.bottom = pageDims.width - lineBox.left;
    lineObj.words.forEach((word) => {
      const wordBox = { ...word.bbox };
      word.bbox.left = word.bbox.top;
      word.bbox.top = pageDims.width - wordBox.right;
      word.bbox.right = wordBox.bottom;
      word.bbox.bottom = pageDims.width - wordBox.left;
      word.poly = {
        tl: { x: word.poly.tr.y, y: pageDims.width - word.poly.tr.x },
        tr: { x: word.poly.br.y, y: pageDims.width - word.poly.br.x },
        br: { x: word.poly.bl.y, y: pageDims.width - word.poly.bl.x },
        bl: { x: word.poly.tl.y, y: pageDims.width - word.poly.tl.x }
      };
    });
    polyLine = {
      tl: { x: polyLine0.tr.y, y: pageDims.width - polyLine0.tr.x },
      tr: { x: polyLine0.br.y, y: pageDims.width - polyLine0.br.x },
      br: { x: polyLine0.bl.y, y: pageDims.width - polyLine0.bl.x },
      bl: { x: polyLine0.tl.y, y: pageDims.width - polyLine0.tl.x }
    };
  } else if (lineObj.orientation === 2) {
    const lineBox = { ...lineObj.bbox };
    lineObj.bbox.left = pageDims.width - lineBox.right;
    lineObj.bbox.top = pageDims.height - lineBox.bottom;
    lineObj.bbox.right = pageDims.width - lineBox.left;
    lineObj.bbox.bottom = pageDims.height - lineBox.top;
    lineObj.words.forEach((word) => {
      const wordBox = { ...word.bbox };
      word.bbox.left = pageDims.width - wordBox.right;
      word.bbox.top = pageDims.height - wordBox.bottom;
      word.bbox.right = pageDims.width - wordBox.left;
      word.bbox.bottom = pageDims.height - wordBox.top;
      word.poly = {
        tl: { x: pageDims.width - word.poly.br.x, y: pageDims.height - word.poly.br.y },
        tr: { x: pageDims.width - word.poly.bl.x, y: pageDims.height - word.poly.bl.y },
        br: { x: pageDims.width - word.poly.tl.x, y: pageDims.height - word.poly.tl.y },
        bl: { x: pageDims.width - word.poly.tr.x, y: pageDims.height - word.poly.tr.y }
      };
    });
    polyLine = {
      tl: { x: pageDims.width - polyLine0.br.x, y: pageDims.height - polyLine0.br.y },
      tr: { x: pageDims.width - polyLine0.bl.x, y: pageDims.height - polyLine0.bl.y },
      br: { x: pageDims.width - polyLine0.tl.x, y: pageDims.height - polyLine0.tl.y },
      bl: { x: pageDims.width - polyLine0.tr.x, y: pageDims.height - polyLine0.tr.y }
    };
  } else if (lineObj.orientation === 3) {
    const lineBox = { ...lineObj.bbox };
    lineObj.bbox.left = pageDims.height - lineBox.bottom;
    lineObj.bbox.top = lineBox.left;
    lineObj.bbox.right = pageDims.height - lineBox.top;
    lineObj.bbox.bottom = lineBox.right;
    lineObj.words.forEach((word) => {
      const wordBox = { ...word.bbox };
      word.bbox.left = pageDims.height - wordBox.bottom;
      word.bbox.top = wordBox.left;
      word.bbox.right = pageDims.height - wordBox.top;
      word.bbox.bottom = wordBox.right;
      word.poly = {
        tl: { x: pageDims.height - word.poly.bl.y, y: word.poly.bl.x },
        tr: { x: pageDims.height - word.poly.tl.y, y: word.poly.tl.x },
        br: { x: pageDims.height - word.poly.tr.y, y: word.poly.tr.x },
        bl: { x: pageDims.height - word.poly.br.y, y: word.poly.br.x }
      };
    });
    polyLine = {
      tl: { x: pageDims.height - polyLine0.bl.y, y: polyLine0.bl.x },
      tr: { x: pageDims.height - polyLine0.tl.y, y: polyLine0.tl.x },
      br: { x: pageDims.height - polyLine0.tr.y, y: polyLine0.tr.x },
      bl: { x: pageDims.height - polyLine0.br.y, y: polyLine0.br.x }
    };
  }
  if (polyLine.br.x !== polyLine.bl.x) {
    lineObj.baseline[0] = (polyLine.br.y - polyLine.bl.y) / (polyLine.br.x - polyLine.bl.x);
  }
  const descCharRegex = new RegExp(`[${descCharArr.join("")}]`);
  const ascCharRegex = new RegExp(`[${ascCharArr.join("")}]`);
  const xCharRegex = new RegExp(`[${xCharArr.join("")}]`);
  const descWords = (
    /** @type {OcrWord[]} */
    []
  );
  const nonDescWords = (
    /** @type {OcrWord[]} */
    []
  );
  const nonDescWordsPoly = (
    /** @type {Polygon[]} */
    []
  );
  const xOnlyWords = (
    /** @type {OcrWord[]} */
    []
  );
  const xOnlyWordsPoly = (
    /** @type {Polygon[]} */
    []
  );
  const ascOnlyWords = (
    /** @type {OcrWord[]} */
    []
  );
  const ascOnlyWordsPoly = (
    /** @type {Polygon[]} */
    []
  );
  const descOnlyWords = (
    /** @type {OcrWord[]} */
    []
  );
  for (let i2 = 0; i2 < lineObj.words.length; i2++) {
    const word = lineObj.words[i2];
    if (descCharRegex.test(word.text)) {
      descWords.push(word);
    }
    if (!descCharRegex.test(word.text) && (xCharRegex.test(word.text) || ascCharRegex.test(word.text))) {
      nonDescWords.push(word);
      nonDescWordsPoly.push(word.poly);
    }
    if (xCharRegex.test(word.text) && !ascCharRegex.test(word.text) && !descCharRegex.test(word.text) && !/[fi]/.test(word.text)) {
      xOnlyWords.push(word);
      xOnlyWordsPoly.push(word.poly);
    }
    if (ascCharRegex.test(word.text) && !descCharRegex.test(word.text)) {
      ascOnlyWords.push(word);
      ascOnlyWordsPoly.push(word.poly);
    }
    if (descCharRegex.test(word.text) && !ascCharRegex.test(word.text)) {
      descOnlyWords.push(word);
    }
    if (/[]/g.test(word.text)) {
      word.text = removeSuperscript(word.text);
    }
  }
  let xHeight = (
    /** @type {?number} */
    mean50(xOnlyWordsPoly.map((wordPoly) => (wordPoly.bl.y - wordPoly.tl.y + (wordPoly.br.y - wordPoly.tr.y)) / 2))
  );
  const ascHeight = mean50(ascOnlyWordsPoly.map((wordPoly) => (wordPoly.bl.y - wordPoly.tl.y + (wordPoly.br.y - wordPoly.tr.y)) / 2));
  if (xHeight && ascHeight && xHeight > ascHeight * 0.8) {
    if (ascOnlyWords.length > xOnlyWords.length) {
      xHeight = null;
    }
  }
  const nonDescBottomDeltaArr = nonDescWordsPoly.map((wordPoly) => {
    const wordBottomMid = Math.round((wordPoly.bl.y + wordPoly.br.y) / 2);
    const wordXMid = Math.round((wordPoly.bl.x + wordPoly.br.x) / 2);
    const wordXMidOffset = wordXMid - lineObj.bbox.left;
    const wordBottomExp = polyLine.bl.y + baseline[0] * wordXMidOffset;
    return wordBottomMid - wordBottomExp;
  });
  const nonDescBottomDelta = mean50(nonDescBottomDeltaArr);
  const lineHeight = (polyLine.br.y - polyLine.tr.y + (polyLine.bl.y - polyLine.tl.y)) / 2;
  if (Number.isFinite(nonDescBottomDelta) && nonDescBottomDelta < lineObj.bbox.bottom && nonDescBottomDelta < lineHeight / 2) {
    lineObj.baseline[1] = nonDescBottomDelta - (lineObj.bbox.bottom - polyLine.bl.y);
  } else {
    lineObj.baseline[1] = lineHeight * -1 / 3 - (lineObj.bbox.bottom - polyLine.bl.y);
  }
  if (xHeight && xHeight > 0) lineObj.xHeight = xHeight;
  if (ascHeight && ascHeight > 0) lineObj.ascHeight = ascHeight;
  return lineObj;
}
function convertBoundingBox(textractBbox, pageDims) {
  return {
    left: Math.round(textractBbox.Left * pageDims.width),
    top: Math.round(textractBbox.Top * pageDims.height),
    right: Math.round((textractBbox.Left + textractBbox.Width) * pageDims.width),
    bottom: Math.round((textractBbox.Top + textractBbox.Height) * pageDims.height)
  };
}
function convertPolygon(textractPolygon, pageDims, orientation) {
  let br2 = 2;
  let bl = 3;
  let tr2 = 1;
  let tl = 0;
  if (orientation === 1) {
    br2 = 1;
    bl = 2;
    tr2 = 0;
    tl = 3;
  } else if (orientation === 2) {
    br2 = 0;
    bl = 1;
    tr2 = 3;
    tl = 2;
  } else if (orientation === 3) {
    br2 = 3;
    bl = 0;
    tr2 = 2;
    tl = 1;
  }
  return {
    br: {
      x: Math.round(textractPolygon[br2].X * pageDims.width),
      y: Math.round(textractPolygon[br2].Y * pageDims.height)
    },
    bl: {
      x: Math.round(textractPolygon[bl].X * pageDims.width),
      y: Math.round(textractPolygon[bl].Y * pageDims.height)
    },
    tr: {
      x: Math.round(textractPolygon[tr2].X * pageDims.width),
      y: Math.round(textractPolygon[tr2].Y * pageDims.height)
    },
    tl: {
      x: Math.round(textractPolygon[tl].X * pageDims.width),
      y: Math.round(textractPolygon[tl].Y * pageDims.height)
    }
  };
}
function createParagraphsFromLayout(pageObj, layoutBlocks, relationshipMap, blockMap, lineObjMap) {
  layoutBlocks.forEach((layoutBlock) => {
    const childIds = relationshipMap.get(layoutBlock.Id) || [];
    const paragraphLines = [];
    childIds.forEach((childId) => {
      const childBlock = blockMap.get(childId);
      if (childBlock && childBlock.BlockType === "LINE") {
        const lineObj = lineObjMap.get(childId);
        if (lineObj) {
          paragraphLines.push(lineObj);
        }
      }
    });
    if (paragraphLines.length > 0) {
      const parBbox = calcBboxUnion(paragraphLines.map((line) => line.bbox));
      const parObj = new ocrObjects_default.OcrPar(pageObj, parBbox);
      parObj.reason = layoutBlock.BlockType || "LAYOUT_UNKNOWN";
      paragraphLines.forEach((lineObj) => {
        lineObj.par = parObj;
      });
      parObj.lines = paragraphLines;
      pageObj.pars.push(parObj);
    }
  });
  const unassignedLines = pageObj.lines.filter((line) => !line.par);
  if (unassignedLines.length > 0) {
    const parBbox = calcBboxUnion(unassignedLines.map((line) => line.bbox));
    const parObj = new ocrObjects_default.OcrPar(pageObj, parBbox);
    parObj.reason = "UNASSIGNED_LINES";
    unassignedLines.forEach((lineObj) => {
      lineObj.par = parObj;
    });
    parObj.lines = unassignedLines;
    pageObj.pars.push(parObj);
  }
}
function convertTableLayoutTextract(pageNum, blocks, pageDims) {
  const tablesPage = new LayoutDataTablePage(pageNum);
  const tableBlocks = blocks.filter((block) => block.BlockType === "TABLE" && (!block.Page && pageNum === 0 || block.Page === pageNum + 1));
  const relationshipMap = /* @__PURE__ */ new Map();
  tableBlocks.forEach((block) => {
    if (block.Relationships) {
      block.Relationships.forEach((rel) => {
        if (rel.Type === "CHILD") {
          relationshipMap.set(block.Id, rel.Ids || []);
        }
      });
    }
  });
  const blockMap = /* @__PURE__ */ new Map();
  blocks.forEach((block) => {
    blockMap.set(block.Id, block);
  });
  for (const tableBlock of tableBlocks) {
    const table = new LayoutDataTable(tablesPage);
    const tableBbox = convertBoundingBox(tableBlock.Geometry.BoundingBox, pageDims);
    const cellIds = relationshipMap.get(tableBlock.Id) || [];
    const cellBlocks = cellIds.map((id) => blockMap.get(id)).filter((block) => block && block.BlockType === "CELL");
    if (cellBlocks.length > 0) {
      const cellsByRow = /* @__PURE__ */ new Map();
      cellBlocks.forEach((cell) => {
        const rowIndex = cell.RowIndex || 0;
        if (!cellsByRow.has(rowIndex)) {
          cellsByRow.set(rowIndex, []);
        }
        cellsByRow.get(rowIndex).push(cell);
      });
      const firstRowCells = cellsByRow.get(0) || cellsByRow.get(1) || [];
      firstRowCells.sort((a2, b2) => (a2.ColumnIndex || 0) - (b2.ColumnIndex || 0));
      firstRowCells.forEach((cell) => {
        const cellBbox = convertBoundingBox(cell.Geometry.BoundingBox, pageDims);
        const column = new LayoutDataColumn({
          left: cellBbox.left,
          top: tableBbox.top,
          right: cellBbox.right,
          bottom: tableBbox.bottom
        }, table);
        table.boxes.push(column);
      });
    }
    if (table.boxes.length > 0) {
      tablesPage.tables.push(table);
    }
  }
  return tablesPage;
}

// node_modules/scribe.js-ocr/js/import/convertDocAzureDocIntel.js
var debugMode3 = false;
async function convertDocAzureDocIntel({ ocrStr, pageDims }) {
  let ocrData;
  try {
    ocrData = JSON.parse(ocrStr);
  } catch (error) {
    throw new Error("Failed to parse Azure Document Intelligence JSON data.");
  }
  if (!ocrData.analyzeResult || !ocrData.analyzeResult.pages || !ocrData.analyzeResult.pages[0]) {
    throw new Error("Invalid Azure Document Intelligence format: missing pages data.");
  }
  const analyzeResultPages = (
    /** @type {AzureDocIntelPage[]} */
    ocrData.analyzeResult.pages
  );
  const resArr = [];
  for (let n2 = 0; n2 < analyzeResultPages.length; n2++) {
    const pageData = analyzeResultPages[n2];
    const pageDimsN = pageDims[n2];
    if (!pageData.width || !pageData.height) {
      throw new Error("Failed to parse page dimensions.");
    }
    const pageObj = new ocrObjects_default.OcrPage(n2, pageDimsN);
    pageObj.textSource = "azure_doc_intel";
    if (!pageData.words || pageData.words.length === 0) {
      const warn = { char: "char_error" };
      resArr.push({
        pageObj,
        charMetricsObj: {},
        dataTables: new LayoutDataTablePage(n2),
        warn
      });
    }
    if (pageData.unit !== "pixel") {
      if (!pageDimsN || !pageDimsN.width || !pageDimsN.height) {
        throw new Error("Page dimensions must be provided for non-pixel units.");
      }
      const pageDimsMult = {
        width: pageDimsN.width / pageData.width,
        height: pageDimsN.height / pageData.height
      };
      pageData.lines.forEach((line) => {
        line.polygon = line.polygon.map((val, idx) => idx % 2 === 0 ? val * pageDimsMult.width : val * pageDimsMult.height);
      });
      pageData.words.forEach((word) => {
        word.polygon = word.polygon.map((val, idx) => idx % 2 === 0 ? val * pageDimsMult.width : val * pageDimsMult.height);
      });
    }
    for (let i2 = 0; i2 < pageData.lines.length; i2++) {
      const lineWordsInput = (
        /** @type {AzureDocIntelWord[]} */
        []
      );
      for (let j2 = 0; j2 < pageData.lines[i2].spans.length; j2++) {
        const span = pageData.lines[i2].spans[j2];
        for (let k2 = 0; k2 < pageData.words.length; k2++) {
          const wordSpan = pageData.words[k2].span;
          if (wordSpan.offset >= span.offset && wordSpan.offset + wordSpan.length <= span.offset + span.length) {
            lineWordsInput.push(pageData.words[k2]);
          }
        }
      }
      if (lineWordsInput.length === 0) continue;
      const allX = lineWordsInput.flatMap((w2) => w2.polygon.filter((_2, i3) => i3 % 2 === 0));
      const allY = lineWordsInput.flatMap((w2) => w2.polygon.filter((_2, i3) => i3 % 2 === 1));
      const lineBbox = {
        left: Math.min(...allX),
        top: Math.min(...allY),
        right: Math.max(...allX),
        bottom: Math.max(...allY)
      };
      const baseline = [0, 0];
      const lineObj = new ocrObjects_default.OcrLine(pageObj, lineBbox, baseline);
      if (debugMode3) lineObj.raw = JSON.stringify(lineWordsInput);
      for (let j2 = 0; j2 < lineWordsInput.length; j2++) {
        const wordData = lineWordsInput[j2];
        if (!wordData.content || wordData.content.trim() === "") continue;
        const wordX = wordData.polygon.filter((_2, i3) => i3 % 2 === 0);
        const wordY = wordData.polygon.filter((_2, i3) => i3 % 2 === 1);
        const wordBbox = {
          left: Math.min(...wordX),
          top: Math.min(...wordY),
          right: Math.max(...wordX),
          bottom: Math.max(...wordY)
        };
        const wordId = `word_${n2 + 1}_${pageObj.lines.length + 1}_${j2 + 1}`;
        const wordObj = new ocrObjects_default.OcrWord(lineObj, wordId, wordData.content, wordBbox);
        wordObj.conf = Math.round((wordData.confidence || 0) * 100);
        if (debugMode3) wordObj.raw = JSON.stringify(wordData);
        lineObj.words.push(wordObj);
      }
      if (lineObj.words.length > 0) {
        pageObj.lines.push(lineObj);
      }
    }
    const pageAngle = pageData.angle || 0;
    pageObj.angle = pageAngle;
    const langSet = pass3(pageObj);
    const dataTables = new LayoutDataTablePage(n2);
    resArr.push({ pageObj, dataTables, langSet });
  }
  return resArr;
}

// node_modules/scribe.js-ocr/js/import/convertPageGoogleVision.js
async function convertPageGoogleVision({ ocrStr, n: n2 }) {
  const ocrJson = JSON.parse(ocrStr);
  let visionResult;
  if (ocrJson.fullTextAnnotation) {
    visionResult = ocrJson;
  } else if (ocrJson?.responses?.[0]?.fullTextAnnotation) {
    visionResult = ocrJson?.responses?.[0];
  } else {
    visionResult = ocrJson?.[0];
  }
  if (!visionResult || !visionResult.fullTextAnnotation) {
    throw new Error("Failed to parse Google Vision OCR data.");
  }
  const pageVision = (
    /** @type {GoogleVisionPage} */
    visionResult.fullTextAnnotation?.pages?.[0]
  );
  const pageWidth = pageVision.width;
  const pageHeight = pageVision.height;
  if (!pageWidth || !pageHeight) {
    throw new Error("Failed to parse page dimensions.");
  }
  const getVertices = (boundingBox) => {
    if (boundingBox.vertices) {
      return boundingBox.vertices;
    }
    if (boundingBox.normalizedVertices) {
      return boundingBox.normalizedVertices.map((v2) => ({
        x: (v2.x || 0) * pageWidth,
        y: (v2.y || 0) * pageHeight
      }));
    }
    throw new Error("No vertices found in bounding box.");
  };
  const pageDims = { width: pageWidth, height: pageHeight };
  const pageObj = new ocrObjects_default.OcrPage(n2, pageDims);
  if (!pageVision.blocks || pageVision.blocks.length === 0) {
    const warn = { char: "char_error" };
    return {
      pageObj,
      charMetricsObj: {},
      dataTables: new LayoutDataTablePage(n2),
      warn
    };
  }
  const tablesPage = new LayoutDataTablePage(n2);
  const angleRisePage = [];
  pageVision.blocks.forEach((block, blockIndex) => {
    if (!block.paragraphs) return;
    block.paragraphs.forEach((paragraph, paragraphIndex) => {
      const wordsVision = paragraph.words;
      if (!wordsVision || wordsVision.length === 0) return;
      const parVertices = getVertices(paragraph.boundingBox);
      const xsPar = parVertices.map((v2) => v2.x || 0);
      const ysPar = parVertices.map((v2) => v2.y || 0);
      const bboxPar = {
        left: Math.min(...xsPar),
        top: Math.min(...ysPar),
        right: Math.max(...xsPar),
        bottom: Math.max(...ysPar)
      };
      const parObj = new ocrObjects_default.OcrPar(pageObj, bboxPar);
      parObj.reason = String(block.blockType || "TEXT");
      let lineObj = new ocrObjects_default.OcrLine(pageObj, null, [0, 0]);
      let lineIndex = 0;
      wordsVision.forEach((word, wordIndex) => {
        if (!word.symbols || word.symbols.length === 0) return;
        const wordVertices = getVertices(word.boundingBox);
        const xs = wordVertices.map((v2) => v2.x || 0);
        const ys = wordVertices.map((v2) => v2.y || 0);
        const bboxWord = {
          left: Math.min(...xs),
          top: Math.min(...ys),
          right: Math.max(...xs),
          bottom: Math.max(...ys)
        };
        const id = `word_${n2 + 1}_${blockIndex + 1}_${paragraphIndex + 1}_${lineIndex + 1}_${wordIndex + 1}`;
        const wordText = word.symbols.map((symbol) => symbol.text || "").join("");
        const incChars = false;
        let charObjs = (
          /** @type {?OcrChar[]} */
          null
        );
        if (incChars) {
          charObjs = [];
          if (word.symbols) {
            word.symbols.forEach((symbol) => {
              const charVertices = getVertices(symbol.boundingBox);
              const charXs = charVertices.map((v2) => v2.x || 0);
              const charYs = charVertices.map((v2) => v2.y || 0);
              const charBbox = {
                left: Math.min(...charXs),
                top: Math.min(...charYs),
                right: Math.max(...charXs),
                bottom: Math.max(...charYs)
              };
              const charObj = new ocrObjects_default.OcrChar(symbol.text || "", charBbox);
              charObjs.push(charObj);
            });
          }
        }
        const wordObj = new ocrObjects_default.OcrWord(lineObj, id, wordText, bboxWord);
        wordObj.conf = (word.confidence || 0) * 100;
        wordObj.chars = charObjs;
        lineObj.words.push(wordObj);
        const hasLineBreak = word.symbols.some((symbol) => {
          const breakType = symbol.property?.detectedBreak?.type;
          return breakType === "LINE_BREAK" || breakType === "EOL_SURE_SPACE";
        });
        if (hasLineBreak || wordIndex === wordsVision.length - 1) {
          if (lineObj.words.length > 0) {
            const wordBboxes = lineObj.words.map((w2) => w2.bbox);
            lineObj.bbox = calcBboxUnion(wordBboxes);
            calculateTextMetrics(lineObj);
            pageObj.lines.push(lineObj);
            parObj.lines.push(lineObj);
            lineObj.par = parObj;
            lineIndex++;
          }
          if (wordIndex !== wordsVision.length - 1) {
            lineObj = new ocrObjects_default.OcrLine(pageObj, null, [0, 0]);
          }
        }
      });
      if (parObj.lines.length > 0) {
        pageObj.pars.push(parObj);
      }
    });
  });
  pageObj.lines.forEach((line) => {
    const wordBoxArr = line.words.map((x2) => x2.bbox);
    line.bbox = calcBboxUnion(wordBoxArr);
  });
  const angleRiseMedian = mean50(angleRisePage) || 0;
  const angleOut = Math.asin(angleRiseMedian) * (180 / Math.PI);
  pageObj.angle = angleOut;
  pageObj.textSource = "google_vision";
  const langSet = pass3(pageObj);
  return { pageObj, dataTables: tablesPage, langSet };
}
function calculateTextMetrics(lineObj) {
  const descCharRegex = new RegExp(`[${descCharArr.join("")}]`);
  const ascCharRegex = new RegExp(`[${ascCharArr.join("")}]`);
  const xCharRegex = new RegExp(`[${xCharArr.join("")}]`);
  const xOnlyWords = (
    /** @type {OcrWord[]} */
    []
  );
  const ascOnlyWords = (
    /** @type {OcrWord[]} */
    []
  );
  lineObj.words.forEach((word) => {
    if (word.text && xCharRegex.test(word.text) && !ascCharRegex.test(word.text) && !descCharRegex.test(word.text) && !/[fi]/.test(word.text)) {
      xOnlyWords.push(word);
    }
    if (word.text && ascCharRegex.test(word.text) && !descCharRegex.test(word.text)) {
      ascOnlyWords.push(word);
    }
  });
  let xHeight = null;
  if (xOnlyWords.length > 0) {
    xHeight = mean50(xOnlyWords.map((word) => word.bbox.bottom - word.bbox.top));
  }
  const ascHeight = ascOnlyWords.length > 0 ? mean50(ascOnlyWords.map((word) => word.bbox.bottom - word.bbox.top)) : null;
  if (xHeight && ascHeight && xHeight > ascHeight * 0.8) {
    if (ascOnlyWords.length > xOnlyWords.length) {
      xHeight = null;
    }
  }
  if (xHeight && xHeight > 0) lineObj.xHeight = xHeight;
  if (ascHeight && ascHeight > 0) lineObj.ascHeight = ascHeight;
}

// node_modules/scribe.js-ocr/js/import/convertPageText.js
var FONT_FAMILY = "Times New Roman";
var FONT_SIZE = 14;
var CHAR_SPACING = 0;
var WORD_SPACING = 0;
var LINE_HEIGHT = 14.4;
var MARGIN_VERTICAL = 30;
var MARGIN_HORIZONTAL = 20;
var fontOpentype = null;
function getTextWidth(text, size, font) {
  const { advanceArr, kerningArr } = calcWordCharMetrics(text, font);
  const advanceTotal = advanceArr.reduce((a2, b2) => a2 + b2, 0);
  const kerningTotal = kerningArr.reduce((a2, b2) => a2 + b2, 0);
  const wordLastGlyphMetrics = font.charToGlyph(text.at(-1)).getMetrics();
  const wordFirstGlyphMetrics = font.charToGlyph(text[0]).getMetrics();
  const wordLeftBearing = wordFirstGlyphMetrics.xMin || 0;
  const lastGlyphMax = wordLastGlyphMetrics.xMax || 0;
  const wordRightBearing = advanceArr[advanceArr.length - 1] - lastGlyphMax;
  const wordWidth1 = advanceTotal + kerningTotal - wordLeftBearing - wordRightBearing;
  const wordWidth1Px = wordWidth1 * (size / font.unitsPerEm);
  const spacingTotalPx = (text.length - 1) * CHAR_SPACING;
  const wordWidth = wordWidth1Px + spacingTotalPx;
  return wordWidth;
}
function splitIntoWords(line) {
  const words = [];
  let currentWord = "";
  let isInWhitespace = false;
  for (let i2 = 0; i2 < line.length; i2++) {
    const char = line[i2];
    const charIsWhitespace = /\s/.test(char);
    if (charIsWhitespace !== isInWhitespace) {
      if (currentWord.length > 0) {
        words.push({ text: currentWord, isWhitespace: isInWhitespace });
        currentWord = "";
      }
      isInWhitespace = charIsWhitespace;
    }
    currentWord += char;
  }
  if (currentWord.length > 0) {
    words.push({ text: currentWord, isWhitespace: isInWhitespace });
  }
  return words;
}
async function convertPageText({ textStr, pageDims = null }) {
  let pageIndex = 0;
  if (!fontOpentype) {
    fontOpentype = (await FontCont.getFont({ font: FONT_FAMILY })).opentype;
  }
  const ASCENDER_HEIGHT = fontOpentype.ascender * (FONT_SIZE / fontOpentype.unitsPerEm);
  const DESCENDER_HEIGHT = fontOpentype.descender * (FONT_SIZE / fontOpentype.unitsPerEm);
  const lines = textStr.split(/\r?\n/);
  if (!pageDims) {
    pageDims = { width: 612, height: 792 };
  }
  let pageObj = new ocrObjects_default.OcrPage(pageIndex, pageDims);
  pageObj.textSource = "text";
  if (lines.length === 0 || lines.every((line) => line.trim() === "")) {
    const warn = { char: "char_error" };
    return {
      pageObj,
      charMetricsObj: {},
      dataTables: new LayoutDataTablePage(0),
      warn
    };
  }
  let tablesPage = new LayoutDataTablePage(0);
  const pagesOut = [{ pageObj, dataTables: tablesPage }];
  const availableWidth = pageDims.width - MARGIN_HORIZONTAL * 2;
  let currentY = MARGIN_VERTICAL + LINE_HEIGHT / 2;
  for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
    const lineText = lines[lineIndex];
    if (lineText.length === 0 || lineText.trim().length === 0) {
      currentY += LINE_HEIGHT;
      if (currentY + FONT_SIZE > pageDims.height - MARGIN_VERTICAL) {
        pageIndex++;
        const newPage = new ocrObjects_default.OcrPage(pageIndex, pageDims);
        newPage.textSource = "text";
        const newTables = new LayoutDataTablePage(0);
        pagesOut.push({ pageObj: newPage, dataTables: newTables });
        pageObj = newPage;
        tablesPage = newTables;
        currentY = MARGIN_VERTICAL + LINE_HEIGHT / 2;
      }
      continue;
    }
    const wordTokens = splitIntoWords(lineText);
    const parLines = [];
    let parRight = MARGIN_HORIZONTAL;
    for (let idx = 0; idx < wordTokens.length; ) {
      if (currentY + FONT_SIZE > pageDims.height - MARGIN_VERTICAL) {
        if (parLines.length > 0) {
          const parBbox = {
            left: MARGIN_HORIZONTAL,
            top: parLines[0].bbox.top,
            right: parRight,
            bottom: parLines[parLines.length - 1].bbox.bottom
          };
          const parObj = new ocrObjects_default.OcrPar(pageObj, parBbox);
          parObj.lines = parLines;
          for (const ln2 of parLines) ln2.par = parObj;
          pageObj.pars.push(parObj);
          parLines.length = 0;
          parRight = MARGIN_HORIZONTAL;
        }
        pageIndex++;
        const newPage = new ocrObjects_default.OcrPage(pageIndex, pageDims);
        newPage.textSource = "text";
        const newTables = new LayoutDataTablePage(0);
        pagesOut.push({ pageObj: newPage, dataTables: newTables });
        pageObj = newPage;
        tablesPage = newTables;
        currentY = MARGIN_VERTICAL + LINE_HEIGHT / 2;
      }
      const baseline = [0, DESCENDER_HEIGHT];
      const lineTop = Math.round(currentY - ASCENDER_HEIGHT);
      const lineBottom = Math.round(currentY + DESCENDER_HEIGHT);
      let currentX = MARGIN_HORIZONTAL;
      let widthSoFar = 0;
      const lineBbox = {
        left: MARGIN_HORIZONTAL,
        top: lineTop,
        right: MARGIN_HORIZONTAL,
        bottom: lineBottom
      };
      const lineObj = new ocrObjects_default.OcrLine(
        pageObj,
        lineBbox,
        baseline,
        ASCENDER_HEIGHT,
        null
      );
      let lastConsumed = idx;
      for (let j2 = idx; j2 < wordTokens.length; j2++) {
        const tok = wordTokens[j2];
        let tokWidth = getTextWidth(tok.text, FONT_SIZE, fontOpentype);
        if (tok.isWhitespace) tokWidth += WORD_SPACING;
        if (tok.isWhitespace) {
          if (lineObj.words.length === 0) {
            if (widthSoFar + tokWidth > availableWidth) break;
            currentX += tokWidth;
            widthSoFar += tokWidth;
            lastConsumed = j2 + 1;
          } else {
            currentX += tokWidth;
            widthSoFar += tokWidth;
            lastConsumed = j2 + 1;
          }
        } else {
          if (lineObj.words.length > 0 && widthSoFar + tokWidth > availableWidth) {
            break;
          }
          const wordBbox = {
            left: Math.round(currentX),
            top: lineTop,
            right: Math.round(currentX + tokWidth),
            bottom: lineBottom
          };
          const wordId = `word_${pageIndex + 1}_${pageObj.lines.length + 1}_${lineObj.words.length + 1}`;
          const wordObj = new ocrObjects_default.OcrWord(lineObj, wordId, tok.text, wordBbox);
          wordObj.conf = 100;
          wordObj.style.font = FONT_FAMILY;
          lineObj.words.push(wordObj);
          currentX += tokWidth;
          widthSoFar += tokWidth;
          lastConsumed = j2 + 1;
        }
      }
      if (lineObj.words.length === 0) {
        const nextTok = wordTokens[idx];
        if (nextTok && !nextTok.isWhitespace) {
          const tokWidth = getTextWidth(nextTok.text, FONT_SIZE, fontOpentype);
          const wordBbox = {
            left: Math.round(currentX),
            top: lineTop,
            right: Math.round(currentX + tokWidth),
            bottom: lineBottom
          };
          const wordId = `word_${pageIndex + 1}_${pageObj.lines.length + 1}_${lineObj.words.length + 1}`;
          const wordObj = new ocrObjects_default.OcrWord(lineObj, wordId, nextTok.text, wordBbox);
          wordObj.conf = 100;
          wordObj.style.font = FONT_FAMILY;
          lineObj.words.push(wordObj);
          currentX += tokWidth;
          widthSoFar += tokWidth;
          lastConsumed = idx + 1;
        } else {
          break;
        }
      }
      if (lineObj.words.length > 0) {
        lineObj.bbox = {
          left: lineObj.words[0].bbox.left,
          top: lineTop,
          right: Math.round(currentX),
          bottom: lineBottom
        };
        pageObj.lines.push(lineObj);
        parLines.push(lineObj);
        parRight = Math.max(parRight, lineObj.bbox.right);
        currentY += LINE_HEIGHT;
        idx = lastConsumed;
      }
    }
    if (parLines.length > 0) {
      const parBbox = {
        left: MARGIN_HORIZONTAL,
        top: parLines[0].bbox.top,
        right: parRight,
        bottom: parLines[parLines.length - 1].bbox.bottom
      };
      const parObj = new ocrObjects_default.OcrPar(pageObj, parBbox);
      parObj.lines = parLines;
      for (const ln2 of parLines) ln2.par = parObj;
      pageObj.pars.push(parObj);
    }
  }
  pageObj.angle = 0;
  return pagesOut;
}

// node_modules/scribe.js-ocr/js/objects/imageObjects.js
var getDims = (img) => {
  if (!img._dims) {
    if (img.format === "jpeg") {
      img._dims = getJpegDimensions(img.src);
    } else {
      img._dims = getPngDimensions(img.src);
    }
  }
  return img._dims;
};
var requiresUndo = (img, props) => {
  if (!props) return false;
  if (img.rotated && props.rotated === false) return true;
  if (img.upscaled && props.upscaled === false) return true;
  if (img.colorMode === "color" && props.colorMode === "gray" || img.colorMode === "gray" && props.colorMode === "color") return true;
  return false;
};
var compatible = (img, props, significantRotation) => {
  if (!props) return true;
  if (props.rotated === false && img.rotated === true) {
    return false;
  }
  if (props.rotated === true && img.rotated === false) {
    if (significantRotation) {
      return false;
    }
  }
  if (props.upscaled === true && img.upscaled === false || props.upscaled === false && img.upscaled === true) return false;
  if (props.colorMode && props.colorMode !== img.colorMode && img.colorMode !== "native" && img.colorMode !== "native") return false;
  return true;
};
var imageUtils = {
  getDims,
  requiresUndo,
  compatible
};

// node_modules/scribe.js-ocr/js/worker/compareOCRModule.js
async function drawWordActual(words, imageBinaryBit, angle) {
  if (!FontCont.raw) throw new Error("Fonts must be defined before running this function.");
  const lineFontSize = calcLineFontSize(words[0].line);
  const fontI = FontCont.getWordFont(words[0]);
  const fontOpentypeI = fontI.opentype;
  const fontAscApprox = fontOpentypeI.charToGlyph("A").getMetrics().yMax * 1.1;
  const fontDescApprox = fontOpentypeI.charToGlyph("j").getMetrics().yMin * 1.1;
  const fontDesc = Math.round(fontDescApprox * (lineFontSize / 1e3));
  const fontAsc = Math.round(fontAscApprox * (lineFontSize / 1e3));
  const sinAngle = Math.sin(angle * (Math.PI / 180));
  const cosAngle = Math.cos(angle * (Math.PI / 180));
  const wordsBox = words.map((x2) => x2.bbox);
  const wordBoxUnion = {
    left: Math.min(...wordsBox.map((x2) => x2.left)),
    top: Math.min(...wordsBox.map((x2) => x2.top)),
    right: Math.max(...wordsBox.map((x2) => x2.right)),
    bottom: Math.max(...wordsBox.map((x2) => x2.bottom))
  };
  const lineObj = words[0].line;
  const linebox = words[0].line.bbox;
  const { baseline } = words[0].line;
  const imageRotated = angle !== 0;
  const angleAdjLine = imageRotated ? ocrObjects_default.calcLineStartAngleAdj(lineObj) : { x: 0, y: 0 };
  const start = linebox.left + angleAdjLine.x + (wordBoxUnion.left - linebox.left) / cosAngle;
  const height = Math.round(fontAsc - fontDesc);
  const width = Math.round(wordBoxUnion.right - wordBoxUnion.left + 1);
  const cropY = linebox.bottom + baseline[1] - fontAsc - 1;
  const cropYAdj = cropY + angleAdjLine.y;
  const canvas = await ca.createCanvas(width, height);
  const ctx = (
    /** @type {OffscreenCanvasRenderingContext2D} */
    canvas.getContext("2d")
  );
  ctx.drawImage(imageBinaryBit, start - 1, cropYAdj, width, height, 0, 0, width, height);
  return {
    canvas,
    cropY,
    width,
    height
  };
}
var printWordOnCanvas = async ({
  ctx,
  charArr,
  left,
  bottom,
  advanceArr,
  font,
  size,
  smallCaps,
  fillStyle = "black"
}) => {
  ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${size}px ${font.fontFaceName}`;
  ctx.fillStyle = fillStyle;
  ctx.textBaseline = "alphabetic";
  let leftI = left;
  for (let i2 = 0; i2 < charArr.length; i2++) {
    let charI = charArr[i2];
    if (smallCaps) {
      if (charI === charI.toUpperCase()) {
        ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${size}px ${font.fontFaceName}`;
      } else {
        charI = charI.toUpperCase();
        ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${size * font.smallCapsMult}px ${font.fontFaceName}`;
      }
    }
    ctx.fillText(charI, leftI, bottom);
    leftI += advanceArr[i2];
  }
};
var drawWordRender = async (ctx, word, offsetX = 0, cropY = 0, ctxView = null, imageRotated = false) => {
  if (!FontCont.raw) throw new Error("Fonts must be defined before running this function.");
  if (!ctx) throw new Error("Canvases must be defined before running this function.");
  const fontI = FontCont.getWordFont(word);
  let baselineY = word.line.bbox.bottom + word.line.baseline[1];
  const wordMetrics = calcWordMetrics(word);
  const advanceArr = wordMetrics.advanceArr;
  const kerningArr = wordMetrics.kerningArr;
  const charSpacing = wordMetrics.charSpacing;
  const wordFontSize = wordMetrics.fontSize;
  if (word.style.sup) {
    const wordboxXMid = word.bbox.left + (word.bbox.right - word.bbox.left) / 2;
    const baselineYWord = word.line.bbox.bottom + word.line.baseline[1] + word.line.baseline[0] * (wordboxXMid - word.line.bbox.left);
    baselineY -= baselineYWord - word.bbox.bottom;
    if (!word.visualCoords) {
      const fontDesc = fontI.opentype.descender / fontI.opentype.unitsPerEm * wordMetrics.fontSize;
      baselineY += fontDesc;
    }
  } else if (!imageRotated) {
    const wordboxXMid = word.bbox.left + (word.bbox.right - word.bbox.left) / 2;
    baselineY = word.line.bbox.bottom + word.line.baseline[1] + word.line.baseline[0] * (wordboxXMid - word.line.bbox.left);
  }
  const y2 = baselineY - cropY;
  const advanceArrTotal = [];
  for (let i2 = 0; i2 < advanceArr.length; i2++) {
    let leftI = 0;
    leftI += advanceArr[i2] || 0;
    leftI += kerningArr[i2] || 0;
    leftI += charSpacing || 0;
    advanceArrTotal.push(leftI);
  }
  let left = 1 + offsetX;
  if (word.visualCoords) left -= wordMetrics.leftSideBearing;
  await printWordOnCanvas({
    ctx,
    charArr: wordMetrics.charArr,
    left,
    bottom: y2,
    advanceArr: advanceArrTotal,
    font: fontI,
    size: wordFontSize,
    smallCaps: word.style.smallCaps
  });
  if (ctxView) {
    await printWordOnCanvas({
      ctx: ctxView,
      charArr: wordMetrics.charArr,
      left,
      bottom: y2,
      advanceArr: advanceArrTotal,
      font: fontI,
      size: wordFontSize,
      smallCaps: word.style.smallCaps,
      fillStyle: "red"
    });
  }
};
async function evalWords({
  wordsA,
  wordsB = [],
  binaryImage,
  angle,
  options = {}
}) {
  let anyChinese = false;
  wordsA.forEach((x2) => {
    if (x2.lang === "chi_sim") anyChinese = true;
  });
  wordsB.forEach((x2) => {
    if (x2.lang === "chi_sim") anyChinese = true;
  });
  if (wordsA[0].line.words[0].lang === "chi_sim") anyChinese = true;
  if (wordsB[0] && wordsB[0].line.words[0].lang === "chi_sim") anyChinese = true;
  if (anyChinese) return { metricA: 1, metricB: 0, debug: null };
  const binaryImageBit = await ca.getImageBitmap(binaryImage);
  if (!FontCont.raw) throw new Error("Fonts must be defined before running this function.");
  const view = options?.view === void 0 ? false : options?.view;
  const useABaseline = options?.useABaseline === void 0 ? true : options?.useABaseline;
  const cosAngle = Math.cos(angle * -1 * (Math.PI / 180)) || 1;
  const linebox = wordsA[0].line.bbox;
  const baselineA = wordsA[0].line.baseline;
  const {
    canvas,
    cropY,
    width,
    height
  } = await drawWordActual([...wordsA, ...wordsB], binaryImageBit, angle);
  const ctx = (
    /** @type {OffscreenCanvasRenderingContext2D} */
    canvas.getContext("2d")
  );
  const imageDataActual = ctx.getImageData(0, 0, width, height).data;
  let canvasView0;
  let ctxView0;
  let canvasView1;
  let ctxView1;
  let canvasView2;
  let ctxView2;
  if (view) {
    let img;
    if (typeof process === "undefined") {
      img = canvas;
    } else {
      img = ca.CanvasKit.MakeImage({
        width,
        height,
        alphaType: ca.CanvasKit.AlphaType.Unpremul,
        colorType: ca.CanvasKit.ColorType.RGBA_8888,
        colorSpace: ca.CanvasKit.ColorSpace.SRGB
      }, imageDataActual, 4 * width);
    }
    canvasView0 = await ca.createCanvas(width, height);
    ctxView0 = /** @type {OffscreenCanvasRenderingContext2D} */
    canvasView0.getContext("2d");
    ctxView0.drawImage(img, 0, 0);
    canvasView1 = await ca.createCanvas(width, height);
    ctxView1 = /** @type {OffscreenCanvasRenderingContext2D} */
    canvasView1.getContext("2d");
    ctxView1.drawImage(img, 0, 0);
    if (wordsB.length > 0) {
      canvasView2 = await ca.createCanvas(width, height);
      ctxView2 = /** @type {OffscreenCanvasRenderingContext2D} */
      canvasView2.getContext("2d");
      ctxView2.drawImage(img, 0, 0);
    }
  }
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, width, height);
  let x0 = wordsA[0].bbox.left;
  const y0 = linebox.bottom + baselineA[1] + baselineA[0] * (wordsA[0].bbox.left - linebox.left);
  for (let i2 = 0; i2 < wordsA.length; i2++) {
    const word = wordsA[i2];
    const wordIBox = word.bbox;
    const offsetX = (wordIBox.left - x0) / cosAngle;
    await drawWordRender(ctx, word, offsetX, cropY, ctxView1, Boolean(angle));
  }
  const imageDataExpectedA = ctx.getImageData(0, 0, width, height).data;
  if (imageDataActual.length !== imageDataExpectedA.length) {
    console.log("Actual and expected images are different sizes");
    debugger;
  }
  let diffA = 0;
  let totalA = 0;
  let lastMatch = false;
  for (let i2 = 0; i2 < imageDataActual.length; i2++) {
    if (imageDataActual[i2] !== 255 || imageDataExpectedA[i2] !== 255) {
      totalA += 1;
      if (imageDataActual[i2] === 255 || imageDataExpectedA[i2] === 255) {
        if (lastMatch) {
          diffA += 0.5;
        } else {
          diffA += 1;
        }
        lastMatch = false;
      } else {
        lastMatch = true;
      }
    }
  }
  const metricA = diffA / totalA;
  let metricB = 1;
  if (wordsB.length > 0) {
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, width, height);
    for (let i2 = 0; i2 < wordsB.length; i2++) {
      const word = ocrObjects_default.cloneWord(wordsB[i2]);
      word.style = { ...wordsA[0].style };
      if (i2 === 0) {
        x0 = word.bbox.left;
      }
      const offsetX = (word.bbox.left - x0) / cosAngle;
      await drawWordRender(ctx, word, offsetX, cropY, ctxView2, Boolean(angle));
    }
    const imageDataExpectedB = ctx.getImageData(0, 0, width, height).data;
    ctx.clearRect(0, 0, width, height);
    let diffB = 0;
    let totalB = 0;
    let lastMatch2 = false;
    for (let i2 = 0; i2 < imageDataActual.length; i2++) {
      if (imageDataActual[i2] !== 255 || imageDataExpectedB[i2] !== 255) {
        totalB += 1;
        if (imageDataActual[i2] === 255 || imageDataExpectedB[i2] === 255) {
          if (lastMatch2) {
            diffB += 0.5;
          } else {
            diffB += 1;
          }
          lastMatch2 = false;
        } else {
          lastMatch2 = true;
        }
      }
    }
    metricB = diffB / totalB;
  }
  let debugImg = null;
  if (view) {
    if (typeof process === "undefined") {
      let imageRaw;
      let imageA;
      let imageB;
      if (canvasView0) imageRaw = await canvasView0.convertToBlob();
      if (canvasView1) imageA = await canvasView1.convertToBlob();
      if (canvasView2) imageB = await canvasView2.convertToBlob();
      const dims = { width, height };
      debugImg = {
        context: "browser",
        imageRaw,
        imageA,
        imageB,
        dims,
        errorRawA: metricA,
        errorRawB: metricB,
        errorAdjA: null,
        errorAdjB: null
      };
    } else {
      let imageRaw;
      let imageA;
      let imageB;
      if (canvasView0) imageRaw = canvasView0.toDataURL("image/png");
      if (canvasView1) imageA = canvasView1.toDataURL("image/png");
      if (canvasView2) imageB = canvasView2.toDataURL("image/png");
      const dims = { width, height };
      debugImg = {
        context: "node",
        imageRaw,
        imageA,
        imageB,
        dims,
        errorRawA: metricA,
        errorRawB: metricB,
        errorAdjA: null,
        errorAdjB: null
      };
    }
  }
  if (typeof process !== "undefined") {
    canvas.dispose();
    if (canvasView0) canvasView0.dispose();
    if (canvasView1) canvasView1.dispose();
    if (canvasView2) canvasView2.dispose();
  }
  return { metricA, metricB, debug: debugImg };
}
function rejectWordLegacy(legacyText, lstmText) {
  const replaceNum = /[a-z]\d[a-z]/i.test(legacyText) && !/[a-z]\d[a-z]/i.test(lstmText);
  const replaceII = /[a-hj-z]ii[a-hj-z]/i.test(legacyText) && !/[a-hj-z]ii[a-hj-z]/i.test(lstmText);
  return replaceNum || replaceII;
}
async function penalizeWord(wordObjs) {
  const wordStr = wordObjs.map((x2) => x2.text).join("");
  let penalty = 0;
  if (/[^0-9]%/.test(wordStr)) penalty += 0.05;
  if (/ii/.test(wordStr)) penalty += 0.05;
  if (/^m$/.test(wordStr)) penalty += 0.05;
  if (/[a-z]\d[a-z]/i.test(wordStr)) penalty += 0.05;
  if (/^\]./.test(wordStr)) penalty += 0.05;
  if (wordObjs.length === 1 && /^[a-z][.,-]$/i.test(wordStr)) {
    const word = wordObjs[0];
    const wordTextArr = wordStr.split("");
    const wordFontSize = calcLineFontSize(word.line);
    const fontI = FontCont.getWordFont(word);
    const fontOpentypeI = fontI.opentype;
    const glyphFirstMetrics = fontOpentypeI.charToGlyph(wordTextArr[0]).getMetrics();
    const widthFirst = (glyphFirstMetrics.xMax - glyphFirstMetrics.xMin) / fontOpentypeI.unitsPerEm * wordFontSize;
    const glyphSecondMetrics = fontOpentypeI.charToGlyph(wordTextArr[1]).getMetrics();
    const widthSecond = (glyphSecondMetrics.xMax - glyphSecondMetrics.xMin) / fontOpentypeI.unitsPerEm * wordFontSize;
    const widthTotal = widthFirst + widthSecond;
    const wordWidth = word.bbox.right - word.bbox.left;
    if (widthFirst >= wordWidth * 0.9 && widthTotal > wordWidth * 1.15) penalty += 0.05;
  }
  return penalty;
}
async function compareOCRPageImp({
  pageA,
  pageB,
  binaryImage,
  pageMetricsObj,
  options = {}
}) {
  let binaryImageBit = null;
  let imageUpscaled = false;
  let imageRotated = false;
  if (binaryImage) {
    binaryImageBit = binaryImage.imageBitmap || await ca.getImageBitmap(binaryImage.src);
    imageUpscaled = binaryImage.upscaled;
    imageRotated = binaryImage.rotated;
  }
  const mode = options?.mode === void 0 ? "stats" : options?.mode;
  const editConf = options?.editConf === void 0 ? false : options?.editConf;
  const legacyLSTMComb = options?.legacyLSTMComb === void 0 ? false : options?.legacyLSTMComb;
  const useBboxB = options?.useBboxB === void 0 ? false : options?.useBboxB;
  const debugLabel = options?.debugLabel === void 0 ? "" : options?.debugLabel;
  const evalConflicts = options?.evalConflicts === void 0 ? true : options?.evalConflicts;
  const supplementComp = options?.supplementComp === void 0 ? false : options?.supplementComp;
  const tessWorker = options?.tessWorker === void 0 ? null : options?.tessWorker;
  const ignorePunct = options?.ignorePunct === void 0 ? false : options?.ignorePunct;
  const ignoreCap = options?.ignoreCap === void 0 ? false : options?.ignoreCap;
  const confThreshHigh = options?.confThreshHigh === void 0 ? 85 : options?.confThreshHigh;
  const confThreshMed = options?.confThreshMed === void 0 ? 75 : options?.confThreshMed;
  if (supplementComp && !tessWorker) console.log("`supplementComp` enabled, but no scheduler was provided. This step will be skipped.");
  if (typeof WorkerGlobalScope === "undefined") {
    pageA = structuredClone(pageA);
    pageB = structuredClone(pageB);
  }
  const imgAngle = imageRotated ? pageMetricsObj.angle || 0 : 0;
  if (imageUpscaled) {
    ocrObjects_default.scalePage(pageA, 2);
    ocrObjects_default.scalePage(pageB, 2);
  }
  const debugImg = [];
  const hocrAOverlap = {};
  const hocrBOverlap = {};
  const hocrBOverlapAWords = {};
  const hocrACorrect = {};
  const hocrBCorrect = {};
  ocrObjects_default.getPageWords(pageA).forEach((x2) => {
    x2.compTruth = false;
    x2.matchTruth = false;
  });
  const pageAInt = structuredClone(pageA);
  if (mode === "comb") {
    ocrObjects_default.getPageWords(pageAInt).forEach((x2) => {
      x2.conf = 0;
    });
  }
  for (let i2 = 0; i2 < pageAInt.lines.length; i2++) {
    const lineA = pageAInt.lines[i2];
    const lineBoxA = lineA.bbox;
    let lineWordsEditedNew = 0;
    let lineBReplace = null;
    for (let j2 = 0; j2 < pageB.lines.length; j2++) {
      const lineB = pageB.lines[j2];
      const lineBoxB = lineB.bbox;
      if (lineBoxA.top > lineBoxB.bottom) {
        continue;
      } else if (lineBoxB.top > lineBoxA.bottom) {
        continue;
      } else {
        let minWordB = 0;
        for (let k2 = 0; k2 < lineA.words.length; k2++) {
          const wordA = lineA.words[k2];
          if (ignorePunct && !wordA.text.replace(/[\W_]/g, "")) {
            wordA.compTruth = true;
            wordA.matchTruth = true;
            if (mode === "comb") wordA.conf = 100;
            hocrACorrect[wordA.id] = 1;
          }
          const wordBoxA = wordA.bbox;
          const wordBoxAHeight = wordBoxA.bottom - wordBoxA.top;
          const wordBoxACore = JSON.parse(JSON.stringify(wordBoxA));
          if (wordA.visualCoords) {
            wordBoxACore.top = wordBoxA.top + Math.round(wordBoxAHeight * 0.1);
            wordBoxACore.bottom = wordBoxA.bottom - Math.round(wordBoxAHeight * 0.1);
          } else {
            wordBoxACore.top = wordBoxA.top + Math.round(wordBoxAHeight * 0.25);
            wordBoxACore.bottom = wordBoxA.bottom - Math.round(wordBoxAHeight * 0.25);
          }
          for (let l2 = minWordB; l2 < lineB.words.length; l2++) {
            const wordB = lineB.words[l2];
            const wordBoxB = wordB.bbox;
            const wordBoxBHeight = wordBoxB.bottom - wordBoxB.top;
            const wordBoxBCore = JSON.parse(JSON.stringify(wordBoxB));
            if (wordB.visualCoords) {
              wordBoxBCore.top = wordBoxB.top + Math.round(wordBoxBHeight * 0.1);
              wordBoxBCore.bottom = wordBoxB.bottom - Math.round(wordBoxBHeight * 0.1);
            } else {
              wordBoxBCore.top = wordBoxB.top + Math.round(wordBoxBHeight * 0.25);
              wordBoxBCore.bottom = wordBoxB.bottom - Math.round(wordBoxBHeight * 0.25);
            }
            if (wordBoxACore.left > wordBoxBCore.right) {
              minWordB += 1;
              continue;
            } else if (wordBoxBCore.left > wordBoxACore.right) {
              continue;
            } else {
              if (wordBoxACore.top > wordBoxBCore.bottom || wordBoxBCore.top > wordBoxACore.bottom) {
                continue;
              }
              wordA.compTruth = true;
              let wordTextA = ocrObjects_default.replaceLigatures(wordA.text);
              let wordTextB = ocrObjects_default.replaceLigatures(wordB.text);
              if (ignorePunct) {
                wordTextA = wordTextA.replace(/(^|\D)[\W_]($|\D)/g, "$1$2");
                wordTextB = wordTextB.replace(/(^|\D)[\W_]($|\D)/g, "$1$2");
              }
              if (ignoreCap) {
                wordTextA = wordTextA.toLowerCase();
                wordTextB = wordTextB.toLowerCase();
              }
              hocrAOverlap[wordA.id] = 1;
              hocrBOverlap[wordB.id] = 1;
              if (!hocrBOverlapAWords[wordB.id]) hocrBOverlapAWords[wordB.id] = {};
              hocrBOverlapAWords[wordB.id][wordA.id] = 1;
              if (wordTextA === wordTextB) {
                wordA.compTruth = true;
                wordA.matchTruth = true;
                if (mode === "comb") wordA.conf = 100;
                hocrACorrect[wordA.id] = 1;
                hocrBCorrect[wordB.id] = 1;
                if (mode === "comb" && useBboxB) {
                  wordA.bbox = structuredClone(wordB.bbox);
                  wordA.visualCoords = true;
                  wordA.chars = structuredClone(wordB.chars);
                }
              } else if (mode === "comb") {
                wordA.conf = 0;
                wordA.matchTruth = false;
                let oneToOne = Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxB.right - wordBoxA.right) < (wordBoxA.right - wordBoxA.left) * 0.1;
                const wordBNext = lineB.words[l2 + 1];
                const wordBNext2 = lineB.words[l2 + 2];
                const wordBNext3 = lineB.words[l2 + 3];
                if (oneToOne && legacyLSTMComb) {
                  if (wordBNext3 && wordBNext3.text.length > 2) {
                    const wordBoxBNext3 = wordBNext3.bbox;
                    if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxA.right - wordBoxBNext3.right) < (wordBoxBNext3.right - wordBoxA.left) * 0.1) oneToOne = false;
                  }
                  if (wordBNext2 && wordBNext2.text.length > 2) {
                    const wordBoxBNext2 = wordBNext2.bbox;
                    if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxA.right - wordBoxBNext2.right) < (wordBoxBNext2.right - wordBoxA.left) * 0.1) oneToOne = false;
                  }
                  if (wordBNext && wordBNext.text.length > 2) {
                    const wordBoxBNext = wordBNext.bbox;
                    if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxA.right - wordBoxBNext.right) < (wordBoxBNext.right - wordBoxA.left) * 0.1) oneToOne = false;
                  }
                }
                let twoToOne = false;
                const wordsAArr = [];
                let wordsBArr = [];
                if (!oneToOne) {
                  if (wordBoxA.right < wordBoxB.right) {
                    const wordANext = lineA.words[k2 + 1];
                    if (wordANext) {
                      const wordBoxANext = wordANext.bbox;
                      if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxB.right - wordBoxANext.right) < (wordBoxANext.right - wordBoxA.left) * 0.1) {
                        twoToOne = true;
                        wordsAArr.push(wordA);
                        wordsAArr.push(wordANext);
                        wordsBArr.push(wordB);
                        wordANext.conf = 0;
                        wordANext.compTruth = true;
                        wordANext.matchTruth = false;
                      }
                    }
                  } else {
                    if (wordBNext3) {
                      const wordBoxBNext3 = wordBNext3.bbox;
                      if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxA.right - wordBoxBNext3.right) < (wordBoxBNext3.right - wordBoxA.left) * 0.1) {
                        twoToOne = true;
                        wordsAArr.push(wordA);
                        wordsBArr.push(wordB);
                        wordsBArr.push(wordBNext);
                        wordsBArr.push(wordBNext2);
                        wordsBArr.push(wordBNext3);
                      }
                    }
                    if (wordBNext2 && !twoToOne) {
                      const wordBoxBNext2 = wordBNext2.bbox;
                      if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxA.right - wordBoxBNext2.right) < (wordBoxBNext2.right - wordBoxA.left) * 0.1) {
                        twoToOne = true;
                        wordsAArr.push(wordA);
                        wordsBArr.push(wordB);
                        wordsBArr.push(wordBNext);
                        wordsBArr.push(wordBNext2);
                      }
                    }
                    if (wordBNext && !twoToOne) {
                      const wordBoxBNext = wordBNext.bbox;
                      if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxA.right - wordBoxBNext.right) < (wordBoxBNext.right - wordBoxA.left) * 0.1) {
                        twoToOne = true;
                        wordsAArr.push(wordA);
                        wordsBArr.push(wordB);
                        wordsBArr.push(wordBNext);
                      }
                    }
                    if (twoToOne && legacyLSTMComb) {
                      const wordsAText = wordsAArr.map((x2) => x2.text).join("");
                      const wordsBText = wordsBArr.map((x2) => x2.text).join("");
                      if (wordsAArr.length === 1 && wordsAArr[0]?.chars?.length === wordsAText.length && wordsAText.length === wordsBText.length) {
                        const match = wordsAText === wordsBText;
                        const match1 = wordsAArr[0].text.substring(0, wordsBArr[0].text.length) === wordsBArr[0].text;
                        const match2 = wordsAArr[0].text.substring(wordsBArr[0].text.length, wordsBArr[0].text.length + wordsBArr[1].text.length) === wordsBArr[1].text;
                        if (match || wordsBArr.length === 2 && (match1 || match2)) {
                          wordsBArr = wordsBArr.map((x2) => ocrObjects_default.cloneWord(x2));
                          wordsBArr[0].chars = wordsAArr[0].chars.slice(0, wordsBArr[0].text.length).map((x2) => ocrObjects_default.cloneChar(x2));
                          wordsBArr[1].chars = wordsAArr[0].chars.slice(wordsBArr[0].text.length, wordsBArr[0].text.length + wordsBArr[1].text.length).map((x2) => ocrObjects_default.cloneChar(x2));
                          if (wordsBArr[2]) {
                            wordsBArr[2].chars = wordsAArr[0].chars.slice(
                              wordsBArr[0].text.length + wordsBArr[1].text.length,
                              wordsBArr[0].text.length + wordsBArr[1].text.length + wordsBArr[2].text.length
                            ).map((x2) => ocrObjects_default.cloneChar(x2));
                          }
                          if (wordsBArr[3]) {
                            wordsBArr[3].chars = wordsAArr[0].chars.slice(
                              wordsBArr[0].text.length + wordsBArr[1].text.length + wordsBArr[2].text.length,
                              wordsBArr[0].text.length + wordsBArr[1].text.length + wordsBArr[2].text.length + wordsBArr[3].text.length
                            ).map((x2) => ocrObjects_default.cloneChar(x2));
                          }
                          if (!match) {
                            wordsBArr[0].chars.forEach((x2, i3) => x2.text = wordsBArr[0].text[i3]);
                            wordsBArr[1].chars.forEach((x2, i3) => x2.text = wordsBArr[1].text[i3]);
                            if (wordsBArr[2]) wordsBArr[2].chars.forEach((x2, i3) => x2.text = wordsBArr[2].text[i3]);
                          }
                          for (const word of wordsBArr) {
                            word.bbox = ocrObjects_default.calcBboxUnion(word.chars.map((x2) => x2.bbox));
                          }
                        }
                      }
                    }
                  }
                }
                if (!oneToOne && !twoToOne) {
                  continue;
                }
                let hocrAError = 1;
                let hocrBError = 1;
                let hocrAAltError = 1;
                if (!evalConflicts) {
                  hocrBError = 0;
                } else if (oneToOne) {
                  if (legacyLSTMComb && rejectWordLegacy(wordA.text, wordB.text)) {
                    hocrBError = 0;
                  } else if (legacyLSTMComb && wordA.textAlt && wordA.textAlt === wordB.text) {
                    hocrBError = 0;
                  } else {
                    const wordAClone = ocrObjects_default.cloneWord(wordA);
                    wordAClone.text = wordB.text;
                    if (wordB.style.smallCaps && !wordA.style.smallCaps) {
                      wordAClone.style.smallCaps = true;
                      wordAClone.style.size = calcWordFontSize(wordB);
                    }
                    const evalRes = await evalWords({
                      wordsA: [wordA],
                      wordsB: [wordAClone],
                      binaryImage: binaryImageBit,
                      angle: imgAngle,
                      options: { view: Boolean(debugLabel) }
                    });
                    hocrAError = evalRes.metricA + await penalizeWord([wordA]);
                    hocrBError = evalRes.metricB + await penalizeWord([wordB]);
                    if (legacyLSTMComb && rejectWordLegacy(wordA.text, wordB.text)) hocrBError = 0;
                    if (legacyLSTMComb && hocrAError > 0.5 && hocrBError > 0.5 && wordA.textAlt && wordA.textAlt !== wordB.text) {
                      wordAClone.text = wordA.textAlt;
                      const evalResAlt = await evalWords({
                        wordsA: [wordAClone],
                        binaryImage: binaryImageBit,
                        angle: imgAngle,
                        options: { view: Boolean(debugLabel) }
                      });
                      hocrAAltError = evalResAlt.metricA + await penalizeWord([wordAClone]);
                      if (hocrAAltError >= 0.5 || hocrAError - hocrAAltError < 0.1 || hocrBError - hocrAAltError < 0.1) hocrAAltError = 1;
                    }
                    if (evalRes.debug) {
                      const debugObj = evalRes.debug;
                      debugObj.errorAdjA = hocrAError;
                      debugObj.errorAdjB = hocrBError;
                      debugImg.push(debugObj);
                    }
                  }
                } else if (twoToOne) {
                  const wordsAText = wordsAArr.map((x2) => x2.text).join("");
                  const wordsBText = wordsBArr.map((x2) => x2.text).join("");
                  if (legacyLSTMComb && rejectWordLegacy(wordsAText, wordsBText)) {
                    hocrBError = 0;
                  } else {
                    const evalRes = await evalWords({
                      wordsA: wordsAArr,
                      wordsB: wordsBArr,
                      binaryImage: binaryImageBit,
                      angle: imgAngle,
                      options: { view: Boolean(debugLabel) }
                    });
                    hocrAError = evalRes.metricA + (wordsAArr.length - 1) * 0.025 + await penalizeWord(wordsAArr);
                    hocrBError = evalRes.metricB + (wordsBArr.length - 1) * 0.025 + await penalizeWord(wordsBArr);
                    if (wordsAText === wordsBText) {
                      if (wordsAArr.map((x2) => /[a-z]/i.test(x2.text)).filter((x2) => !x2).length > 0 || wordsBArr.map((x2) => /[a-z]/i.test(x2.text)).filter((x2) => !x2).length > 0) {
                        hocrAError += (wordsAArr.length - 1) * 0.05;
                        hocrBError += (wordsBArr.length - 1) * 0.05;
                      }
                    }
                    if (legacyLSTMComb && rejectWordLegacy(wordsAText, wordsBText)) hocrBError = 0;
                    if (evalRes.debug) {
                      const debugObj = evalRes.debug;
                      debugObj.errorAdjA = hocrAError;
                      debugObj.errorAdjB = hocrBError;
                      debugImg.push(debugObj);
                    }
                  }
                }
                if (hocrBError < hocrAError && hocrBError < hocrAAltError || legacyLSTMComb && hocrAError > 0.5 && hocrAAltError > 0.5) {
                  const skip = ["eg", "ie"].includes(wordA.text.replace(/\W/g, ""));
                  if (!skip) {
                    if (oneToOne) {
                      lineWordsEditedNew += 1;
                      lineBReplace = lineB;
                      wordA.text = wordB.text;
                      wordA.chars = null;
                      if (wordB.style.smallCaps) wordA.style.smallCaps = true;
                    } else {
                      const wordsBArrRep = wordsBArr.map((x2) => ocrObjects_default.cloneWord(x2));
                      lineWordsEditedNew += wordsBArrRep.length;
                      lineBReplace = lineB;
                      wordsBArrRep.forEach((x2) => {
                        if (legacyLSTMComb) {
                          x2.style = { ...wordA.style };
                        }
                        x2.conf = 0;
                        x2.chars = null;
                        x2.compTruth = true;
                        x2.matchTruth = false;
                        x2.line = lineA;
                        x2.id += "b";
                      });
                      lineA.words.splice(k2, wordsAArr.length, ...wordsBArrRep);
                      k2 = k2 + wordsBArrRep.length - 1;
                      break;
                    }
                  }
                } else if (wordA.textAlt && hocrAAltError < 0.5 && hocrAAltError < hocrAError) {
                  lineWordsEditedNew += 1;
                  if (wordA.text.length !== wordA.textAlt.length) wordA.chars = null;
                  wordA.text = wordA.textAlt;
                }
              }
            }
          }
        }
      }
    }
    if (lineBReplace && lineWordsEditedNew > lineA.words.length * 0.5) {
      lineA.ascHeight = lineBReplace.ascHeight;
      lineA.xHeight = lineBReplace.xHeight;
    }
  }
  if (supplementComp && tessWorker && evalConflicts) {
    for (let i2 = 0; i2 < pageAInt.lines.length; i2++) {
      const line = pageAInt.lines[i2];
      for (let j2 = 0; j2 < line.words.length; j2++) {
        const word = line.words[j2];
        if (!word.compTruth) {
          const res = await checkWords([word], binaryImageBit, imageRotated, pageMetricsObj, tessWorker, {
            ignorePunct,
            tessWorker,
            view: false
          });
          word.matchTruth = res.match;
          word.conf = word.matchTruth ? 100 : 0;
        }
      }
    }
  }
  if (mode === "comb") {
    if (imageUpscaled) ocrObjects_default.scalePage(pageAInt, 0.5);
    return {
      page: pageAInt,
      metrics: null,
      debugImg
    };
  }
  const hocrBAll = {};
  ocrObjects_default.getPageWords(pageB).forEach((x2) => {
    hocrBAll[x2.id] = 1;
  });
  const hocrAAll = {};
  ocrObjects_default.getPageWords(pageAInt).forEach((x2) => {
    hocrAAll[x2.id] = 1;
  });
  if (ignorePunct) {
    const punctOnlyIDsA = ocrObjects_default.getPageWords(pageA).filter((x2) => !x2.text.replace(/[\W_]/g, "")).map((x2) => x2.id);
    punctOnlyIDsA.forEach((x2) => {
      delete hocrAAll[x2];
      delete hocrAOverlap[x2];
      delete hocrACorrect[x2];
    });
    const punctOnlyIDsB = ocrObjects_default.getPageWords(pageB).filter((x2) => !x2.text.replace(/[\W_]/g, "")).map((x2) => x2.id);
    punctOnlyIDsB.forEach((x2) => {
      delete hocrBAll[x2];
      delete hocrBOverlap[x2];
      delete hocrBCorrect[x2];
    });
  }
  const totalCountB = Object.keys(hocrBAll).length;
  const totalCountA = Object.keys(hocrAAll).length;
  const overlapCountB = Object.keys(hocrBOverlap).length;
  const overlapCountA = Object.keys(hocrAOverlap).length;
  const correctCount = Object.keys(hocrBCorrect).length;
  const incorrectCount = overlapCountB - correctCount;
  let correctCountLowConf = 0;
  let incorrectCountHighConf = 0;
  const overlappingWordsB = Object.keys(hocrBOverlap);
  for (let i2 = 0; i2 < overlappingWordsB.length; i2++) {
    const wordBID = overlappingWordsB[i2];
    const wordAIDs = Object.keys(hocrBOverlapAWords[wordBID]);
    let lowConfCount = 0;
    let highConfCount = 0;
    for (let j2 = 0; j2 < wordAIDs.length; j2++) {
      const word = ocrObjects_default.getPageWord(pageA, wordAIDs[j2]);
      if (word.conf <= confThreshMed) {
        lowConfCount++;
      } else if (word.conf > confThreshHigh) {
        highConfCount++;
      }
    }
    const match = hocrBCorrect[wordBID];
    if (match && lowConfCount > 0) {
      correctCountLowConf++;
    } else if (!match && highConfCount > 0) {
      incorrectCountHighConf++;
    }
  }
  const metricsRet = {
    total: totalCountB,
    correct: correctCount,
    incorrect: incorrectCount,
    missed: totalCountB - overlapCountB,
    extra: totalCountA - overlapCountA,
    correctLowConf: correctCountLowConf,
    incorrectHighConf: incorrectCountHighConf
  };
  if (editConf) {
    ocrObjects_default.getPageWords(pageAInt).forEach((x2) => {
      x2.conf = x2.matchTruth ? 100 : 0;
    });
  }
  if (imageUpscaled) ocrObjects_default.scalePage(pageAInt, 0.5);
  return {
    page: pageAInt,
    metrics: metricsRet,
    debugImg
  };
}
async function checkWords(wordsA, binaryImage, imageRotated, pageMetricsObj, tessWorker, options = {}) {
  const view = options?.view === void 0 ? false : options?.view;
  const ignorePunct = options?.ignorePunct === void 0 ? false : options?.ignorePunct;
  const ignoreCap = options?.ignoreCap === void 0 ? false : options?.ignoreCap;
  const angle = imageRotated ? pageMetricsObj.angle || 0 : 0;
  const { canvas } = await drawWordActual(wordsA, binaryImage, angle);
  const extraConfig = {
    tessedit_pageseg_mode: "6"
    // "Single block"
  };
  const inputImage = typeof process === "undefined" ? await canvas.convertToBlob() : await canvas.toDataURL();
  const res = (await tessWorker.recognize(inputImage, extraConfig)).data;
  let wordTextA = wordsA.map((x2) => x2.text).join(" ");
  let wordTextB = res.text.trim();
  wordTextA = ocrObjects_default.replaceLigatures(wordTextA);
  wordTextB = ocrObjects_default.replaceLigatures(wordTextB);
  if (ignorePunct) {
    wordTextA = wordTextA.replace(/(^|\D)[\W_]($|\D)/g, "$1$2");
    wordTextB = wordTextB.replace(/(^|\D)[\W_]($|\D)/g, "$1$2");
  }
  if (ignoreCap) {
    wordTextA = wordTextA.toLowerCase();
    wordTextB = wordTextB.toLowerCase();
  }
  return { match: wordTextA === wordTextB };
}
async function evalPageBase({
  page,
  binaryImage,
  pageMetricsObj,
  func = null,
  view = false
}) {
  if (typeof WorkerGlobalScope === "undefined") {
    page = structuredClone(page);
  }
  const lines = "lines" in page ? page.lines : [page];
  const imgAngle = binaryImage.rotated ? pageMetricsObj.angle || 0 : 0;
  if (binaryImage.upscaled) {
    for (let i2 = 0; i2 < lines.length; i2++) {
      ocrObjects_default.scaleLine(lines[i2], 2);
    }
  }
  const binaryImageBit = binaryImage.imageBitmap || await ca.getImageBitmap(binaryImage.src);
  if (!FontCont.raw) throw new Error("Fonts must be defined before running this function.");
  let metricTotal = 0;
  let wordsTotal = 0;
  const debugArr = [];
  for (let j2 = 0; j2 < lines.length; j2++) {
    let ocrLineJ = lines[j2];
    if (ocrLineJ.words[0].lang === "chi_sim") continue;
    if (func) {
      ocrLineJ = await func(lines[j2]);
    }
    if (!ocrLineJ) continue;
    const evalRes = await evalWords({
      wordsA: ocrLineJ.words,
      binaryImage: binaryImageBit,
      angle: imgAngle,
      options: { view }
    });
    metricTotal += evalRes.metricA * ocrLineJ.words.length;
    wordsTotal += ocrLineJ.words.length;
    if (evalRes.debug) debugArr.push(evalRes.debug);
  }
  return { wordsTotal, metricTotal, debug: debugArr };
}
async function evalPageFont({
  page,
  binaryImage,
  pageMetricsObj,
  font,
  opt: opt2 = false
}) {
  const enableOptSave = FontCont.state.enableOpt;
  const forceOptSave = FontCont.state.forceOpt;
  if (opt2 === true) {
    if (!FontCont.opt) throw new Error("Optimized fonts requested but not defined.");
    FontCont.state.forceOpt = true;
  } else if (opt2 === false) {
    if (!FontCont.raw) throw new Error("Raw fonts requested but not defined.");
    FontCont.state.enableOpt = false;
    FontCont.state.forceOpt = false;
  }
  const transformLineFont = (ocrLineJ) => {
    if (!FontCont.raw) throw new Error("Fonts must be defined before running this function.");
    if (!ocrLineJ.words[0]) {
      console.log("Line has 0 words, this should not happen.");
      return ocrObjects_default.cloneLine(ocrLineJ);
    }
    const lineFontType = FontCont.getWordFont(ocrLineJ.words[0]).type;
    if (FontCont.raw[font].normal.type !== lineFontType) return null;
    const ocrLineJClone = ocrObjects_default.cloneLine(ocrLineJ);
    ocrLineJClone.words.forEach((x2) => {
      x2.style.font = font;
    });
    return ocrLineJClone;
  };
  const res = await evalPageBase({
    page,
    binaryImage,
    pageMetricsObj,
    func: transformLineFont
  });
  FontCont.state.enableOpt = enableOptSave;
  FontCont.state.forceOpt = forceOptSave;
  return res;
}
async function nudgePageBase({
  page,
  binaryImage,
  pageMetricsObj,
  func,
  view = false
}) {
  if (typeof WorkerGlobalScope === "undefined") {
    page = structuredClone(page);
  }
  const imgAngle = binaryImage.rotated ? pageMetricsObj.angle || 0 : 0;
  if (binaryImage.upscaled) {
    ocrObjects_default.scalePage(page, 2);
  }
  const binaryImageBit = binaryImage.imageBitmap || await ca.getImageBitmap(binaryImage.src);
  if (!FontCont.raw) throw new Error("Fonts must be defined before running this function.");
  if (!calcCtx) throw new Error("Canvases must be defined before running this function.");
  let improveCt = 0;
  let totalCt = 0;
  const debugImg = [];
  for (const ocrLineJ of page.lines) {
    const tryNudge = async (x2) => {
      const ocrLineJClone = ocrObjects_default.cloneLine(ocrLineJ);
      await func(ocrLineJClone, x2);
      if (!ocrLineJClone) return false;
      const evalRes = await evalWords({
        wordsA: ocrLineJ.words,
        wordsB: ocrLineJClone.words,
        binaryImage: binaryImageBit,
        angle: imgAngle,
        options: { view, useAFontSize: false, useABaseline: false }
      });
      if (evalRes.debug) debugImg.push(evalRes.debug);
      if (evalRes.metricB < evalRes.metricA) {
        return true;
      }
      return false;
    };
    const res1 = await tryNudge(1);
    if (res1) {
      await func(ocrLineJ, 1);
      improveCt += 1;
    } else {
      const res2 = await tryNudge(-1);
      if (res2) {
        await func(ocrLineJ, -1);
        improveCt += 1;
      }
    }
    totalCt += 1;
  }
  return {
    page,
    improveCt,
    totalCt,
    debug: view ? debugImg : null
  };
}
async function nudgePageFontSize({
  page,
  binaryImage,
  pageMetricsObj,
  view = false
}) {
  const func = async (lineJ, x2) => {
    const fontSizeBase = calcLineFontSize(lineJ);
    if (!fontSizeBase) return;
    lineJ._size = fontSizeBase + x2;
  };
  return await nudgePageBase({
    page,
    binaryImage,
    pageMetricsObj,
    func,
    view
  });
}
async function nudgePageBaseline({
  page,
  binaryImage,
  pageMetricsObj,
  view = false
}) {
  const func = async (lineJ, x2) => {
    lineJ.baseline[1] += x2;
  };
  return await nudgePageBase({
    page,
    binaryImage,
    pageMetricsObj,
    func,
    view
  });
}
var renderPageStaticImp = async ({
  page,
  image,
  angle = 0,
  displayMode = "proof",
  confThreshMed = 75,
  confThreshHigh = 85
}) => {
  const dims = image ? imageUtils.getDims(image) : page.dims;
  const canvas = await ca.createCanvas(dims.width, dims.height);
  const ctx = (
    /** @type {OffscreenCanvasRenderingContext2D} */
    /** @type {unknown} */
    canvas.getContext("2d")
  );
  if (image) {
    const imageBit = await ca.getImageBitmap(image.src);
    ctx.drawImage(imageBit, 0, 0);
  }
  angle = angle ?? 0;
  ctx.textBaseline = "alphabetic";
  const sinAngle = Math.sin(angle * (Math.PI / 180));
  const cosAngle = Math.cos(angle * (Math.PI / 180));
  for (const lineObj of page.lines) {
    const angleAdjLine = image?.rotated ? ocrObjects_default.calcLineStartAngleAdj(lineObj) : { x: 0, y: 0 };
    const baselineY = lineObj.bbox.bottom + lineObj.baseline[1] + angleAdjLine.y;
    const lineLeftAdj = lineObj.bbox.left + angleAdjLine.x;
    const rotateText = !image?.rotated;
    if (rotateText) {
      ctx.setTransform(cosAngle, sinAngle, -sinAngle, cosAngle, lineLeftAdj, baselineY);
    } else {
      ctx.setTransform(1, 0, 0, 1, lineLeftAdj, baselineY);
    }
    for (const wordObj of lineObj.words) {
      if (!wordObj.text) continue;
      const { fill, opacity } = ocrObjects_default.getWordFillOpacity(wordObj, displayMode, confThreshMed, confThreshHigh);
      ctx.fillStyle = fill;
      const angleAdjWord = wordObj.style.sup ? ocrObjects_default.calcWordAngleAdj(wordObj) : { x: 0, y: 0 };
      const wordMetrics = calcWordMetrics(wordObj);
      const advanceArr = wordMetrics.advanceArr;
      const kerningArr = wordMetrics.kerningArr;
      const charSpacing = wordMetrics.charSpacing;
      const wordFontSize = wordMetrics.fontSize;
      const leftSideBearing = wordMetrics.leftSideBearing;
      let ts = 0;
      if (wordObj.style.sup || wordObj.style.dropcap) {
        ts = lineObj.bbox.bottom + lineObj.baseline[1] + angleAdjLine.y - (wordObj.bbox.bottom + angleAdjLine.y + angleAdjWord.y);
        if (!wordObj.visualCoords) {
          const font2 = FontCont.getWordFont(wordObj);
          const fontDesc = font2.opentype.descender / font2.opentype.unitsPerEm * wordMetrics.fontSize;
          ts -= fontDesc;
        }
      } else {
        ts = 0;
      }
      const width = (wordObj.bbox.left - wordObj.line.bbox.left) / cosAngle;
      const visualLeft = width + angleAdjWord.x;
      const advanceArrTotal = [];
      for (let i2 = 0; i2 < advanceArr.length; i2++) {
        let leftI2 = 0;
        leftI2 += advanceArr[i2] || 0;
        leftI2 += kerningArr[i2] || 0;
        leftI2 += charSpacing || 0;
        advanceArrTotal.push(leftI2);
      }
      const font = FontCont.getWordFont(wordObj);
      ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${wordFontSize}px ${font.fontFaceName}`;
      let leftI = wordObj.visualCoords ? visualLeft - leftSideBearing : visualLeft;
      for (let i2 = 0; i2 < wordMetrics.charArr.length; i2++) {
        let charI = wordMetrics.charArr[i2];
        if (wordObj.style.smallCaps) {
          if (charI === charI.toUpperCase()) {
            ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${wordFontSize}px ${font.fontFaceName}`;
          } else {
            charI = charI.toUpperCase();
            ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${wordFontSize * font.smallCapsMult}px ${font.fontFaceName}`;
          }
        }
        ctx.fillText(charI, leftI, -ts);
        leftI += advanceArrTotal[i2];
      }
    }
  }
  const img = typeof process === "undefined" ? await canvas.convertToBlob() : await canvas.toDataURL();
  return img;
};

// node_modules/scribe.js-ocr/js/worker/optimizeFontModule.js
if (typeof process === "object") {
  globalThis.self = globalThis;
  const { createRequire } = await import("node:module");
  globalThis.require = createRequire(import.meta.url);
  const { fileURLToPath } = await import("node:url");
  const { dirname } = await import("node:path");
  globalThis.__dirname = dirname(fileURLToPath(import.meta.url));
} else if (globalThis.window === void 0) {
  globalThis.window = {};
}
function round62(x2) {
  return Math.round(x2 * 1e6) / 1e6;
}
function transformGlyph(glyph, func, transX = false, transY = false) {
  const funcRound = (x2) => Math.round(func(x2));
  for (let j2 = 0; j2 < glyph.path.commands.length; j2++) {
    const pointJ = glyph.path.commands[j2];
    if (pointJ.type === "M" || pointJ.type === "L" || pointJ.type === "C" || pointJ.type === "Q") {
      if (transX) pointJ.x = funcRound(pointJ.x);
      if (transY) pointJ.y = funcRound(pointJ.y);
      if (pointJ.type === "C" || pointJ.type === "Q") {
        if (transX) pointJ.x1 = funcRound(pointJ.x1);
        if (transY) pointJ.y1 = funcRound(pointJ.y1);
        if (pointJ.type === "C") {
          if (transX) pointJ.x2 = funcRound(pointJ.x2);
          if (transY) pointJ.y2 = funcRound(pointJ.y2);
        }
      }
    }
  }
  if (transX) {
    const glyphMetrics = glyph.getMetrics();
    glyph.leftSideBearing = glyphMetrics.xMin;
    glyph.advanceWidth = funcRound(glyph.advanceWidth);
  }
}
var calculateKerningPairs = (font, charMetricsObj, xHeight, styleLookup) => {
  const fontKerningObj = {};
  const maxKern = Math.round(font.unitsPerEm * 0.1);
  const minKern = maxKern * -1;
  for (const [key, value] of Object.entries(charMetricsObj.kerning)) {
    if (key === "102,102" && ["italic", "boldItalic"].includes(styleLookup)) continue;
    const nameFirst = key.match(/\w+/)[0];
    const nameSecond = key.match(/\w+$/)[0];
    const charFirst = String.fromCharCode(parseInt(nameFirst));
    const charSecond = String.fromCharCode(parseInt(nameSecond));
    const indexFirst = font.charToGlyphIndex(charFirst);
    const indexSecond = font.charToGlyphIndex(charSecond);
    const glyphFirst = font.glyphs.glyphs[indexFirst];
    const glyphSecond = font.glyphs.glyphs[indexSecond];
    const metricsFirst = glyphFirst.getMetrics();
    const metricsSecond = glyphSecond.getMetrics();
    const fontKern1 = Math.round(value * xHeight);
    let spaceTarget = fontKern1;
    if (charMetricsObj.kerning2) {
      const value2 = charMetricsObj.kerning2[key];
      if (value2) {
        const fontKern2 = Math.round(value2 * xHeight);
        spaceTarget = Math.round((fontKern1 + fontKern2) / 2);
      }
    }
    const spaceCurrent = glyphFirst.advanceWidth - metricsFirst.xMax + metricsSecond.xMin;
    let fontKern = spaceTarget - spaceCurrent;
    if (["8220", "8216"].includes(nameFirst) || ["8221", "8217"].includes(nameSecond)) {
      fontKern = Math.min(Math.max(fontKern, minKern), maxKern * 2);
    } else if (["102,102", "102,105", "102,108"].includes(key)) {
      fontKern = Math.min(Math.max(fontKern, Math.round(minKern * 1.5)), maxKern);
    } else {
      fontKern = Math.min(Math.max(fontKern, minKern), maxKern);
    }
    fontKerningObj[`${indexFirst},${indexSecond}`] = fontKern;
  }
  return fontKerningObj;
};
async function optimizeFont({
  fontData,
  charMetricsObj,
  style,
  adjustAllLeftBearings = false,
  standardizeSize = false,
  targetEmSize = null,
  transGlyphs = true
}) {
  const workingFont = typeof fontData === "string" ? await An.load(fontData) : An.parse(fontData, { lowMemory: false });
  workingFont.tables.gsub = null;
  const xHeightStandard = 0.47 * workingFont.unitsPerEm;
  let oGlyph = workingFont.charToGlyph("o").getMetrics();
  let xHeight = oGlyph.yMax - oGlyph.yMin;
  const xHeightScale = xHeightStandard / xHeight;
  const scaleGlyph = (x2) => x2 * xHeightScale;
  if (Math.abs(1 - xHeightScale) > 0.01) {
    if (standardizeSize) {
      for (const [key, value] of Object.entries(workingFont.glyphs.glyphs)) {
        transformGlyph(value, scaleGlyph, true, true);
      }
    } else {
      console.log("Font is not standard size ('o' 0.47x em size).  Either standardize the font ahead of time or enable `standardizeSize = true` to standardize on the fly.");
    }
  }
  if (targetEmSize && targetEmSize !== workingFont.unitsPerEm) {
    for (const [key, value] of Object.entries(workingFont.glyphs.glyphs)) {
      transformGlyph(value, (x2) => x2 * (targetEmSize / workingFont.unitsPerEm), true, true);
    }
    workingFont.unitsPerEm = targetEmSize;
  }
  if (!transGlyphs) {
    workingFont.kerningPairs = calculateKerningPairs(workingFont, charMetricsObj, xHeight, style);
    return { fontData: workingFont.toArrayBuffer(), kerningPairs: workingFont.kerningPairs };
  }
  oGlyph = workingFont.charToGlyph("o").getMetrics();
  xHeight = oGlyph.yMax - oGlyph.yMin;
  const heightCapsBelievable = charMetricsObj.obsCaps >= 10 && charMetricsObj.heightCaps >= 1.1 && charMetricsObj.heightCaps < 2;
  const fontAscHeight = workingFont.charToGlyph("A").getMetrics().yMax;
  const lower = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
  const singleStemClassA = ["i", "l", "t", "I"];
  const singleStemClassB = ["f", "i", "j", "l", "t", "I", "J", "T"];
  for (const [key, value] of Object.entries(charMetricsObj.width)) {
    if (parseInt(key) < 33) {
      continue;
    }
    const charLit = String.fromCharCode(parseInt(key));
    if (["."].includes(charLit)) {
      continue;
    }
    const glyphI = workingFont.charToGlyph(charLit);
    if (glyphI.name === ".notdef" || glyphI.name === "NULL") continue;
    let glyphIMetrics = glyphI.getMetrics();
    const glyphIWidth = glyphIMetrics.xMax - glyphIMetrics.xMin;
    let scaleXFactor = value * xHeight / glyphIWidth;
    const glyphICenterPoint = charLit === "f" ? 0.35 : 0.5;
    const glyphICenter = Math.max(glyphIMetrics.xMin, 0) + Math.round(glyphIWidth * glyphICenterPoint);
    const glyphIWidthQuarter = Math.round(glyphIWidth / 4);
    if (singleStemClassA.includes(charLit)) {
      scaleXFactor = Math.max(Math.min(scaleXFactor, 1.1), 0.9);
    } else if (["\u201C", "\u201D"].includes(charLit)) {
      scaleXFactor = Math.max(Math.min(scaleXFactor, 1.5), 0.7);
    } else {
      scaleXFactor = Math.max(Math.min(scaleXFactor, 1.3), 0.7);
    }
    const scaleH1 = (x2) => Math.round((x2 - glyphICenter) * scaleXFactor) + glyphICenter;
    const scaleH2 = (x2) => Math.round(x2 * scaleXFactor);
    if (singleStemClassB.includes(charLit) && style !== "italic") {
      transformGlyph(glyphI, scaleH1, true, false);
    } else {
      transformGlyph(glyphI, scaleH2, true, false);
    }
    glyphIMetrics = glyphI.getMetrics();
    glyphI.leftSideBearing = glyphIMetrics.xMin;
    let shiftX = 0;
    if ([";", ":", "\u2018", "\u2019", "\u201C", "\u201D", '"'].includes(charLit) || adjustAllLeftBearings) {
      const leftBearingCorrect = 0;
      const leftBearingAct = glyphIMetrics.xMin;
      if (Number.isFinite(leftBearingCorrect) && leftBearingAct !== void 0) {
        shiftX = leftBearingCorrect - leftBearingAct;
        if (shiftX + glyphI.advanceWidth < workingFont.unitsPerEm * 0.05) {
          shiftX = 0;
        }
      }
    }
    if (shiftX !== 0) {
      const shiftH = (x2) => x2 + shiftX;
      transformGlyph(glyphI, shiftH, true, false);
      glyphIMetrics = glyphI.getMetrics();
    }
    glyphI.leftSideBearing = glyphIMetrics.xMin;
  }
  if (heightCapsBelievable) {
    const capsMult = xHeight * charMetricsObj.heightCaps / fontAscHeight;
    for (const key of [...Array(26).keys()].map((x2) => x2 + 65)) {
      const charLit = String.fromCharCode(key);
      const glyphI = workingFont.charToGlyph(charLit);
      const scaleCaps = (x2) => x2 * capsMult;
      transformGlyph(glyphI, scaleCaps, false, true);
    }
  }
  const upperAsc = ["A", "B", "D", "E", "F", "H", "I", "K", "L", "M", "N", "P", "R", "T", "U", "V", "W", "X", "Y", "Z"];
  const upperAscCodes = upperAsc.map((x2) => String(x2.charCodeAt(0)));
  const charHeightKeys = Object.keys(charMetricsObj.height);
  const heightAscArr = Object.values(charMetricsObj.height).filter((element, index) => upperAscCodes.includes(charHeightKeys[index]));
  if (heightAscArr.length >= 10) {
    const heightAscMedian0 = quantile(heightAscArr, 0.5);
    if (heightAscMedian0) {
      const charHeightA = round62(heightAscMedian0);
      const actJMult = Math.max(round62(charMetricsObj.height[74]) / charHeightA, 0);
      const fontJMetrics = workingFont.charToGlyph("J").getMetrics();
      const fontAMetrics2 = workingFont.charToGlyph("A").getMetrics();
      const fontJMult = Math.max((fontJMetrics.yMax - fontJMetrics.yMin) / (fontAMetrics2.yMax - fontAMetrics2.yMin), 1);
      const actFontJMult = actJMult / fontJMult;
      if (Math.abs(1 - actFontJMult) > 0.02) {
        const glyphI = workingFont.charToGlyph("J");
        const glyphIMetrics = glyphI.getMetrics();
        const yAdj = Math.round(glyphIMetrics.yMax - glyphIMetrics.yMax * actFontJMult);
        const transDescFunc = (x2) => Math.round(x2 * actFontJMult + yAdj);
        transformGlyph(glyphI, transDescFunc, false, true);
      }
    }
  }
  const descAdjArr = ["g", "p", "q"];
  const fontAMetrics = workingFont.charToGlyph("a").getMetrics();
  const minA = fontAMetrics.yMin;
  for (let i2 = 0; i2 < descAdjArr.length; i2++) {
    const charI = descAdjArr[i2];
    const charICode = charI.charCodeAt(0);
    const actMult = Math.max(charMetricsObj.height[charICode] / charMetricsObj.height[97], 0);
    const metrics = workingFont.charToGlyph(charI).getMetrics();
    const fontMult = (metrics.yMax - metrics.yMin) / (fontAMetrics.yMax - fontAMetrics.yMin);
    const actFontMult = actMult / fontMult;
    const glyphHeight = metrics.yMax - metrics.yMin;
    const glyphLowerStemHeight = minA - metrics.yMin;
    const scaleYFactor = (actFontMult - 1) * (glyphHeight / glyphLowerStemHeight) + 1;
    const scaleYFunc = (x2) => Math.round((x2 - minA) * scaleYFactor);
    if (Math.abs(actFontMult) > 1.02) {
      const glyphI = workingFont.charToGlyph(charI);
      for (let j2 = 0; j2 < glyphI.path.commands.length; j2++) {
        const pointJ = glyphI.path.commands[j2];
        if (pointJ.type === "M" || pointJ.type === "L" || pointJ.type === "C" || pointJ.type === "Q") {
          if (pointJ.y < minA) pointJ.y = Math.round((pointJ.y - minA) * scaleYFactor);
          if (pointJ.type === "C" || pointJ.type === "Q") {
            if (pointJ.y1 < minA) pointJ.y1 = Math.round((pointJ.y1 - minA) * scaleYFactor);
            if (pointJ.type === "C") {
              if (pointJ.y2 < minA) pointJ.y2 = Math.round((pointJ.y2 - minA) * scaleYFactor);
            }
          }
        }
      }
    }
  }
  workingFont.kerningPairs = calculateKerningPairs(workingFont, charMetricsObj, xHeight, style);
  workingFont.tables.name.postScriptName.en = `${workingFont.tables.name.postScriptName.en.replaceAll(/\s+/g, "")}-Opt`;
  return { fontData: workingFont.toArrayBuffer(), kerningPairs: workingFont.kerningPairs };
}

// node_modules/scribe.js-ocr/js/worker/generalWorker.js
var parentPort = typeof process === "undefined" ? globalThis : (await import("node:worker_threads")).parentPort;
if (!parentPort) throw new Error("This file must be run in a worker");
var Tesseract = typeof process === "undefined" ? (await Promise.resolve().then(() => (init_tesseract_esm_min(), tesseract_esm_min_exports))).default : await Promise.resolve().then(() => __toESM(require_src(), 1));
var nodeOs = typeof process === "undefined" ? null : await import("node:os");
var nodePath = typeof process === "undefined" ? null : await import("node:path");
var getOcrCachePath = () => {
  if (typeof process === "undefined" || !nodeOs || !nodePath) return void 0;
  return nodePath.join(nodeOs.homedir(), ".auditaria", "ocr");
};
var defaultConfigsVanilla = {
  tessedit_pageseg_mode: Tesseract.PSM.AUTO
};
var defaultConfigs = {
  tessedit_pageseg_mode: Tesseract.PSM.AUTO,
  // This is virtually always a false positive (usually "I").
  tessedit_char_blacklist: "|",
  // This option disables an undesirable behavior where Tesseract categorizes blobs *of any size* as noise,
  // simply because they are too rectangular.  This option should always be enabled outside of debugging purposes.
  textord_noise_area_ratio: "1",
  // Table detection appears to interfere with the layout analysis of some documents with multi-column layouts,
  // causing columns to be combined into a single line.  This should be investigated in more detail,
  // but disabling as it does not seem to improve results even when the input document is a table.
  textord_tabfind_find_tables: "0"
};
var defaultInitConfigsVanilla = {};
var defaultInitConfigs = {
  // load_system_dawg: '0',
  load_freq_dawg: "0"
  // load_unambig_dawg: '0',
  // load_punc_dawg: '0',
  // load_number_dawg: '0',
  // load_bigram_dawg: '0',
};
var oemCurrent = 2;
var langArrCurrent = ["eng"];
var vanillaMode_ = false;
var corePath;
if (vanillaMode_) {
  corePath = new URL("../../tess/core_vanilla/tesseract-core-simd.wasm.js", import.meta.url).href;
} else {
  corePath = new URL("../../tess/core/tesseract-core-simd.wasm.js", import.meta.url).href;
}
var workerPath = new URL("../../tess/worker.min.js", import.meta.url).href;
var tessOptions = typeof process === "undefined" ? {
  corePath,
  workerPath,
  // langPath: '/tess/tessdata_dist',
  legacyCore: true,
  legacyLang: true,
  workerBlobURL: false
} : { legacyCore: true, legacyLang: true, cachePath: getOcrCachePath() };
var worker;
var workerLegacy;
var workerLSTM;
var reinitialize = async ({
  langs,
  oem,
  vanillaMode,
  config
}) => {
  const langArr = typeof langs === "string" ? langs.split("+") : langs;
  const changeLang = langs && JSON.stringify(langArr.sort()) !== JSON.stringify(langArrCurrent.sort());
  const changeOEM = oem !== null && oem !== void 0 && oem !== oemCurrent;
  const changeVanilla = vanillaMode && vanillaMode !== vanillaMode_;
  if (!changeLang && !changeOEM && !changeVanilla && worker) {
    if (config && Object.keys(config).length > 0) {
      await worker.setParameters(config);
    }
    return;
  }
  if (changeLang) langArrCurrent = langArr;
  if (changeOEM) oemCurrent = oem;
  if (changeVanilla) vanillaMode_ = vanillaMode;
  const initConfigs = vanillaMode_ ? structuredClone(defaultInitConfigsVanilla) : structuredClone(defaultInitConfigs);
  const defaultConfigsI = vanillaMode_ ? defaultConfigsVanilla : defaultConfigs;
  for (const [key, value] of Object.entries(defaultConfigsI)) {
    initConfigs[key] = value;
  }
  if (config) {
    for (const [key, value] of Object.entries(config)) {
      initConfigs[key] = value;
    }
  }
  if (changeVanilla || !worker) {
    if (vanillaMode_) {
      tessOptions.corePath = new URL("../../tess/core_vanilla/tesseract-core-simd.wasm.js", import.meta.url).href;
    } else {
      tessOptions.corePath = new URL("../../tess/core/tesseract-core-simd.wasm.js", import.meta.url).href;
    }
    if (worker) await worker.terminate();
    worker = await Tesseract.createWorker(langArrCurrent, oemCurrent, tessOptions, initConfigs);
  } else {
    await worker.reinitialize(langArrCurrent, oemCurrent, initConfigs);
  }
};
var reinitialize2 = async ({ langs, vanillaMode }) => {
  const langArr = typeof langs === "string" ? langs.split("+") : langs;
  const changeLang = langs && JSON.stringify(langArr.sort()) !== JSON.stringify(langArrCurrent.sort());
  const changeVanilla = vanillaMode && vanillaMode !== vanillaMode_;
  if (!changeLang && !changeVanilla && workerLegacy && workerLSTM) return;
  if (changeLang) langArrCurrent = langArr;
  if (changeVanilla) vanillaMode_ = vanillaMode;
  const initConfigs = vanillaMode_ ? defaultInitConfigsVanilla : defaultInitConfigs;
  if (changeVanilla || !workerLegacy || !workerLSTM) {
    if (vanillaMode_) {
      tessOptions.corePath = new URL("../../tess/core_vanilla/tesseract-core-simd.wasm.js", import.meta.url).href;
    } else {
      tessOptions.corePath = new URL("../../tess/core/tesseract-core-simd.wasm.js", import.meta.url).href;
    }
    if (workerLegacy) {
      console.log("terminating legacy");
      await workerLegacy.terminate();
      workerLegacy = null;
    }
    if (workerLSTM) {
      console.log("terminating lstm");
      await workerLSTM.terminate();
      workerLSTM = null;
    }
    workerLegacy = await Tesseract.createWorker(langArrCurrent, 0, tessOptions, initConfigs);
    workerLSTM = await Tesseract.createWorker(langArrCurrent, 1, tessOptions, initConfigs);
  } else if (changeLang) {
    await workerLegacy.reinitialize(langArrCurrent, 0, initConfigs);
    await workerLSTM.reinitialize(langArrCurrent, 1, initConfigs);
  }
  const config = vanillaMode_ ? defaultConfigsVanilla : defaultConfigs;
  await workerLegacy.setParameters(config);
  await workerLSTM.setParameters(config);
};
var recognizeAndConvert = async ({
  image,
  options,
  output,
  n: n2,
  knownAngle = null,
  pageDims
}) => {
  if (!worker) throw new Error("Worker not initialized");
  const res1 = await worker.recognize(image, options, output);
  const angle = knownAngle === null || knownAngle === void 0 ? (res1.data.rotateRadians || 0) * (180 / Math.PI) * -1 : knownAngle;
  const keepItalic = oemCurrent === 0;
  const ocrBlocks = (
    /** @type {Array<import('@scribe.js/tesseract.js').Block>} */
    res1.data.blocks
  );
  const res2 = await convertPageBlocks({
    ocrBlocks,
    n: n2,
    pageDims,
    rotateAngle: angle,
    keepItalic
  });
  return { recognize: res1.data, convert: res2 };
};
var recognizeAndConvert2 = async ({
  image,
  options,
  output,
  n: n2,
  pageDims,
  knownAngle = null
}, id) => {
  if (!worker && !(workerLegacy && workerLSTM)) throw new Error("Worker not initialized");
  if (!output) output = {};
  output.hocr = false;
  output.tsv = false;
  output.text = false;
  output.debug = false;
  let resArr;
  if (workerLegacy && workerLSTM) {
    if (options.legacy && !options.lstm) {
      const res1Promise = workerLegacy.recognize(image, options, output);
      resArr = [res1Promise];
    } else if (!options.legacy && options.lstm) {
      const res1Promise = workerLSTM.recognize(image, options, output);
      resArr = [res1Promise];
    } else {
      const res1Promise = workerLegacy.recognize(image, options, output);
      const res2Promise = workerLSTM.recognize(image, options, output);
      resArr = [res1Promise, res2Promise];
    }
  } else {
    resArr = await worker.recognize2(image, options, output);
  }
  const res0 = await resArr[0];
  const angle = knownAngle === null || knownAngle === void 0 ? (res0.data.rotateRadians || 0) * (180 / Math.PI) * -1 : knownAngle;
  let resLegacy;
  let resLSTM;
  if (options.lstm && options.legacy) {
    const legacyBlocks = (
      /** @type {Array<import('@scribe.js/tesseract.js').Block>} */
      res0.data.blocks
    );
    resLegacy = await convertPageBlocks({
      ocrBlocks: legacyBlocks,
      n: n2,
      pageDims,
      rotateAngle: angle,
      keepItalic: true,
      upscale: res0.data.upscale
    });
    (async () => {
      const res1 = await resArr[1];
      const lstmBlocks = (
        /** @type {Array<import('@scribe.js/tesseract.js').Block>} */
        res1.data.blocks
      );
      resLSTM = await convertPageBlocks({
        ocrBlocks: lstmBlocks,
        n: n2,
        pageDims,
        rotateAngle: angle,
        keepItalic: false,
        upscale: res0.data.upscale
      });
      const xB = { recognize: res1.data, convert: { legacy: null, lstm: resLSTM } };
      parentPort.postMessage({ data: xB, id: `${id}b`, status: "resolve" });
    })();
  } else if (!options.lstm && options.legacy) {
    const legacyBlocks = (
      /** @type {Array<import('@scribe.js/tesseract.js').Block>} */
      res0.data.blocks
    );
    resLegacy = await convertPageBlocks({
      ocrBlocks: legacyBlocks,
      n: n2,
      pageDims,
      rotateAngle: angle,
      keepItalic: true,
      upscale: res0.data.upscale
    });
  } else if (options.lstm && !options.legacy) {
    const lstmBlocks = (
      /** @type {Array<import('@scribe.js/tesseract.js').Block>} */
      res0.data.blocks
    );
    resLSTM = await convertPageBlocks({
      ocrBlocks: lstmBlocks,
      n: n2,
      pageDims,
      rotateAngle: angle,
      keepItalic: false,
      upscale: res0.data.upscale
    });
  }
  const x2 = { recognize: res0.data, convert: { legacy: resLegacy, lstm: resLSTM } };
  parentPort.postMessage({ data: x2, id, status: "resolve" });
  if (!options.legacy || !options.lstm) parentPort.postMessage({ data: null, id: `${id}b` });
};
var recognize = async ({ image, options, output }) => {
  if (!worker) throw new Error("Worker not initialized");
  const res1 = await worker.recognize(image, options, output);
  return res1.data;
};
async function loadFontsWorker({ src, opt: opt2 }) {
  const fonts = await loadFontsFromSource(src, opt2);
  if (opt2) {
    if (FontCont.opt) {
      Object.assign(FontCont.opt, fonts);
    } else {
      FontCont.opt = fonts;
    }
  } else if (FontCont.raw) {
    Object.assign(FontCont.raw, fonts);
  } else {
    FontCont.raw = fonts;
  }
  return true;
}
async function updateFontContWorker({
  rawMetrics,
  optMetrics,
  defaultFontName,
  sansDefaultName,
  serifDefaultName,
  enableOpt,
  forceOpt
}) {
  if (sansDefaultName) FontCont.state.sansDefaultName = sansDefaultName;
  if (serifDefaultName) FontCont.state.serifDefaultName = serifDefaultName;
  if (defaultFontName) FontCont.state.defaultFontName = defaultFontName;
  if (rawMetrics) FontCont.rawMetrics = rawMetrics;
  if (optMetrics) FontCont.optMetrics = optMetrics;
  if (enableOpt === true || enableOpt === false) FontCont.state.enableOpt = enableOpt;
  if (forceOpt === true || forceOpt === false) FontCont.state.forceOpt = forceOpt;
}
async function compareOCRPageImpWrap(args) {
  args.options.tessWorker = worker;
  return await compareOCRPageImp(args);
}
var handleMessage = async (data) => {
  const func = data[0];
  const args = data[1];
  const id = data[2];
  if (func === "recognizeAndConvert2") {
    recognizeAndConvert2(args, id);
    return;
  }
  ({
    // Convert page functions
    convertPageAbbyy,
    convertPageHocr,
    convertPageStext,
    convertDocTextract,
    convertDocAzureDocIntel,
    convertPageGoogleVision,
    convertPageBlocks,
    convertPageText,
    // Optimize font functions
    optimizeFont,
    // OCR comparison/evaluation functions
    evalPageFont,
    evalPageBase,
    evalWords,
    compareOCRPageImp: compareOCRPageImpWrap,
    nudgePageFontSize,
    nudgePageBaseline,
    renderPageStaticImp,
    // Recognition
    reinitialize,
    reinitialize2,
    recognize,
    recognizeAndConvert,
    // Change state of worker
    loadFontsWorker,
    updateFontContWorker
  })[func](args).then((x2) => parentPort.postMessage({ data: x2, id, status: "resolve" })).catch((err) => parentPort.postMessage({ data: err, id, status: "reject" }));
};
if (typeof process === "undefined") {
  onmessage = (event) => handleMessage(event.data);
} else {
  parentPort.on("message", handleMessage);
}
parentPort.postMessage({ data: "ready", id: 0, status: "resolve" });
export {
  recognize,
  recognizeAndConvert,
  recognizeAndConvert2
};
/*! Bundled license information:

scribe.js-ocr/tess/tesseract.esm.min.js:
  (*! For license information please see tesseract.min.js.LICENSE.txt *)

scribe.js-ocr/lib/opentype.module.js:
  (*! https://mths.be/codepointat v0.2.0 by @mathias *)
*/
