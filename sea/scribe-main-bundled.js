var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a2, b2) => (typeof require !== "undefined" ? require : a2)[b2]
}) : x2)(function(x2) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/scribe.js-ocr/js/containers/app.js
var opt, inputData;
var init_app = __esm({
  "node_modules/scribe.js-ocr/js/containers/app.js"() {
    opt = class {
      static ligatures = false;
      static kerning = true;
      static omitNativeText = false;
      static extractText = false;
      static enableUpscale = false;
      static ignorePunct = false;
      static ignoreCap = false;
      static ignoreExtra = false;
      static confThreshHigh = 85;
      static confThreshMed = 75;
      static addOverlay = true;
      static standardizePageSize = false;
      static humanReadablePDF = false;
      static intermediatePDF = false;
      static reflow = true;
      static removeMargins = false;
      static includeImages = false;
      static pageBreaks = true;
      /** @type {("invis"|"ebook"|"eval"|"proof")} */
      static displayMode = "proof";
      /** @type {('color'|'gray'|'binary')} */
      static colorMode = "color";
      static overlayOpacity = 80;
      static autoRotate = true;
      static enableLayout = false;
      static xlsxFilenameColumn = true;
      static xlsxPageNumberColumn = true;
      static saveDebugImages = false;
      static warningHandler = (x2) => console.warn(x2);
      static errorHandler = (x2) => console.error(x2);
      /** @param {ProgressMessage} x */
      // eslint-disable-next-line no-unused-vars
      static progressHandler = (x2) => {
      };
      /** Generate debug visualizations when running OCR. */
      static debugVis = false;
      static extractPDFFonts = false;
      static calcSuppFontInfo = false;
      /**
       * How to use PDF text data extracted from input PDFs (if any).
       * The `native` option controls how native text data is used (i.e. visible text rendered by the PDF viewer),
       * while the `ocr` option controls how OCR text data is used (i.e. invisible text printed over an image).
       * If `main` is true, then the data will be used as the primary data source.
       * If `supp` is true, then the data will be used as a supplemental data source (may be used to correct errors in the primary data source).
       */
      static usePDFText = {
        native: {
          supp: true,
          main: true
        },
        ocr: {
          supp: true,
          main: false
        }
      };
      /**
       * Always convert and retain existing PDF text data.
       * By default (`false`), if the existing PDF text data will not be used (per the `usePDFText` settings),
       * it is discarded and never converted into the internal OCR format.
       * This performance/memory optimization can be disabled by setting this option to `true`,
       * resulting in the PDF text being converted and retained even if (for example) it is corrupted.
       */
      static keepPDFTextAlways = false;
      /**
       * Number of workers to use. Must be set prior to initialization.
       * If set to `null` (default), the number of workers will be set up to 6 (browser) or 8 (node),
       * if the system has enough resources.
       * @type {?number}
       */
      static workerN = null;
    };
    inputData = class _inputData {
      /** `true` if OCR data exists (whether from upload or built-in engine) */
      static xmlMode = [];
      /** `true` if user uploaded pdf */
      static pdfMode = false;
      /** @type {?('text'|'ocr'|'image')} */
      static pdfType = null;
      /** `true` if user uploaded image files (.png, .jpeg) */
      static imageMode = false;
      /** `true` if user re-uploaded HOCR data created by Scribe OCR */
      static resumeMode = false;
      /** `true` if ground truth data is uploaded */
      static evalMode = false;
      static inputFileNames = [];
      static defaultDownloadFileName = "";
      static pageCount = 0;
      static clear = () => {
        _inputData.xmlMode.length = 0;
        _inputData.pdfMode = false;
        _inputData.imageMode = false;
        _inputData.resumeMode = false;
        _inputData.evalMode = false;
        _inputData.inputFileNames = [];
        _inputData.defaultDownloadFileName = "";
        _inputData.pageCount = 0;
      };
    };
  }
});

// node_modules/scribe.js-ocr/js/containers/dataContainer.js
var layoutRegions, layoutDataTables, ocrAll, ocrAllRaw, pageMetricsAll, DebugData, visInstructions, convertPageWarn;
var init_dataContainer = __esm({
  "node_modules/scribe.js-ocr/js/containers/dataContainer.js"() {
    layoutRegions = class {
      /** @type {Array<LayoutPage>} */
      static pages = [];
      /**
       *
       * @param {LayoutRegion} region - Region to delete.
       * @param {number} n - Page number.
       */
      static deleteLayoutRegion(region, n2) {
        for (const [key, value] of Object.entries(this.pages[n2].boxes)) {
          if (value.id === region.id) {
            delete this.pages[n2].boxes[key];
            break;
          }
        }
      }
    };
    layoutDataTables = class {
      /** @type {Array<LayoutDataTablePage>} */
      static pages = [];
      /**
       * Serialize the layout data tables as JSON.
       * A special function is needed to remove circular references.
       */
      static serialize() {
        const pages = structuredClone(this.pages);
        pages.forEach((page) => {
          page.tables.forEach((table3) => {
            delete table3.page;
            table3.boxes.forEach((box) => {
              delete box.table;
            });
          });
        });
        return JSON.stringify(pages);
      }
      /**
       *
       * @param {LayoutDataTable} table - Table to delete.
       * @param {number} n - Page number.
       */
      static deleteLayoutDataTable(table3, n2) {
        const idx = this.pages[n2].tables.findIndex((t2) => t2.id === table3.id);
        if (idx >= 0) {
          this.pages[n2].tables.splice(idx, 1);
        }
      }
    };
    ocrAll = { active: [] };
    ocrAllRaw = { active: [] };
    pageMetricsAll = [];
    DebugData = class {
      /** @type {{[key: string]: Array<Array<CompDebugBrowser|CompDebugNode>> | undefined}} */
      static debugImg = {};
    };
    visInstructions = [];
    convertPageWarn = [];
  }
});

// node_modules/scribe.js-ocr/lib/pako.esm.min.js
var pako_esm_min_exports = {};
__export(pako_esm_min_exports, {
  Deflate: () => Deflate_1,
  Inflate: () => Inflate_1,
  constants: () => constants_1,
  default: () => pako,
  deflate: () => deflate_1,
  deflateRaw: () => deflateRaw_1,
  gzip: () => gzip_1,
  inflate: () => inflate_1,
  inflateRaw: () => inflateRaw_1,
  ungzip: () => ungzip_1
});
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
function Deflate$1(options) {
  this.options = common.assign({ level: Z_DEFAULT_COMPRESSION, method: Z_DEFLATED$1, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: Z_DEFAULT_STRATEGY }, options || {});
  let opt2 = this.options;
  if (opt2.raw && opt2.windowBits > 0) {
    opt2.windowBits = -opt2.windowBits;
  } else if (opt2.gzip && opt2.windowBits > 0 && opt2.windowBits < 16) {
    opt2.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(this.strm, opt2.level, opt2.method, opt2.windowBits, opt2.memLevel, opt2.strategy);
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt2.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt2.header);
  }
  if (opt2.dictionary) {
    let dict;
    if (typeof opt2.dictionary === "string") {
      dict = strings.string2buf(opt2.dictionary);
    } else if (toString$1.call(opt2.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt2.dictionary);
    } else {
      dict = opt2.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
function Inflate$1(options) {
  this.options = common.assign({ chunkSize: 1024 * 64, windowBits: 15, to: "" }, options || {});
  const opt2 = this.options;
  if (opt2.raw && opt2.windowBits >= 0 && opt2.windowBits < 16) {
    opt2.windowBits = -opt2.windowBits;
    if (opt2.windowBits === 0) {
      opt2.windowBits = -15;
    }
  }
  if (opt2.windowBits >= 0 && opt2.windowBits < 16 && !(options && options.windowBits)) {
    opt2.windowBits += 32;
  }
  if (opt2.windowBits > 15 && opt2.windowBits < 48) {
    if ((opt2.windowBits & 15) === 0) {
      opt2.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(this.strm, opt2.windowBits);
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt2.dictionary) {
    if (typeof opt2.dictionary === "string") {
      opt2.dictionary = strings.string2buf(opt2.dictionary);
    } else if (toString.call(opt2.dictionary) === "[object ArrayBuffer]") {
      opt2.dictionary = new Uint8Array(opt2.dictionary);
    }
    if (opt2.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt2.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Z_FIXED$1, Z_BINARY, Z_TEXT, Z_UNKNOWN$1, STORED_BLOCK, STATIC_TREES, DYN_TREES, MIN_MATCH$1, MAX_MATCH$1, LENGTH_CODES$1, LITERALS$1, L_CODES$1, D_CODES$1, BL_CODES$1, HEAP_SIZE$1, MAX_BITS$1, Buf_size, MAX_BL_BITS, END_BLOCK, REP_3_6, REPZ_3_10, REPZ_11_138, extra_lbits, extra_dbits, extra_blbits, bl_order, DIST_CODE_LEN, static_ltree, static_dtree, _dist_code, _length_code, base_length, base_dist, static_l_desc, static_d_desc, static_bl_desc, d_code, put_short, send_bits, send_code, bi_reverse, bi_flush, gen_bitlen, gen_codes, tr_static_init, init_block, bi_windup, copy_block, smaller, pqdownheap, compress_block, build_tree, scan_tree, send_tree, build_bl_tree, send_all_trees, detect_data_type, static_init_done, _tr_init$1, _tr_stored_block$1, _tr_align$1, _tr_flush_block$1, _tr_tally$1, _tr_init_1, _tr_stored_block_1, _tr_flush_block_1, _tr_tally_1, _tr_align_1, trees, adler32, adler32_1, makeTable, crcTable, crc32, crc32_1, messages, constants$2, _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align, Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH$1, Z_FINISH$3, Z_BLOCK$1, Z_OK$3, Z_STREAM_END$3, Z_STREAM_ERROR$2, Z_DATA_ERROR$2, Z_BUF_ERROR$1, Z_DEFAULT_COMPRESSION$1, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY$1, Z_UNKNOWN, Z_DEFLATED$2, MAX_MEM_LEVEL, MAX_WBITS$1, DEF_MEM_LEVEL, LENGTH_CODES, LITERALS, L_CODES, D_CODES, BL_CODES, HEAP_SIZE, MAX_BITS, MIN_MATCH, MAX_MATCH, MIN_LOOKAHEAD, PRESET_DICT, INIT_STATE, EXTRA_STATE, NAME_STATE, COMMENT_STATE, HCRC_STATE, BUSY_STATE, FINISH_STATE, BS_NEED_MORE, BS_BLOCK_DONE, BS_FINISH_STARTED, BS_FINISH_DONE, OS_CODE, err, rank, zero, HASH_ZLIB, HASH, flush_pending, flush_block_only, put_byte, putShortMSB, read_buf, longest_match, fill_window, deflate_stored, deflate_fast, deflate_slow, deflate_rle, deflate_huff, configuration_table, lm_init, deflateResetKeep, deflateReset, deflateSetHeader, deflateInit2, deflateInit, deflate$2, deflateEnd, deflateSetDictionary, deflateInit_1, deflateInit2_1, deflateReset_1, deflateResetKeep_1, deflateSetHeader_1, deflate_2$1, deflateEnd_1, deflateSetDictionary_1, deflateInfo, deflate_1$2, _has, assign, flattenChunks, common, STR_APPLY_UIA_OK, _utf8len, string2buf, buf2binstring, buf2string, utf8border, strings, zstream, toString$1, Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH$2, Z_OK$2, Z_STREAM_END$2, Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY, Z_DEFLATED$1, Deflate_1$1, deflate_2, deflateRaw_1$1, gzip_1$1, constants$1, deflate_1$1, BAD$1, TYPE$1, inffast, MAXBITS, ENOUGH_LENS$1, ENOUGH_DISTS$1, CODES$1, LENS$1, DISTS$1, lbase, lext, dbase, dext, inflate_table, inftrees, CODES, LENS, DISTS, Z_FINISH$1, Z_BLOCK, Z_TREES, Z_OK$1, Z_STREAM_END$1, Z_NEED_DICT$1, Z_STREAM_ERROR$1, Z_DATA_ERROR$1, Z_MEM_ERROR$1, Z_BUF_ERROR, Z_DEFLATED, HEAD, FLAGS, TIME, OS, EXLEN, EXTRA, NAME, COMMENT, HCRC, DICTID, DICT, TYPE, TYPEDO, STORED, COPY_, COPY, TABLE, LENLENS, CODELENS, LEN_, LEN, LENEXT, DIST, DISTEXT, MATCH, LIT, CHECK, LENGTH, DONE, BAD, MEM, SYNC, ENOUGH_LENS, ENOUGH_DISTS, MAX_WBITS, DEF_WBITS, zswap32, inflateResetKeep, inflateReset, inflateReset2, inflateInit2, inflateInit, virgin, lenfix, distfix, fixedtables, updatewindow, inflate$2, inflateEnd, inflateGetHeader, inflateSetDictionary, inflateReset_1, inflateReset2_1, inflateResetKeep_1, inflateInit_1, inflateInit2_1, inflate_2$1, inflateEnd_1, inflateGetHeader_1, inflateSetDictionary_1, inflateInfo, inflate_1$2, gzheader, toString, Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR, Inflate_1$1, inflate_2, inflateRaw_1$1, ungzip$1, constants, inflate_1$1, Deflate, deflate, deflateRaw, gzip, Inflate, inflate, inflateRaw, ungzip, Deflate_1, deflate_1, deflateRaw_1, gzip_1, Inflate_1, inflate_1, inflateRaw_1, ungzip_1, constants_1, pako;
var init_pako_esm_min = __esm({
  "node_modules/scribe.js-ocr/lib/pako.esm.min.js"() {
    Z_FIXED$1 = 4;
    Z_BINARY = 0;
    Z_TEXT = 1;
    Z_UNKNOWN$1 = 2;
    STORED_BLOCK = 0;
    STATIC_TREES = 1;
    DYN_TREES = 2;
    MIN_MATCH$1 = 3;
    MAX_MATCH$1 = 258;
    LENGTH_CODES$1 = 29;
    LITERALS$1 = 256;
    L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
    D_CODES$1 = 30;
    BL_CODES$1 = 19;
    HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
    MAX_BITS$1 = 15;
    Buf_size = 16;
    MAX_BL_BITS = 7;
    END_BLOCK = 256;
    REP_3_6 = 16;
    REPZ_3_10 = 17;
    REPZ_11_138 = 18;
    extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
    extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
    extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
    bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    DIST_CODE_LEN = 512;
    static_ltree = new Array((L_CODES$1 + 2) * 2);
    zero$1(static_ltree);
    static_dtree = new Array(D_CODES$1 * 2);
    zero$1(static_dtree);
    _dist_code = new Array(DIST_CODE_LEN);
    zero$1(_dist_code);
    _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
    zero$1(_length_code);
    base_length = new Array(LENGTH_CODES$1);
    zero$1(base_length);
    base_dist = new Array(D_CODES$1);
    zero$1(base_dist);
    d_code = (dist) => dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    put_short = (s2, w2) => {
      s2.pending_buf[s2.pending++] = w2 & 255;
      s2.pending_buf[s2.pending++] = w2 >>> 8 & 255;
    };
    send_bits = (s2, value, length) => {
      if (s2.bi_valid > Buf_size - length) {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        put_short(s2, s2.bi_buf);
        s2.bi_buf = value >> Buf_size - s2.bi_valid;
        s2.bi_valid += length - Buf_size;
      } else {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        s2.bi_valid += length;
      }
    };
    send_code = (s2, c2, tree) => {
      send_bits(s2, tree[c2 * 2], tree[c2 * 2 + 1]);
    };
    bi_reverse = (code, len) => {
      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };
    bi_flush = (s2) => {
      if (s2.bi_valid === 16) {
        put_short(s2, s2.bi_buf);
        s2.bi_buf = 0;
        s2.bi_valid = 0;
      } else if (s2.bi_valid >= 8) {
        s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
        s2.bi_buf >>= 8;
        s2.bi_valid -= 8;
      }
    };
    gen_bitlen = (s2, desc) => {
      const tree = desc.dyn_tree;
      const max_code = desc.max_code;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const extra = desc.stat_desc.extra_bits;
      const base = desc.stat_desc.extra_base;
      const max_length = desc.stat_desc.max_length;
      let h2;
      let n2, m2;
      let bits;
      let xbits;
      let f2;
      let overflow = 0;
      for (bits = 0; bits <= MAX_BITS$1; bits++) {
        s2.bl_count[bits] = 0;
      }
      tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
      for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE$1; h2++) {
        n2 = s2.heap[h2];
        bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n2 * 2 + 1] = bits;
        if (n2 > max_code) {
          continue;
        }
        s2.bl_count[bits]++;
        xbits = 0;
        if (n2 >= base) {
          xbits = extra[n2 - base];
        }
        f2 = tree[n2 * 2];
        s2.opt_len += f2 * (bits + xbits);
        if (has_stree) {
          s2.static_len += f2 * (stree[n2 * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s2.bl_count[bits] === 0) {
          bits--;
        }
        s2.bl_count[bits]--;
        s2.bl_count[bits + 1] += 2;
        s2.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n2 = s2.bl_count[bits];
        while (n2 !== 0) {
          m2 = s2.heap[--h2];
          if (m2 > max_code) {
            continue;
          }
          if (tree[m2 * 2 + 1] !== bits) {
            s2.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
            tree[m2 * 2 + 1] = bits;
          }
          n2--;
        }
      }
    };
    gen_codes = (tree, max_code, bl_count) => {
      const next_code = new Array(MAX_BITS$1 + 1);
      let code = 0;
      let bits;
      let n2;
      for (bits = 1; bits <= MAX_BITS$1; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n2 = 0; n2 <= max_code; n2++) {
        let len = tree[n2 * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n2 * 2] = bi_reverse(next_code[len]++, len);
      }
    };
    tr_static_init = () => {
      let n2;
      let bits;
      let length;
      let code;
      let dist;
      const bl_count = new Array(MAX_BITS$1 + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
        base_length[code] = length;
        for (n2 = 0; n2 < 1 << extra_lbits[code]; n2++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n2 = 0; n2 < 1 << extra_dbits[code]; n2++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES$1; code++) {
        base_dist[code] = dist << 7;
        for (n2 = 0; n2 < 1 << extra_dbits[code] - 7; n2++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS$1; bits++) {
        bl_count[bits] = 0;
      }
      n2 = 0;
      while (n2 <= 143) {
        static_ltree[n2 * 2 + 1] = 8;
        n2++;
        bl_count[8]++;
      }
      while (n2 <= 255) {
        static_ltree[n2 * 2 + 1] = 9;
        n2++;
        bl_count[9]++;
      }
      while (n2 <= 279) {
        static_ltree[n2 * 2 + 1] = 7;
        n2++;
        bl_count[7]++;
      }
      while (n2 <= 287) {
        static_ltree[n2 * 2 + 1] = 8;
        n2++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
      for (n2 = 0; n2 < D_CODES$1; n2++) {
        static_dtree[n2 * 2 + 1] = 5;
        static_dtree[n2 * 2] = bi_reverse(n2, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
    };
    init_block = (s2) => {
      let n2;
      for (n2 = 0; n2 < L_CODES$1; n2++) {
        s2.dyn_ltree[n2 * 2] = 0;
      }
      for (n2 = 0; n2 < D_CODES$1; n2++) {
        s2.dyn_dtree[n2 * 2] = 0;
      }
      for (n2 = 0; n2 < BL_CODES$1; n2++) {
        s2.bl_tree[n2 * 2] = 0;
      }
      s2.dyn_ltree[END_BLOCK * 2] = 1;
      s2.opt_len = s2.static_len = 0;
      s2.last_lit = s2.matches = 0;
    };
    bi_windup = (s2) => {
      if (s2.bi_valid > 8) {
        put_short(s2, s2.bi_buf);
      } else if (s2.bi_valid > 0) {
        s2.pending_buf[s2.pending++] = s2.bi_buf;
      }
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    };
    copy_block = (s2, buf, len, header) => {
      bi_windup(s2);
      if (header) {
        put_short(s2, len);
        put_short(s2, ~len);
      }
      s2.pending_buf.set(s2.window.subarray(buf, buf + len), s2.pending);
      s2.pending += len;
    };
    smaller = (tree, n2, m2, depth) => {
      const _n2 = n2 * 2;
      const _m2 = m2 * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m2];
    };
    pqdownheap = (s2, tree, k2) => {
      const v2 = s2.heap[k2];
      let j2 = k2 << 1;
      while (j2 <= s2.heap_len) {
        if (j2 < s2.heap_len && smaller(tree, s2.heap[j2 + 1], s2.heap[j2], s2.depth)) {
          j2++;
        }
        if (smaller(tree, v2, s2.heap[j2], s2.depth)) {
          break;
        }
        s2.heap[k2] = s2.heap[j2];
        k2 = j2;
        j2 <<= 1;
      }
      s2.heap[k2] = v2;
    };
    compress_block = (s2, ltree, dtree) => {
      let dist;
      let lc;
      let lx = 0;
      let code;
      let extra;
      if (s2.last_lit !== 0) {
        do {
          dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
          lc = s2.pending_buf[s2.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s2, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s2, code + LITERALS$1 + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s2, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s2, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s2, dist, extra);
            }
          }
        } while (lx < s2.last_lit);
      }
      send_code(s2, END_BLOCK, ltree);
    };
    build_tree = (s2, desc) => {
      const tree = desc.dyn_tree;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems = desc.stat_desc.elems;
      let n2, m2;
      let max_code = -1;
      let node;
      s2.heap_len = 0;
      s2.heap_max = HEAP_SIZE$1;
      for (n2 = 0; n2 < elems; n2++) {
        if (tree[n2 * 2] !== 0) {
          s2.heap[++s2.heap_len] = max_code = n2;
          s2.depth[n2] = 0;
        } else {
          tree[n2 * 2 + 1] = 0;
        }
      }
      while (s2.heap_len < 2) {
        node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s2.depth[node] = 0;
        s2.opt_len--;
        if (has_stree) {
          s2.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n2 = s2.heap_len >> 1; n2 >= 1; n2--) {
        pqdownheap(s2, tree, n2);
      }
      node = elems;
      do {
        n2 = s2.heap[1];
        s2.heap[1] = s2.heap[s2.heap_len--];
        pqdownheap(s2, tree, 1);
        m2 = s2.heap[1];
        s2.heap[--s2.heap_max] = n2;
        s2.heap[--s2.heap_max] = m2;
        tree[node * 2] = tree[n2 * 2] + tree[m2 * 2];
        s2.depth[node] = (s2.depth[n2] >= s2.depth[m2] ? s2.depth[n2] : s2.depth[m2]) + 1;
        tree[n2 * 2 + 1] = tree[m2 * 2 + 1] = node;
        s2.heap[1] = node++;
        pqdownheap(s2, tree, 1);
      } while (s2.heap_len >= 2);
      s2.heap[--s2.heap_max] = s2.heap[1];
      gen_bitlen(s2, desc);
      gen_codes(tree, max_code, s2.bl_count);
    };
    scan_tree = (s2, tree, max_code) => {
      let n2;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n2 = 0; n2 <= max_code; n2++) {
        curlen = nextlen;
        nextlen = tree[(n2 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s2.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s2.bl_tree[curlen * 2]++;
          }
          s2.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s2.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s2.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    send_tree = (s2, tree, max_code) => {
      let n2;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n2 = 0; n2 <= max_code; n2++) {
        curlen = nextlen;
        nextlen = tree[(n2 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s2, curlen, s2.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s2, curlen, s2.bl_tree);
            count--;
          }
          send_code(s2, REP_3_6, s2.bl_tree);
          send_bits(s2, count - 3, 2);
        } else if (count <= 10) {
          send_code(s2, REPZ_3_10, s2.bl_tree);
          send_bits(s2, count - 3, 3);
        } else {
          send_code(s2, REPZ_11_138, s2.bl_tree);
          send_bits(s2, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    build_bl_tree = (s2) => {
      let max_blindex;
      scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
      scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
      build_tree(s2, s2.bl_desc);
      for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
        if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    };
    send_all_trees = (s2, lcodes, dcodes, blcodes) => {
      let rank3;
      send_bits(s2, lcodes - 257, 5);
      send_bits(s2, dcodes - 1, 5);
      send_bits(s2, blcodes - 4, 4);
      for (rank3 = 0; rank3 < blcodes; rank3++) {
        send_bits(s2, s2.bl_tree[bl_order[rank3] * 2 + 1], 3);
      }
      send_tree(s2, s2.dyn_ltree, lcodes - 1);
      send_tree(s2, s2.dyn_dtree, dcodes - 1);
    };
    detect_data_type = (s2) => {
      let black_mask = 4093624447;
      let n2;
      for (n2 = 0; n2 <= 31; n2++, black_mask >>>= 1) {
        if (black_mask & 1 && s2.dyn_ltree[n2 * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n2 = 32; n2 < LITERALS$1; n2++) {
        if (s2.dyn_ltree[n2 * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    };
    static_init_done = false;
    _tr_init$1 = (s2) => {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
      s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
      s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
      init_block(s2);
    };
    _tr_stored_block$1 = (s2, buf, stored_len, last) => {
      send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s2, buf, stored_len, true);
    };
    _tr_align$1 = (s2) => {
      send_bits(s2, STATIC_TREES << 1, 3);
      send_code(s2, END_BLOCK, static_ltree);
      bi_flush(s2);
    };
    _tr_flush_block$1 = (s2, buf, stored_len, last) => {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (s2.level > 0) {
        if (s2.strm.data_type === Z_UNKNOWN$1) {
          s2.strm.data_type = detect_data_type(s2);
        }
        build_tree(s2, s2.l_desc);
        build_tree(s2, s2.d_desc);
        max_blindex = build_bl_tree(s2);
        opt_lenb = s2.opt_len + 3 + 7 >>> 3;
        static_lenb = s2.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block$1(s2, buf, stored_len, last);
      } else if (s2.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
        send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s2, static_ltree, static_dtree);
      } else {
        send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
      }
      init_block(s2);
      if (last) {
        bi_windup(s2);
      }
    };
    _tr_tally$1 = (s2, dist, lc) => {
      s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
      s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
      s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
      s2.last_lit++;
      if (dist === 0) {
        s2.dyn_ltree[lc * 2]++;
      } else {
        s2.matches++;
        dist--;
        s2.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
        s2.dyn_dtree[d_code(dist) * 2]++;
      }
      return s2.last_lit === s2.lit_bufsize - 1;
    };
    _tr_init_1 = _tr_init$1;
    _tr_stored_block_1 = _tr_stored_block$1;
    _tr_flush_block_1 = _tr_flush_block$1;
    _tr_tally_1 = _tr_tally$1;
    _tr_align_1 = _tr_align$1;
    trees = { _tr_init: _tr_init_1, _tr_stored_block: _tr_stored_block_1, _tr_flush_block: _tr_flush_block_1, _tr_tally: _tr_tally_1, _tr_align: _tr_align_1 };
    adler32 = (adler, buf, len, pos) => {
      let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
      while (len !== 0) {
        n2 = len > 2e3 ? 2e3 : len;
        len -= n2;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n2);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    };
    adler32_1 = adler32;
    makeTable = () => {
      let c2, table3 = [];
      for (var n2 = 0; n2 < 256; n2++) {
        c2 = n2;
        for (var k2 = 0; k2 < 8; k2++) {
          c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
        }
        table3[n2] = c2;
      }
      return table3;
    };
    crcTable = new Uint32Array(makeTable());
    crc32 = (crc, buf, len, pos) => {
      const t2 = crcTable;
      const end = pos + len;
      crc ^= -1;
      for (let i2 = pos; i2 < end; i2++) {
        crc = crc >>> 8 ^ t2[(crc ^ buf[i2]) & 255];
      }
      return crc ^ -1;
    };
    crc32_1 = crc32;
    messages = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    constants$2 = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    ({ _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees);
    ({ Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1, Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1, Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1, Z_UNKNOWN, Z_DEFLATED: Z_DEFLATED$2 } = constants$2);
    MAX_MEM_LEVEL = 9;
    MAX_WBITS$1 = 15;
    DEF_MEM_LEVEL = 8;
    LENGTH_CODES = 29;
    LITERALS = 256;
    L_CODES = LITERALS + 1 + LENGTH_CODES;
    D_CODES = 30;
    BL_CODES = 19;
    HEAP_SIZE = 2 * L_CODES + 1;
    MAX_BITS = 15;
    MIN_MATCH = 3;
    MAX_MATCH = 258;
    MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    PRESET_DICT = 32;
    INIT_STATE = 42;
    EXTRA_STATE = 69;
    NAME_STATE = 73;
    COMMENT_STATE = 91;
    HCRC_STATE = 103;
    BUSY_STATE = 113;
    FINISH_STATE = 666;
    BS_NEED_MORE = 1;
    BS_BLOCK_DONE = 2;
    BS_FINISH_STARTED = 3;
    BS_FINISH_DONE = 4;
    OS_CODE = 3;
    err = (strm, errorCode) => {
      strm.msg = messages[errorCode];
      return errorCode;
    };
    rank = (f2) => (f2 << 1) - (f2 > 4 ? 9 : 0);
    zero = (buf) => {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    };
    HASH_ZLIB = (s2, prev, data2) => (prev << s2.hash_shift ^ data2) & s2.hash_mask;
    HASH = HASH_ZLIB;
    flush_pending = (strm) => {
      const s2 = strm.state;
      let len = s2.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      strm.output.set(s2.pending_buf.subarray(s2.pending_out, s2.pending_out + len), strm.next_out);
      strm.next_out += len;
      s2.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s2.pending -= len;
      if (s2.pending === 0) {
        s2.pending_out = 0;
      }
    };
    flush_block_only = (s2, last) => {
      _tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
      s2.block_start = s2.strstart;
      flush_pending(s2.strm);
    };
    put_byte = (s2, b2) => {
      s2.pending_buf[s2.pending++] = b2;
    };
    putShortMSB = (s2, b2) => {
      s2.pending_buf[s2.pending++] = b2 >>> 8 & 255;
      s2.pending_buf[s2.pending++] = b2 & 255;
    };
    read_buf = (strm, buf, start, size) => {
      let len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32_1(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32_1(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    };
    longest_match = (s2, cur_match) => {
      let chain_length = s2.max_chain_length;
      let scan = s2.strstart;
      let match;
      let len;
      let best_len = s2.prev_length;
      let nice_match = s2.nice_match;
      const limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
      const _win = s2.window;
      const wmask = s2.w_mask;
      const prev = s2.prev;
      const strend = s2.strstart + MAX_MATCH;
      let scan_end1 = _win[scan + best_len - 1];
      let scan_end = _win[scan + best_len];
      if (s2.prev_length >= s2.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s2.lookahead) {
        nice_match = s2.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s2.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s2.lookahead) {
        return best_len;
      }
      return s2.lookahead;
    };
    fill_window = (s2) => {
      const _w_size = s2.w_size;
      let p2, n2, m2, more, str;
      do {
        more = s2.window_size - s2.lookahead - s2.strstart;
        if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          s2.window.set(s2.window.subarray(_w_size, _w_size + _w_size), 0);
          s2.match_start -= _w_size;
          s2.strstart -= _w_size;
          s2.block_start -= _w_size;
          n2 = s2.hash_size;
          p2 = n2;
          do {
            m2 = s2.head[--p2];
            s2.head[p2] = m2 >= _w_size ? m2 - _w_size : 0;
          } while (--n2);
          n2 = _w_size;
          p2 = n2;
          do {
            m2 = s2.prev[--p2];
            s2.prev[p2] = m2 >= _w_size ? m2 - _w_size : 0;
          } while (--n2);
          more += _w_size;
        }
        if (s2.strm.avail_in === 0) {
          break;
        }
        n2 = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
        s2.lookahead += n2;
        if (s2.lookahead + s2.insert >= MIN_MATCH) {
          str = s2.strstart - s2.insert;
          s2.ins_h = s2.window[str];
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + 1]);
          while (s2.insert) {
            s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
            s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = str;
            str++;
            s2.insert--;
            if (s2.lookahead + s2.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
    };
    deflate_stored = (s2, flush) => {
      let max_block_size = 65535;
      if (max_block_size > s2.pending_buf_size - 5) {
        max_block_size = s2.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s2.lookahead <= 1) {
          fill_window(s2);
          if (s2.lookahead === 0 && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.strstart += s2.lookahead;
        s2.lookahead = 0;
        const max_start = s2.block_start + max_block_size;
        if (s2.strstart === 0 || s2.strstart >= max_start) {
          s2.lookahead = s2.strstart - max_start;
          s2.strstart = max_start;
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH$3) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.strstart > s2.block_start) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    };
    deflate_fast = (s2, flush) => {
      let hash_head;
      let bflush;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
            s2.match_length--;
            do {
              s2.strstart++;
              s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            } while (--s2.match_length !== 0);
            s2.strstart++;
          } else {
            s2.strstart += s2.match_length;
            s2.match_length = 0;
            s2.ins_h = s2.window[s2.strstart];
            s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + 1]);
          }
        } else {
          bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH$3) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    deflate_slow = (s2, flush) => {
      let hash_head;
      let bflush;
      let max_insert;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        s2.prev_length = s2.match_length;
        s2.prev_match = s2.match_start;
        s2.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
          if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
            s2.match_length = MIN_MATCH - 1;
          }
        }
        if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
          max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
          bflush = _tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
          s2.lookahead -= s2.prev_length - 1;
          s2.prev_length -= 2;
          do {
            if (++s2.strstart <= max_insert) {
              s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
          } while (--s2.prev_length !== 0);
          s2.match_available = 0;
          s2.match_length = MIN_MATCH - 1;
          s2.strstart++;
          if (bflush) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s2.match_available) {
          bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
          if (bflush) {
            flush_block_only(s2, false);
          }
          s2.strstart++;
          s2.lookahead--;
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s2.match_available = 1;
          s2.strstart++;
          s2.lookahead--;
        }
      }
      if (s2.match_available) {
        bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        s2.match_available = 0;
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH$3) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    deflate_rle = (s2, flush) => {
      let bflush;
      let prev;
      let scan, strend;
      const _win = s2.window;
      for (; ; ) {
        if (s2.lookahead <= MAX_MATCH) {
          fill_window(s2);
          if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.match_length = 0;
        if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
          scan = s2.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s2.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s2.match_length = MAX_MATCH - (strend - scan);
            if (s2.match_length > s2.lookahead) {
              s2.match_length = s2.lookahead;
            }
          }
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s2, 1, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          s2.strstart += s2.match_length;
          s2.match_length = 0;
        } else {
          bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH$3) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    deflate_huff = (s2, flush) => {
      let bflush;
      for (; ; ) {
        if (s2.lookahead === 0) {
          fill_window(s2);
          if (s2.lookahead === 0) {
            if (flush === Z_NO_FLUSH$2) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s2.match_length = 0;
        bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH$3) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    configuration_table = [new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow)];
    lm_init = (s2) => {
      s2.window_size = 2 * s2.w_size;
      zero(s2.head);
      s2.max_lazy_match = configuration_table[s2.level].max_lazy;
      s2.good_match = configuration_table[s2.level].good_length;
      s2.nice_match = configuration_table[s2.level].nice_length;
      s2.max_chain_length = configuration_table[s2.level].max_chain;
      s2.strstart = 0;
      s2.block_start = 0;
      s2.lookahead = 0;
      s2.insert = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      s2.ins_h = 0;
    };
    deflateResetKeep = (strm) => {
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR$2);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      const s2 = strm.state;
      s2.pending = 0;
      s2.pending_out = 0;
      if (s2.wrap < 0) {
        s2.wrap = -s2.wrap;
      }
      s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s2.wrap === 2 ? 0 : 1;
      s2.last_flush = Z_NO_FLUSH$2;
      _tr_init(s2);
      return Z_OK$3;
    };
    deflateReset = (strm) => {
      const ret = deflateResetKeep(strm);
      if (ret === Z_OK$3) {
        lm_init(strm.state);
      }
      return ret;
    };
    deflateSetHeader = (strm, head) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$2;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR$2;
      }
      strm.state.gzhead = head;
      return Z_OK$3;
    };
    deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
      if (!strm) {
        return Z_STREAM_ERROR$2;
      }
      let wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION$1) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR$2);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      const s2 = new DeflateState();
      strm.state = s2;
      s2.strm = strm;
      s2.wrap = wrap;
      s2.gzhead = null;
      s2.w_bits = windowBits;
      s2.w_size = 1 << s2.w_bits;
      s2.w_mask = s2.w_size - 1;
      s2.hash_bits = memLevel + 7;
      s2.hash_size = 1 << s2.hash_bits;
      s2.hash_mask = s2.hash_size - 1;
      s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s2.window = new Uint8Array(s2.w_size * 2);
      s2.head = new Uint16Array(s2.hash_size);
      s2.prev = new Uint16Array(s2.w_size);
      s2.lit_bufsize = 1 << memLevel + 6;
      s2.pending_buf_size = s2.lit_bufsize * 4;
      s2.pending_buf = new Uint8Array(s2.pending_buf_size);
      s2.d_buf = 1 * s2.lit_bufsize;
      s2.l_buf = (1 + 2) * s2.lit_bufsize;
      s2.level = level;
      s2.strategy = strategy;
      s2.method = method;
      return deflateReset(strm);
    };
    deflateInit = (strm, level) => deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
    deflate$2 = (strm, flush) => {
      let beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK$1 || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
      }
      const s2 = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush !== Z_FINISH$3) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
      }
      s2.strm = strm;
      const old_flush = s2.last_flush;
      s2.last_flush = flush;
      if (s2.status === INIT_STATE) {
        if (s2.wrap === 2) {
          strm.adler = 0;
          put_byte(s2, 31);
          put_byte(s2, 139);
          put_byte(s2, 8);
          if (!s2.gzhead) {
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
            put_byte(s2, OS_CODE);
            s2.status = BUSY_STATE;
          } else {
            put_byte(s2, (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16));
            put_byte(s2, s2.gzhead.time & 255);
            put_byte(s2, s2.gzhead.time >> 8 & 255);
            put_byte(s2, s2.gzhead.time >> 16 & 255);
            put_byte(s2, s2.gzhead.time >> 24 & 255);
            put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
            put_byte(s2, s2.gzhead.os & 255);
            if (s2.gzhead.extra && s2.gzhead.extra.length) {
              put_byte(s2, s2.gzhead.extra.length & 255);
              put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
            }
            if (s2.gzhead.hcrc) {
              strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending, 0);
            }
            s2.gzindex = 0;
            s2.status = EXTRA_STATE;
          }
        } else {
          let header = Z_DEFLATED$2 + (s2.w_bits - 8 << 4) << 8;
          let level_flags = -1;
          if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
            level_flags = 0;
          } else if (s2.level < 6) {
            level_flags = 1;
          } else if (s2.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s2.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s2.status = BUSY_STATE;
          putShortMSB(s2, header);
          if (s2.strstart !== 0) {
            putShortMSB(s2, strm.adler >>> 16);
            putShortMSB(s2, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s2.status === EXTRA_STATE) {
        if (s2.gzhead.extra) {
          beg = s2.pending;
          while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                break;
              }
            }
            put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
            s2.gzindex++;
          }
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (s2.gzindex === s2.gzhead.extra.length) {
            s2.gzindex = 0;
            s2.status = NAME_STATE;
          }
        } else {
          s2.status = NAME_STATE;
        }
      }
      if (s2.status === NAME_STATE) {
        if (s2.gzhead.name) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.name.length) {
              val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.gzindex = 0;
            s2.status = COMMENT_STATE;
          }
        } else {
          s2.status = COMMENT_STATE;
        }
      }
      if (s2.status === COMMENT_STATE) {
        if (s2.gzhead.comment) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.comment.length) {
              val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.status = HCRC_STATE;
          }
        } else {
          s2.status = HCRC_STATE;
        }
      }
      if (s2.status === HCRC_STATE) {
        if (s2.gzhead.hcrc) {
          if (s2.pending + 2 > s2.pending_buf_size) {
            flush_pending(strm);
          }
          if (s2.pending + 2 <= s2.pending_buf_size) {
            put_byte(s2, strm.adler & 255);
            put_byte(s2, strm.adler >> 8 & 255);
            strm.adler = 0;
            s2.status = BUSY_STATE;
          }
        } else {
          s2.status = BUSY_STATE;
        }
      }
      if (s2.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK$3;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
        return err(strm, Z_BUF_ERROR$1);
      }
      if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR$1);
      }
      if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s2.status !== FINISH_STATE) {
        let bstate = s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s2.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
          }
          return Z_OK$3;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            _tr_align(s2);
          } else if (flush !== Z_BLOCK$1) {
            _tr_stored_block(s2, 0, 0, false);
            if (flush === Z_FULL_FLUSH$1) {
              zero(s2.head);
              if (s2.lookahead === 0) {
                s2.strstart = 0;
                s2.block_start = 0;
                s2.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
            return Z_OK$3;
          }
        }
      }
      if (flush !== Z_FINISH$3) {
        return Z_OK$3;
      }
      if (s2.wrap <= 0) {
        return Z_STREAM_END$3;
      }
      if (s2.wrap === 2) {
        put_byte(s2, strm.adler & 255);
        put_byte(s2, strm.adler >> 8 & 255);
        put_byte(s2, strm.adler >> 16 & 255);
        put_byte(s2, strm.adler >> 24 & 255);
        put_byte(s2, strm.total_in & 255);
        put_byte(s2, strm.total_in >> 8 & 255);
        put_byte(s2, strm.total_in >> 16 & 255);
        put_byte(s2, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s2, strm.adler >>> 16);
        putShortMSB(s2, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s2.wrap > 0) {
        s2.wrap = -s2.wrap;
      }
      return s2.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
    };
    deflateEnd = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$2;
      }
      const status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR$2);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
    };
    deflateSetDictionary = (strm, dictionary) => {
      let dictLength = dictionary.length;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$2;
      }
      const s2 = strm.state;
      const wrap = s2.wrap;
      if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
        return Z_STREAM_ERROR$2;
      }
      if (wrap === 1) {
        strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
      }
      s2.wrap = 0;
      if (dictLength >= s2.w_size) {
        if (wrap === 0) {
          zero(s2.head);
          s2.strstart = 0;
          s2.block_start = 0;
          s2.insert = 0;
        }
        let tmpDict = new Uint8Array(s2.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s2.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s2.w_size;
      }
      const avail = strm.avail_in;
      const next = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s2);
      while (s2.lookahead >= MIN_MATCH) {
        let str = s2.strstart;
        let n2 = s2.lookahead - (MIN_MATCH - 1);
        do {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
        } while (--n2);
        s2.strstart = str;
        s2.lookahead = MIN_MATCH - 1;
        fill_window(s2);
      }
      s2.strstart += s2.lookahead;
      s2.block_start = s2.strstart;
      s2.insert = s2.lookahead;
      s2.lookahead = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s2.wrap = wrap;
      return Z_OK$3;
    };
    deflateInit_1 = deflateInit;
    deflateInit2_1 = deflateInit2;
    deflateReset_1 = deflateReset;
    deflateResetKeep_1 = deflateResetKeep;
    deflateSetHeader_1 = deflateSetHeader;
    deflate_2$1 = deflate$2;
    deflateEnd_1 = deflateEnd;
    deflateSetDictionary_1 = deflateSetDictionary;
    deflateInfo = "pako deflate (from Nodeca project)";
    deflate_1$2 = { deflateInit: deflateInit_1, deflateInit2: deflateInit2_1, deflateReset: deflateReset_1, deflateResetKeep: deflateResetKeep_1, deflateSetHeader: deflateSetHeader_1, deflate: deflate_2$1, deflateEnd: deflateEnd_1, deflateSetDictionary: deflateSetDictionary_1, deflateInfo };
    _has = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
    assign = function(obj) {
      const sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        const source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (const p2 in source) {
          if (_has(source, p2)) {
            obj[p2] = source[p2];
          }
        }
      }
      return obj;
    };
    flattenChunks = (chunks) => {
      let len = 0;
      for (let i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
        len += chunks[i2].length;
      }
      const result = new Uint8Array(len);
      for (let i2 = 0, pos = 0, l2 = chunks.length; i2 < l2; i2++) {
        let chunk = chunks[i2];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    };
    common = { assign, flattenChunks };
    STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    _utf8len = new Uint8Array(256);
    for (let q2 = 0; q2 < 256; q2++) {
      _utf8len[q2] = q2 >= 252 ? 6 : q2 >= 248 ? 5 : q2 >= 240 ? 4 : q2 >= 224 ? 3 : q2 >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    string2buf = (str) => {
      if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str);
      }
      let buf, c2, c22, m_pos, i2, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c2 = str.charCodeAt(m_pos);
        if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
      }
      buf = new Uint8Array(buf_len);
      for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
        c2 = str.charCodeAt(m_pos);
        if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        if (c2 < 128) {
          buf[i2++] = c2;
        } else if (c2 < 2048) {
          buf[i2++] = 192 | c2 >>> 6;
          buf[i2++] = 128 | c2 & 63;
        } else if (c2 < 65536) {
          buf[i2++] = 224 | c2 >>> 12;
          buf[i2++] = 128 | c2 >>> 6 & 63;
          buf[i2++] = 128 | c2 & 63;
        } else {
          buf[i2++] = 240 | c2 >>> 18;
          buf[i2++] = 128 | c2 >>> 12 & 63;
          buf[i2++] = 128 | c2 >>> 6 & 63;
          buf[i2++] = 128 | c2 & 63;
        }
      }
      return buf;
    };
    buf2binstring = (buf, len) => {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
          return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
      }
      let result = "";
      for (let i2 = 0; i2 < len; i2++) {
        result += String.fromCharCode(buf[i2]);
      }
      return result;
    };
    buf2string = (buf, max) => {
      const len = max || buf.length;
      if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max));
      }
      let i2, out;
      const utf16buf = new Array(len * 2);
      for (out = 0, i2 = 0; i2 < len; ) {
        let c2 = buf[i2++];
        if (c2 < 128) {
          utf16buf[out++] = c2;
          continue;
        }
        let c_len = _utf8len[c2];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i2 += c_len - 1;
          continue;
        }
        c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i2 < len) {
          c2 = c2 << 6 | buf[i2++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c2 < 65536) {
          utf16buf[out++] = c2;
        } else {
          c2 -= 65536;
          utf16buf[out++] = 55296 | c2 >> 10 & 1023;
          utf16buf[out++] = 56320 | c2 & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    utf8border = (buf, max) => {
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      let pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
    strings = { string2buf, buf2string, utf8border };
    zstream = ZStream;
    toString$1 = Object.prototype.toString;
    ({ Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2, Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2, Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY, Z_DEFLATED: Z_DEFLATED$1 } = constants$2);
    Deflate$1.prototype.push = function(data2, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      let status, _flush_mode;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
      else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
      if (typeof data2 === "string") {
        strm.input = strings.string2buf(data2);
      } else if (toString$1.call(data2) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data2);
      } else {
        strm.input = data2;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        status = deflate_1$2.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END$2) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = deflate_1$2.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK$2;
        }
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        if (strm.avail_in === 0) break;
      }
      return true;
    };
    Deflate$1.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate$1.prototype.onEnd = function(status) {
      if (status === Z_OK$2) {
        this.result = common.flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    Deflate_1$1 = Deflate$1;
    deflate_2 = deflate$1;
    deflateRaw_1$1 = deflateRaw$1;
    gzip_1$1 = gzip$1;
    constants$1 = constants$2;
    deflate_1$1 = { Deflate: Deflate_1$1, deflate: deflate_2, deflateRaw: deflateRaw_1$1, gzip: gzip_1$1, constants: constants$1 };
    BAD$1 = 30;
    TYPE$1 = 12;
    inffast = function inflate_fast(strm, start) {
      let _in;
      let last;
      let _out;
      let beg;
      let end;
      let dmax;
      let wsize;
      let whave;
      let wnext;
      let s_window;
      let hold;
      let bits;
      let lcode;
      let dcode;
      let lmask;
      let dmask;
      let here;
      let op;
      let len;
      let dist;
      let from;
      let from_source;
      let input, output;
      const state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top: do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen: for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist: for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op & 16) {
                dist = here & 65535;
                op &= 15;
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                }
                dist += hold & (1 << op) - 1;
                if (dist > dmax) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD$1;
                  break top;
                }
                hold >>>= op;
                bits -= op;
                op = _out - beg;
                if (dist > op) {
                  op = dist - op;
                  if (op > whave) {
                    if (state.sane) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD$1;
                      break top;
                    }
                  }
                  from = 0;
                  from_source = s_window;
                  if (wnext === 0) {
                    from += wsize - op;
                    if (op < len) {
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist;
                      from_source = output;
                    }
                  } else if (wnext < op) {
                    from += wsize + wnext - op;
                    op -= wnext;
                    if (op < len) {
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = 0;
                      if (wnext < len) {
                        op = wnext;
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                  } else {
                    from += wnext - op;
                    if (op < len) {
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist;
                      from_source = output;
                    }
                  }
                  while (len > 2) {
                    output[_out++] = from_source[from++];
                    output[_out++] = from_source[from++];
                    output[_out++] = from_source[from++];
                    len -= 3;
                  }
                  if (len) {
                    output[_out++] = from_source[from++];
                    if (len > 1) {
                      output[_out++] = from_source[from++];
                    }
                  }
                } else {
                  from = _out - dist;
                  do {
                    output[_out++] = output[from++];
                    output[_out++] = output[from++];
                    output[_out++] = output[from++];
                    len -= 3;
                  } while (len > 2);
                  if (len) {
                    output[_out++] = output[from++];
                    if (len > 1) {
                      output[_out++] = output[from++];
                    }
                  }
                }
              } else if ((op & 64) === 0) {
                here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dodist;
              } else {
                strm.msg = "invalid distance code";
                state.mode = BAD$1;
                break top;
              }
              break;
            }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
      } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
    MAXBITS = 15;
    ENOUGH_LENS$1 = 852;
    ENOUGH_DISTS$1 = 592;
    CODES$1 = 0;
    LENS$1 = 1;
    DISTS$1 = 2;
    lbase = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]);
    lext = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]);
    dbase = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]);
    dext = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
    inflate_table = (type, lens, lens_index, codes, table3, table_index, work, opts) => {
      const bits = opts.bits;
      let len = 0;
      let sym = 0;
      let min = 0, max = 0;
      let root = 0;
      let curr = 0;
      let drop = 0;
      let left = 0;
      let used = 0;
      let huff = 0;
      let incr;
      let fill;
      let low;
      let mask;
      let next;
      let base = null;
      let base_index = 0;
      let end;
      const count = new Uint16Array(MAXBITS + 1);
      const offs = new Uint16Array(MAXBITS + 1);
      let extra = null;
      let extra_index = 0;
      let here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table3[table_index++] = 1 << 24 | 64 << 16 | 0;
        table3[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES$1 || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES$1) {
        base = extra = work;
        end = 19;
      } else if (type === LENS$1) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table3[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
            return 1;
          }
          low = huff & mask;
          table3[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table3[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
    inftrees = inflate_table;
    CODES = 0;
    LENS = 1;
    DISTS = 2;
    ({ Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES, Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR, Z_DEFLATED } = constants$2);
    HEAD = 1;
    FLAGS = 2;
    TIME = 3;
    OS = 4;
    EXLEN = 5;
    EXTRA = 6;
    NAME = 7;
    COMMENT = 8;
    HCRC = 9;
    DICTID = 10;
    DICT = 11;
    TYPE = 12;
    TYPEDO = 13;
    STORED = 14;
    COPY_ = 15;
    COPY = 16;
    TABLE = 17;
    LENLENS = 18;
    CODELENS = 19;
    LEN_ = 20;
    LEN = 21;
    LENEXT = 22;
    DIST = 23;
    DISTEXT = 24;
    MATCH = 25;
    LIT = 26;
    CHECK = 27;
    LENGTH = 28;
    DONE = 29;
    BAD = 30;
    MEM = 31;
    SYNC = 32;
    ENOUGH_LENS = 852;
    ENOUGH_DISTS = 592;
    MAX_WBITS = 15;
    DEF_WBITS = MAX_WBITS;
    zswap32 = (q2) => (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
    inflateResetKeep = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
      state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK$1;
    };
    inflateReset = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    };
    inflateReset2 = (strm, windowBits) => {
      let wrap;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR$1;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    };
    inflateInit2 = (strm, windowBits) => {
      if (!strm) {
        return Z_STREAM_ERROR$1;
      }
      const state = new InflateState();
      strm.state = state;
      state.window = null;
      const ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK$1) {
        strm.state = null;
      }
      return ret;
    };
    inflateInit = (strm) => inflateInit2(strm, DEF_WBITS);
    virgin = true;
    fixedtables = (state) => {
      if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    };
    updatewindow = (strm, src, end, copy) => {
      let dist;
      const state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
      }
      if (copy >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
        copy -= dist;
        if (copy) {
          state.window.set(src.subarray(end - copy, end), 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    };
    inflate$2 = (strm, flush) => {
      let state;
      let input, output;
      let next;
      let put;
      let have, left;
      let hold;
      let bits;
      let _in, _out;
      let copy;
      let from;
      let from_source;
      let here = 0;
      let here_bits, here_op, here_val;
      let last_bits, last_op, last_val;
      let len;
      let ret;
      const hbuf = new Uint8Array(4);
      let opts;
      let n2;
      const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR$1;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK$1;
      inf_leave: for (; ; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32_1(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_1(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(input.subarray(next, next + copy), len);
                }
                if (state.flags & 512) {
                  state.check = crc32_1(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT$1;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n2 = here_bits + 2;
                  while (bits < n2) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n2 = here_bits + 3;
                  while (bits < n2) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n2 = here_bits + 7;
                  while (bits < n2) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inffast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n2 = state.extra;
              while (bits < n2) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n2 = state.extra;
              while (bits < n2) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END$1;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR$1;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR$1;
          case SYNC:
          default:
            return Z_STREAM_ERROR$1;
        }
      }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    };
    inflateEnd = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
      }
      let state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK$1;
    };
    inflateGetHeader = (strm, head) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR$1;
      }
      state.head = head;
      head.done = false;
      return Z_OK$1;
    };
    inflateSetDictionary = (strm, dictionary) => {
      const dictLength = dictionary.length;
      let state;
      let dictid;
      let ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR$1;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32_1(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR$1;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR$1;
      }
      state.havedict = 1;
      return Z_OK$1;
    };
    inflateReset_1 = inflateReset;
    inflateReset2_1 = inflateReset2;
    inflateResetKeep_1 = inflateResetKeep;
    inflateInit_1 = inflateInit;
    inflateInit2_1 = inflateInit2;
    inflate_2$1 = inflate$2;
    inflateEnd_1 = inflateEnd;
    inflateGetHeader_1 = inflateGetHeader;
    inflateSetDictionary_1 = inflateSetDictionary;
    inflateInfo = "pako inflate (from Nodeca project)";
    inflate_1$2 = { inflateReset: inflateReset_1, inflateReset2: inflateReset2_1, inflateResetKeep: inflateResetKeep_1, inflateInit: inflateInit_1, inflateInit2: inflateInit2_1, inflate: inflate_2$1, inflateEnd: inflateEnd_1, inflateGetHeader: inflateGetHeader_1, inflateSetDictionary: inflateSetDictionary_1, inflateInfo };
    gzheader = GZheader;
    toString = Object.prototype.toString;
    ({ Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR } = constants$2);
    Inflate$1.prototype.push = function(data2, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      const dictionary = this.options.dictionary;
      let status, _flush_mode, last_avail_out;
      if (this.ended) return false;
      if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
      else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (toString.call(data2) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data2);
      } else {
        strm.input = data2;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = inflate_1$2.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
          status = inflate_1$2.inflateSetDictionary(strm, dictionary);
          if (status === Z_OK) {
            status = inflate_1$2.inflate(strm, _flush_mode);
          } else if (status === Z_DATA_ERROR) {
            status = Z_NEED_DICT;
          }
        }
        while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data2[strm.next_in] !== 0) {
          inflate_1$2.inflateReset(strm);
          status = inflate_1$2.inflate(strm, _flush_mode);
        }
        switch (status) {
          case Z_STREAM_ERROR:
          case Z_DATA_ERROR:
          case Z_NEED_DICT:
          case Z_MEM_ERROR:
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === Z_STREAM_END) {
            if (this.options.to === "string") {
              let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              let tail = strm.next_out - next_out_utf8;
              let utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
              this.onData(utf8str);
            } else {
              this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
            }
          }
        }
        if (status === Z_OK && last_avail_out === 0) continue;
        if (status === Z_STREAM_END) {
          status = inflate_1$2.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return true;
        }
        if (strm.avail_in === 0) break;
      }
      return true;
    };
    Inflate$1.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate$1.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = common.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    Inflate_1$1 = Inflate$1;
    inflate_2 = inflate$1;
    inflateRaw_1$1 = inflateRaw$1;
    ungzip$1 = inflate$1;
    constants = constants$2;
    inflate_1$1 = { Inflate: Inflate_1$1, inflate: inflate_2, inflateRaw: inflateRaw_1$1, ungzip: ungzip$1, constants };
    ({ Deflate, deflate, deflateRaw, gzip } = deflate_1$1);
    ({ Inflate, inflate, inflateRaw, ungzip } = inflate_1$1);
    Deflate_1 = Deflate;
    deflate_1 = deflate;
    deflateRaw_1 = deflateRaw;
    gzip_1 = gzip;
    Inflate_1 = Inflate;
    inflate_1 = inflate;
    inflateRaw_1 = inflateRaw;
    ungzip_1 = ungzip;
    constants_1 = constants$2;
    pako = { Deflate: Deflate_1, deflate: deflate_1, deflateRaw: deflateRaw_1, gzip: gzip_1, Inflate: Inflate_1, inflate: inflate_1, inflateRaw: inflateRaw_1, ungzip: ungzip_1, constants: constants_1 };
  }
});

// node_modules/scribe.js-ocr/js/utils/miscUtils.js
function calcBoxOverlap(boxA, boxB) {
  const left = Math.max(boxA.left, boxB.left);
  const top = Math.max(boxA.top, boxB.top);
  const right = Math.min(boxA.right, boxB.right);
  const bottom = Math.min(boxA.bottom, boxB.bottom);
  const width = right - left;
  const height = bottom - top;
  if (width < 0 || height < 0) return 0;
  const areaA = (boxA.bottom - boxA.top) * (boxA.right - boxA.left);
  const area = width * height;
  return area / areaA;
}
function calcHorizontalOverlap(boxA, boxB) {
  const left = Math.max(boxA.left, boxB.left);
  const right = Math.min(boxA.right, boxB.right);
  const widthOverlap = right - left;
  if (widthOverlap < 0) return 0;
  const widthA = boxA.right - boxA.left;
  return widthOverlap / widthA;
}
function getRandomInt(min, max) {
  const minI = Math.ceil(min);
  const maxI = Math.floor(max);
  return Math.floor(Math.random() * (maxI - minI) + minI);
}
function getRandomAlphanum(num) {
  const outArr = new Array(num);
  for (let i2 = 0; i2 < num; i2++) {
    let intI = getRandomInt(1, 62);
    if (intI <= 10) {
      intI += 47;
    } else if (intI <= 36) {
      intI = intI - 10 + 64;
    } else {
      intI = intI - 36 + 96;
    }
    outArr[i2] = String.fromCharCode(intI);
  }
  return outArr.join("");
}
function quantile(arr, ntile) {
  if (arr.length === 0) {
    return null;
  }
  const arr1 = [...arr];
  const mid = Math.floor(arr.length * ntile);
  arr1.sort((a2, b2) => a2 - b2);
  return arr1[mid];
}
async function readOcrFile(file) {
  if (file instanceof ArrayBuffer) {
    const fileUint8Array = new Uint8Array(file);
    const isGzipped = fileUint8Array[0] === 31 && fileUint8Array[1] === 139;
    if (isGzipped) {
      const pako3 = await Promise.resolve().then(() => (init_pako_esm_min(), pako_esm_min_exports));
      file = pako3.inflate(file)?.buffer;
    }
    const decoder = new TextDecoder("utf-8");
    return decoder.decode(file);
  }
  if (typeof file === "string") return file;
  if (typeof process === "undefined" && file instanceof File) {
    if (/\.gz|\.scribe$/i.test(file.name)) {
      return readTextFileGz(file);
    }
    return readTextFile(file);
  }
  if (typeof process !== "undefined") {
    if (!file?.fileData?.toString) throw new Error("Invalid input. Must be a FileNode, ArrayBuffer, or string.");
    return file.fileData.toString();
  }
  throw new Error("Invalid input. Must be a File, ArrayBuffer, or string.");
}
async function readTextFileGz(file) {
  const pako3 = await Promise.resolve().then(() => (init_pako_esm_min(), pako_esm_min_exports));
  return new Promise(async (resolve, reject) => {
    const zip1 = await file.arrayBuffer();
    const zip2 = await pako3.inflate(zip1, { to: "string" });
    resolve(zip2);
  });
}
function readTextFile(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      resolve(reader.result);
    };
    reader.onerror = reject;
    reader.readAsText(file);
  });
}
function round6(x2) {
  return Math.round(x2 * 1e6) / 1e6;
}
function countSubstringOccurrences(string, subString, allowOverlapping, caseSensitive = false) {
  string += "";
  subString += "";
  if (subString.length <= 0) return string.length + 1;
  if (!caseSensitive) {
    string = string.toLowerCase();
    subString = subString.toLowerCase();
  }
  let n2 = 0;
  let pos = 0;
  const step = allowOverlapping ? 1 : subString.length;
  while (true) {
    pos = string.indexOf(subString, pos);
    if (pos >= 0) {
      ++n2;
      pos += step;
    } else break;
  }
  return n2;
}
function clearObjectProperties(obj) {
  for (const prop in obj) {
    if (Object.hasOwnProperty.call(obj, prop)) {
      delete obj[prop];
    }
  }
}
function objectAssignDefined(target, ...sources) {
  for (const source of sources) {
    for (const key in source) {
      if (Object.hasOwnProperty.call(source, key) && source[key] !== void 0) {
        target[key] = source[key];
      }
    }
  }
  return target;
}
function determineSansSerif(fontName) {
  fontName = fontName?.replaceAll(/[_\s]/gi, "");
  let fontFamily = "Default";
  if (fontName && !["Default", "GlyphLessFont", "HiddenHorzOCR"].includes(fontName)) {
    if (/(^|\W|_)sans($|\W|_)/i.test(fontName)) {
      fontFamily = "SansDefault";
    } else if (/(^|\W|_)serif($|\W|_)/i.test(fontName)) {
      fontFamily = "SerifDefault";
    } else if (serifFontsRegex.test(fontName)) {
      fontFamily = "SerifDefault";
    } else if (sansFontsRegex.test(fontName)) {
      fontFamily = "SansDefault";
    } else if (fontName !== "Default Metrics Font") {
      if (/serif|rom/i.test(fontName) && !/sans/i.test(fontName)) {
        fontFamily = "SerifDefault";
      } else if (/san/i.test(fontName)) {
        fontFamily = "SansDefault";
      } else if (FontProps.sansFontsDoc.has(fontName)) {
        fontFamily = "SansDefault";
      } else if (FontProps.serifFontsDoc.has(fontName)) {
        fontFamily = "SerifDefault";
      } else if (!unidentifiedFonts.has(fontName)) {
        unidentifiedFonts.add(fontName);
        console.log(`Unidentified font: ${fontName}`);
      }
    }
  }
  return fontFamily;
}
function range(min, max) {
  const result = [];
  for (let i2 = min; i2 <= max; i2++) {
    result.push(i2);
  }
  return result;
}
var calcBboxUnion, mean50, saveAs, serifFonts, sansFonts, serifFontsRegex, sansFontsRegex, unidentifiedFonts, FontProps, replaceSmartQuotes, getStyleLookup;
var init_miscUtils = __esm({
  "node_modules/scribe.js-ocr/js/utils/miscUtils.js"() {
    calcBboxUnion = (bboxArr) => ({
      left: Math.min(...bboxArr.map((x2) => x2.left)),
      top: Math.min(...bboxArr.map((x2) => x2.top)),
      right: Math.max(...bboxArr.map((x2) => x2.right)),
      bottom: Math.max(...bboxArr.map((x2) => x2.bottom))
    });
    mean50 = (arr) => {
      if (arr.length === 0) {
        return null;
      }
      const per25 = Math.floor(arr.length / 4) - 1;
      const per75 = Math.ceil(arr.length * 3 / 4) - 1;
      const nums = [...arr].sort((a2, b2) => a2 - b2);
      const numsMiddle = nums.slice(per25, per75 + 1);
      return numsMiddle.reduce((a2, b2) => a2 + b2) / numsMiddle.length;
    };
    saveAs = async (content, fileName) => {
      if (typeof process !== "undefined") {
        const { promises: fsPromises } = await import("node:fs");
        const buffer = content instanceof ArrayBuffer ? Buffer.from(content) : content;
        await fsPromises.writeFile(fileName, buffer);
        return;
      }
      let blob;
      if (typeof Blob !== "undefined" && content instanceof Blob) {
        blob = content;
      } else {
        blob = new Blob([content], { type: "application/octet-stream" });
      }
      const a2 = document.createElement("a");
      a2.download = fileName;
      a2.href = globalThis.URL.createObjectURL(blob);
      a2.dispatchEvent(new MouseEvent("click", {
        bubbles: true,
        cancelable: true,
        view: window
      }));
    };
    serifFonts = [
      "SerifDefault",
      "Baskerville",
      "Bembo",
      "Bodoni",
      "Bookman",
      "C059",
      "Calibri",
      "Cambria",
      "Century",
      "Cheltenham",
      "Courier",
      "Garamond",
      "Georgia",
      "LucidaBright",
      "Minion",
      "NimbusMono",
      "Optima",
      "P052",
      "Palatino",
      "Times"
    ];
    sansFonts = [
      "SansDefault",
      "Avenir",
      "Arial",
      "Calibri",
      "Candara",
      "Carlito",
      "Comic",
      "Franklin",
      "Futura",
      "Gotham",
      "Gothic",
      "Helvetica",
      "Impact",
      "Interstate",
      "Myriad",
      "Tahoma",
      "Trebuchet",
      "Univers",
      "Verdana"
    ];
    serifFontsRegex = new RegExp(serifFonts.reduce((x2, y2) => `${x2}|${y2}`), "i");
    sansFontsRegex = new RegExp(sansFonts.reduce((x2, y2) => `${x2}|${y2}`), "i");
    unidentifiedFonts = /* @__PURE__ */ new Set();
    FontProps = class {
      static sansFontsDoc = /* @__PURE__ */ new Set();
      static serifFontsDoc = /* @__PURE__ */ new Set();
      static sizeMult = {};
    };
    replaceSmartQuotes = (text) => {
      if (!/['"]/.test(text)) return text;
      return text.replace(/(^|[-])'/, "$1\u2018").replace(/(^|[-])"/, "$1\u201C").replace(/'(?=$|[-])/, "\u2019").replace(/"(?=$|[-])/, "\u201D").replace(/([a-z])'(?=[a-z]$)/i, "$1\u2019");
    };
    getStyleLookup = (style) => {
      let styleStr = "normal";
      if (style.bold && style.italic) {
        styleStr = "boldItalic";
      } else if (style.bold) {
        styleStr = "bold";
      } else if (style.italic) {
        styleStr = "italic";
      }
      return styleStr;
    };
  }
});

// node_modules/canvaskit-wasm/bin/canvaskit.js
var require_canvaskit = __commonJS({
  "node_modules/canvaskit-wasm/bin/canvaskit.js"(exports2, module) {
    var CanvasKitInit = (() => {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined") _scriptDir = _scriptDir || __filename;
      return function(moduleArg = {}) {
        var w2 = moduleArg, ba, fa;
        w2.ready = new Promise((a2, b2) => {
          ba = a2;
          fa = b2;
        });
        (function(a2) {
          a2.Td = a2.Td || [];
          a2.Td.push(function() {
            a2.MakeSWCanvasSurface = function(b2) {
              var c2 = b2, f2 = "undefined" !== typeof OffscreenCanvas && c2 instanceof OffscreenCanvas;
              if (!("undefined" !== typeof HTMLCanvasElement && c2 instanceof HTMLCanvasElement || f2 || (c2 = document.getElementById(b2), c2))) throw "Canvas with id " + b2 + " was not found";
              if (b2 = a2.MakeSurface(c2.width, c2.height)) b2.Ld = c2;
              return b2;
            };
            a2.MakeCanvasSurface || (a2.MakeCanvasSurface = a2.MakeSWCanvasSurface);
            a2.MakeSurface = function(b2, c2) {
              var f2 = {
                width: b2,
                height: c2,
                colorType: a2.ColorType.RGBA_8888,
                alphaType: a2.AlphaType.Unpremul,
                colorSpace: a2.ColorSpace.SRGB
              }, h2 = b2 * c2 * 4, m2 = a2._malloc(h2);
              if (f2 = a2.Surface._makeRasterDirect(f2, m2, 4 * b2)) f2.Ld = null, f2.Hf = b2, f2.Df = c2, f2.Ff = h2, f2.bf = m2, f2.getCanvas().clear(a2.TRANSPARENT);
              return f2;
            };
            a2.MakeRasterDirectSurface = function(b2, c2, f2) {
              return a2.Surface._makeRasterDirect(b2, c2.byteOffset, f2);
            };
            a2.Surface.prototype.flush = function(b2) {
              a2.Md(this.Kd);
              this._flush();
              if (this.Ld) {
                var c2 = new Uint8ClampedArray(a2.HEAPU8.buffer, this.bf, this.Ff);
                c2 = new ImageData(c2, this.Hf, this.Df);
                b2 ? this.Ld.getContext("2d").putImageData(
                  c2,
                  0,
                  0,
                  b2[0],
                  b2[1],
                  b2[2] - b2[0],
                  b2[3] - b2[1]
                ) : this.Ld.getContext("2d").putImageData(c2, 0, 0);
              }
            };
            a2.Surface.prototype.dispose = function() {
              this.bf && a2._free(this.bf);
              this.delete();
            };
            a2.Md = a2.Md || function() {
            };
            a2.Te = a2.Te || function() {
              return null;
            };
          });
        })(w2);
        (function(a2) {
          a2.Td = a2.Td || [];
          a2.Td.push(function() {
            function b2(n2, p2, v2) {
              return n2 && n2.hasOwnProperty(p2) ? n2[p2] : v2;
            }
            function c2(n2) {
              var p2 = ha(ia);
              ia[p2] = n2;
              return p2;
            }
            function f2(n2) {
              return n2.naturalHeight || n2.videoHeight || n2.displayHeight || n2.height;
            }
            function h2(n2) {
              return n2.naturalWidth || n2.videoWidth || n2.displayWidth || n2.width;
            }
            function m2(n2, p2, v2, E2) {
              n2.bindTexture(n2.TEXTURE_2D, p2);
              E2 || v2.alphaType !== a2.AlphaType.Premul || n2.pixelStorei(n2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
              return p2;
            }
            function u2(n2, p2, v2) {
              v2 || p2.alphaType !== a2.AlphaType.Premul || n2.pixelStorei(n2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
              n2.bindTexture(n2.TEXTURE_2D, null);
            }
            a2.GetWebGLContext = function(n2, p2) {
              if (!n2) throw "null canvas passed into makeWebGLContext";
              var v2 = { alpha: b2(p2, "alpha", 1), depth: b2(p2, "depth", 1), stencil: b2(p2, "stencil", 8), antialias: b2(p2, "antialias", 0), premultipliedAlpha: b2(p2, "premultipliedAlpha", 1), preserveDrawingBuffer: b2(p2, "preserveDrawingBuffer", 0), preferLowPowerToHighPerformance: b2(p2, "preferLowPowerToHighPerformance", 0), failIfMajorPerformanceCaveat: b2(
                p2,
                "failIfMajorPerformanceCaveat",
                0
              ), enableExtensionsByDefault: b2(p2, "enableExtensionsByDefault", 1), explicitSwapControl: b2(p2, "explicitSwapControl", 0), renderViaOffscreenBackBuffer: b2(p2, "renderViaOffscreenBackBuffer", 0) };
              v2.majorVersion = p2 && p2.majorVersion ? p2.majorVersion : "undefined" !== typeof WebGL2RenderingContext ? 2 : 1;
              if (v2.explicitSwapControl) throw "explicitSwapControl is not supported";
              n2 = la(n2, v2);
              if (!n2) return 0;
              oa(n2);
              A2.fe.getExtension("WEBGL_debug_renderer_info");
              return n2;
            };
            a2.deleteContext = function(n2) {
              A2 === pa[n2] && (A2 = null);
              "object" == typeof JSEvents && JSEvents.ug(pa[n2].fe.canvas);
              pa[n2] && pa[n2].fe.canvas && (pa[n2].fe.canvas.zf = void 0);
              pa[n2] = null;
            };
            a2._setTextureCleanup({ deleteTexture: function(n2, p2) {
              var v2 = ia[p2];
              v2 && pa[n2].fe.deleteTexture(v2);
              ia[p2] = null;
            } });
            a2.MakeWebGLContext = function(n2) {
              if (!this.Md(n2)) return null;
              var p2 = this._MakeGrContext();
              if (!p2) return null;
              p2.Kd = n2;
              var v2 = p2.delete.bind(p2);
              p2["delete"] = function() {
                a2.Md(this.Kd);
                v2();
              }.bind(p2);
              return A2.ff = p2;
            };
            a2.MakeGrContext = a2.MakeWebGLContext;
            a2.GrDirectContext.prototype.getResourceCacheLimitBytes = function() {
              a2.Md(this.Kd);
              this._getResourceCacheLimitBytes();
            };
            a2.GrDirectContext.prototype.getResourceCacheUsageBytes = function() {
              a2.Md(this.Kd);
              this._getResourceCacheUsageBytes();
            };
            a2.GrDirectContext.prototype.releaseResourcesAndAbandonContext = function() {
              a2.Md(this.Kd);
              this._releaseResourcesAndAbandonContext();
            };
            a2.GrDirectContext.prototype.setResourceCacheLimitBytes = function(n2) {
              a2.Md(this.Kd);
              this._setResourceCacheLimitBytes(n2);
            };
            a2.MakeOnScreenGLSurface = function(n2, p2, v2, E2, H2, L2) {
              if (!this.Md(n2.Kd)) return null;
              p2 = void 0 === H2 || void 0 === L2 ? this._MakeOnScreenGLSurface(n2, p2, v2, E2) : this._MakeOnScreenGLSurface(n2, p2, v2, E2, H2, L2);
              if (!p2) return null;
              p2.Kd = n2.Kd;
              return p2;
            };
            a2.MakeRenderTarget = function() {
              var n2 = arguments[0];
              if (!this.Md(n2.Kd)) return null;
              if (3 === arguments.length) {
                var p2 = this._MakeRenderTargetWH(n2, arguments[1], arguments[2]);
                if (!p2) return null;
              } else if (2 === arguments.length) {
                if (p2 = this._MakeRenderTargetII(n2, arguments[1]), !p2) return null;
              } else return null;
              p2.Kd = n2.Kd;
              return p2;
            };
            a2.MakeWebGLCanvasSurface = function(n2, p2, v2) {
              p2 = p2 || null;
              var E2 = n2, H2 = "undefined" !== typeof OffscreenCanvas && E2 instanceof OffscreenCanvas;
              if (!("undefined" !== typeof HTMLCanvasElement && E2 instanceof HTMLCanvasElement || H2 || (E2 = document.getElementById(n2), E2))) throw "Canvas with id " + n2 + " was not found";
              n2 = this.GetWebGLContext(E2, v2);
              if (!n2 || 0 > n2) throw "failed to create webgl context: err " + n2;
              n2 = this.MakeWebGLContext(n2);
              p2 = this.MakeOnScreenGLSurface(n2, E2.width, E2.height, p2);
              return p2 ? p2 : (p2 = E2.cloneNode(true), E2.parentNode.replaceChild(p2, E2), p2.classList.add("ck-replaced"), a2.MakeSWCanvasSurface(p2));
            };
            a2.MakeCanvasSurface = a2.MakeWebGLCanvasSurface;
            a2.Surface.prototype.makeImageFromTexture = function(n2, p2) {
              a2.Md(this.Kd);
              n2 = c2(n2);
              if (p2 = this._makeImageFromTexture(this.Kd, n2, p2)) p2.Le = n2;
              return p2;
            };
            a2.Surface.prototype.makeImageFromTextureSource = function(n2, p2, v2) {
              p2 || (p2 = { height: f2(n2), width: h2(n2), colorType: a2.ColorType.RGBA_8888, alphaType: v2 ? a2.AlphaType.Premul : a2.AlphaType.Unpremul });
              p2.colorSpace || (p2.colorSpace = a2.ColorSpace.SRGB);
              a2.Md(this.Kd);
              var E2 = A2.fe;
              v2 = m2(E2, E2.createTexture(), p2, v2);
              2 === A2.version ? E2.texImage2D(
                E2.TEXTURE_2D,
                0,
                E2.RGBA,
                p2.width,
                p2.height,
                0,
                E2.RGBA,
                E2.UNSIGNED_BYTE,
                n2
              ) : E2.texImage2D(E2.TEXTURE_2D, 0, E2.RGBA, E2.RGBA, E2.UNSIGNED_BYTE, n2);
              u2(E2, p2);
              this._resetContext();
              return this.makeImageFromTexture(v2, p2);
            };
            a2.Surface.prototype.updateTextureFromSource = function(n2, p2, v2) {
              if (n2.Le) {
                a2.Md(this.Kd);
                var E2 = n2.getImageInfo(), H2 = A2.fe, L2 = m2(H2, ia[n2.Le], E2, v2);
                2 === A2.version ? H2.texImage2D(H2.TEXTURE_2D, 0, H2.RGBA, h2(p2), f2(p2), 0, H2.RGBA, H2.UNSIGNED_BYTE, p2) : H2.texImage2D(H2.TEXTURE_2D, 0, H2.RGBA, H2.RGBA, H2.UNSIGNED_BYTE, p2);
                u2(H2, E2, v2);
                this._resetContext();
                ia[n2.Le] = null;
                n2.Le = c2(L2);
                E2.colorSpace = n2.getColorSpace();
                p2 = this._makeImageFromTexture(this.Kd, n2.Le, E2);
                v2 = n2.Jd.Rd;
                H2 = n2.Jd.Yd;
                n2.Jd.Rd = p2.Jd.Rd;
                n2.Jd.Yd = p2.Jd.Yd;
                p2.Jd.Rd = v2;
                p2.Jd.Yd = H2;
                p2.delete();
                E2.colorSpace.delete();
              }
            };
            a2.MakeLazyImageFromTextureSource = function(n2, p2, v2) {
              p2 || (p2 = { height: f2(n2), width: h2(n2), colorType: a2.ColorType.RGBA_8888, alphaType: v2 ? a2.AlphaType.Premul : a2.AlphaType.Unpremul });
              p2.colorSpace || (p2.colorSpace = a2.ColorSpace.SRGB);
              var E2 = { makeTexture: function() {
                var H2 = A2, L2 = H2.fe, y2 = m2(L2, L2.createTexture(), p2, v2);
                2 === H2.version ? L2.texImage2D(
                  L2.TEXTURE_2D,
                  0,
                  L2.RGBA,
                  p2.width,
                  p2.height,
                  0,
                  L2.RGBA,
                  L2.UNSIGNED_BYTE,
                  n2
                ) : L2.texImage2D(L2.TEXTURE_2D, 0, L2.RGBA, L2.RGBA, L2.UNSIGNED_BYTE, n2);
                u2(L2, p2, v2);
                return c2(y2);
              }, freeSrc: function() {
              } };
              "VideoFrame" === n2.constructor.name && (E2.freeSrc = function() {
                n2.close();
              });
              return a2.Image._makeFromGenerator(p2, E2);
            };
            a2.Md = function(n2) {
              return n2 ? oa(n2) : false;
            };
            a2.Te = function() {
              return A2 && A2.ff && !A2.ff.isDeleted() ? A2.ff : null;
            };
          });
        })(w2);
        (function(a2) {
          function b2(e3, d2, g2, l2, t2) {
            for (var x2 = 0; x2 < e3.length; x2++) d2[x2 * g2 + (x2 * t2 + l2 + g2) % g2] = e3[x2];
            return d2;
          }
          function c2(e3) {
            for (var d2 = e3 * e3, g2 = Array(d2); d2--; ) g2[d2] = 0 === d2 % (e3 + 1) ? 1 : 0;
            return g2;
          }
          function f2(e3) {
            return e3 ? e3.constructor === Float32Array && 4 === e3.length : false;
          }
          function h2(e3) {
            return (n2(255 * e3[3]) << 24 | n2(255 * e3[0]) << 16 | n2(255 * e3[1]) << 8 | n2(255 * e3[2]) << 0) >>> 0;
          }
          function m2(e3) {
            if (e3 && e3._ck) return e3;
            if (e3 instanceof Float32Array) {
              for (var d2 = Math.floor(e3.length / 4), g2 = new Uint32Array(d2), l2 = 0; l2 < d2; l2++) g2[l2] = h2(e3.slice(4 * l2, 4 * (l2 + 1)));
              return g2;
            }
            if (e3 instanceof Uint32Array) return e3;
            if (e3 instanceof Array && e3[0] instanceof Float32Array) return e3.map(h2);
          }
          function u2(e3) {
            if (void 0 === e3) return 1;
            var d2 = parseFloat(e3);
            return e3 && -1 !== e3.indexOf("%") ? d2 / 100 : d2;
          }
          function n2(e3) {
            return Math.round(Math.max(0, Math.min(e3 || 0, 255)));
          }
          function p2(e3, d2) {
            d2 && d2._ck || a2._free(e3);
          }
          function v2(e3, d2, g2) {
            if (!e3 || !e3.length) return W2;
            if (e3 && e3._ck) return e3.byteOffset;
            var l2 = a2[d2].BYTES_PER_ELEMENT;
            g2 || (g2 = a2._malloc(e3.length * l2));
            a2[d2].set(e3, g2 / l2);
            return g2;
          }
          function E2(e3) {
            var d2 = { be: W2, count: e3.length, colorType: a2.ColorType.RGBA_F32 };
            if (e3 instanceof Float32Array) d2.be = v2(e3, "HEAPF32"), d2.count = e3.length / 4;
            else if (e3 instanceof Uint32Array) d2.be = v2(e3, "HEAPU32"), d2.colorType = a2.ColorType.RGBA_8888;
            else if (e3 instanceof Array) {
              if (e3 && e3.length) {
                for (var g2 = a2._malloc(16 * e3.length), l2 = 0, t2 = g2 / 4, x2 = 0; x2 < e3.length; x2++) for (var C2 = 0; 4 > C2; C2++) a2.HEAPF32[t2 + l2] = e3[x2][C2], l2++;
                e3 = g2;
              } else e3 = W2;
              d2.be = e3;
            } else throw "Invalid argument to copyFlexibleColorArray, Not a color array " + typeof e3;
            return d2;
          }
          function H2(e3) {
            if (!e3) return W2;
            var d2 = Vb.toTypedArray();
            if (e3.length) {
              if (6 === e3.length || 9 === e3.length) return v2(e3, "HEAPF32", Na), 6 === e3.length && a2.HEAPF32.set(wd, 6 + Na / 4), Na;
              if (16 === e3.length) return d2[0] = e3[0], d2[1] = e3[1], d2[2] = e3[3], d2[3] = e3[4], d2[4] = e3[5], d2[5] = e3[7], d2[6] = e3[12], d2[7] = e3[13], d2[8] = e3[15], Na;
              throw "invalid matrix size";
            }
            if (void 0 === e3.m11) throw "invalid matrix argument";
            d2[0] = e3.m11;
            d2[1] = e3.m21;
            d2[2] = e3.m41;
            d2[3] = e3.m12;
            d2[4] = e3.m22;
            d2[5] = e3.m42;
            d2[6] = e3.m14;
            d2[7] = e3.m24;
            d2[8] = e3.m44;
            return Na;
          }
          function L2(e3) {
            if (!e3) return W2;
            var d2 = Wb.toTypedArray();
            if (e3.length) {
              if (16 !== e3.length && 6 !== e3.length && 9 !== e3.length) throw "invalid matrix size";
              if (16 === e3.length) return v2(e3, "HEAPF32", $a);
              d2.fill(0);
              d2[0] = e3[0];
              d2[1] = e3[1];
              d2[3] = e3[2];
              d2[4] = e3[3];
              d2[5] = e3[4];
              d2[7] = e3[5];
              d2[10] = 1;
              d2[12] = e3[6];
              d2[13] = e3[7];
              d2[15] = e3[8];
              6 === e3.length && (d2[12] = 0, d2[13] = 0, d2[15] = 1);
              return $a;
            }
            if (void 0 === e3.m11) throw "invalid matrix argument";
            d2[0] = e3.m11;
            d2[1] = e3.m21;
            d2[2] = e3.m31;
            d2[3] = e3.m41;
            d2[4] = e3.m12;
            d2[5] = e3.m22;
            d2[6] = e3.m32;
            d2[7] = e3.m42;
            d2[8] = e3.m13;
            d2[9] = e3.m23;
            d2[10] = e3.m33;
            d2[11] = e3.m43;
            d2[12] = e3.m14;
            d2[13] = e3.m24;
            d2[14] = e3.m34;
            d2[15] = e3.m44;
            return $a;
          }
          function y2(e3, d2) {
            return v2(e3, "HEAPF32", d2 || Ta);
          }
          function N2(e3, d2, g2, l2) {
            var t2 = Xb.toTypedArray();
            t2[0] = e3;
            t2[1] = d2;
            t2[2] = g2;
            t2[3] = l2;
            return Ta;
          }
          function T2(e3) {
            for (var d2 = new Float32Array(4), g2 = 0; 4 > g2; g2++) d2[g2] = a2.HEAPF32[e3 / 4 + g2];
            return d2;
          }
          function S2(e3, d2) {
            return v2(e3, "HEAPF32", d2 || ja);
          }
          function sa(e3, d2) {
            return v2(e3, "HEAPF32", d2 || Yb);
          }
          function ma() {
            for (var e3 = 0, d2 = 0; d2 < arguments.length - 1; d2 += 2) e3 += arguments[d2] * arguments[d2 + 1];
            return e3;
          }
          function gb(e3, d2, g2) {
            for (var l2 = Array(e3.length), t2 = 0; t2 < g2; t2++) for (var x2 = 0; x2 < g2; x2++) {
              for (var C2 = 0, J2 = 0; J2 < g2; J2++) C2 += e3[g2 * t2 + J2] * d2[g2 * J2 + x2];
              l2[t2 * g2 + x2] = C2;
            }
            return l2;
          }
          function hb(e3, d2) {
            for (var g2 = gb(d2[0], d2[1], e3), l2 = 2; l2 < d2.length; ) g2 = gb(g2, d2[l2], e3), l2++;
            return g2;
          }
          a2.Color = function(e3, d2, g2, l2) {
            void 0 === l2 && (l2 = 1);
            return a2.Color4f(n2(e3) / 255, n2(d2) / 255, n2(g2) / 255, l2);
          };
          a2.ColorAsInt = function(e3, d2, g2, l2) {
            void 0 === l2 && (l2 = 255);
            return (n2(l2) << 24 | n2(e3) << 16 | n2(d2) << 8 | n2(g2) << 0 & 268435455) >>> 0;
          };
          a2.Color4f = function(e3, d2, g2, l2) {
            void 0 === l2 && (l2 = 1);
            return Float32Array.of(e3, d2, g2, l2);
          };
          Object.defineProperty(a2, "TRANSPARENT", { get: function() {
            return a2.Color4f(0, 0, 0, 0);
          } });
          Object.defineProperty(a2, "BLACK", { get: function() {
            return a2.Color4f(0, 0, 0, 1);
          } });
          Object.defineProperty(
            a2,
            "WHITE",
            { get: function() {
              return a2.Color4f(1, 1, 1, 1);
            } }
          );
          Object.defineProperty(a2, "RED", { get: function() {
            return a2.Color4f(1, 0, 0, 1);
          } });
          Object.defineProperty(a2, "GREEN", { get: function() {
            return a2.Color4f(0, 1, 0, 1);
          } });
          Object.defineProperty(a2, "BLUE", { get: function() {
            return a2.Color4f(0, 0, 1, 1);
          } });
          Object.defineProperty(a2, "YELLOW", { get: function() {
            return a2.Color4f(1, 1, 0, 1);
          } });
          Object.defineProperty(a2, "CYAN", { get: function() {
            return a2.Color4f(0, 1, 1, 1);
          } });
          Object.defineProperty(a2, "MAGENTA", { get: function() {
            return a2.Color4f(
              1,
              0,
              1,
              1
            );
          } });
          a2.getColorComponents = function(e3) {
            return [Math.floor(255 * e3[0]), Math.floor(255 * e3[1]), Math.floor(255 * e3[2]), e3[3]];
          };
          a2.parseColorString = function(e3, d2) {
            e3 = e3.toLowerCase();
            if (e3.startsWith("#")) {
              d2 = 255;
              switch (e3.length) {
                case 9:
                  d2 = parseInt(e3.slice(7, 9), 16);
                case 7:
                  var g2 = parseInt(e3.slice(1, 3), 16);
                  var l2 = parseInt(e3.slice(3, 5), 16);
                  var t2 = parseInt(e3.slice(5, 7), 16);
                  break;
                case 5:
                  d2 = 17 * parseInt(e3.slice(4, 5), 16);
                case 4:
                  g2 = 17 * parseInt(e3.slice(1, 2), 16), l2 = 17 * parseInt(e3.slice(2, 3), 16), t2 = 17 * parseInt(e3.slice(3, 4), 16);
              }
              return a2.Color(
                g2,
                l2,
                t2,
                d2 / 255
              );
            }
            return e3.startsWith("rgba") ? (e3 = e3.slice(5, -1), e3 = e3.split(","), a2.Color(+e3[0], +e3[1], +e3[2], u2(e3[3]))) : e3.startsWith("rgb") ? (e3 = e3.slice(4, -1), e3 = e3.split(","), a2.Color(+e3[0], +e3[1], +e3[2], u2(e3[3]))) : e3.startsWith("gray(") || e3.startsWith("hsl") || !d2 || (e3 = d2[e3], void 0 === e3) ? a2.BLACK : e3;
          };
          a2.multiplyByAlpha = function(e3, d2) {
            e3 = e3.slice();
            e3[3] = Math.max(0, Math.min(e3[3] * d2, 1));
            return e3;
          };
          a2.Malloc = function(e3, d2) {
            var g2 = a2._malloc(d2 * e3.BYTES_PER_ELEMENT);
            return { _ck: true, length: d2, byteOffset: g2, qe: null, subarray: function(l2, t2) {
              l2 = this.toTypedArray().subarray(
                l2,
                t2
              );
              l2._ck = true;
              return l2;
            }, toTypedArray: function() {
              if (this.qe && this.qe.length) return this.qe;
              this.qe = new e3(a2.HEAPU8.buffer, g2, d2);
              this.qe._ck = true;
              return this.qe;
            } };
          };
          a2.Free = function(e3) {
            a2._free(e3.byteOffset);
            e3.byteOffset = W2;
            e3.toTypedArray = null;
            e3.qe = null;
          };
          var Na = W2, Vb, $a = W2, Wb, Ta = W2, Xb, Ba, ja = W2, xc, Oa = W2, yc, Zb = W2, zc, $b = W2, yb, ib = W2, Ac, Yb = W2, Bc, Cc = W2, wd = Float32Array.of(0, 0, 1), W2 = 0;
          a2.onRuntimeInitialized = function() {
            function e3(d2, g2, l2, t2, x2, C2, J2) {
              C2 || (C2 = 4 * t2.width, t2.colorType === a2.ColorType.RGBA_F16 ? C2 *= 2 : t2.colorType === a2.ColorType.RGBA_F32 && (C2 *= 4));
              var P2 = C2 * t2.height;
              var O2 = x2 ? x2.byteOffset : a2._malloc(P2);
              if (J2 ? !d2._readPixels(t2, O2, C2, g2, l2, J2) : !d2._readPixels(t2, O2, C2, g2, l2)) return x2 || a2._free(O2), null;
              if (x2) return x2.toTypedArray();
              switch (t2.colorType) {
                case a2.ColorType.RGBA_8888:
                case a2.ColorType.RGBA_F16:
                  d2 = new Uint8Array(a2.HEAPU8.buffer, O2, P2).slice();
                  break;
                case a2.ColorType.RGBA_F32:
                  d2 = new Float32Array(a2.HEAPU8.buffer, O2, P2).slice();
                  break;
                default:
                  return null;
              }
              a2._free(O2);
              return d2;
            }
            Xb = a2.Malloc(Float32Array, 4);
            Ta = Xb.byteOffset;
            Wb = a2.Malloc(Float32Array, 16);
            $a = Wb.byteOffset;
            Vb = a2.Malloc(Float32Array, 9);
            Na = Vb.byteOffset;
            Ac = a2.Malloc(Float32Array, 12);
            Yb = Ac.byteOffset;
            Bc = a2.Malloc(Float32Array, 12);
            Cc = Bc.byteOffset;
            Ba = a2.Malloc(Float32Array, 4);
            ja = Ba.byteOffset;
            xc = a2.Malloc(Float32Array, 4);
            Oa = xc.byteOffset;
            yc = a2.Malloc(Float32Array, 3);
            Zb = yc.byteOffset;
            zc = a2.Malloc(Float32Array, 3);
            $b = zc.byteOffset;
            yb = a2.Malloc(Int32Array, 4);
            ib = yb.byteOffset;
            a2.ColorSpace.SRGB = a2.ColorSpace._MakeSRGB();
            a2.ColorSpace.DISPLAY_P3 = a2.ColorSpace._MakeDisplayP3();
            a2.ColorSpace.ADOBE_RGB = a2.ColorSpace._MakeAdobeRGB();
            a2.GlyphRunFlags = { IsWhiteSpace: a2._GlyphRunFlags_isWhiteSpace };
            a2.Path.MakeFromCmds = function(d2) {
              var g2 = v2(d2, "HEAPF32"), l2 = a2.Path._MakeFromCmds(g2, d2.length);
              p2(g2, d2);
              return l2;
            };
            a2.Path.MakeFromVerbsPointsWeights = function(d2, g2, l2) {
              var t2 = v2(d2, "HEAPU8"), x2 = v2(g2, "HEAPF32"), C2 = v2(l2, "HEAPF32"), J2 = a2.Path._MakeFromVerbsPointsWeights(t2, d2.length, x2, g2.length, C2, l2 && l2.length || 0);
              p2(t2, d2);
              p2(x2, g2);
              p2(C2, l2);
              return J2;
            };
            a2.Path.prototype.addArc = function(d2, g2, l2) {
              d2 = S2(d2);
              this._addArc(d2, g2, l2);
              return this;
            };
            a2.Path.prototype.addCircle = function(d2, g2, l2, t2) {
              this._addCircle(
                d2,
                g2,
                l2,
                !!t2
              );
              return this;
            };
            a2.Path.prototype.addOval = function(d2, g2, l2) {
              void 0 === l2 && (l2 = 1);
              d2 = S2(d2);
              this._addOval(d2, !!g2, l2);
              return this;
            };
            a2.Path.prototype.addPath = function() {
              var d2 = Array.prototype.slice.call(arguments), g2 = d2[0], l2 = false;
              "boolean" === typeof d2[d2.length - 1] && (l2 = d2.pop());
              if (1 === d2.length) this._addPath(g2, 1, 0, 0, 0, 1, 0, 0, 0, 1, l2);
              else if (2 === d2.length) d2 = d2[1], this._addPath(g2, d2[0], d2[1], d2[2], d2[3], d2[4], d2[5], d2[6] || 0, d2[7] || 0, d2[8] || 1, l2);
              else if (7 === d2.length || 10 === d2.length) this._addPath(g2, d2[1], d2[2], d2[3], d2[4], d2[5], d2[6], d2[7] || 0, d2[8] || 0, d2[9] || 1, l2);
              else return null;
              return this;
            };
            a2.Path.prototype.addPoly = function(d2, g2) {
              var l2 = v2(d2, "HEAPF32");
              this._addPoly(l2, d2.length / 2, g2);
              p2(l2, d2);
              return this;
            };
            a2.Path.prototype.addRect = function(d2, g2) {
              d2 = S2(d2);
              this._addRect(d2, !!g2);
              return this;
            };
            a2.Path.prototype.addRRect = function(d2, g2) {
              d2 = sa(d2);
              this._addRRect(d2, !!g2);
              return this;
            };
            a2.Path.prototype.addVerbsPointsWeights = function(d2, g2, l2) {
              var t2 = v2(d2, "HEAPU8"), x2 = v2(g2, "HEAPF32"), C2 = v2(l2, "HEAPF32");
              this._addVerbsPointsWeights(t2, d2.length, x2, g2.length, C2, l2 && l2.length || 0);
              p2(t2, d2);
              p2(x2, g2);
              p2(C2, l2);
            };
            a2.Path.prototype.arc = function(d2, g2, l2, t2, x2, C2) {
              d2 = a2.LTRBRect(d2 - l2, g2 - l2, d2 + l2, g2 + l2);
              x2 = (x2 - t2) / Math.PI * 180 - 360 * !!C2;
              C2 = new a2.Path();
              C2.addArc(d2, t2 / Math.PI * 180, x2);
              this.addPath(C2, true);
              C2.delete();
              return this;
            };
            a2.Path.prototype.arcToOval = function(d2, g2, l2, t2) {
              d2 = S2(d2);
              this._arcToOval(d2, g2, l2, t2);
              return this;
            };
            a2.Path.prototype.arcToRotated = function(d2, g2, l2, t2, x2, C2, J2) {
              this._arcToRotated(d2, g2, l2, !!t2, !!x2, C2, J2);
              return this;
            };
            a2.Path.prototype.arcToTangent = function(d2, g2, l2, t2, x2) {
              this._arcToTangent(d2, g2, l2, t2, x2);
              return this;
            };
            a2.Path.prototype.close = function() {
              this._close();
              return this;
            };
            a2.Path.prototype.conicTo = function(d2, g2, l2, t2, x2) {
              this._conicTo(d2, g2, l2, t2, x2);
              return this;
            };
            a2.Path.prototype.computeTightBounds = function(d2) {
              this._computeTightBounds(ja);
              var g2 = Ba.toTypedArray();
              return d2 ? (d2.set(g2), d2) : g2.slice();
            };
            a2.Path.prototype.cubicTo = function(d2, g2, l2, t2, x2, C2) {
              this._cubicTo(d2, g2, l2, t2, x2, C2);
              return this;
            };
            a2.Path.prototype.dash = function(d2, g2, l2) {
              return this._dash(d2, g2, l2) ? this : null;
            };
            a2.Path.prototype.getBounds = function(d2) {
              this._getBounds(ja);
              var g2 = Ba.toTypedArray();
              return d2 ? (d2.set(g2), d2) : g2.slice();
            };
            a2.Path.prototype.lineTo = function(d2, g2) {
              this._lineTo(d2, g2);
              return this;
            };
            a2.Path.prototype.moveTo = function(d2, g2) {
              this._moveTo(d2, g2);
              return this;
            };
            a2.Path.prototype.offset = function(d2, g2) {
              this._transform(1, 0, d2, 0, 1, g2, 0, 0, 1);
              return this;
            };
            a2.Path.prototype.quadTo = function(d2, g2, l2, t2) {
              this._quadTo(d2, g2, l2, t2);
              return this;
            };
            a2.Path.prototype.rArcTo = function(d2, g2, l2, t2, x2, C2, J2) {
              this._rArcTo(d2, g2, l2, t2, x2, C2, J2);
              return this;
            };
            a2.Path.prototype.rConicTo = function(d2, g2, l2, t2, x2) {
              this._rConicTo(d2, g2, l2, t2, x2);
              return this;
            };
            a2.Path.prototype.rCubicTo = function(d2, g2, l2, t2, x2, C2) {
              this._rCubicTo(d2, g2, l2, t2, x2, C2);
              return this;
            };
            a2.Path.prototype.rLineTo = function(d2, g2) {
              this._rLineTo(d2, g2);
              return this;
            };
            a2.Path.prototype.rMoveTo = function(d2, g2) {
              this._rMoveTo(d2, g2);
              return this;
            };
            a2.Path.prototype.rQuadTo = function(d2, g2, l2, t2) {
              this._rQuadTo(d2, g2, l2, t2);
              return this;
            };
            a2.Path.prototype.stroke = function(d2) {
              d2 = d2 || {};
              d2.width = d2.width || 1;
              d2.miter_limit = d2.miter_limit || 4;
              d2.cap = d2.cap || a2.StrokeCap.Butt;
              d2.join = d2.join || a2.StrokeJoin.Miter;
              d2.precision = d2.precision || 1;
              return this._stroke(d2) ? this : null;
            };
            a2.Path.prototype.transform = function() {
              if (1 === arguments.length) {
                var d2 = arguments[0];
                this._transform(d2[0], d2[1], d2[2], d2[3], d2[4], d2[5], d2[6] || 0, d2[7] || 0, d2[8] || 1);
              } else if (6 === arguments.length || 9 === arguments.length) d2 = arguments, this._transform(d2[0], d2[1], d2[2], d2[3], d2[4], d2[5], d2[6] || 0, d2[7] || 0, d2[8] || 1);
              else throw "transform expected to take 1 or 9 arguments. Got " + arguments.length;
              return this;
            };
            a2.Path.prototype.trim = function(d2, g2, l2) {
              return this._trim(d2, g2, !!l2) ? this : null;
            };
            a2.Image.prototype.encodeToBytes = function(d2, g2) {
              var l2 = a2.Te();
              d2 = d2 || a2.ImageFormat.PNG;
              g2 = g2 || 100;
              return l2 ? this._encodeToBytes(d2, g2, l2) : this._encodeToBytes(d2, g2);
            };
            a2.Image.prototype.makeShaderCubic = function(d2, g2, l2, t2, x2) {
              x2 = H2(x2);
              return this._makeShaderCubic(d2, g2, l2, t2, x2);
            };
            a2.Image.prototype.makeShaderOptions = function(d2, g2, l2, t2, x2) {
              x2 = H2(x2);
              return this._makeShaderOptions(d2, g2, l2, t2, x2);
            };
            a2.Image.prototype.readPixels = function(d2, g2, l2, t2, x2) {
              var C2 = a2.Te();
              return e3(this, d2, g2, l2, t2, x2, C2);
            };
            a2.Canvas.prototype.clear = function(d2) {
              a2.Md(this.Kd);
              d2 = y2(d2);
              this._clear(d2);
            };
            a2.Canvas.prototype.clipRRect = function(d2, g2, l2) {
              a2.Md(this.Kd);
              d2 = sa(d2);
              this._clipRRect(d2, g2, l2);
            };
            a2.Canvas.prototype.clipRect = function(d2, g2, l2) {
              a2.Md(this.Kd);
              d2 = S2(d2);
              this._clipRect(d2, g2, l2);
            };
            a2.Canvas.prototype.concat = function(d2) {
              a2.Md(this.Kd);
              d2 = L2(d2);
              this._concat(d2);
            };
            a2.Canvas.prototype.drawArc = function(d2, g2, l2, t2, x2) {
              a2.Md(this.Kd);
              d2 = S2(d2);
              this._drawArc(d2, g2, l2, t2, x2);
            };
            a2.Canvas.prototype.drawAtlas = function(d2, g2, l2, t2, x2, C2, J2) {
              if (d2 && t2 && g2 && l2 && g2.length === l2.length) {
                a2.Md(this.Kd);
                x2 || (x2 = a2.BlendMode.SrcOver);
                var P2 = v2(g2, "HEAPF32"), O2 = v2(l2, "HEAPF32"), Y2 = l2.length / 4, aa = v2(m2(C2), "HEAPU32");
                if (J2 && "B" in J2 && "C" in J2) this._drawAtlasCubic(d2, O2, P2, aa, Y2, x2, J2.B, J2.C, t2);
                else {
                  let r2 = a2.FilterMode.Linear, D2 = a2.MipmapMode.None;
                  J2 && (r2 = J2.filter, "mipmap" in J2 && (D2 = J2.mipmap));
                  this._drawAtlasOptions(d2, O2, P2, aa, Y2, x2, r2, D2, t2);
                }
                p2(P2, g2);
                p2(O2, l2);
                p2(aa, C2);
              }
            };
            a2.Canvas.prototype.drawCircle = function(d2, g2, l2, t2) {
              a2.Md(this.Kd);
              this._drawCircle(d2, g2, l2, t2);
            };
            a2.Canvas.prototype.drawColor = function(d2, g2) {
              a2.Md(this.Kd);
              d2 = y2(d2);
              void 0 !== g2 ? this._drawColor(d2, g2) : this._drawColor(d2);
            };
            a2.Canvas.prototype.drawColorInt = function(d2, g2) {
              a2.Md(this.Kd);
              this._drawColorInt(d2, g2 || a2.BlendMode.SrcOver);
            };
            a2.Canvas.prototype.drawColorComponents = function(d2, g2, l2, t2, x2) {
              a2.Md(this.Kd);
              d2 = N2(d2, g2, l2, t2);
              void 0 !== x2 ? this._drawColor(d2, x2) : this._drawColor(d2);
            };
            a2.Canvas.prototype.drawDRRect = function(d2, g2, l2) {
              a2.Md(this.Kd);
              d2 = sa(d2, Yb);
              g2 = sa(g2, Cc);
              this._drawDRRect(d2, g2, l2);
            };
            a2.Canvas.prototype.drawImage = function(d2, g2, l2, t2) {
              a2.Md(this.Kd);
              this._drawImage(d2, g2, l2, t2 || null);
            };
            a2.Canvas.prototype.drawImageCubic = function(d2, g2, l2, t2, x2, C2) {
              a2.Md(this.Kd);
              this._drawImageCubic(d2, g2, l2, t2, x2, C2 || null);
            };
            a2.Canvas.prototype.drawImageOptions = function(d2, g2, l2, t2, x2, C2) {
              a2.Md(this.Kd);
              this._drawImageOptions(d2, g2, l2, t2, x2, C2 || null);
            };
            a2.Canvas.prototype.drawImageNine = function(d2, g2, l2, t2, x2) {
              a2.Md(this.Kd);
              g2 = v2(g2, "HEAP32", ib);
              l2 = S2(l2);
              this._drawImageNine(d2, g2, l2, t2, x2 || null);
            };
            a2.Canvas.prototype.drawImageRect = function(d2, g2, l2, t2, x2) {
              a2.Md(this.Kd);
              S2(g2, ja);
              S2(l2, Oa);
              this._drawImageRect(d2, ja, Oa, t2, !!x2);
            };
            a2.Canvas.prototype.drawImageRectCubic = function(d2, g2, l2, t2, x2, C2) {
              a2.Md(this.Kd);
              S2(g2, ja);
              S2(l2, Oa);
              this._drawImageRectCubic(d2, ja, Oa, t2, x2, C2 || null);
            };
            a2.Canvas.prototype.drawImageRectOptions = function(d2, g2, l2, t2, x2, C2) {
              a2.Md(this.Kd);
              S2(g2, ja);
              S2(l2, Oa);
              this._drawImageRectOptions(d2, ja, Oa, t2, x2, C2 || null);
            };
            a2.Canvas.prototype.drawLine = function(d2, g2, l2, t2, x2) {
              a2.Md(this.Kd);
              this._drawLine(d2, g2, l2, t2, x2);
            };
            a2.Canvas.prototype.drawOval = function(d2, g2) {
              a2.Md(this.Kd);
              d2 = S2(d2);
              this._drawOval(d2, g2);
            };
            a2.Canvas.prototype.drawPaint = function(d2) {
              a2.Md(this.Kd);
              this._drawPaint(d2);
            };
            a2.Canvas.prototype.drawParagraph = function(d2, g2, l2) {
              a2.Md(this.Kd);
              this._drawParagraph(d2, g2, l2);
            };
            a2.Canvas.prototype.drawPatch = function(d2, g2, l2, t2, x2) {
              if (24 > d2.length) throw "Need 12 cubic points";
              if (g2 && 4 > g2.length) throw "Need 4 colors";
              if (l2 && 8 > l2.length) throw "Need 4 shader coordinates";
              a2.Md(this.Kd);
              const C2 = v2(d2, "HEAPF32"), J2 = g2 ? v2(m2(g2), "HEAPU32") : W2, P2 = l2 ? v2(l2, "HEAPF32") : W2;
              t2 || (t2 = a2.BlendMode.Modulate);
              this._drawPatch(C2, J2, P2, t2, x2);
              p2(P2, l2);
              p2(J2, g2);
              p2(C2, d2);
            };
            a2.Canvas.prototype.drawPath = function(d2, g2) {
              a2.Md(this.Kd);
              this._drawPath(d2, g2);
            };
            a2.Canvas.prototype.drawPicture = function(d2) {
              a2.Md(this.Kd);
              this._drawPicture(d2);
            };
            a2.Canvas.prototype.drawPoints = function(d2, g2, l2) {
              a2.Md(this.Kd);
              var t2 = v2(g2, "HEAPF32");
              this._drawPoints(
                d2,
                t2,
                g2.length / 2,
                l2
              );
              p2(t2, g2);
            };
            a2.Canvas.prototype.drawRRect = function(d2, g2) {
              a2.Md(this.Kd);
              d2 = sa(d2);
              this._drawRRect(d2, g2);
            };
            a2.Canvas.prototype.drawRect = function(d2, g2) {
              a2.Md(this.Kd);
              d2 = S2(d2);
              this._drawRect(d2, g2);
            };
            a2.Canvas.prototype.drawRect4f = function(d2, g2, l2, t2, x2) {
              a2.Md(this.Kd);
              this._drawRect4f(d2, g2, l2, t2, x2);
            };
            a2.Canvas.prototype.drawShadow = function(d2, g2, l2, t2, x2, C2, J2) {
              a2.Md(this.Kd);
              var P2 = v2(x2, "HEAPF32"), O2 = v2(C2, "HEAPF32");
              g2 = v2(g2, "HEAPF32", Zb);
              l2 = v2(l2, "HEAPF32", $b);
              this._drawShadow(d2, g2, l2, t2, P2, O2, J2);
              p2(P2, x2);
              p2(O2, C2);
            };
            a2.getShadowLocalBounds = function(d2, g2, l2, t2, x2, C2, J2) {
              d2 = H2(d2);
              l2 = v2(l2, "HEAPF32", Zb);
              t2 = v2(t2, "HEAPF32", $b);
              if (!this._getShadowLocalBounds(d2, g2, l2, t2, x2, C2, ja)) return null;
              g2 = Ba.toTypedArray();
              return J2 ? (J2.set(g2), J2) : g2.slice();
            };
            a2.Canvas.prototype.drawTextBlob = function(d2, g2, l2, t2) {
              a2.Md(this.Kd);
              this._drawTextBlob(d2, g2, l2, t2);
            };
            a2.Canvas.prototype.drawVertices = function(d2, g2, l2) {
              a2.Md(this.Kd);
              this._drawVertices(d2, g2, l2);
            };
            a2.Canvas.prototype.getDeviceClipBounds = function(d2) {
              this._getDeviceClipBounds(ib);
              var g2 = yb.toTypedArray();
              d2 ? d2.set(g2) : d2 = g2.slice();
              return d2;
            };
            a2.Canvas.prototype.getLocalToDevice = function() {
              this._getLocalToDevice($a);
              for (var d2 = $a, g2 = Array(16), l2 = 0; 16 > l2; l2++) g2[l2] = a2.HEAPF32[d2 / 4 + l2];
              return g2;
            };
            a2.Canvas.prototype.getTotalMatrix = function() {
              this._getTotalMatrix(Na);
              for (var d2 = Array(9), g2 = 0; 9 > g2; g2++) d2[g2] = a2.HEAPF32[Na / 4 + g2];
              return d2;
            };
            a2.Canvas.prototype.makeSurface = function(d2) {
              d2 = this._makeSurface(d2);
              d2.Kd = this.Kd;
              return d2;
            };
            a2.Canvas.prototype.readPixels = function(d2, g2, l2, t2, x2) {
              a2.Md(this.Kd);
              return e3(this, d2, g2, l2, t2, x2);
            };
            a2.Canvas.prototype.saveLayer = function(d2, g2, l2, t2) {
              g2 = S2(g2);
              return this._saveLayer(d2 || null, g2, l2 || null, t2 || 0);
            };
            a2.Canvas.prototype.writePixels = function(d2, g2, l2, t2, x2, C2, J2, P2) {
              if (d2.byteLength % (g2 * l2)) throw "pixels length must be a multiple of the srcWidth * srcHeight";
              a2.Md(this.Kd);
              var O2 = d2.byteLength / (g2 * l2);
              C2 = C2 || a2.AlphaType.Unpremul;
              J2 = J2 || a2.ColorType.RGBA_8888;
              P2 = P2 || a2.ColorSpace.SRGB;
              var Y2 = O2 * g2;
              O2 = v2(d2, "HEAPU8");
              g2 = this._writePixels({ width: g2, height: l2, colorType: J2, alphaType: C2, colorSpace: P2 }, O2, Y2, t2, x2);
              p2(O2, d2);
              return g2;
            };
            a2.ColorFilter.MakeBlend = function(d2, g2, l2) {
              d2 = y2(d2);
              l2 = l2 || a2.ColorSpace.SRGB;
              return a2.ColorFilter._MakeBlend(d2, g2, l2);
            };
            a2.ColorFilter.MakeMatrix = function(d2) {
              if (!d2 || 20 !== d2.length) throw "invalid color matrix";
              var g2 = v2(d2, "HEAPF32"), l2 = a2.ColorFilter._makeMatrix(g2);
              p2(g2, d2);
              return l2;
            };
            a2.ContourMeasure.prototype.getPosTan = function(d2, g2) {
              this._getPosTan(d2, ja);
              d2 = Ba.toTypedArray();
              return g2 ? (g2.set(d2), g2) : d2.slice();
            };
            a2.ImageFilter.prototype.getOutputBounds = function(d2, g2, l2) {
              d2 = S2(d2, ja);
              g2 = H2(g2);
              this._getOutputBounds(d2, g2, ib);
              g2 = yb.toTypedArray();
              return l2 ? (l2.set(g2), l2) : g2.slice();
            };
            a2.ImageFilter.MakeDropShadow = function(d2, g2, l2, t2, x2, C2) {
              x2 = y2(x2, Ta);
              return a2.ImageFilter._MakeDropShadow(d2, g2, l2, t2, x2, C2);
            };
            a2.ImageFilter.MakeDropShadowOnly = function(d2, g2, l2, t2, x2, C2) {
              x2 = y2(x2, Ta);
              return a2.ImageFilter._MakeDropShadowOnly(d2, g2, l2, t2, x2, C2);
            };
            a2.ImageFilter.MakeImage = function(d2, g2, l2, t2) {
              l2 = S2(l2, ja);
              t2 = S2(t2, Oa);
              if ("B" in g2 && "C" in g2) return a2.ImageFilter._MakeImageCubic(d2, g2.B, g2.C, l2, t2);
              const x2 = g2.filter;
              let C2 = a2.MipmapMode.None;
              "mipmap" in g2 && (C2 = g2.mipmap);
              return a2.ImageFilter._MakeImageOptions(d2, x2, C2, l2, t2);
            };
            a2.ImageFilter.MakeMatrixTransform = function(d2, g2, l2) {
              d2 = H2(d2);
              if ("B" in g2 && "C" in g2) return a2.ImageFilter._MakeMatrixTransformCubic(d2, g2.B, g2.C, l2);
              const t2 = g2.filter;
              let x2 = a2.MipmapMode.None;
              "mipmap" in g2 && (x2 = g2.mipmap);
              return a2.ImageFilter._MakeMatrixTransformOptions(d2, t2, x2, l2);
            };
            a2.Paint.prototype.getColor = function() {
              this._getColor(Ta);
              return T2(Ta);
            };
            a2.Paint.prototype.setColor = function(d2, g2) {
              g2 = g2 || null;
              d2 = y2(d2);
              this._setColor(d2, g2);
            };
            a2.Paint.prototype.setColorComponents = function(d2, g2, l2, t2, x2) {
              x2 = x2 || null;
              d2 = N2(d2, g2, l2, t2);
              this._setColor(d2, x2);
            };
            a2.Path.prototype.getPoint = function(d2, g2) {
              this._getPoint(d2, ja);
              d2 = Ba.toTypedArray();
              return g2 ? (g2[0] = d2[0], g2[1] = d2[1], g2) : d2.slice(0, 2);
            };
            a2.Picture.prototype.makeShader = function(d2, g2, l2, t2, x2) {
              t2 = H2(t2);
              x2 = S2(x2);
              return this._makeShader(d2, g2, l2, t2, x2);
            };
            a2.Picture.prototype.cullRect = function(d2) {
              this._cullRect(ja);
              var g2 = Ba.toTypedArray();
              return d2 ? (d2.set(g2), d2) : g2.slice();
            };
            a2.PictureRecorder.prototype.beginRecording = function(d2, g2) {
              d2 = S2(d2);
              return this._beginRecording(d2, !!g2);
            };
            a2.Surface.prototype.getCanvas = function() {
              var d2 = this._getCanvas();
              d2.Kd = this.Kd;
              return d2;
            };
            a2.Surface.prototype.makeImageSnapshot = function(d2) {
              a2.Md(this.Kd);
              d2 = v2(d2, "HEAP32", ib);
              return this._makeImageSnapshot(d2);
            };
            a2.Surface.prototype.makeSurface = function(d2) {
              a2.Md(this.Kd);
              d2 = this._makeSurface(d2);
              d2.Kd = this.Kd;
              return d2;
            };
            a2.Surface.prototype.Gf = function(d2, g2) {
              this.He || (this.He = this.getCanvas());
              return requestAnimationFrame(function() {
                a2.Md(this.Kd);
                d2(this.He);
                this.flush(g2);
              }.bind(this));
            };
            a2.Surface.prototype.requestAnimationFrame || (a2.Surface.prototype.requestAnimationFrame = a2.Surface.prototype.Gf);
            a2.Surface.prototype.Cf = function(d2, g2) {
              this.He || (this.He = this.getCanvas());
              requestAnimationFrame(function() {
                a2.Md(this.Kd);
                d2(this.He);
                this.flush(g2);
                this.dispose();
              }.bind(this));
            };
            a2.Surface.prototype.drawOnce || (a2.Surface.prototype.drawOnce = a2.Surface.prototype.Cf);
            a2.PathEffect.MakeDash = function(d2, g2) {
              g2 || (g2 = 0);
              if (!d2.length || 1 === d2.length % 2) throw "Intervals array must have even length";
              var l2 = v2(d2, "HEAPF32");
              g2 = a2.PathEffect._MakeDash(l2, d2.length, g2);
              p2(l2, d2);
              return g2;
            };
            a2.PathEffect.MakeLine2D = function(d2, g2) {
              g2 = H2(g2);
              return a2.PathEffect._MakeLine2D(d2, g2);
            };
            a2.PathEffect.MakePath2D = function(d2, g2) {
              d2 = H2(d2);
              return a2.PathEffect._MakePath2D(d2, g2);
            };
            a2.Shader.MakeColor = function(d2, g2) {
              g2 = g2 || null;
              d2 = y2(d2);
              return a2.Shader._MakeColor(d2, g2);
            };
            a2.Shader.Blend = a2.Shader.MakeBlend;
            a2.Shader.Color = a2.Shader.MakeColor;
            a2.Shader.MakeLinearGradient = function(d2, g2, l2, t2, x2, C2, J2, P2) {
              P2 = P2 || null;
              var O2 = E2(l2), Y2 = v2(t2, "HEAPF32");
              J2 = J2 || 0;
              C2 = H2(C2);
              var aa = Ba.toTypedArray();
              aa.set(d2);
              aa.set(g2, 2);
              d2 = a2.Shader._MakeLinearGradient(ja, O2.be, O2.colorType, Y2, O2.count, x2, J2, C2, P2);
              p2(O2.be, l2);
              t2 && p2(Y2, t2);
              return d2;
            };
            a2.Shader.MakeRadialGradient = function(d2, g2, l2, t2, x2, C2, J2, P2) {
              P2 = P2 || null;
              var O2 = E2(l2), Y2 = v2(t2, "HEAPF32");
              J2 = J2 || 0;
              C2 = H2(C2);
              d2 = a2.Shader._MakeRadialGradient(d2[0], d2[1], g2, O2.be, O2.colorType, Y2, O2.count, x2, J2, C2, P2);
              p2(O2.be, l2);
              t2 && p2(Y2, t2);
              return d2;
            };
            a2.Shader.MakeSweepGradient = function(d2, g2, l2, t2, x2, C2, J2, P2, O2, Y2) {
              Y2 = Y2 || null;
              var aa = E2(l2), r2 = v2(t2, "HEAPF32");
              J2 = J2 || 0;
              P2 = P2 || 0;
              O2 = O2 || 360;
              C2 = H2(C2);
              d2 = a2.Shader._MakeSweepGradient(d2, g2, aa.be, aa.colorType, r2, aa.count, x2, P2, O2, J2, C2, Y2);
              p2(aa.be, l2);
              t2 && p2(r2, t2);
              return d2;
            };
            a2.Shader.MakeTwoPointConicalGradient = function(d2, g2, l2, t2, x2, C2, J2, P2, O2, Y2) {
              Y2 = Y2 || null;
              var aa = E2(x2), r2 = v2(C2, "HEAPF32");
              O2 = O2 || 0;
              P2 = H2(P2);
              var D2 = Ba.toTypedArray();
              D2.set(d2);
              D2.set(l2, 2);
              d2 = a2.Shader._MakeTwoPointConicalGradient(ja, g2, t2, aa.be, aa.colorType, r2, aa.count, J2, O2, P2, Y2);
              p2(aa.be, x2);
              C2 && p2(r2, C2);
              return d2;
            };
            a2.Vertices.prototype.bounds = function(d2) {
              this._bounds(ja);
              var g2 = Ba.toTypedArray();
              return d2 ? (d2.set(g2), d2) : g2.slice();
            };
            a2.Td && a2.Td.forEach(function(d2) {
              d2();
            });
          };
          a2.computeTonalColors = function(e3) {
            var d2 = v2(e3.ambient, "HEAPF32"), g2 = v2(e3.spot, "HEAPF32");
            this._computeTonalColors(d2, g2);
            var l2 = { ambient: T2(d2), spot: T2(g2) };
            p2(d2, e3.ambient);
            p2(g2, e3.spot);
            return l2;
          };
          a2.LTRBRect = function(e3, d2, g2, l2) {
            return Float32Array.of(e3, d2, g2, l2);
          };
          a2.XYWHRect = function(e3, d2, g2, l2) {
            return Float32Array.of(e3, d2, e3 + g2, d2 + l2);
          };
          a2.LTRBiRect = function(e3, d2, g2, l2) {
            return Int32Array.of(e3, d2, g2, l2);
          };
          a2.XYWHiRect = function(e3, d2, g2, l2) {
            return Int32Array.of(e3, d2, e3 + g2, d2 + l2);
          };
          a2.RRectXY = function(e3, d2, g2) {
            return Float32Array.of(e3[0], e3[1], e3[2], e3[3], d2, g2, d2, g2, d2, g2, d2, g2);
          };
          a2.MakeAnimatedImageFromEncoded = function(e3) {
            e3 = new Uint8Array(e3);
            var d2 = a2._malloc(e3.byteLength);
            a2.HEAPU8.set(e3, d2);
            return (e3 = a2._decodeAnimatedImage(
              d2,
              e3.byteLength
            )) ? e3 : null;
          };
          a2.MakeImageFromEncoded = function(e3) {
            e3 = new Uint8Array(e3);
            var d2 = a2._malloc(e3.byteLength);
            a2.HEAPU8.set(e3, d2);
            return (e3 = a2._decodeImage(d2, e3.byteLength)) ? e3 : null;
          };
          var jb = null;
          a2.MakeImageFromCanvasImageSource = function(e3) {
            var d2 = e3.width, g2 = e3.height;
            jb || (jb = document.createElement("canvas"));
            jb.width = d2;
            jb.height = g2;
            var l2 = jb.getContext("2d", { willReadFrequently: true });
            l2.drawImage(e3, 0, 0);
            e3 = l2.getImageData(0, 0, d2, g2);
            return a2.MakeImage({
              width: d2,
              height: g2,
              alphaType: a2.AlphaType.Unpremul,
              colorType: a2.ColorType.RGBA_8888,
              colorSpace: a2.ColorSpace.SRGB
            }, e3.data, 4 * d2);
          };
          a2.MakeImage = function(e3, d2, g2) {
            var l2 = a2._malloc(d2.length);
            a2.HEAPU8.set(d2, l2);
            return a2._MakeImage(e3, l2, d2.length, g2);
          };
          a2.MakeVertices = function(e3, d2, g2, l2, t2, x2) {
            var C2 = t2 && t2.length || 0, J2 = 0;
            g2 && g2.length && (J2 |= 1);
            l2 && l2.length && (J2 |= 2);
            void 0 === x2 || x2 || (J2 |= 4);
            e3 = new a2._VerticesBuilder(e3, d2.length / 2, C2, J2);
            v2(d2, "HEAPF32", e3.positions());
            e3.texCoords() && v2(g2, "HEAPF32", e3.texCoords());
            e3.colors() && v2(m2(l2), "HEAPU32", e3.colors());
            e3.indices() && v2(t2, "HEAPU16", e3.indices());
            return e3.detach();
          };
          a2.Matrix = {};
          a2.Matrix.identity = function() {
            return c2(3);
          };
          a2.Matrix.invert = function(e3) {
            var d2 = e3[0] * e3[4] * e3[8] + e3[1] * e3[5] * e3[6] + e3[2] * e3[3] * e3[7] - e3[2] * e3[4] * e3[6] - e3[1] * e3[3] * e3[8] - e3[0] * e3[5] * e3[7];
            return d2 ? [(e3[4] * e3[8] - e3[5] * e3[7]) / d2, (e3[2] * e3[7] - e3[1] * e3[8]) / d2, (e3[1] * e3[5] - e3[2] * e3[4]) / d2, (e3[5] * e3[6] - e3[3] * e3[8]) / d2, (e3[0] * e3[8] - e3[2] * e3[6]) / d2, (e3[2] * e3[3] - e3[0] * e3[5]) / d2, (e3[3] * e3[7] - e3[4] * e3[6]) / d2, (e3[1] * e3[6] - e3[0] * e3[7]) / d2, (e3[0] * e3[4] - e3[1] * e3[3]) / d2] : null;
          };
          a2.Matrix.mapPoints = function(e3, d2) {
            for (var g2 = 0; g2 < d2.length; g2 += 2) {
              var l2 = d2[g2], t2 = d2[g2 + 1], x2 = e3[6] * l2 + e3[7] * t2 + e3[8], C2 = e3[3] * l2 + e3[4] * t2 + e3[5];
              d2[g2] = (e3[0] * l2 + e3[1] * t2 + e3[2]) / x2;
              d2[g2 + 1] = C2 / x2;
            }
            return d2;
          };
          a2.Matrix.multiply = function() {
            return hb(3, arguments);
          };
          a2.Matrix.rotated = function(e3, d2, g2) {
            d2 = d2 || 0;
            g2 = g2 || 0;
            var l2 = Math.sin(e3);
            e3 = Math.cos(e3);
            return [e3, -l2, ma(l2, g2, 1 - e3, d2), l2, e3, ma(-l2, d2, 1 - e3, g2), 0, 0, 1];
          };
          a2.Matrix.scaled = function(e3, d2, g2, l2) {
            g2 = g2 || 0;
            l2 = l2 || 0;
            var t2 = b2([e3, d2], c2(3), 3, 0, 1);
            return b2([g2 - e3 * g2, l2 - d2 * l2], t2, 3, 2, 0);
          };
          a2.Matrix.skewed = function(e3, d2, g2, l2) {
            g2 = g2 || 0;
            l2 = l2 || 0;
            var t2 = b2([e3, d2], c2(3), 3, 1, -1);
            return b2([-e3 * g2, -d2 * l2], t2, 3, 2, 0);
          };
          a2.Matrix.translated = function(e3, d2) {
            return b2(
              arguments,
              c2(3),
              3,
              2,
              0
            );
          };
          a2.Vector = {};
          a2.Vector.dot = function(e3, d2) {
            return e3.map(function(g2, l2) {
              return g2 * d2[l2];
            }).reduce(function(g2, l2) {
              return g2 + l2;
            });
          };
          a2.Vector.lengthSquared = function(e3) {
            return a2.Vector.dot(e3, e3);
          };
          a2.Vector.length = function(e3) {
            return Math.sqrt(a2.Vector.lengthSquared(e3));
          };
          a2.Vector.mulScalar = function(e3, d2) {
            return e3.map(function(g2) {
              return g2 * d2;
            });
          };
          a2.Vector.add = function(e3, d2) {
            return e3.map(function(g2, l2) {
              return g2 + d2[l2];
            });
          };
          a2.Vector.sub = function(e3, d2) {
            return e3.map(function(g2, l2) {
              return g2 - d2[l2];
            });
          };
          a2.Vector.dist = function(e3, d2) {
            return a2.Vector.length(a2.Vector.sub(e3, d2));
          };
          a2.Vector.normalize = function(e3) {
            return a2.Vector.mulScalar(e3, 1 / a2.Vector.length(e3));
          };
          a2.Vector.cross = function(e3, d2) {
            return [e3[1] * d2[2] - e3[2] * d2[1], e3[2] * d2[0] - e3[0] * d2[2], e3[0] * d2[1] - e3[1] * d2[0]];
          };
          a2.M44 = {};
          a2.M44.identity = function() {
            return c2(4);
          };
          a2.M44.translated = function(e3) {
            return b2(e3, c2(4), 4, 3, 0);
          };
          a2.M44.scaled = function(e3) {
            return b2(e3, c2(4), 4, 0, 1);
          };
          a2.M44.rotated = function(e3, d2) {
            return a2.M44.rotatedUnitSinCos(a2.Vector.normalize(e3), Math.sin(d2), Math.cos(d2));
          };
          a2.M44.rotatedUnitSinCos = function(e3, d2, g2) {
            var l2 = e3[0], t2 = e3[1];
            e3 = e3[2];
            var x2 = 1 - g2;
            return [x2 * l2 * l2 + g2, x2 * l2 * t2 - d2 * e3, x2 * l2 * e3 + d2 * t2, 0, x2 * l2 * t2 + d2 * e3, x2 * t2 * t2 + g2, x2 * t2 * e3 - d2 * l2, 0, x2 * l2 * e3 - d2 * t2, x2 * t2 * e3 + d2 * l2, x2 * e3 * e3 + g2, 0, 0, 0, 0, 1];
          };
          a2.M44.lookat = function(e3, d2, g2) {
            d2 = a2.Vector.normalize(a2.Vector.sub(d2, e3));
            g2 = a2.Vector.normalize(g2);
            g2 = a2.Vector.normalize(a2.Vector.cross(d2, g2));
            var l2 = a2.M44.identity();
            b2(g2, l2, 4, 0, 0);
            b2(a2.Vector.cross(g2, d2), l2, 4, 1, 0);
            b2(a2.Vector.mulScalar(d2, -1), l2, 4, 2, 0);
            b2(e3, l2, 4, 3, 0);
            e3 = a2.M44.invert(l2);
            return null === e3 ? a2.M44.identity() : e3;
          };
          a2.M44.perspective = function(e3, d2, g2) {
            var l2 = 1 / (d2 - e3);
            g2 /= 2;
            g2 = Math.cos(g2) / Math.sin(g2);
            return [g2, 0, 0, 0, 0, g2, 0, 0, 0, 0, (d2 + e3) * l2, 2 * d2 * e3 * l2, 0, 0, -1, 1];
          };
          a2.M44.rc = function(e3, d2, g2) {
            return e3[4 * d2 + g2];
          };
          a2.M44.multiply = function() {
            return hb(4, arguments);
          };
          a2.M44.invert = function(e3) {
            var d2 = e3[0], g2 = e3[4], l2 = e3[8], t2 = e3[12], x2 = e3[1], C2 = e3[5], J2 = e3[9], P2 = e3[13], O2 = e3[2], Y2 = e3[6], aa = e3[10], r2 = e3[14], D2 = e3[3], U2 = e3[7], ca2 = e3[11];
            e3 = e3[15];
            var ka = d2 * C2 - g2 * x2, va = d2 * J2 - l2 * x2, wa = d2 * P2 - t2 * x2, na = g2 * J2 - l2 * C2, G2 = g2 * P2 - t2 * C2, k2 = l2 * P2 - t2 * J2, q2 = O2 * U2 - Y2 * D2, z2 = O2 * ca2 - aa * D2, B2 = O2 * e3 - r2 * D2, F2 = Y2 * ca2 - aa * U2, I2 = Y2 * e3 - r2 * U2, M2 = aa * e3 - r2 * ca2, da = ka * M2 - va * I2 + wa * F2 + na * B2 - G2 * z2 + k2 * q2, ea = 1 / da;
            if (0 === da || Infinity === ea) return null;
            ka *= ea;
            va *= ea;
            wa *= ea;
            na *= ea;
            G2 *= ea;
            k2 *= ea;
            q2 *= ea;
            z2 *= ea;
            B2 *= ea;
            F2 *= ea;
            I2 *= ea;
            M2 *= ea;
            d2 = [C2 * M2 - J2 * I2 + P2 * F2, J2 * B2 - x2 * M2 - P2 * z2, x2 * I2 - C2 * B2 + P2 * q2, C2 * z2 - x2 * F2 - J2 * q2, l2 * I2 - g2 * M2 - t2 * F2, d2 * M2 - l2 * B2 + t2 * z2, g2 * B2 - d2 * I2 - t2 * q2, d2 * F2 - g2 * z2 + l2 * q2, U2 * k2 - ca2 * G2 + e3 * na, ca2 * wa - D2 * k2 - e3 * va, D2 * G2 - U2 * wa + e3 * ka, U2 * va - D2 * na - ca2 * ka, aa * G2 - Y2 * k2 - r2 * na, O2 * k2 - aa * wa + r2 * va, Y2 * wa - O2 * G2 - r2 * ka, O2 * na - Y2 * va + aa * ka];
            return d2.every(function(Ia) {
              return !isNaN(Ia) && Infinity !== Ia && -Infinity !== Ia;
            }) ? d2 : null;
          };
          a2.M44.transpose = function(e3) {
            return [
              e3[0],
              e3[4],
              e3[8],
              e3[12],
              e3[1],
              e3[5],
              e3[9],
              e3[13],
              e3[2],
              e3[6],
              e3[10],
              e3[14],
              e3[3],
              e3[7],
              e3[11],
              e3[15]
            ];
          };
          a2.M44.mustInvert = function(e3) {
            e3 = a2.M44.invert(e3);
            if (null === e3) throw "Matrix not invertible";
            return e3;
          };
          a2.M44.setupCamera = function(e3, d2, g2) {
            var l2 = a2.M44.lookat(g2.eye, g2.coa, g2.up);
            g2 = a2.M44.perspective(g2.near, g2.far, g2.angle);
            d2 = [(e3[2] - e3[0]) / 2, (e3[3] - e3[1]) / 2, d2];
            e3 = a2.M44.multiply(a2.M44.translated([(e3[0] + e3[2]) / 2, (e3[1] + e3[3]) / 2, 0]), a2.M44.scaled(d2));
            return a2.M44.multiply(e3, g2, l2, a2.M44.mustInvert(e3));
          };
          a2.ColorMatrix = {};
          a2.ColorMatrix.identity = function() {
            var e3 = new Float32Array(20);
            e3[0] = 1;
            e3[6] = 1;
            e3[12] = 1;
            e3[18] = 1;
            return e3;
          };
          a2.ColorMatrix.scaled = function(e3, d2, g2, l2) {
            var t2 = new Float32Array(20);
            t2[0] = e3;
            t2[6] = d2;
            t2[12] = g2;
            t2[18] = l2;
            return t2;
          };
          var xd = [[6, 7, 11, 12], [0, 10, 2, 12], [0, 1, 5, 6]];
          a2.ColorMatrix.rotated = function(e3, d2, g2) {
            var l2 = a2.ColorMatrix.identity();
            e3 = xd[e3];
            l2[e3[0]] = g2;
            l2[e3[1]] = d2;
            l2[e3[2]] = -d2;
            l2[e3[3]] = g2;
            return l2;
          };
          a2.ColorMatrix.postTranslate = function(e3, d2, g2, l2, t2) {
            e3[4] += d2;
            e3[9] += g2;
            e3[14] += l2;
            e3[19] += t2;
            return e3;
          };
          a2.ColorMatrix.concat = function(e3, d2) {
            for (var g2 = new Float32Array(20), l2 = 0, t2 = 0; 20 > t2; t2 += 5) {
              for (var x2 = 0; 4 > x2; x2++) g2[l2++] = e3[t2] * d2[x2] + e3[t2 + 1] * d2[x2 + 5] + e3[t2 + 2] * d2[x2 + 10] + e3[t2 + 3] * d2[x2 + 15];
              g2[l2++] = e3[t2] * d2[4] + e3[t2 + 1] * d2[9] + e3[t2 + 2] * d2[14] + e3[t2 + 3] * d2[19] + e3[t2 + 4];
            }
            return g2;
          };
          (function(e3) {
            e3.Td = e3.Td || [];
            e3.Td.push(function() {
              function d2(r2) {
                r2 && (r2.dir = 0 === r2.dir ? e3.TextDirection.RTL : e3.TextDirection.LTR);
                return r2;
              }
              function g2(r2) {
                if (!r2 || !r2.length) return [];
                for (var D2 = [], U2 = 0; U2 < r2.length; U2 += 5) {
                  var ca2 = e3.LTRBRect(r2[U2], r2[U2 + 1], r2[U2 + 2], r2[U2 + 3]), ka = e3.TextDirection.LTR;
                  0 === r2[U2 + 4] && (ka = e3.TextDirection.RTL);
                  D2.push({ rect: ca2, dir: ka });
                }
                e3._free(r2.byteOffset);
                return D2;
              }
              function l2(r2) {
                r2 = r2 || {};
                void 0 === r2.weight && (r2.weight = e3.FontWeight.Normal);
                r2.width = r2.width || e3.FontWidth.Normal;
                r2.slant = r2.slant || e3.FontSlant.Upright;
                return r2;
              }
              function t2(r2) {
                if (!r2 || !r2.length) return W2;
                for (var D2 = [], U2 = 0; U2 < r2.length; U2++) {
                  var ca2 = x2(r2[U2]);
                  D2.push(ca2);
                }
                return v2(D2, "HEAPU32");
              }
              function x2(r2) {
                if (P2[r2]) return P2[r2];
                var D2 = qa(r2) + 1, U2 = e3._malloc(D2);
                ra(r2, K2, U2, D2);
                return P2[r2] = U2;
              }
              function C2(r2) {
                r2._colorPtr = y2(r2.color);
                r2._foregroundColorPtr = W2;
                r2._backgroundColorPtr = W2;
                r2._decorationColorPtr = W2;
                r2.foregroundColor && (r2._foregroundColorPtr = y2(r2.foregroundColor, O2));
                r2.backgroundColor && (r2._backgroundColorPtr = y2(r2.backgroundColor, Y2));
                r2.decorationColor && (r2._decorationColorPtr = y2(r2.decorationColor, aa));
                Array.isArray(r2.fontFamilies) && r2.fontFamilies.length ? (r2._fontFamiliesPtr = t2(r2.fontFamilies), r2._fontFamiliesLen = r2.fontFamilies.length) : (r2._fontFamiliesPtr = W2, r2._fontFamiliesLen = 0);
                if (r2.locale) {
                  var D2 = r2.locale;
                  r2._localePtr = x2(D2);
                  r2._localeLen = qa(D2) + 1;
                } else r2._localePtr = W2, r2._localeLen = 0;
                if (Array.isArray(r2.shadows) && r2.shadows.length) {
                  D2 = r2.shadows;
                  var U2 = D2.map(function(G2) {
                    return G2.color || e3.BLACK;
                  }), ca2 = D2.map(function(G2) {
                    return G2.blurRadius || 0;
                  });
                  r2._shadowLen = D2.length;
                  for (var ka = e3._malloc(8 * D2.length), va = ka / 4, wa = 0; wa < D2.length; wa++) {
                    var na = D2[wa].offset || [0, 0];
                    e3.HEAPF32[va] = na[0];
                    e3.HEAPF32[va + 1] = na[1];
                    va += 2;
                  }
                  r2._shadowColorsPtr = E2(U2).be;
                  r2._shadowOffsetsPtr = ka;
                  r2._shadowBlurRadiiPtr = v2(ca2, "HEAPF32");
                } else r2._shadowLen = 0, r2._shadowColorsPtr = W2, r2._shadowOffsetsPtr = W2, r2._shadowBlurRadiiPtr = W2;
                Array.isArray(r2.fontFeatures) && r2.fontFeatures.length ? (D2 = r2.fontFeatures, U2 = D2.map(function(G2) {
                  return G2.name;
                }), ca2 = D2.map(function(G2) {
                  return G2.value;
                }), r2._fontFeatureLen = D2.length, r2._fontFeatureNamesPtr = t2(U2), r2._fontFeatureValuesPtr = v2(ca2, "HEAPU32")) : (r2._fontFeatureLen = 0, r2._fontFeatureNamesPtr = W2, r2._fontFeatureValuesPtr = W2);
                Array.isArray(r2.fontVariations) && r2.fontVariations.length ? (D2 = r2.fontVariations, U2 = D2.map(function(G2) {
                  return G2.axis;
                }), ca2 = D2.map(function(G2) {
                  return G2.value;
                }), r2._fontVariationLen = D2.length, r2._fontVariationAxesPtr = t2(U2), r2._fontVariationValuesPtr = v2(ca2, "HEAPF32")) : (r2._fontVariationLen = 0, r2._fontVariationAxesPtr = W2, r2._fontVariationValuesPtr = W2);
              }
              function J2(r2) {
                e3._free(r2._fontFamiliesPtr);
                e3._free(r2._shadowColorsPtr);
                e3._free(r2._shadowOffsetsPtr);
                e3._free(r2._shadowBlurRadiiPtr);
                e3._free(r2._fontFeatureNamesPtr);
                e3._free(r2._fontFeatureValuesPtr);
                e3._free(r2._fontVariationAxesPtr);
                e3._free(r2._fontVariationValuesPtr);
              }
              e3.Paragraph.prototype.getRectsForRange = function(r2, D2, U2, ca2) {
                r2 = this._getRectsForRange(r2, D2, U2, ca2);
                return g2(r2);
              };
              e3.Paragraph.prototype.getRectsForPlaceholders = function() {
                var r2 = this._getRectsForPlaceholders();
                return g2(r2);
              };
              e3.Paragraph.prototype.getGlyphInfoAt = function(r2) {
                return d2(this._getGlyphInfoAt(r2));
              };
              e3.Paragraph.prototype.getClosestGlyphInfoAtCoordinate = function(r2, D2) {
                return d2(this._getClosestGlyphInfoAtCoordinate(r2, D2));
              };
              e3.TypefaceFontProvider.prototype.registerFont = function(r2, D2) {
                r2 = e3.Typeface.MakeFreeTypeFaceFromData(r2);
                if (!r2) return null;
                D2 = x2(D2);
                this._registerFont(r2, D2);
              };
              e3.ParagraphStyle = function(r2) {
                r2.disableHinting = r2.disableHinting || false;
                if (r2.ellipsis) {
                  var D2 = r2.ellipsis;
                  r2._ellipsisPtr = x2(D2);
                  r2._ellipsisLen = qa(D2) + 1;
                } else r2._ellipsisPtr = W2, r2._ellipsisLen = 0;
                null == r2.heightMultiplier && (r2.heightMultiplier = -1);
                r2.maxLines = r2.maxLines || 0;
                r2.replaceTabCharacters = r2.replaceTabCharacters || false;
                D2 = (D2 = r2.strutStyle) || {};
                D2.strutEnabled = D2.strutEnabled || false;
                D2.strutEnabled && Array.isArray(D2.fontFamilies) && D2.fontFamilies.length ? (D2._fontFamiliesPtr = t2(D2.fontFamilies), D2._fontFamiliesLen = D2.fontFamilies.length) : (D2._fontFamiliesPtr = W2, D2._fontFamiliesLen = 0);
                D2.fontStyle = l2(D2.fontStyle);
                null == D2.fontSize && (D2.fontSize = -1);
                null == D2.heightMultiplier && (D2.heightMultiplier = -1);
                D2.halfLeading = D2.halfLeading || false;
                D2.leading = D2.leading || 0;
                D2.forceStrutHeight = D2.forceStrutHeight || false;
                r2.strutStyle = D2;
                r2.textAlign = r2.textAlign || e3.TextAlign.Start;
                r2.textDirection = r2.textDirection || e3.TextDirection.LTR;
                r2.textHeightBehavior = r2.textHeightBehavior || e3.TextHeightBehavior.All;
                r2.textStyle = e3.TextStyle(r2.textStyle);
                r2.applyRoundingHack = false !== r2.applyRoundingHack;
                return r2;
              };
              e3.TextStyle = function(r2) {
                r2.color || (r2.color = e3.BLACK);
                r2.decoration = r2.decoration || 0;
                r2.decorationThickness = r2.decorationThickness || 0;
                r2.decorationStyle = r2.decorationStyle || e3.DecorationStyle.Solid;
                r2.textBaseline = r2.textBaseline || e3.TextBaseline.Alphabetic;
                null == r2.fontSize && (r2.fontSize = -1);
                r2.letterSpacing = r2.letterSpacing || 0;
                r2.wordSpacing = r2.wordSpacing || 0;
                null == r2.heightMultiplier && (r2.heightMultiplier = -1);
                r2.halfLeading = r2.halfLeading || false;
                r2.fontStyle = l2(r2.fontStyle);
                return r2;
              };
              var P2 = {}, O2 = e3._malloc(16), Y2 = e3._malloc(16), aa = e3._malloc(16);
              e3.ParagraphBuilder.Make = function(r2, D2) {
                C2(r2.textStyle);
                D2 = e3.ParagraphBuilder._Make(r2, D2);
                J2(r2.textStyle);
                return D2;
              };
              e3.ParagraphBuilder.MakeFromFontProvider = function(r2, D2) {
                C2(r2.textStyle);
                D2 = e3.ParagraphBuilder._MakeFromFontProvider(r2, D2);
                J2(r2.textStyle);
                return D2;
              };
              e3.ParagraphBuilder.MakeFromFontCollection = function(r2, D2) {
                C2(r2.textStyle);
                D2 = e3.ParagraphBuilder._MakeFromFontCollection(r2, D2);
                J2(r2.textStyle);
                return D2;
              };
              e3.ParagraphBuilder.ShapeText = function(r2, D2, U2) {
                let ca2 = 0;
                for (const ka of D2) ca2 += ka.length;
                if (ca2 !== r2.length) throw "Accumulated block lengths must equal text.length";
                return e3.ParagraphBuilder._ShapeText(r2, D2, U2);
              };
              e3.ParagraphBuilder.prototype.pushStyle = function(r2) {
                C2(r2);
                this._pushStyle(r2);
                J2(r2);
              };
              e3.ParagraphBuilder.prototype.pushPaintStyle = function(r2, D2, U2) {
                C2(r2);
                this._pushPaintStyle(r2, D2, U2);
                J2(r2);
              };
              e3.ParagraphBuilder.prototype.addPlaceholder = function(r2, D2, U2, ca2, ka) {
                U2 = U2 || e3.PlaceholderAlignment.Baseline;
                ca2 = ca2 || e3.TextBaseline.Alphabetic;
                this._addPlaceholder(r2 || 0, D2 || 0, U2, ca2, ka || 0);
              };
              e3.ParagraphBuilder.prototype.setWordsUtf8 = function(r2) {
                var D2 = v2(r2, "HEAPU32");
                this._setWordsUtf8(D2, r2 && r2.length || 0);
                p2(D2, r2);
              };
              e3.ParagraphBuilder.prototype.setWordsUtf16 = function(r2) {
                var D2 = v2(r2, "HEAPU32");
                this._setWordsUtf16(
                  D2,
                  r2 && r2.length || 0
                );
                p2(D2, r2);
              };
              e3.ParagraphBuilder.prototype.setGraphemeBreaksUtf8 = function(r2) {
                var D2 = v2(r2, "HEAPU32");
                this._setGraphemeBreaksUtf8(D2, r2 && r2.length || 0);
                p2(D2, r2);
              };
              e3.ParagraphBuilder.prototype.setGraphemeBreaksUtf16 = function(r2) {
                var D2 = v2(r2, "HEAPU32");
                this._setGraphemeBreaksUtf16(D2, r2 && r2.length || 0);
                p2(D2, r2);
              };
              e3.ParagraphBuilder.prototype.setLineBreaksUtf8 = function(r2) {
                var D2 = v2(r2, "HEAPU32");
                this._setLineBreaksUtf8(D2, r2 && r2.length || 0);
                p2(D2, r2);
              };
              e3.ParagraphBuilder.prototype.setLineBreaksUtf16 = function(r2) {
                var D2 = v2(
                  r2,
                  "HEAPU32"
                );
                this._setLineBreaksUtf16(D2, r2 && r2.length || 0);
                p2(D2, r2);
              };
            });
          })(w2);
          a2.Td = a2.Td || [];
          a2.Td.push(function() {
            a2.Path.prototype.op = function(e3, d2) {
              return this._op(e3, d2) ? this : null;
            };
            a2.Path.prototype.simplify = function() {
              return this._simplify() ? this : null;
            };
          });
          a2.Td = a2.Td || [];
          a2.Td.push(function() {
            a2.Canvas.prototype.drawText = function(e3, d2, g2, l2, t2) {
              var x2 = qa(e3), C2 = a2._malloc(x2 + 1);
              ra(e3, K2, C2, x2 + 1);
              this._drawSimpleText(C2, x2, d2, g2, t2, l2);
              a2._free(C2);
            };
            a2.Canvas.prototype.drawGlyphs = function(e3, d2, g2, l2, t2, x2) {
              if (!(2 * e3.length <= d2.length)) throw "Not enough positions for the array of gyphs";
              a2.Md(this.Kd);
              const C2 = v2(e3, "HEAPU16"), J2 = v2(d2, "HEAPF32");
              this._drawGlyphs(e3.length, C2, J2, g2, l2, t2, x2);
              p2(J2, d2);
              p2(C2, e3);
            };
            a2.Font.prototype.getGlyphBounds = function(e3, d2, g2) {
              var l2 = v2(e3, "HEAPU16"), t2 = a2._malloc(16 * e3.length);
              this._getGlyphWidthBounds(l2, e3.length, W2, t2, d2 || null);
              d2 = new Float32Array(a2.HEAPU8.buffer, t2, 4 * e3.length);
              p2(l2, e3);
              if (g2) return g2.set(d2), a2._free(t2), g2;
              e3 = Float32Array.from(d2);
              a2._free(t2);
              return e3;
            };
            a2.Font.prototype.getGlyphIDs = function(e3, d2, g2) {
              d2 || (d2 = e3.length);
              var l2 = qa(e3) + 1, t2 = a2._malloc(l2);
              ra(e3, K2, t2, l2);
              e3 = a2._malloc(2 * d2);
              d2 = this._getGlyphIDs(t2, l2 - 1, d2, e3);
              a2._free(t2);
              if (0 > d2) return a2._free(e3), null;
              t2 = new Uint16Array(a2.HEAPU8.buffer, e3, d2);
              if (g2) return g2.set(t2), a2._free(e3), g2;
              g2 = Uint16Array.from(t2);
              a2._free(e3);
              return g2;
            };
            a2.Font.prototype.getGlyphIntercepts = function(e3, d2, g2, l2) {
              var t2 = v2(e3, "HEAPU16"), x2 = v2(d2, "HEAPF32");
              return this._getGlyphIntercepts(t2, e3.length, !(e3 && e3._ck), x2, d2.length, !(d2 && d2._ck), g2, l2);
            };
            a2.Font.prototype.getGlyphWidths = function(e3, d2, g2) {
              var l2 = v2(e3, "HEAPU16"), t2 = a2._malloc(4 * e3.length);
              this._getGlyphWidthBounds(
                l2,
                e3.length,
                t2,
                W2,
                d2 || null
              );
              d2 = new Float32Array(a2.HEAPU8.buffer, t2, e3.length);
              p2(l2, e3);
              if (g2) return g2.set(d2), a2._free(t2), g2;
              e3 = Float32Array.from(d2);
              a2._free(t2);
              return e3;
            };
            a2.FontMgr.FromData = function() {
              if (!arguments.length) return null;
              var e3 = arguments;
              1 === e3.length && Array.isArray(e3[0]) && (e3 = arguments[0]);
              if (!e3.length) return null;
              for (var d2 = [], g2 = [], l2 = 0; l2 < e3.length; l2++) {
                var t2 = new Uint8Array(e3[l2]), x2 = v2(t2, "HEAPU8");
                d2.push(x2);
                g2.push(t2.byteLength);
              }
              d2 = v2(d2, "HEAPU32");
              g2 = v2(g2, "HEAPU32");
              e3 = a2.FontMgr._fromData(d2, g2, e3.length);
              a2._free(d2);
              a2._free(g2);
              return e3;
            };
            a2.Typeface.MakeFreeTypeFaceFromData = function(e3) {
              e3 = new Uint8Array(e3);
              var d2 = v2(e3, "HEAPU8");
              return (e3 = a2.Typeface._MakeFreeTypeFaceFromData(d2, e3.byteLength)) ? e3 : null;
            };
            a2.Typeface.prototype.getGlyphIDs = function(e3, d2, g2) {
              d2 || (d2 = e3.length);
              var l2 = qa(e3) + 1, t2 = a2._malloc(l2);
              ra(e3, K2, t2, l2);
              e3 = a2._malloc(2 * d2);
              d2 = this._getGlyphIDs(t2, l2 - 1, d2, e3);
              a2._free(t2);
              if (0 > d2) return a2._free(e3), null;
              t2 = new Uint16Array(a2.HEAPU8.buffer, e3, d2);
              if (g2) return g2.set(t2), a2._free(e3), g2;
              g2 = Uint16Array.from(t2);
              a2._free(e3);
              return g2;
            };
            a2.TextBlob.MakeOnPath = function(e3, d2, g2, l2) {
              if (e3 && e3.length && d2 && d2.countPoints()) {
                if (1 === d2.countPoints()) return this.MakeFromText(e3, g2);
                l2 || (l2 = 0);
                var t2 = g2.getGlyphIDs(e3);
                t2 = g2.getGlyphWidths(t2);
                var x2 = [];
                d2 = new a2.ContourMeasureIter(d2, false, 1);
                for (var C2 = d2.next(), J2 = new Float32Array(4), P2 = 0; P2 < e3.length && C2; P2++) {
                  var O2 = t2[P2];
                  l2 += O2 / 2;
                  if (l2 > C2.length()) {
                    C2.delete();
                    C2 = d2.next();
                    if (!C2) {
                      e3 = e3.substring(0, P2);
                      break;
                    }
                    l2 = O2 / 2;
                  }
                  C2.getPosTan(l2, J2);
                  var Y2 = J2[2], aa = J2[3];
                  x2.push(Y2, aa, J2[0] - O2 / 2 * Y2, J2[1] - O2 / 2 * aa);
                  l2 += O2 / 2;
                }
                e3 = this.MakeFromRSXform(e3, x2, g2);
                C2 && C2.delete();
                d2.delete();
                return e3;
              }
            };
            a2.TextBlob.MakeFromRSXform = function(e3, d2, g2) {
              var l2 = qa(e3) + 1, t2 = a2._malloc(l2);
              ra(e3, K2, t2, l2);
              e3 = v2(d2, "HEAPF32");
              g2 = a2.TextBlob._MakeFromRSXform(t2, l2 - 1, e3, g2);
              a2._free(t2);
              return g2 ? g2 : null;
            };
            a2.TextBlob.MakeFromRSXformGlyphs = function(e3, d2, g2) {
              var l2 = v2(e3, "HEAPU16");
              d2 = v2(d2, "HEAPF32");
              g2 = a2.TextBlob._MakeFromRSXformGlyphs(l2, 2 * e3.length, d2, g2);
              p2(l2, e3);
              return g2 ? g2 : null;
            };
            a2.TextBlob.MakeFromGlyphs = function(e3, d2) {
              var g2 = v2(e3, "HEAPU16");
              d2 = a2.TextBlob._MakeFromGlyphs(g2, 2 * e3.length, d2);
              p2(g2, e3);
              return d2 ? d2 : null;
            };
            a2.TextBlob.MakeFromText = function(e3, d2) {
              var g2 = qa(e3) + 1, l2 = a2._malloc(g2);
              ra(e3, K2, l2, g2);
              e3 = a2.TextBlob._MakeFromText(l2, g2 - 1, d2);
              a2._free(l2);
              return e3 ? e3 : null;
            };
            a2.MallocGlyphIDs = function(e3) {
              return a2.Malloc(Uint16Array, e3);
            };
          });
          a2.Td = a2.Td || [];
          a2.Td.push(function() {
            a2.MakePicture = function(e3) {
              e3 = new Uint8Array(e3);
              var d2 = a2._malloc(e3.byteLength);
              a2.HEAPU8.set(e3, d2);
              return (e3 = a2._MakePicture(d2, e3.byteLength)) ? e3 : null;
            };
          });
          a2.Td = a2.Td || [];
          a2.Td.push(function() {
            a2.RuntimeEffect.Make = function(e3, d2) {
              return a2.RuntimeEffect._Make(e3, { onError: d2 || function(g2) {
                console.log(
                  "RuntimeEffect error",
                  g2
                );
              } });
            };
            a2.RuntimeEffect.MakeForBlender = function(e3, d2) {
              return a2.RuntimeEffect._MakeForBlender(e3, { onError: d2 || function(g2) {
                console.log("RuntimeEffect error", g2);
              } });
            };
            a2.RuntimeEffect.prototype.makeShader = function(e3, d2) {
              var g2 = !e3._ck, l2 = v2(e3, "HEAPF32");
              d2 = H2(d2);
              return this._makeShader(l2, 4 * e3.length, g2, d2);
            };
            a2.RuntimeEffect.prototype.makeShaderWithChildren = function(e3, d2, g2) {
              var l2 = !e3._ck, t2 = v2(e3, "HEAPF32");
              g2 = H2(g2);
              for (var x2 = [], C2 = 0; C2 < d2.length; C2++) x2.push(d2[C2].Jd.Rd);
              d2 = v2(x2, "HEAPU32");
              return this._makeShaderWithChildren(
                t2,
                4 * e3.length,
                l2,
                d2,
                x2.length,
                g2
              );
            };
            a2.RuntimeEffect.prototype.makeBlender = function(e3) {
              var d2 = !e3._ck, g2 = v2(e3, "HEAPF32");
              return this._makeBlender(g2, 4 * e3.length, d2);
            };
          });
          (function() {
            function e3(G2) {
              for (var k2 = 0; k2 < G2.length; k2++) if (void 0 !== G2[k2] && !Number.isFinite(G2[k2])) return false;
              return true;
            }
            function d2(G2) {
              var k2 = a2.getColorComponents(G2);
              G2 = k2[0];
              var q2 = k2[1], z2 = k2[2];
              k2 = k2[3];
              if (1 === k2) return G2 = G2.toString(16).toLowerCase(), q2 = q2.toString(16).toLowerCase(), z2 = z2.toString(16).toLowerCase(), G2 = 1 === G2.length ? "0" + G2 : G2, q2 = 1 === q2.length ? "0" + q2 : q2, z2 = 1 === z2.length ? "0" + z2 : z2, "#" + G2 + q2 + z2;
              k2 = 0 === k2 || 1 === k2 ? k2 : k2.toFixed(8);
              return "rgba(" + G2 + ", " + q2 + ", " + z2 + ", " + k2 + ")";
            }
            function g2(G2) {
              return a2.parseColorString(G2, va);
            }
            function l2(G2) {
              G2 = wa.exec(G2);
              if (!G2) return null;
              var k2 = parseFloat(G2[4]), q2 = 16;
              switch (G2[5]) {
                case "em":
                case "rem":
                  q2 = 16 * k2;
                  break;
                case "pt":
                  q2 = 4 * k2 / 3;
                  break;
                case "px":
                  q2 = k2;
                  break;
                case "pc":
                  q2 = 16 * k2;
                  break;
                case "in":
                  q2 = 96 * k2;
                  break;
                case "cm":
                  q2 = 96 * k2 / 2.54;
                  break;
                case "mm":
                  q2 = 96 / 25.4 * k2;
                  break;
                case "q":
                  q2 = 96 / 25.4 / 4 * k2;
                  break;
                case "%":
                  q2 = 16 / 75 * k2;
              }
              return { style: G2[1], variant: G2[2], weight: G2[3], sizePx: q2, family: G2[6].trim() };
            }
            function t2(G2) {
              this.Ld = G2;
              this.Od = new a2.Paint();
              this.Od.setAntiAlias(true);
              this.Od.setStrokeMiter(10);
              this.Od.setStrokeCap(a2.StrokeCap.Butt);
              this.Od.setStrokeJoin(a2.StrokeJoin.Miter);
              this.Re = "10px monospace";
              this.me = new a2.Font(null, 10);
              this.me.setSubpixel(true);
              this.ae = this.ge = a2.BLACK;
              this.ve = 0;
              this.Je = a2.TRANSPARENT;
              this.xe = this.we = 0;
              this.Ke = this.ie = 1;
              this.Ie = 0;
              this.ue = [];
              this.Nd = a2.BlendMode.SrcOver;
              this.Od.setStrokeWidth(this.Ke);
              this.Od.setBlendMode(this.Nd);
              this.Qd = new a2.Path();
              this.Sd = a2.Matrix.identity();
              this.lf = [];
              this.Be = [];
              this.le = function() {
                this.Qd.delete();
                this.Od.delete();
                this.me.delete();
                this.Be.forEach(function(k2) {
                  k2.le();
                });
              };
              Object.defineProperty(this, "currentTransform", { enumerable: true, get: function() {
                return { a: this.Sd[0], c: this.Sd[1], e: this.Sd[2], b: this.Sd[3], d: this.Sd[4], f: this.Sd[5] };
              }, set: function(k2) {
                k2.a && this.setTransform(k2.a, k2.b, k2.c, k2.d, k2.e, k2.f);
              } });
              Object.defineProperty(this, "fillStyle", { enumerable: true, get: function() {
                return f2(this.ae) ? d2(this.ae) : this.ae;
              }, set: function(k2) {
                "string" === typeof k2 ? this.ae = g2(k2) : k2.te && (this.ae = k2);
              } });
              Object.defineProperty(this, "font", { enumerable: true, get: function() {
                return this.Re;
              }, set: function(k2) {
                var q2 = l2(k2), z2 = q2.family;
                q2.typeface = na[z2] ? na[z2][(q2.style || "normal") + "|" + (q2.variant || "normal") + "|" + (q2.weight || "normal")] || na[z2]["*"] : null;
                q2 && (this.me.setSize(q2.sizePx), this.me.setTypeface(q2.typeface), this.Re = k2);
              } });
              Object.defineProperty(this, "globalAlpha", { enumerable: true, get: function() {
                return this.ie;
              }, set: function(k2) {
                !isFinite(k2) || 0 > k2 || 1 < k2 || (this.ie = k2);
              } });
              Object.defineProperty(
                this,
                "globalCompositeOperation",
                { enumerable: true, get: function() {
                  switch (this.Nd) {
                    case a2.BlendMode.SrcOver:
                      return "source-over";
                    case a2.BlendMode.DstOver:
                      return "destination-over";
                    case a2.BlendMode.Src:
                      return "copy";
                    case a2.BlendMode.Dst:
                      return "destination";
                    case a2.BlendMode.Clear:
                      return "clear";
                    case a2.BlendMode.SrcIn:
                      return "source-in";
                    case a2.BlendMode.DstIn:
                      return "destination-in";
                    case a2.BlendMode.SrcOut:
                      return "source-out";
                    case a2.BlendMode.DstOut:
                      return "destination-out";
                    case a2.BlendMode.SrcATop:
                      return "source-atop";
                    case a2.BlendMode.DstATop:
                      return "destination-atop";
                    case a2.BlendMode.Xor:
                      return "xor";
                    case a2.BlendMode.Plus:
                      return "lighter";
                    case a2.BlendMode.Multiply:
                      return "multiply";
                    case a2.BlendMode.Screen:
                      return "screen";
                    case a2.BlendMode.Overlay:
                      return "overlay";
                    case a2.BlendMode.Darken:
                      return "darken";
                    case a2.BlendMode.Lighten:
                      return "lighten";
                    case a2.BlendMode.ColorDodge:
                      return "color-dodge";
                    case a2.BlendMode.ColorBurn:
                      return "color-burn";
                    case a2.BlendMode.HardLight:
                      return "hard-light";
                    case a2.BlendMode.SoftLight:
                      return "soft-light";
                    case a2.BlendMode.Difference:
                      return "difference";
                    case a2.BlendMode.Exclusion:
                      return "exclusion";
                    case a2.BlendMode.Hue:
                      return "hue";
                    case a2.BlendMode.Saturation:
                      return "saturation";
                    case a2.BlendMode.Color:
                      return "color";
                    case a2.BlendMode.Luminosity:
                      return "luminosity";
                  }
                }, set: function(k2) {
                  switch (k2) {
                    case "source-over":
                      this.Nd = a2.BlendMode.SrcOver;
                      break;
                    case "destination-over":
                      this.Nd = a2.BlendMode.DstOver;
                      break;
                    case "copy":
                      this.Nd = a2.BlendMode.Src;
                      break;
                    case "destination":
                      this.Nd = a2.BlendMode.Dst;
                      break;
                    case "clear":
                      this.Nd = a2.BlendMode.Clear;
                      break;
                    case "source-in":
                      this.Nd = a2.BlendMode.SrcIn;
                      break;
                    case "destination-in":
                      this.Nd = a2.BlendMode.DstIn;
                      break;
                    case "source-out":
                      this.Nd = a2.BlendMode.SrcOut;
                      break;
                    case "destination-out":
                      this.Nd = a2.BlendMode.DstOut;
                      break;
                    case "source-atop":
                      this.Nd = a2.BlendMode.SrcATop;
                      break;
                    case "destination-atop":
                      this.Nd = a2.BlendMode.DstATop;
                      break;
                    case "xor":
                      this.Nd = a2.BlendMode.Xor;
                      break;
                    case "lighter":
                      this.Nd = a2.BlendMode.Plus;
                      break;
                    case "plus-lighter":
                      this.Nd = a2.BlendMode.Plus;
                      break;
                    case "plus-darker":
                      throw "plus-darker is not supported";
                    case "multiply":
                      this.Nd = a2.BlendMode.Multiply;
                      break;
                    case "screen":
                      this.Nd = a2.BlendMode.Screen;
                      break;
                    case "overlay":
                      this.Nd = a2.BlendMode.Overlay;
                      break;
                    case "darken":
                      this.Nd = a2.BlendMode.Darken;
                      break;
                    case "lighten":
                      this.Nd = a2.BlendMode.Lighten;
                      break;
                    case "color-dodge":
                      this.Nd = a2.BlendMode.ColorDodge;
                      break;
                    case "color-burn":
                      this.Nd = a2.BlendMode.ColorBurn;
                      break;
                    case "hard-light":
                      this.Nd = a2.BlendMode.HardLight;
                      break;
                    case "soft-light":
                      this.Nd = a2.BlendMode.SoftLight;
                      break;
                    case "difference":
                      this.Nd = a2.BlendMode.Difference;
                      break;
                    case "exclusion":
                      this.Nd = a2.BlendMode.Exclusion;
                      break;
                    case "hue":
                      this.Nd = a2.BlendMode.Hue;
                      break;
                    case "saturation":
                      this.Nd = a2.BlendMode.Saturation;
                      break;
                    case "color":
                      this.Nd = a2.BlendMode.Color;
                      break;
                    case "luminosity":
                      this.Nd = a2.BlendMode.Luminosity;
                      break;
                    default:
                      return;
                  }
                  this.Od.setBlendMode(this.Nd);
                } }
              );
              Object.defineProperty(this, "imageSmoothingEnabled", { enumerable: true, get: function() {
                return true;
              }, set: function() {
              } });
              Object.defineProperty(this, "imageSmoothingQuality", {
                enumerable: true,
                get: function() {
                  return "high";
                },
                set: function() {
                }
              });
              Object.defineProperty(this, "lineCap", { enumerable: true, get: function() {
                switch (this.Od.getStrokeCap()) {
                  case a2.StrokeCap.Butt:
                    return "butt";
                  case a2.StrokeCap.Round:
                    return "round";
                  case a2.StrokeCap.Square:
                    return "square";
                }
              }, set: function(k2) {
                switch (k2) {
                  case "butt":
                    this.Od.setStrokeCap(a2.StrokeCap.Butt);
                    break;
                  case "round":
                    this.Od.setStrokeCap(a2.StrokeCap.Round);
                    break;
                  case "square":
                    this.Od.setStrokeCap(a2.StrokeCap.Square);
                }
              } });
              Object.defineProperty(this, "lineDashOffset", {
                enumerable: true,
                get: function() {
                  return this.Ie;
                },
                set: function(k2) {
                  isFinite(k2) && (this.Ie = k2);
                }
              });
              Object.defineProperty(this, "lineJoin", { enumerable: true, get: function() {
                switch (this.Od.getStrokeJoin()) {
                  case a2.StrokeJoin.Miter:
                    return "miter";
                  case a2.StrokeJoin.Round:
                    return "round";
                  case a2.StrokeJoin.Bevel:
                    return "bevel";
                }
              }, set: function(k2) {
                switch (k2) {
                  case "miter":
                    this.Od.setStrokeJoin(a2.StrokeJoin.Miter);
                    break;
                  case "round":
                    this.Od.setStrokeJoin(a2.StrokeJoin.Round);
                    break;
                  case "bevel":
                    this.Od.setStrokeJoin(a2.StrokeJoin.Bevel);
                }
              } });
              Object.defineProperty(
                this,
                "lineWidth",
                { enumerable: true, get: function() {
                  return this.Od.getStrokeWidth();
                }, set: function(k2) {
                  0 >= k2 || !k2 || (this.Ke = k2, this.Od.setStrokeWidth(k2));
                } }
              );
              Object.defineProperty(this, "miterLimit", { enumerable: true, get: function() {
                return this.Od.getStrokeMiter();
              }, set: function(k2) {
                0 >= k2 || !k2 || this.Od.setStrokeMiter(k2);
              } });
              Object.defineProperty(this, "shadowBlur", { enumerable: true, get: function() {
                return this.ve;
              }, set: function(k2) {
                0 > k2 || !isFinite(k2) || (this.ve = k2);
              } });
              Object.defineProperty(this, "shadowColor", {
                enumerable: true,
                get: function() {
                  return d2(this.Je);
                },
                set: function(k2) {
                  this.Je = g2(k2);
                }
              });
              Object.defineProperty(this, "shadowOffsetX", { enumerable: true, get: function() {
                return this.we;
              }, set: function(k2) {
                isFinite(k2) && (this.we = k2);
              } });
              Object.defineProperty(this, "shadowOffsetY", { enumerable: true, get: function() {
                return this.xe;
              }, set: function(k2) {
                isFinite(k2) && (this.xe = k2);
              } });
              Object.defineProperty(this, "strokeStyle", { enumerable: true, get: function() {
                return d2(this.ge);
              }, set: function(k2) {
                "string" === typeof k2 ? this.ge = g2(k2) : k2.te && (this.ge = k2);
              } });
              this.arc = function(k2, q2, z2, B2, F2, I2) {
                r2(
                  this.Qd,
                  k2,
                  q2,
                  z2,
                  z2,
                  0,
                  B2,
                  F2,
                  I2
                );
              };
              this.arcTo = function(k2, q2, z2, B2, F2) {
                O2(this.Qd, k2, q2, z2, B2, F2);
              };
              this.beginPath = function() {
                this.Qd.delete();
                this.Qd = new a2.Path();
              };
              this.bezierCurveTo = function(k2, q2, z2, B2, F2, I2) {
                var M2 = this.Qd;
                e3([k2, q2, z2, B2, F2, I2]) && (M2.isEmpty() && M2.moveTo(k2, q2), M2.cubicTo(k2, q2, z2, B2, F2, I2));
              };
              this.clearRect = function(k2, q2, z2, B2) {
                this.Od.setStyle(a2.PaintStyle.Fill);
                this.Od.setBlendMode(a2.BlendMode.Clear);
                this.Ld.drawRect(a2.XYWHRect(k2, q2, z2, B2), this.Od);
                this.Od.setBlendMode(this.Nd);
              };
              this.clip = function(k2, q2) {
                "string" === typeof k2 ? (q2 = k2, k2 = this.Qd) : k2 && k2.af && (k2 = k2.Ud);
                k2 || (k2 = this.Qd);
                k2 = k2.copy();
                q2 && "evenodd" === q2.toLowerCase() ? k2.setFillType(a2.FillType.EvenOdd) : k2.setFillType(a2.FillType.Winding);
                this.Ld.clipPath(k2, a2.ClipOp.Intersect, true);
                k2.delete();
              };
              this.closePath = function() {
                Y2(this.Qd);
              };
              this.createImageData = function() {
                if (1 === arguments.length) {
                  var k2 = arguments[0];
                  return new J2(new Uint8ClampedArray(4 * k2.width * k2.height), k2.width, k2.height);
                }
                if (2 === arguments.length) {
                  k2 = arguments[0];
                  var q2 = arguments[1];
                  return new J2(new Uint8ClampedArray(4 * k2 * q2), k2, q2);
                }
                throw "createImageData expects 1 or 2 arguments, got " + arguments.length;
              };
              this.createLinearGradient = function(k2, q2, z2, B2) {
                if (e3(arguments)) {
                  var F2 = new P2(k2, q2, z2, B2);
                  this.Be.push(F2);
                  return F2;
                }
              };
              this.createPattern = function(k2, q2) {
                k2 = new ca2(k2, q2);
                this.Be.push(k2);
                return k2;
              };
              this.createRadialGradient = function(k2, q2, z2, B2, F2, I2) {
                if (e3(arguments)) {
                  var M2 = new ka(k2, q2, z2, B2, F2, I2);
                  this.Be.push(M2);
                  return M2;
                }
              };
              this.drawImage = function(k2) {
                k2 instanceof C2 && (k2 = k2.tf());
                var q2 = this.Qe();
                if (3 === arguments.length || 5 === arguments.length) var z2 = a2.XYWHRect(
                  arguments[1],
                  arguments[2],
                  arguments[3] || k2.width(),
                  arguments[4] || k2.height()
                ), B2 = a2.XYWHRect(0, 0, k2.width(), k2.height());
                else if (9 === arguments.length) z2 = a2.XYWHRect(arguments[5], arguments[6], arguments[7], arguments[8]), B2 = a2.XYWHRect(arguments[1], arguments[2], arguments[3], arguments[4]);
                else throw "invalid number of args for drawImage, need 3, 5, or 9; got " + arguments.length;
                this.Ld.drawImageRect(k2, B2, z2, q2, false);
                q2.dispose();
              };
              this.ellipse = function(k2, q2, z2, B2, F2, I2, M2, da) {
                r2(this.Qd, k2, q2, z2, B2, F2, I2, M2, da);
              };
              this.Qe = function() {
                var k2 = this.Od.copy();
                k2.setStyle(a2.PaintStyle.Fill);
                if (f2(this.ae)) {
                  var q2 = a2.multiplyByAlpha(this.ae, this.ie);
                  k2.setColor(q2);
                } else q2 = this.ae.te(this.Sd), k2.setColor(a2.Color(0, 0, 0, this.ie)), k2.setShader(q2);
                k2.dispose = function() {
                  this.delete();
                };
                return k2;
              };
              this.fill = function(k2, q2) {
                "string" === typeof k2 ? (q2 = k2, k2 = this.Qd) : k2 && k2.af && (k2 = k2.Ud);
                if ("evenodd" === q2) this.Qd.setFillType(a2.FillType.EvenOdd);
                else {
                  if ("nonzero" !== q2 && q2) throw "invalid fill rule";
                  this.Qd.setFillType(a2.FillType.Winding);
                }
                k2 || (k2 = this.Qd);
                q2 = this.Qe();
                var z2 = this.ye(q2);
                z2 && (this.Ld.save(), this.re(), this.Ld.drawPath(
                  k2,
                  z2
                ), this.Ld.restore(), z2.dispose());
                this.Ld.drawPath(k2, q2);
                q2.dispose();
              };
              this.fillRect = function(k2, q2, z2, B2) {
                var F2 = this.Qe(), I2 = this.ye(F2);
                I2 && (this.Ld.save(), this.re(), this.Ld.drawRect(a2.XYWHRect(k2, q2, z2, B2), I2), this.Ld.restore(), I2.dispose());
                this.Ld.drawRect(a2.XYWHRect(k2, q2, z2, B2), F2);
                F2.dispose();
              };
              this.fillText = function(k2, q2, z2) {
                var B2 = this.Qe();
                k2 = a2.TextBlob.MakeFromText(k2, this.me);
                var F2 = this.ye(B2);
                F2 && (this.Ld.save(), this.re(), this.Ld.drawTextBlob(k2, q2, z2, F2), this.Ld.restore(), F2.dispose());
                this.Ld.drawTextBlob(k2, q2, z2, B2);
                k2.delete();
                B2.dispose();
              };
              this.getImageData = function(k2, q2, z2, B2) {
                return (k2 = this.Ld.readPixels(k2, q2, { width: z2, height: B2, colorType: a2.ColorType.RGBA_8888, alphaType: a2.AlphaType.Unpremul, colorSpace: a2.ColorSpace.SRGB })) ? new J2(new Uint8ClampedArray(k2.buffer), z2, B2) : null;
              };
              this.getLineDash = function() {
                return this.ue.slice();
              };
              this.mf = function(k2) {
                var q2 = a2.Matrix.invert(this.Sd);
                a2.Matrix.mapPoints(q2, k2);
                return k2;
              };
              this.isPointInPath = function(k2, q2, z2) {
                var B2 = arguments;
                if (3 === B2.length) var F2 = this.Qd;
                else if (4 === B2.length) F2 = B2[0], k2 = B2[1], q2 = B2[2], z2 = B2[3];
                else throw "invalid arg count, need 3 or 4, got " + B2.length;
                if (!isFinite(k2) || !isFinite(q2)) return false;
                z2 = z2 || "nonzero";
                if ("nonzero" !== z2 && "evenodd" !== z2) return false;
                B2 = this.mf([k2, q2]);
                k2 = B2[0];
                q2 = B2[1];
                F2.setFillType("nonzero" === z2 ? a2.FillType.Winding : a2.FillType.EvenOdd);
                return F2.contains(k2, q2);
              };
              this.isPointInStroke = function(k2, q2) {
                var z2 = arguments;
                if (2 === z2.length) var B2 = this.Qd;
                else if (3 === z2.length) B2 = z2[0], k2 = z2[1], q2 = z2[2];
                else throw "invalid arg count, need 2 or 3, got " + z2.length;
                if (!isFinite(k2) || !isFinite(q2)) return false;
                z2 = this.mf([k2, q2]);
                k2 = z2[0];
                q2 = z2[1];
                B2 = B2.copy();
                B2.setFillType(a2.FillType.Winding);
                B2.stroke({ width: this.lineWidth, miter_limit: this.miterLimit, cap: this.Od.getStrokeCap(), join: this.Od.getStrokeJoin(), precision: 0.3 });
                z2 = B2.contains(k2, q2);
                B2.delete();
                return z2;
              };
              this.lineTo = function(k2, q2) {
                D2(this.Qd, k2, q2);
              };
              this.measureText = function(k2) {
                k2 = this.me.getGlyphIDs(k2);
                k2 = this.me.getGlyphWidths(k2);
                let q2 = 0;
                for (const z2 of k2) q2 += z2;
                return { width: q2 };
              };
              this.moveTo = function(k2, q2) {
                var z2 = this.Qd;
                e3([k2, q2]) && z2.moveTo(k2, q2);
              };
              this.putImageData = function(k2, q2, z2, B2, F2, I2, M2) {
                if (e3([q2, z2, B2, F2, I2, M2])) {
                  if (void 0 === B2) this.Ld.writePixels(k2.data, k2.width, k2.height, q2, z2);
                  else if (B2 = B2 || 0, F2 = F2 || 0, I2 = I2 || k2.width, M2 = M2 || k2.height, 0 > I2 && (B2 += I2, I2 = Math.abs(I2)), 0 > M2 && (F2 += M2, M2 = Math.abs(M2)), 0 > B2 && (I2 += B2, B2 = 0), 0 > F2 && (M2 += F2, F2 = 0), !(0 >= I2 || 0 >= M2)) {
                    k2 = a2.MakeImage({ width: k2.width, height: k2.height, alphaType: a2.AlphaType.Unpremul, colorType: a2.ColorType.RGBA_8888, colorSpace: a2.ColorSpace.SRGB }, k2.data, 4 * k2.width);
                    var da = a2.XYWHRect(B2, F2, I2, M2);
                    q2 = a2.XYWHRect(q2 + B2, z2 + F2, I2, M2);
                    z2 = a2.Matrix.invert(this.Sd);
                    this.Ld.save();
                    this.Ld.concat(z2);
                    this.Ld.drawImageRect(k2, da, q2, null, false);
                    this.Ld.restore();
                    k2.delete();
                  }
                }
              };
              this.quadraticCurveTo = function(k2, q2, z2, B2) {
                var F2 = this.Qd;
                e3([k2, q2, z2, B2]) && (F2.isEmpty() && F2.moveTo(k2, q2), F2.quadTo(k2, q2, z2, B2));
              };
              this.rect = function(k2, q2, z2, B2) {
                var F2 = this.Qd;
                k2 = a2.XYWHRect(k2, q2, z2, B2);
                e3(k2) && F2.addRect(k2);
              };
              this.resetTransform = function() {
                this.Qd.transform(this.Sd);
                var k2 = a2.Matrix.invert(this.Sd);
                this.Ld.concat(k2);
                this.Sd = this.Ld.getTotalMatrix();
              };
              this.restore = function() {
                var k2 = this.lf.pop();
                if (k2) {
                  var q2 = a2.Matrix.multiply(this.Sd, a2.Matrix.invert(k2.Jf));
                  this.Qd.transform(q2);
                  this.Od.delete();
                  this.Od = k2.ag;
                  this.ue = k2.Zf;
                  this.Ke = k2.mg;
                  this.ge = k2.lg;
                  this.ae = k2.fs;
                  this.we = k2.jg;
                  this.xe = k2.kg;
                  this.ve = k2.sb;
                  this.Je = k2.ig;
                  this.ie = k2.ga;
                  this.Nd = k2.Qf;
                  this.Ie = k2.$f;
                  this.Re = k2.Pf;
                  this.Ld.restore();
                  this.Sd = this.Ld.getTotalMatrix();
                }
              };
              this.rotate = function(k2) {
                if (isFinite(k2)) {
                  var q2 = a2.Matrix.rotated(-k2);
                  this.Qd.transform(q2);
                  this.Ld.rotate(k2 / Math.PI * 180, 0, 0);
                  this.Sd = this.Ld.getTotalMatrix();
                }
              };
              this.save = function() {
                if (this.ae.se) {
                  var k2 = this.ae.se();
                  this.Be.push(k2);
                } else k2 = this.ae;
                if (this.ge.se) {
                  var q2 = this.ge.se();
                  this.Be.push(q2);
                } else q2 = this.ge;
                this.lf.push({ Jf: this.Sd.slice(), Zf: this.ue.slice(), mg: this.Ke, lg: q2, fs: k2, jg: this.we, kg: this.xe, sb: this.ve, ig: this.Je, ga: this.ie, $f: this.Ie, Qf: this.Nd, ag: this.Od.copy(), Pf: this.Re });
                this.Ld.save();
              };
              this.scale = function(k2, q2) {
                if (e3(arguments)) {
                  var z2 = a2.Matrix.scaled(1 / k2, 1 / q2);
                  this.Qd.transform(z2);
                  this.Ld.scale(k2, q2);
                  this.Sd = this.Ld.getTotalMatrix();
                }
              };
              this.setLineDash = function(k2) {
                for (var q2 = 0; q2 < k2.length; q2++) if (!isFinite(k2[q2]) || 0 > k2[q2]) return;
                1 === k2.length % 2 && Array.prototype.push.apply(k2, k2);
                this.ue = k2;
              };
              this.setTransform = function(k2, q2, z2, B2, F2, I2) {
                e3(arguments) && (this.resetTransform(), this.transform(k2, q2, z2, B2, F2, I2));
              };
              this.re = function() {
                var k2 = a2.Matrix.invert(this.Sd);
                this.Ld.concat(k2);
                this.Ld.concat(a2.Matrix.translated(this.we, this.xe));
                this.Ld.concat(this.Sd);
              };
              this.ye = function(k2) {
                var q2 = a2.multiplyByAlpha(this.Je, this.ie);
                if (!a2.getColorComponents(q2)[3] || !(this.ve || this.xe || this.we)) return null;
                k2 = k2.copy();
                k2.setColor(q2);
                var z2 = a2.MaskFilter.MakeBlur(
                  a2.BlurStyle.Normal,
                  this.ve / 2,
                  false
                );
                k2.setMaskFilter(z2);
                k2.dispose = function() {
                  z2.delete();
                  this.delete();
                };
                return k2;
              };
              this.cf = function() {
                var k2 = this.Od.copy();
                k2.setStyle(a2.PaintStyle.Stroke);
                if (f2(this.ge)) {
                  var q2 = a2.multiplyByAlpha(this.ge, this.ie);
                  k2.setColor(q2);
                } else q2 = this.ge.te(this.Sd), k2.setColor(a2.Color(0, 0, 0, this.ie)), k2.setShader(q2);
                k2.setStrokeWidth(this.Ke);
                if (this.ue.length) {
                  var z2 = a2.PathEffect.MakeDash(this.ue, this.Ie);
                  k2.setPathEffect(z2);
                }
                k2.dispose = function() {
                  z2 && z2.delete();
                  this.delete();
                };
                return k2;
              };
              this.stroke = function(k2) {
                k2 = k2 ? k2.Ud : this.Qd;
                var q2 = this.cf(), z2 = this.ye(q2);
                z2 && (this.Ld.save(), this.re(), this.Ld.drawPath(k2, z2), this.Ld.restore(), z2.dispose());
                this.Ld.drawPath(k2, q2);
                q2.dispose();
              };
              this.strokeRect = function(k2, q2, z2, B2) {
                var F2 = this.cf(), I2 = this.ye(F2);
                I2 && (this.Ld.save(), this.re(), this.Ld.drawRect(a2.XYWHRect(k2, q2, z2, B2), I2), this.Ld.restore(), I2.dispose());
                this.Ld.drawRect(a2.XYWHRect(k2, q2, z2, B2), F2);
                F2.dispose();
              };
              this.strokeText = function(k2, q2, z2) {
                var B2 = this.cf();
                k2 = a2.TextBlob.MakeFromText(k2, this.me);
                var F2 = this.ye(B2);
                F2 && (this.Ld.save(), this.re(), this.Ld.drawTextBlob(k2, q2, z2, F2), this.Ld.restore(), F2.dispose());
                this.Ld.drawTextBlob(k2, q2, z2, B2);
                k2.delete();
                B2.dispose();
              };
              this.translate = function(k2, q2) {
                if (e3(arguments)) {
                  var z2 = a2.Matrix.translated(-k2, -q2);
                  this.Qd.transform(z2);
                  this.Ld.translate(k2, q2);
                  this.Sd = this.Ld.getTotalMatrix();
                }
              };
              this.transform = function(k2, q2, z2, B2, F2, I2) {
                k2 = [k2, z2, F2, q2, B2, I2, 0, 0, 1];
                q2 = a2.Matrix.invert(k2);
                this.Qd.transform(q2);
                this.Ld.concat(k2);
                this.Sd = this.Ld.getTotalMatrix();
              };
              this.addHitRegion = function() {
              };
              this.clearHitRegions = function() {
              };
              this.drawFocusIfNeeded = function() {
              };
              this.removeHitRegion = function() {
              };
              this.scrollPathIntoView = function() {
              };
              Object.defineProperty(this, "canvas", { value: null, writable: false });
            }
            function x2(G2) {
              this.df = G2;
              this.Kd = new t2(G2.getCanvas());
              this.Se = [];
              this.decodeImage = function(k2) {
                k2 = a2.MakeImageFromEncoded(k2);
                if (!k2) throw "Invalid input";
                this.Se.push(k2);
                return new C2(k2);
              };
              this.loadFont = function(k2, q2) {
                k2 = a2.Typeface.MakeFreeTypeFaceFromData(k2);
                if (!k2) return null;
                this.Se.push(k2);
                var z2 = (q2.style || "normal") + "|" + (q2.variant || "normal") + "|" + (q2.weight || "normal");
                q2 = q2.family;
                na[q2] || (na[q2] = { "*": k2 });
                na[q2][z2] = k2;
              };
              this.makePath2D = function(k2) {
                k2 = new U2(k2);
                this.Se.push(k2.Ud);
                return k2;
              };
              this.getContext = function(k2) {
                return "2d" === k2 ? this.Kd : null;
              };
              this.toDataURL = function(k2, q2) {
                this.df.flush();
                var z2 = this.df.makeImageSnapshot();
                if (z2) {
                  k2 = k2 || "image/png";
                  var B2 = a2.ImageFormat.PNG;
                  "image/jpeg" === k2 && (B2 = a2.ImageFormat.JPEG);
                  if (q2 = z2.encodeToBytes(B2, q2 || 0.92)) {
                    z2.delete();
                    k2 = "data:" + k2 + ";base64,";
                    if ("undefined" !== typeof Buffer) q2 = Buffer.from(q2).toString("base64");
                    else {
                      z2 = 0;
                      B2 = q2.length;
                      for (var F2 = "", I2; z2 < B2; ) I2 = q2.slice(z2, Math.min(z2 + 32768, B2)), F2 += String.fromCharCode.apply(null, I2), z2 += 32768;
                      q2 = btoa(F2);
                    }
                    return k2 + q2;
                  }
                }
              };
              this.dispose = function() {
                this.Kd.le();
                this.Se.forEach(function(k2) {
                  k2.delete();
                });
                this.df.dispose();
              };
            }
            function C2(G2) {
              this.width = G2.width();
              this.height = G2.height();
              this.naturalWidth = this.width;
              this.naturalHeight = this.height;
              this.tf = function() {
                return G2;
              };
            }
            function J2(G2, k2, q2) {
              if (!k2 || 0 === q2) throw "invalid dimensions, width and height must be non-zero";
              if (G2.length % 4) throw "arr must be a multiple of 4";
              q2 = q2 || G2.length / (4 * k2);
              Object.defineProperty(this, "data", { value: G2, writable: false });
              Object.defineProperty(this, "height", { value: q2, writable: false });
              Object.defineProperty(this, "width", { value: k2, writable: false });
            }
            function P2(G2, k2, q2, z2) {
              this.Wd = null;
              this.ce = [];
              this.Zd = [];
              this.addColorStop = function(B2, F2) {
                if (0 > B2 || 1 < B2 || !isFinite(B2)) throw "offset must be between 0 and 1 inclusively";
                F2 = g2(F2);
                var I2 = this.Zd.indexOf(B2);
                if (-1 !== I2) this.ce[I2] = F2;
                else {
                  for (I2 = 0; I2 < this.Zd.length && !(this.Zd[I2] > B2); I2++) ;
                  this.Zd.splice(I2, 0, B2);
                  this.ce.splice(I2, 0, F2);
                }
              };
              this.se = function() {
                var B2 = new P2(G2, k2, q2, z2);
                B2.ce = this.ce.slice();
                B2.Zd = this.Zd.slice();
                return B2;
              };
              this.le = function() {
                this.Wd && (this.Wd.delete(), this.Wd = null);
              };
              this.te = function(B2) {
                var F2 = [G2, k2, q2, z2];
                a2.Matrix.mapPoints(B2, F2);
                B2 = F2[0];
                var I2 = F2[1], M2 = F2[2];
                F2 = F2[3];
                this.le();
                return this.Wd = a2.Shader.MakeLinearGradient([B2, I2], [M2, F2], this.ce, this.Zd, a2.TileMode.Clamp);
              };
            }
            function O2(G2, k2, q2, z2, B2, F2) {
              if (e3([k2, q2, z2, B2, F2])) {
                if (0 > F2) throw "radii cannot be negative";
                G2.isEmpty() && G2.moveTo(k2, q2);
                G2.arcToTangent(k2, q2, z2, B2, F2);
              }
            }
            function Y2(G2) {
              if (!G2.isEmpty()) {
                var k2 = G2.getBounds();
                (k2[3] - k2[1] || k2[2] - k2[0]) && G2.close();
              }
            }
            function aa(G2, k2, q2, z2, B2, F2, I2) {
              I2 = (I2 - F2) / Math.PI * 180;
              F2 = F2 / Math.PI * 180;
              k2 = a2.LTRBRect(k2 - z2, q2 - B2, k2 + z2, q2 + B2);
              1e-5 > Math.abs(Math.abs(I2) - 360) ? (q2 = I2 / 2, G2.arcToOval(k2, F2, q2, false), G2.arcToOval(k2, F2 + q2, q2, false)) : G2.arcToOval(k2, F2, I2, false);
            }
            function r2(G2, k2, q2, z2, B2, F2, I2, M2, da) {
              if (e3([k2, q2, z2, B2, F2, I2, M2])) {
                if (0 > z2 || 0 > B2) throw "radii cannot be negative";
                var ea = 2 * Math.PI, Ia = I2 % ea;
                0 > Ia && (Ia += ea);
                var ab = Ia - I2;
                I2 = Ia;
                M2 += ab;
                !da && M2 - I2 >= ea ? M2 = I2 + ea : da && I2 - M2 >= ea ? M2 = I2 - ea : !da && I2 > M2 ? M2 = I2 + (ea - (I2 - M2) % ea) : da && I2 < M2 && (M2 = I2 - (ea - (M2 - I2) % ea));
                F2 ? (da = a2.Matrix.rotated(F2, k2, q2), F2 = a2.Matrix.rotated(-F2, k2, q2), G2.transform(F2), aa(G2, k2, q2, z2, B2, I2, M2), G2.transform(da)) : aa(G2, k2, q2, z2, B2, I2, M2);
              }
            }
            function D2(G2, k2, q2) {
              e3([k2, q2]) && (G2.isEmpty() && G2.moveTo(k2, q2), G2.lineTo(k2, q2));
            }
            function U2(G2) {
              this.Ud = null;
              this.Ud = "string" === typeof G2 ? a2.Path.MakeFromSVGString(G2) : G2 && G2.af ? G2.Ud.copy() : new a2.Path();
              this.af = function() {
                return this.Ud;
              };
              this.addPath = function(k2, q2) {
                q2 || (q2 = { a: 1, c: 0, e: 0, b: 0, d: 1, f: 0 });
                this.Ud.addPath(k2.Ud, [q2.a, q2.c, q2.e, q2.b, q2.d, q2.f]);
              };
              this.arc = function(k2, q2, z2, B2, F2, I2) {
                r2(
                  this.Ud,
                  k2,
                  q2,
                  z2,
                  z2,
                  0,
                  B2,
                  F2,
                  I2
                );
              };
              this.arcTo = function(k2, q2, z2, B2, F2) {
                O2(this.Ud, k2, q2, z2, B2, F2);
              };
              this.bezierCurveTo = function(k2, q2, z2, B2, F2, I2) {
                var M2 = this.Ud;
                e3([k2, q2, z2, B2, F2, I2]) && (M2.isEmpty() && M2.moveTo(k2, q2), M2.cubicTo(k2, q2, z2, B2, F2, I2));
              };
              this.closePath = function() {
                Y2(this.Ud);
              };
              this.ellipse = function(k2, q2, z2, B2, F2, I2, M2, da) {
                r2(this.Ud, k2, q2, z2, B2, F2, I2, M2, da);
              };
              this.lineTo = function(k2, q2) {
                D2(this.Ud, k2, q2);
              };
              this.moveTo = function(k2, q2) {
                var z2 = this.Ud;
                e3([k2, q2]) && z2.moveTo(k2, q2);
              };
              this.quadraticCurveTo = function(k2, q2, z2, B2) {
                var F2 = this.Ud;
                e3([k2, q2, z2, B2]) && (F2.isEmpty() && F2.moveTo(k2, q2), F2.quadTo(k2, q2, z2, B2));
              };
              this.rect = function(k2, q2, z2, B2) {
                var F2 = this.Ud;
                k2 = a2.XYWHRect(k2, q2, z2, B2);
                e3(k2) && F2.addRect(k2);
              };
            }
            function ca2(G2, k2) {
              this.Wd = null;
              G2 instanceof C2 && (G2 = G2.tf());
              this.Ef = G2;
              this._transform = a2.Matrix.identity();
              "" === k2 && (k2 = "repeat");
              switch (k2) {
                case "repeat-x":
                  this.ze = a2.TileMode.Repeat;
                  this.Ae = a2.TileMode.Decal;
                  break;
                case "repeat-y":
                  this.ze = a2.TileMode.Decal;
                  this.Ae = a2.TileMode.Repeat;
                  break;
                case "repeat":
                  this.Ae = this.ze = a2.TileMode.Repeat;
                  break;
                case "no-repeat":
                  this.Ae = this.ze = a2.TileMode.Decal;
                  break;
                default:
                  throw "invalid repetition mode " + k2;
              }
              this.setTransform = function(q2) {
                q2 = [q2.a, q2.c, q2.e, q2.b, q2.d, q2.f, 0, 0, 1];
                e3(q2) && (this._transform = q2);
              };
              this.se = function() {
                var q2 = new ca2();
                q2.ze = this.ze;
                q2.Ae = this.Ae;
                return q2;
              };
              this.le = function() {
                this.Wd && (this.Wd.delete(), this.Wd = null);
              };
              this.te = function() {
                this.le();
                return this.Wd = this.Ef.makeShaderCubic(this.ze, this.Ae, 1 / 3, 1 / 3, this._transform);
              };
            }
            function ka(G2, k2, q2, z2, B2, F2) {
              this.Wd = null;
              this.ce = [];
              this.Zd = [];
              this.addColorStop = function(I2, M2) {
                if (0 > I2 || 1 < I2 || !isFinite(I2)) throw "offset must be between 0 and 1 inclusively";
                M2 = g2(M2);
                var da = this.Zd.indexOf(I2);
                if (-1 !== da) this.ce[da] = M2;
                else {
                  for (da = 0; da < this.Zd.length && !(this.Zd[da] > I2); da++) ;
                  this.Zd.splice(da, 0, I2);
                  this.ce.splice(da, 0, M2);
                }
              };
              this.se = function() {
                var I2 = new ka(G2, k2, q2, z2, B2, F2);
                I2.ce = this.ce.slice();
                I2.Zd = this.Zd.slice();
                return I2;
              };
              this.le = function() {
                this.Wd && (this.Wd.delete(), this.Wd = null);
              };
              this.te = function(I2) {
                var M2 = [G2, k2, z2, B2];
                a2.Matrix.mapPoints(I2, M2);
                var da = M2[0], ea = M2[1], Ia = M2[2];
                M2 = M2[3];
                var ab = (Math.abs(I2[0]) + Math.abs(I2[4])) / 2;
                I2 = q2 * ab;
                ab *= F2;
                this.le();
                return this.Wd = a2.Shader.MakeTwoPointConicalGradient([
                  da,
                  ea
                ], I2, [Ia, M2], ab, this.ce, this.Zd, a2.TileMode.Clamp);
              };
            }
            a2._testing = {};
            var va = {
              aliceblue: Float32Array.of(0.941, 0.973, 1, 1),
              antiquewhite: Float32Array.of(0.98, 0.922, 0.843, 1),
              aqua: Float32Array.of(0, 1, 1, 1),
              aquamarine: Float32Array.of(0.498, 1, 0.831, 1),
              azure: Float32Array.of(0.941, 1, 1, 1),
              beige: Float32Array.of(0.961, 0.961, 0.863, 1),
              bisque: Float32Array.of(1, 0.894, 0.769, 1),
              black: Float32Array.of(0, 0, 0, 1),
              blanchedalmond: Float32Array.of(1, 0.922, 0.804, 1),
              blue: Float32Array.of(0, 0, 1, 1),
              blueviolet: Float32Array.of(0.541, 0.169, 0.886, 1),
              brown: Float32Array.of(
                0.647,
                0.165,
                0.165,
                1
              ),
              burlywood: Float32Array.of(0.871, 0.722, 0.529, 1),
              cadetblue: Float32Array.of(0.373, 0.62, 0.627, 1),
              chartreuse: Float32Array.of(0.498, 1, 0, 1),
              chocolate: Float32Array.of(0.824, 0.412, 0.118, 1),
              coral: Float32Array.of(1, 0.498, 0.314, 1),
              cornflowerblue: Float32Array.of(0.392, 0.584, 0.929, 1),
              cornsilk: Float32Array.of(1, 0.973, 0.863, 1),
              crimson: Float32Array.of(0.863, 0.078, 0.235, 1),
              cyan: Float32Array.of(0, 1, 1, 1),
              darkblue: Float32Array.of(0, 0, 0.545, 1),
              darkcyan: Float32Array.of(0, 0.545, 0.545, 1),
              darkgoldenrod: Float32Array.of(
                0.722,
                0.525,
                0.043,
                1
              ),
              darkgray: Float32Array.of(0.663, 0.663, 0.663, 1),
              darkgreen: Float32Array.of(0, 0.392, 0, 1),
              darkgrey: Float32Array.of(0.663, 0.663, 0.663, 1),
              darkkhaki: Float32Array.of(0.741, 0.718, 0.42, 1),
              darkmagenta: Float32Array.of(0.545, 0, 0.545, 1),
              darkolivegreen: Float32Array.of(0.333, 0.42, 0.184, 1),
              darkorange: Float32Array.of(1, 0.549, 0, 1),
              darkorchid: Float32Array.of(0.6, 0.196, 0.8, 1),
              darkred: Float32Array.of(0.545, 0, 0, 1),
              darksalmon: Float32Array.of(0.914, 0.588, 0.478, 1),
              darkseagreen: Float32Array.of(0.561, 0.737, 0.561, 1),
              darkslateblue: Float32Array.of(
                0.282,
                0.239,
                0.545,
                1
              ),
              darkslategray: Float32Array.of(0.184, 0.31, 0.31, 1),
              darkslategrey: Float32Array.of(0.184, 0.31, 0.31, 1),
              darkturquoise: Float32Array.of(0, 0.808, 0.82, 1),
              darkviolet: Float32Array.of(0.58, 0, 0.827, 1),
              deeppink: Float32Array.of(1, 0.078, 0.576, 1),
              deepskyblue: Float32Array.of(0, 0.749, 1, 1),
              dimgray: Float32Array.of(0.412, 0.412, 0.412, 1),
              dimgrey: Float32Array.of(0.412, 0.412, 0.412, 1),
              dodgerblue: Float32Array.of(0.118, 0.565, 1, 1),
              firebrick: Float32Array.of(0.698, 0.133, 0.133, 1),
              floralwhite: Float32Array.of(1, 0.98, 0.941, 1),
              forestgreen: Float32Array.of(
                0.133,
                0.545,
                0.133,
                1
              ),
              fuchsia: Float32Array.of(1, 0, 1, 1),
              gainsboro: Float32Array.of(0.863, 0.863, 0.863, 1),
              ghostwhite: Float32Array.of(0.973, 0.973, 1, 1),
              gold: Float32Array.of(1, 0.843, 0, 1),
              goldenrod: Float32Array.of(0.855, 0.647, 0.125, 1),
              gray: Float32Array.of(0.502, 0.502, 0.502, 1),
              green: Float32Array.of(0, 0.502, 0, 1),
              greenyellow: Float32Array.of(0.678, 1, 0.184, 1),
              grey: Float32Array.of(0.502, 0.502, 0.502, 1),
              honeydew: Float32Array.of(0.941, 1, 0.941, 1),
              hotpink: Float32Array.of(1, 0.412, 0.706, 1),
              indianred: Float32Array.of(0.804, 0.361, 0.361, 1),
              indigo: Float32Array.of(
                0.294,
                0,
                0.51,
                1
              ),
              ivory: Float32Array.of(1, 1, 0.941, 1),
              khaki: Float32Array.of(0.941, 0.902, 0.549, 1),
              lavender: Float32Array.of(0.902, 0.902, 0.98, 1),
              lavenderblush: Float32Array.of(1, 0.941, 0.961, 1),
              lawngreen: Float32Array.of(0.486, 0.988, 0, 1),
              lemonchiffon: Float32Array.of(1, 0.98, 0.804, 1),
              lightblue: Float32Array.of(0.678, 0.847, 0.902, 1),
              lightcoral: Float32Array.of(0.941, 0.502, 0.502, 1),
              lightcyan: Float32Array.of(0.878, 1, 1, 1),
              lightgoldenrodyellow: Float32Array.of(0.98, 0.98, 0.824, 1),
              lightgray: Float32Array.of(0.827, 0.827, 0.827, 1),
              lightgreen: Float32Array.of(
                0.565,
                0.933,
                0.565,
                1
              ),
              lightgrey: Float32Array.of(0.827, 0.827, 0.827, 1),
              lightpink: Float32Array.of(1, 0.714, 0.757, 1),
              lightsalmon: Float32Array.of(1, 0.627, 0.478, 1),
              lightseagreen: Float32Array.of(0.125, 0.698, 0.667, 1),
              lightskyblue: Float32Array.of(0.529, 0.808, 0.98, 1),
              lightslategray: Float32Array.of(0.467, 0.533, 0.6, 1),
              lightslategrey: Float32Array.of(0.467, 0.533, 0.6, 1),
              lightsteelblue: Float32Array.of(0.69, 0.769, 0.871, 1),
              lightyellow: Float32Array.of(1, 1, 0.878, 1),
              lime: Float32Array.of(0, 1, 0, 1),
              limegreen: Float32Array.of(0.196, 0.804, 0.196, 1),
              linen: Float32Array.of(
                0.98,
                0.941,
                0.902,
                1
              ),
              magenta: Float32Array.of(1, 0, 1, 1),
              maroon: Float32Array.of(0.502, 0, 0, 1),
              mediumaquamarine: Float32Array.of(0.4, 0.804, 0.667, 1),
              mediumblue: Float32Array.of(0, 0, 0.804, 1),
              mediumorchid: Float32Array.of(0.729, 0.333, 0.827, 1),
              mediumpurple: Float32Array.of(0.576, 0.439, 0.859, 1),
              mediumseagreen: Float32Array.of(0.235, 0.702, 0.443, 1),
              mediumslateblue: Float32Array.of(0.482, 0.408, 0.933, 1),
              mediumspringgreen: Float32Array.of(0, 0.98, 0.604, 1),
              mediumturquoise: Float32Array.of(0.282, 0.82, 0.8, 1),
              mediumvioletred: Float32Array.of(
                0.78,
                0.082,
                0.522,
                1
              ),
              midnightblue: Float32Array.of(0.098, 0.098, 0.439, 1),
              mintcream: Float32Array.of(0.961, 1, 0.98, 1),
              mistyrose: Float32Array.of(1, 0.894, 0.882, 1),
              moccasin: Float32Array.of(1, 0.894, 0.71, 1),
              navajowhite: Float32Array.of(1, 0.871, 0.678, 1),
              navy: Float32Array.of(0, 0, 0.502, 1),
              oldlace: Float32Array.of(0.992, 0.961, 0.902, 1),
              olive: Float32Array.of(0.502, 0.502, 0, 1),
              olivedrab: Float32Array.of(0.42, 0.557, 0.137, 1),
              orange: Float32Array.of(1, 0.647, 0, 1),
              orangered: Float32Array.of(1, 0.271, 0, 1),
              orchid: Float32Array.of(0.855, 0.439, 0.839, 1),
              palegoldenrod: Float32Array.of(
                0.933,
                0.91,
                0.667,
                1
              ),
              palegreen: Float32Array.of(0.596, 0.984, 0.596, 1),
              paleturquoise: Float32Array.of(0.686, 0.933, 0.933, 1),
              palevioletred: Float32Array.of(0.859, 0.439, 0.576, 1),
              papayawhip: Float32Array.of(1, 0.937, 0.835, 1),
              peachpuff: Float32Array.of(1, 0.855, 0.725, 1),
              peru: Float32Array.of(0.804, 0.522, 0.247, 1),
              pink: Float32Array.of(1, 0.753, 0.796, 1),
              plum: Float32Array.of(0.867, 0.627, 0.867, 1),
              powderblue: Float32Array.of(0.69, 0.878, 0.902, 1),
              purple: Float32Array.of(0.502, 0, 0.502, 1),
              rebeccapurple: Float32Array.of(0.4, 0.2, 0.6, 1),
              red: Float32Array.of(1, 0, 0, 1),
              rosybrown: Float32Array.of(0.737, 0.561, 0.561, 1),
              royalblue: Float32Array.of(0.255, 0.412, 0.882, 1),
              saddlebrown: Float32Array.of(0.545, 0.271, 0.075, 1),
              salmon: Float32Array.of(0.98, 0.502, 0.447, 1),
              sandybrown: Float32Array.of(0.957, 0.643, 0.376, 1),
              seagreen: Float32Array.of(0.18, 0.545, 0.341, 1),
              seashell: Float32Array.of(1, 0.961, 0.933, 1),
              sienna: Float32Array.of(0.627, 0.322, 0.176, 1),
              silver: Float32Array.of(0.753, 0.753, 0.753, 1),
              skyblue: Float32Array.of(0.529, 0.808, 0.922, 1),
              slateblue: Float32Array.of(0.416, 0.353, 0.804, 1),
              slategray: Float32Array.of(
                0.439,
                0.502,
                0.565,
                1
              ),
              slategrey: Float32Array.of(0.439, 0.502, 0.565, 1),
              snow: Float32Array.of(1, 0.98, 0.98, 1),
              springgreen: Float32Array.of(0, 1, 0.498, 1),
              steelblue: Float32Array.of(0.275, 0.51, 0.706, 1),
              tan: Float32Array.of(0.824, 0.706, 0.549, 1),
              teal: Float32Array.of(0, 0.502, 0.502, 1),
              thistle: Float32Array.of(0.847, 0.749, 0.847, 1),
              tomato: Float32Array.of(1, 0.388, 0.278, 1),
              transparent: Float32Array.of(0, 0, 0, 0),
              turquoise: Float32Array.of(0.251, 0.878, 0.816, 1),
              violet: Float32Array.of(0.933, 0.51, 0.933, 1),
              wheat: Float32Array.of(0.961, 0.871, 0.702, 1),
              white: Float32Array.of(
                1,
                1,
                1,
                1
              ),
              whitesmoke: Float32Array.of(0.961, 0.961, 0.961, 1),
              yellow: Float32Array.of(1, 1, 0, 1),
              yellowgreen: Float32Array.of(0.604, 0.804, 0.196, 1)
            };
            a2._testing.parseColor = g2;
            a2._testing.colorToString = d2;
            var wa = RegExp("(italic|oblique|normal|)\\s*(small-caps|normal|)\\s*(bold|bolder|lighter|[1-9]00|normal|)\\s*([\\d\\.]+)(px|pt|pc|in|cm|mm|%|em|ex|ch|rem|q)(.+)"), na = { "Noto Mono": { "*": null }, monospace: { "*": null } };
            a2._testing.parseFontString = l2;
            a2.MakeCanvas = function(G2, k2) {
              return (G2 = a2.MakeSurface(G2, k2)) ? new x2(G2) : null;
            };
            a2.ImageData = function() {
              if (2 === arguments.length) {
                var G2 = arguments[0], k2 = arguments[1];
                return new J2(new Uint8ClampedArray(4 * G2 * k2), G2, k2);
              }
              if (3 === arguments.length) {
                var q2 = arguments[0];
                if (q2.prototype.constructor !== Uint8ClampedArray) throw "bytes must be given as a Uint8ClampedArray";
                G2 = arguments[1];
                k2 = arguments[2];
                if (q2 % 4) throw "bytes must be given in a multiple of 4";
                if (q2 % G2) throw "bytes must divide evenly by width";
                if (k2 && k2 !== q2 / (4 * G2)) throw "invalid height given";
                return new J2(q2, G2, q2 / (4 * G2));
              }
              throw "invalid number of arguments - takes 2 or 3, saw " + arguments.length;
            };
          })();
        })(w2);
        var ta = Object.assign({}, w2), ua = "./this.program", xa = (a2, b2) => {
          throw b2;
        }, ya = "object" == typeof window, za = "function" == typeof importScripts, Aa = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, Ca = "", Da, Ea, Fa;
        if (Aa) {
          var fs3 = __require("fs"), Ga = __require("path");
          Ca = za ? Ga.dirname(Ca) + "/" : __dirname + "/";
          Da = (a2, b2) => {
            a2 = a2.startsWith("file://") ? new URL(a2) : Ga.normalize(a2);
            return fs3.readFileSync(a2, b2 ? void 0 : "utf8");
          };
          Fa = (a2) => {
            a2 = Da(a2, true);
            a2.buffer || (a2 = new Uint8Array(a2));
            return a2;
          };
          Ea = (a2, b2, c2, f2 = true) => {
            a2 = a2.startsWith("file://") ? new URL(a2) : Ga.normalize(a2);
            fs3.readFile(a2, f2 ? void 0 : "utf8", (h2, m2) => {
              h2 ? c2(h2) : b2(f2 ? m2.buffer : m2);
            });
          };
          !w2.thisProgram && 1 < process.argv.length && (ua = process.argv[1].replace(/\\/g, "/"));
          process.argv.slice(2);
          xa = (a2, b2) => {
            process.exitCode = a2;
            throw b2;
          };
          w2.inspect = () => "[Emscripten Module object]";
        } else if (ya || za) za ? Ca = self.location.href : "undefined" != typeof document && document.currentScript && (Ca = document.currentScript.src), _scriptDir && (Ca = _scriptDir), 0 !== Ca.indexOf("blob:") ? Ca = Ca.substr(0, Ca.replace(/[?#].*/, "").lastIndexOf("/") + 1) : Ca = "", Da = (a2) => {
          var b2 = new XMLHttpRequest();
          b2.open("GET", a2, false);
          b2.send(null);
          return b2.responseText;
        }, za && (Fa = (a2) => {
          var b2 = new XMLHttpRequest();
          b2.open("GET", a2, false);
          b2.responseType = "arraybuffer";
          b2.send(null);
          return new Uint8Array(b2.response);
        }), Ea = (a2, b2, c2) => {
          var f2 = new XMLHttpRequest();
          f2.open("GET", a2, true);
          f2.responseType = "arraybuffer";
          f2.onload = () => {
            200 == f2.status || 0 == f2.status && f2.response ? b2(f2.response) : c2();
          };
          f2.onerror = c2;
          f2.send(null);
        };
        var Ha = w2.print || console.log.bind(console), Ja = w2.printErr || console.error.bind(console);
        Object.assign(w2, ta);
        ta = null;
        w2.thisProgram && (ua = w2.thisProgram);
        w2.quit && (xa = w2.quit);
        var Ka;
        w2.wasmBinary && (Ka = w2.wasmBinary);
        var noExitRuntime = w2.noExitRuntime || true;
        "object" != typeof WebAssembly && La("no native wasm support detected");
        var Ma, Q2, Pa = false, Qa, K2, Ra, Sa, R2, Ua, V2, Va;
        function Wa() {
          var a2 = Ma.buffer;
          w2.HEAP8 = Qa = new Int8Array(a2);
          w2.HEAP16 = Ra = new Int16Array(a2);
          w2.HEAP32 = R2 = new Int32Array(a2);
          w2.HEAPU8 = K2 = new Uint8Array(a2);
          w2.HEAPU16 = Sa = new Uint16Array(a2);
          w2.HEAPU32 = Ua = new Uint32Array(a2);
          w2.HEAPF32 = V2 = new Float32Array(a2);
          w2.HEAPF64 = Va = new Float64Array(a2);
        }
        var Xa, Ya = [], Za = [], bb = [];
        function cb() {
          var a2 = w2.preRun.shift();
          Ya.unshift(a2);
        }
        var db = 0, eb = null, fb = null;
        function La(a2) {
          if (w2.onAbort) w2.onAbort(a2);
          a2 = "Aborted(" + a2 + ")";
          Ja(a2);
          Pa = true;
          a2 = new WebAssembly.RuntimeError(a2 + ". Build with -sASSERTIONS for more info.");
          fa(a2);
          throw a2;
        }
        function kb(a2) {
          return a2.startsWith("data:application/octet-stream;base64,");
        }
        var lb;
        lb = "canvaskit.wasm";
        if (!kb(lb)) {
          var mb = lb;
          lb = w2.locateFile ? w2.locateFile(mb, Ca) : Ca + mb;
        }
        function nb(a2) {
          if (a2 == lb && Ka) return new Uint8Array(Ka);
          if (Fa) return Fa(a2);
          throw "both async and sync fetching of the wasm failed";
        }
        function ob(a2) {
          if (!Ka && (ya || za)) {
            if ("function" == typeof fetch && !a2.startsWith("file://")) return fetch(a2, { credentials: "same-origin" }).then((b2) => {
              if (!b2.ok) throw "failed to load wasm binary file at '" + a2 + "'";
              return b2.arrayBuffer();
            }).catch(() => nb(a2));
            if (Ea) return new Promise((b2, c2) => {
              Ea(a2, (f2) => b2(new Uint8Array(f2)), c2);
            });
          }
          return Promise.resolve().then(() => nb(a2));
        }
        function pb(a2, b2, c2) {
          return ob(a2).then((f2) => WebAssembly.instantiate(f2, b2)).then((f2) => f2).then(c2, (f2) => {
            Ja("failed to asynchronously prepare wasm: " + f2);
            La(f2);
          });
        }
        function qb(a2, b2) {
          var c2 = lb;
          return Ka || "function" != typeof WebAssembly.instantiateStreaming || kb(c2) || c2.startsWith("file://") || Aa || "function" != typeof fetch ? pb(c2, a2, b2) : fetch(c2, { credentials: "same-origin" }).then((f2) => WebAssembly.instantiateStreaming(f2, a2).then(b2, function(h2) {
            Ja("wasm streaming compile failed: " + h2);
            Ja("falling back to ArrayBuffer instantiation");
            return pb(c2, a2, b2);
          }));
        }
        function rb(a2) {
          this.name = "ExitStatus";
          this.message = `Program terminated with exit(${a2})`;
          this.status = a2;
        }
        var sb = (a2) => {
          for (; 0 < a2.length; ) a2.shift()(w2);
        }, tb = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, ub = (a2, b2, c2) => {
          var f2 = b2 + c2;
          for (c2 = b2; a2[c2] && !(c2 >= f2); ) ++c2;
          if (16 < c2 - b2 && a2.buffer && tb) return tb.decode(a2.subarray(b2, c2));
          for (f2 = ""; b2 < c2; ) {
            var h2 = a2[b2++];
            if (h2 & 128) {
              var m2 = a2[b2++] & 63;
              if (192 == (h2 & 224)) f2 += String.fromCharCode((h2 & 31) << 6 | m2);
              else {
                var u2 = a2[b2++] & 63;
                h2 = 224 == (h2 & 240) ? (h2 & 15) << 12 | m2 << 6 | u2 : (h2 & 7) << 18 | m2 << 12 | u2 << 6 | a2[b2++] & 63;
                65536 > h2 ? f2 += String.fromCharCode(h2) : (h2 -= 65536, f2 += String.fromCharCode(55296 | h2 >> 10, 56320 | h2 & 1023));
              }
            } else f2 += String.fromCharCode(h2);
          }
          return f2;
        }, vb = {};
        function wb(a2) {
          for (; a2.length; ) {
            var b2 = a2.pop();
            a2.pop()(b2);
          }
        }
        function xb(a2) {
          return this.fromWireType(R2[a2 >> 2]);
        }
        var zb = {}, Ab = {}, Bb = {}, Cb = void 0;
        function Db(a2) {
          throw new Cb(a2);
        }
        function Eb(a2, b2, c2) {
          function f2(n2) {
            n2 = c2(n2);
            n2.length !== a2.length && Db("Mismatched type converter count");
            for (var p2 = 0; p2 < a2.length; ++p2) Fb(a2[p2], n2[p2]);
          }
          a2.forEach(function(n2) {
            Bb[n2] = b2;
          });
          var h2 = Array(b2.length), m2 = [], u2 = 0;
          b2.forEach((n2, p2) => {
            Ab.hasOwnProperty(n2) ? h2[p2] = Ab[n2] : (m2.push(n2), zb.hasOwnProperty(n2) || (zb[n2] = []), zb[n2].push(() => {
              h2[p2] = Ab[n2];
              ++u2;
              u2 === m2.length && f2(h2);
            }));
          });
          0 === m2.length && f2(h2);
        }
        function Gb(a2) {
          switch (a2) {
            case 1:
              return 0;
            case 2:
              return 1;
            case 4:
              return 2;
            case 8:
              return 3;
            default:
              throw new TypeError(`Unknown type size: ${a2}`);
          }
        }
        var Hb = void 0;
        function Ib(a2) {
          for (var b2 = ""; K2[a2]; ) b2 += Hb[K2[a2++]];
          return b2;
        }
        var Jb = void 0;
        function X2(a2) {
          throw new Jb(a2);
        }
        function Kb(a2, b2, c2 = {}) {
          var f2 = b2.name;
          a2 || X2(`type "${f2}" must have a positive integer typeid pointer`);
          if (Ab.hasOwnProperty(a2)) {
            if (c2.Wf) return;
            X2(`Cannot register type '${f2}' twice`);
          }
          Ab[a2] = b2;
          delete Bb[a2];
          zb.hasOwnProperty(a2) && (b2 = zb[a2], delete zb[a2], b2.forEach((h2) => h2()));
        }
        function Fb(a2, b2, c2 = {}) {
          if (!("argPackAdvance" in b2)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
          Kb(a2, b2, c2);
        }
        function Lb(a2) {
          X2(a2.Jd.Vd.Pd.name + " instance already deleted");
        }
        var Mb = false;
        function Nb() {
        }
        function Ob(a2) {
          --a2.count.value;
          0 === a2.count.value && (a2.Yd ? a2.ee.ke(a2.Yd) : a2.Vd.Pd.ke(a2.Rd));
        }
        function Pb(a2, b2, c2) {
          if (b2 === c2) return a2;
          if (void 0 === c2.$d) return null;
          a2 = Pb(a2, b2, c2.$d);
          return null === a2 ? null : c2.Mf(a2);
        }
        var Qb = {}, Rb = [];
        function Sb() {
          for (; Rb.length; ) {
            var a2 = Rb.pop();
            a2.Jd.Ee = false;
            a2["delete"]();
          }
        }
        var Tb = void 0, Ub = {};
        function ac(a2, b2) {
          for (void 0 === b2 && X2("ptr should not be undefined"); a2.$d; ) b2 = a2.Oe(b2), a2 = a2.$d;
          return Ub[b2];
        }
        function bc(a2, b2) {
          b2.Vd && b2.Rd || Db("makeClassHandle requires ptr and ptrType");
          !!b2.ee !== !!b2.Yd && Db("Both smartPtrType and smartPtr must be specified");
          b2.count = { value: 1 };
          return cc(Object.create(a2, { Jd: { value: b2 } }));
        }
        function cc(a2) {
          if ("undefined" === typeof FinalizationRegistry) return cc = (b2) => b2, a2;
          Mb = new FinalizationRegistry((b2) => {
            Ob(b2.Jd);
          });
          cc = (b2) => {
            var c2 = b2.Jd;
            c2.Yd && Mb.register(b2, { Jd: c2 }, b2);
            return b2;
          };
          Nb = (b2) => {
            Mb.unregister(b2);
          };
          return cc(a2);
        }
        function dc() {
        }
        function ec(a2) {
          if (void 0 === a2) return "_unknown";
          a2 = a2.replace(/[^a-zA-Z0-9_]/g, "$");
          var b2 = a2.charCodeAt(0);
          return 48 <= b2 && 57 >= b2 ? `_${a2}` : a2;
        }
        function fc(a2, b2) {
          a2 = ec(a2);
          return { [a2]: function() {
            return b2.apply(this, arguments);
          } }[a2];
        }
        function gc(a2, b2, c2) {
          if (void 0 === a2[b2].Xd) {
            var f2 = a2[b2];
            a2[b2] = function() {
              a2[b2].Xd.hasOwnProperty(arguments.length) || X2(`Function '${c2}' called with an invalid number of arguments (${arguments.length}) - expects one of (${a2[b2].Xd})!`);
              return a2[b2].Xd[arguments.length].apply(this, arguments);
            };
            a2[b2].Xd = [];
            a2[b2].Xd[f2.Ce] = f2;
          }
        }
        function hc(a2, b2, c2) {
          w2.hasOwnProperty(a2) ? ((void 0 === c2 || void 0 !== w2[a2].Xd && void 0 !== w2[a2].Xd[c2]) && X2(`Cannot register public name '${a2}' twice`), gc(w2, a2, a2), w2.hasOwnProperty(c2) && X2(`Cannot register multiple overloads of a function with the same number of arguments (${c2})!`), w2[a2].Xd[c2] = b2) : (w2[a2] = b2, void 0 !== c2 && (w2[a2].tg = c2));
        }
        function ic(a2, b2, c2, f2, h2, m2, u2, n2) {
          this.name = a2;
          this.constructor = b2;
          this.Fe = c2;
          this.ke = f2;
          this.$d = h2;
          this.Rf = m2;
          this.Oe = u2;
          this.Mf = n2;
          this.cg = [];
        }
        function jc(a2, b2, c2) {
          for (; b2 !== c2; ) b2.Oe || X2(`Expected null or instance of ${c2.name}, got an instance of ${b2.name}`), a2 = b2.Oe(a2), b2 = b2.$d;
          return a2;
        }
        function kc(a2, b2) {
          if (null === b2) return this.gf && X2(`null is not a valid ${this.name}`), 0;
          b2.Jd || X2(`Cannot pass "${lc(b2)}" as a ${this.name}`);
          b2.Jd.Rd || X2(`Cannot pass deleted object as a pointer of type ${this.name}`);
          return jc(b2.Jd.Rd, b2.Jd.Vd.Pd, this.Pd);
        }
        function mc(a2, b2) {
          if (null === b2) {
            this.gf && X2(`null is not a valid ${this.name}`);
            if (this.Ve) {
              var c2 = this.hf();
              null !== a2 && a2.push(this.ke, c2);
              return c2;
            }
            return 0;
          }
          b2.Jd || X2(`Cannot pass "${lc(b2)}" as a ${this.name}`);
          b2.Jd.Rd || X2(`Cannot pass deleted object as a pointer of type ${this.name}`);
          !this.Ue && b2.Jd.Vd.Ue && X2(`Cannot convert argument of type ${b2.Jd.ee ? b2.Jd.ee.name : b2.Jd.Vd.name} to parameter type ${this.name}`);
          c2 = jc(b2.Jd.Rd, b2.Jd.Vd.Pd, this.Pd);
          if (this.Ve) switch (void 0 === b2.Jd.Yd && X2("Passing raw pointer to smart pointer is illegal"), this.hg) {
            case 0:
              b2.Jd.ee === this ? c2 = b2.Jd.Yd : X2(`Cannot convert argument of type ${b2.Jd.ee ? b2.Jd.ee.name : b2.Jd.Vd.name} to parameter type ${this.name}`);
              break;
            case 1:
              c2 = b2.Jd.Yd;
              break;
            case 2:
              if (b2.Jd.ee === this) c2 = b2.Jd.Yd;
              else {
                var f2 = b2.clone();
                c2 = this.dg(c2, nc(function() {
                  f2["delete"]();
                }));
                null !== a2 && a2.push(this.ke, c2);
              }
              break;
            default:
              X2("Unsupporting sharing policy");
          }
          return c2;
        }
        function oc(a2, b2) {
          if (null === b2) return this.gf && X2(`null is not a valid ${this.name}`), 0;
          b2.Jd || X2(`Cannot pass "${lc(b2)}" as a ${this.name}`);
          b2.Jd.Rd || X2(`Cannot pass deleted object as a pointer of type ${this.name}`);
          b2.Jd.Vd.Ue && X2(`Cannot convert argument of type ${b2.Jd.Vd.name} to parameter type ${this.name}`);
          return jc(b2.Jd.Rd, b2.Jd.Vd.Pd, this.Pd);
        }
        function pc(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2, E2) {
          this.name = a2;
          this.Pd = b2;
          this.gf = c2;
          this.Ue = f2;
          this.Ve = h2;
          this.bg = m2;
          this.hg = u2;
          this.vf = n2;
          this.hf = p2;
          this.dg = v2;
          this.ke = E2;
          h2 || void 0 !== b2.$d ? this.toWireType = mc : (this.toWireType = f2 ? kc : oc, this.de = null);
        }
        function qc(a2, b2, c2) {
          w2.hasOwnProperty(a2) || Db("Replacing nonexistant public symbol");
          void 0 !== w2[a2].Xd && void 0 !== c2 ? w2[a2].Xd[c2] = b2 : (w2[a2] = b2, w2[a2].Ce = c2);
        }
        var rc = (a2, b2) => {
          var c2 = [];
          return function() {
            c2.length = 0;
            Object.assign(c2, arguments);
            if (a2.includes("j")) {
              var f2 = w2["dynCall_" + a2];
              f2 = c2 && c2.length ? f2.apply(null, [b2].concat(c2)) : f2.call(null, b2);
            } else f2 = Xa.get(b2).apply(null, c2);
            return f2;
          };
        };
        function sc(a2, b2) {
          a2 = Ib(a2);
          var c2 = a2.includes("j") ? rc(a2, b2) : Xa.get(b2);
          "function" != typeof c2 && X2(`unknown function pointer with signature ${a2}: ${b2}`);
          return c2;
        }
        var tc = void 0;
        function uc(a2) {
          a2 = vc(a2);
          var b2 = Ib(a2);
          wc(a2);
          return b2;
        }
        function Dc(a2, b2) {
          function c2(m2) {
            h2[m2] || Ab[m2] || (Bb[m2] ? Bb[m2].forEach(c2) : (f2.push(m2), h2[m2] = true));
          }
          var f2 = [], h2 = {};
          b2.forEach(c2);
          throw new tc(`${a2}: ` + f2.map(uc).join([", "]));
        }
        function Ec(a2, b2, c2, f2, h2) {
          var m2 = b2.length;
          2 > m2 && X2("argTypes array size mismatch! Must at least get return value and 'this' types!");
          var u2 = null !== b2[1] && null !== c2, n2 = false;
          for (c2 = 1; c2 < b2.length; ++c2) if (null !== b2[c2] && void 0 === b2[c2].de) {
            n2 = true;
            break;
          }
          var p2 = "void" !== b2[0].name, v2 = m2 - 2, E2 = Array(v2), H2 = [], L2 = [];
          return function() {
            arguments.length !== v2 && X2(`function ${a2} called with ${arguments.length} arguments, expected ${v2} args!`);
            L2.length = 0;
            H2.length = u2 ? 2 : 1;
            H2[0] = h2;
            if (u2) {
              var y2 = b2[1].toWireType(L2, this);
              H2[1] = y2;
            }
            for (var N2 = 0; N2 < v2; ++N2) E2[N2] = b2[N2 + 2].toWireType(L2, arguments[N2]), H2.push(E2[N2]);
            N2 = f2.apply(null, H2);
            if (n2) wb(L2);
            else for (var T2 = u2 ? 1 : 2; T2 < b2.length; T2++) {
              var S2 = 1 === T2 ? y2 : E2[T2 - 2];
              null !== b2[T2].de && b2[T2].de(S2);
            }
            y2 = p2 ? b2[0].fromWireType(N2) : void 0;
            return y2;
          };
        }
        function Fc(a2, b2) {
          for (var c2 = [], f2 = 0; f2 < a2; f2++) c2.push(Ua[b2 + 4 * f2 >> 2]);
          return c2;
        }
        function Gc() {
          this.je = [void 0];
          this.sf = [];
        }
        var Hc = new Gc();
        function Ic(a2) {
          a2 >= Hc.Ge && 0 === --Hc.get(a2).wf && Hc.Bf(a2);
        }
        var Jc = (a2) => {
          a2 || X2("Cannot use deleted val. handle = " + a2);
          return Hc.get(a2).value;
        }, nc = (a2) => {
          switch (a2) {
            case void 0:
              return 1;
            case null:
              return 2;
            case true:
              return 3;
            case false:
              return 4;
            default:
              return Hc.Af({ wf: 1, value: a2 });
          }
        };
        function Kc(a2, b2, c2) {
          switch (b2) {
            case 0:
              return function(f2) {
                return this.fromWireType((c2 ? Qa : K2)[f2]);
              };
            case 1:
              return function(f2) {
                return this.fromWireType((c2 ? Ra : Sa)[f2 >> 1]);
              };
            case 2:
              return function(f2) {
                return this.fromWireType((c2 ? R2 : Ua)[f2 >> 2]);
              };
            default:
              throw new TypeError("Unknown integer type: " + a2);
          }
        }
        function Lc(a2, b2) {
          var c2 = Ab[a2];
          void 0 === c2 && X2(b2 + " has unknown type " + uc(a2));
          return c2;
        }
        function lc(a2) {
          if (null === a2) return "null";
          var b2 = typeof a2;
          return "object" === b2 || "array" === b2 || "function" === b2 ? a2.toString() : "" + a2;
        }
        function Mc(a2, b2) {
          switch (b2) {
            case 2:
              return function(c2) {
                return this.fromWireType(V2[c2 >> 2]);
              };
            case 3:
              return function(c2) {
                return this.fromWireType(Va[c2 >> 3]);
              };
            default:
              throw new TypeError("Unknown float type: " + a2);
          }
        }
        function Nc(a2, b2, c2) {
          switch (b2) {
            case 0:
              return c2 ? function(f2) {
                return Qa[f2];
              } : function(f2) {
                return K2[f2];
              };
            case 1:
              return c2 ? function(f2) {
                return Ra[f2 >> 1];
              } : function(f2) {
                return Sa[f2 >> 1];
              };
            case 2:
              return c2 ? function(f2) {
                return R2[f2 >> 2];
              } : function(f2) {
                return Ua[f2 >> 2];
              };
            default:
              throw new TypeError("Unknown integer type: " + a2);
          }
        }
        var ra = (a2, b2, c2, f2) => {
          if (!(0 < f2)) return 0;
          var h2 = c2;
          f2 = c2 + f2 - 1;
          for (var m2 = 0; m2 < a2.length; ++m2) {
            var u2 = a2.charCodeAt(m2);
            if (55296 <= u2 && 57343 >= u2) {
              var n2 = a2.charCodeAt(++m2);
              u2 = 65536 + ((u2 & 1023) << 10) | n2 & 1023;
            }
            if (127 >= u2) {
              if (c2 >= f2) break;
              b2[c2++] = u2;
            } else {
              if (2047 >= u2) {
                if (c2 + 1 >= f2) break;
                b2[c2++] = 192 | u2 >> 6;
              } else {
                if (65535 >= u2) {
                  if (c2 + 2 >= f2) break;
                  b2[c2++] = 224 | u2 >> 12;
                } else {
                  if (c2 + 3 >= f2) break;
                  b2[c2++] = 240 | u2 >> 18;
                  b2[c2++] = 128 | u2 >> 12 & 63;
                }
                b2[c2++] = 128 | u2 >> 6 & 63;
              }
              b2[c2++] = 128 | u2 & 63;
            }
          }
          b2[c2] = 0;
          return c2 - h2;
        }, qa = (a2) => {
          for (var b2 = 0, c2 = 0; c2 < a2.length; ++c2) {
            var f2 = a2.charCodeAt(c2);
            127 >= f2 ? b2++ : 2047 >= f2 ? b2 += 2 : 55296 <= f2 && 57343 >= f2 ? (b2 += 4, ++c2) : b2 += 3;
          }
          return b2;
        }, Oc = "undefined" != typeof TextDecoder ? new TextDecoder("utf-16le") : void 0, Pc = (a2, b2) => {
          var c2 = a2 >> 1;
          for (var f2 = c2 + b2 / 2; !(c2 >= f2) && Sa[c2]; ) ++c2;
          c2 <<= 1;
          if (32 < c2 - a2 && Oc) return Oc.decode(K2.subarray(a2, c2));
          c2 = "";
          for (f2 = 0; !(f2 >= b2 / 2); ++f2) {
            var h2 = Ra[a2 + 2 * f2 >> 1];
            if (0 == h2) break;
            c2 += String.fromCharCode(h2);
          }
          return c2;
        }, Qc = (a2, b2, c2) => {
          void 0 === c2 && (c2 = 2147483647);
          if (2 > c2) return 0;
          c2 -= 2;
          var f2 = b2;
          c2 = c2 < 2 * a2.length ? c2 / 2 : a2.length;
          for (var h2 = 0; h2 < c2; ++h2) Ra[b2 >> 1] = a2.charCodeAt(h2), b2 += 2;
          Ra[b2 >> 1] = 0;
          return b2 - f2;
        }, Rc = (a2) => 2 * a2.length, Sc = (a2, b2) => {
          for (var c2 = 0, f2 = ""; !(c2 >= b2 / 4); ) {
            var h2 = R2[a2 + 4 * c2 >> 2];
            if (0 == h2) break;
            ++c2;
            65536 <= h2 ? (h2 -= 65536, f2 += String.fromCharCode(55296 | h2 >> 10, 56320 | h2 & 1023)) : f2 += String.fromCharCode(h2);
          }
          return f2;
        }, Tc = (a2, b2, c2) => {
          void 0 === c2 && (c2 = 2147483647);
          if (4 > c2) return 0;
          var f2 = b2;
          c2 = f2 + c2 - 4;
          for (var h2 = 0; h2 < a2.length; ++h2) {
            var m2 = a2.charCodeAt(h2);
            if (55296 <= m2 && 57343 >= m2) {
              var u2 = a2.charCodeAt(++h2);
              m2 = 65536 + ((m2 & 1023) << 10) | u2 & 1023;
            }
            R2[b2 >> 2] = m2;
            b2 += 4;
            if (b2 + 4 > c2) break;
          }
          R2[b2 >> 2] = 0;
          return b2 - f2;
        }, Uc = (a2) => {
          for (var b2 = 0, c2 = 0; c2 < a2.length; ++c2) {
            var f2 = a2.charCodeAt(c2);
            55296 <= f2 && 57343 >= f2 && ++c2;
            b2 += 4;
          }
          return b2;
        }, Vc = {};
        function Wc(a2) {
          var b2 = Vc[a2];
          return void 0 === b2 ? Ib(a2) : b2;
        }
        var Xc = [];
        function Yc() {
          function a2(b2) {
            b2.$$$embind_global$$$ = b2;
            var c2 = "object" == typeof $$$embind_global$$$ && b2.$$$embind_global$$$ == b2;
            c2 || delete b2.$$$embind_global$$$;
            return c2;
          }
          if ("object" == typeof globalThis) return globalThis;
          if ("object" == typeof $$$embind_global$$$) return $$$embind_global$$$;
          "object" == typeof global && a2(global) ? $$$embind_global$$$ = global : "object" == typeof self && a2(self) && ($$$embind_global$$$ = self);
          if ("object" == typeof $$$embind_global$$$) return $$$embind_global$$$;
          throw Error("unable to get global object.");
        }
        function Zc(a2) {
          var b2 = Xc.length;
          Xc.push(a2);
          return b2;
        }
        function $c(a2, b2) {
          for (var c2 = Array(a2), f2 = 0; f2 < a2; ++f2) c2[f2] = Lc(Ua[b2 + 4 * f2 >> 2], "parameter " + f2);
          return c2;
        }
        var ad = [];
        function bd(a2) {
          var b2 = Array(a2 + 1);
          return function(c2, f2, h2) {
            b2[0] = c2;
            for (var m2 = 0; m2 < a2; ++m2) {
              var u2 = Lc(Ua[f2 + 4 * m2 >> 2], "parameter " + m2);
              b2[m2 + 1] = u2.readValueFromPointer(h2);
              h2 += u2.argPackAdvance;
            }
            c2 = new (c2.bind.apply(c2, b2))();
            return nc(c2);
          };
        }
        var cd = {};
        function dd(a2) {
          var b2 = a2.getExtension("ANGLE_instanced_arrays");
          b2 && (a2.vertexAttribDivisor = function(c2, f2) {
            b2.vertexAttribDivisorANGLE(c2, f2);
          }, a2.drawArraysInstanced = function(c2, f2, h2, m2) {
            b2.drawArraysInstancedANGLE(c2, f2, h2, m2);
          }, a2.drawElementsInstanced = function(c2, f2, h2, m2, u2) {
            b2.drawElementsInstancedANGLE(c2, f2, h2, m2, u2);
          });
        }
        function ed(a2) {
          var b2 = a2.getExtension("OES_vertex_array_object");
          b2 && (a2.createVertexArray = function() {
            return b2.createVertexArrayOES();
          }, a2.deleteVertexArray = function(c2) {
            b2.deleteVertexArrayOES(c2);
          }, a2.bindVertexArray = function(c2) {
            b2.bindVertexArrayOES(c2);
          }, a2.isVertexArray = function(c2) {
            return b2.isVertexArrayOES(c2);
          });
        }
        function fd(a2) {
          var b2 = a2.getExtension("WEBGL_draw_buffers");
          b2 && (a2.drawBuffers = function(c2, f2) {
            b2.drawBuffersWEBGL(c2, f2);
          });
        }
        var gd = 1, hd = [], jd = [], kd = [], ld = [], ia = [], md = [], nd = [], pa = [], od = [], pd = [], qd = {}, rd = {}, sd = 4;
        function td(a2) {
          ud || (ud = a2);
        }
        function ha(a2) {
          for (var b2 = gd++, c2 = a2.length; c2 < b2; c2++) a2[c2] = null;
          return b2;
        }
        function la(a2, b2) {
          a2.Ge || (a2.Ge = a2.getContext, a2.getContext = function(f2, h2) {
            h2 = a2.Ge(f2, h2);
            return "webgl" == f2 == h2 instanceof WebGLRenderingContext ? h2 : null;
          });
          var c2 = 1 < b2.majorVersion ? a2.getContext("webgl2", b2) : a2.getContext("webgl", b2);
          return c2 ? vd(c2, b2) : 0;
        }
        function vd(a2, b2) {
          var c2 = ha(pa), f2 = { handle: c2, attributes: b2, version: b2.majorVersion, fe: a2 };
          a2.canvas && (a2.canvas.zf = f2);
          pa[c2] = f2;
          ("undefined" == typeof b2.Nf || b2.Nf) && yd(f2);
          return c2;
        }
        function oa(a2) {
          A2 = pa[a2];
          w2.rg = Z2 = A2 && A2.fe;
          return !(a2 && !Z2);
        }
        function yd(a2) {
          a2 || (a2 = A2);
          if (!a2.Xf) {
            a2.Xf = true;
            var b2 = a2.fe;
            dd(b2);
            ed(b2);
            fd(b2);
            b2.pf = b2.getExtension("WEBGL_draw_instanced_base_vertex_base_instance");
            b2.uf = b2.getExtension("WEBGL_multi_draw_instanced_base_vertex_base_instance");
            2 <= a2.version && (b2.qf = b2.getExtension("EXT_disjoint_timer_query_webgl2"));
            if (2 > a2.version || !b2.qf) b2.qf = b2.getExtension("EXT_disjoint_timer_query");
            b2.sg = b2.getExtension("WEBGL_multi_draw");
            (b2.getSupportedExtensions() || []).forEach(function(c2) {
              c2.includes("lose_context") || c2.includes("debug") || b2.getExtension(c2);
            });
          }
        }
        var A2, ud, zd = {}, Bd = () => {
          if (!Ad) {
            var a2 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: ua || "./this.program" }, b2;
            for (b2 in zd) void 0 === zd[b2] ? delete a2[b2] : a2[b2] = zd[b2];
            var c2 = [];
            for (b2 in a2) c2.push(`${b2}=${a2[b2]}`);
            Ad = c2;
          }
          return Ad;
        }, Ad, Cd = [null, [], []];
        function Dd(a2) {
          Z2.bindVertexArray(nd[a2]);
        }
        function Ed(a2, b2) {
          for (var c2 = 0; c2 < a2; c2++) {
            var f2 = R2[b2 + 4 * c2 >> 2];
            Z2.deleteVertexArray(nd[f2]);
            nd[f2] = null;
          }
        }
        var Fd = [];
        function Gd(a2, b2, c2, f2) {
          Z2.drawElements(a2, b2, c2, f2);
        }
        function Hd(a2, b2, c2, f2) {
          for (var h2 = 0; h2 < a2; h2++) {
            var m2 = Z2[c2](), u2 = m2 && ha(f2);
            m2 ? (m2.name = u2, f2[u2] = m2) : td(1282);
            R2[b2 + 4 * h2 >> 2] = u2;
          }
        }
        function Id(a2, b2) {
          Hd(a2, b2, "createVertexArray", nd);
        }
        function Jd(a2, b2, c2) {
          if (b2) {
            var f2 = void 0;
            switch (a2) {
              case 36346:
                f2 = 1;
                break;
              case 36344:
                0 != c2 && 1 != c2 && td(1280);
                return;
              case 34814:
              case 36345:
                f2 = 0;
                break;
              case 34466:
                var h2 = Z2.getParameter(34467);
                f2 = h2 ? h2.length : 0;
                break;
              case 33309:
                if (2 > A2.version) {
                  td(1282);
                  return;
                }
                f2 = 2 * (Z2.getSupportedExtensions() || []).length;
                break;
              case 33307:
              case 33308:
                if (2 > A2.version) {
                  td(1280);
                  return;
                }
                f2 = 33307 == a2 ? 3 : 0;
            }
            if (void 0 === f2) switch (h2 = Z2.getParameter(a2), typeof h2) {
              case "number":
                f2 = h2;
                break;
              case "boolean":
                f2 = h2 ? 1 : 0;
                break;
              case "string":
                td(1280);
                return;
              case "object":
                if (null === h2) switch (a2) {
                  case 34964:
                  case 35725:
                  case 34965:
                  case 36006:
                  case 36007:
                  case 32873:
                  case 34229:
                  case 36662:
                  case 36663:
                  case 35053:
                  case 35055:
                  case 36010:
                  case 35097:
                  case 35869:
                  case 32874:
                  case 36389:
                  case 35983:
                  case 35368:
                  case 34068:
                    f2 = 0;
                    break;
                  default:
                    td(1280);
                    return;
                }
                else {
                  if (h2 instanceof Float32Array || h2 instanceof Uint32Array || h2 instanceof Int32Array || h2 instanceof Array) {
                    for (a2 = 0; a2 < h2.length; ++a2) switch (c2) {
                      case 0:
                        R2[b2 + 4 * a2 >> 2] = h2[a2];
                        break;
                      case 2:
                        V2[b2 + 4 * a2 >> 2] = h2[a2];
                        break;
                      case 4:
                        Qa[b2 + a2 >> 0] = h2[a2] ? 1 : 0;
                    }
                    return;
                  }
                  try {
                    f2 = h2.name | 0;
                  } catch (m2) {
                    td(1280);
                    Ja("GL_INVALID_ENUM in glGet" + c2 + "v: Unknown object returned from WebGL getParameter(" + a2 + ")! (error: " + m2 + ")");
                    return;
                  }
                }
                break;
              default:
                td(1280);
                Ja("GL_INVALID_ENUM in glGet" + c2 + "v: Native code calling glGet" + c2 + "v(" + a2 + ") and it returns " + h2 + " of type " + typeof h2 + "!");
                return;
            }
            switch (c2) {
              case 1:
                c2 = f2;
                Ua[b2 >> 2] = c2;
                Ua[b2 + 4 >> 2] = (c2 - Ua[b2 >> 2]) / 4294967296;
                break;
              case 0:
                R2[b2 >> 2] = f2;
                break;
              case 2:
                V2[b2 >> 2] = f2;
                break;
              case 4:
                Qa[b2 >> 0] = f2 ? 1 : 0;
            }
          } else td(1281);
        }
        var Ld = (a2) => {
          var b2 = qa(a2) + 1, c2 = Kd(b2);
          c2 && ra(a2, K2, c2, b2);
          return c2;
        };
        function Md(a2) {
          return "]" == a2.slice(-1) && a2.lastIndexOf("[");
        }
        function Nd(a2) {
          a2 -= 5120;
          return 0 == a2 ? Qa : 1 == a2 ? K2 : 2 == a2 ? Ra : 4 == a2 ? R2 : 6 == a2 ? V2 : 5 == a2 || 28922 == a2 || 28520 == a2 || 30779 == a2 || 30782 == a2 ? Ua : Sa;
        }
        function Od(a2, b2, c2, f2, h2) {
          a2 = Nd(a2);
          var m2 = 31 - Math.clz32(a2.BYTES_PER_ELEMENT), u2 = sd;
          return a2.subarray(h2 >> m2, h2 + f2 * (c2 * ({ 5: 3, 6: 4, 8: 2, 29502: 3, 29504: 4, 26917: 2, 26918: 2, 29846: 3, 29847: 4 }[b2 - 6402] || 1) * (1 << m2) + u2 - 1 & -u2) >> m2);
        }
        function Pd(a2) {
          var b2 = Z2.Kf;
          if (b2) {
            var c2 = b2.Ne[a2];
            "number" == typeof c2 && (b2.Ne[a2] = c2 = Z2.getUniformLocation(b2, b2.xf[a2] + (0 < c2 ? "[" + c2 + "]" : "")));
            return c2;
          }
          td(1282);
        }
        var Qd = [], Rd = [], Sd = (a2) => 0 === a2 % 4 && (0 !== a2 % 100 || 0 === a2 % 400), Td = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Ud = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function Vd(a2) {
          var b2 = Array(qa(a2) + 1);
          ra(a2, b2, 0, b2.length);
          return b2;
        }
        var Wd = (a2, b2, c2, f2) => {
          function h2(y2, N2, T2) {
            for (y2 = "number" == typeof y2 ? y2.toString() : y2 || ""; y2.length < N2; ) y2 = T2[0] + y2;
            return y2;
          }
          function m2(y2, N2) {
            return h2(y2, N2, "0");
          }
          function u2(y2, N2) {
            function T2(sa) {
              return 0 > sa ? -1 : 0 < sa ? 1 : 0;
            }
            var S2;
            0 === (S2 = T2(y2.getFullYear() - N2.getFullYear())) && 0 === (S2 = T2(y2.getMonth() - N2.getMonth())) && (S2 = T2(y2.getDate() - N2.getDate()));
            return S2;
          }
          function n2(y2) {
            switch (y2.getDay()) {
              case 0:
                return new Date(y2.getFullYear() - 1, 11, 29);
              case 1:
                return y2;
              case 2:
                return new Date(y2.getFullYear(), 0, 3);
              case 3:
                return new Date(
                  y2.getFullYear(),
                  0,
                  2
                );
              case 4:
                return new Date(y2.getFullYear(), 0, 1);
              case 5:
                return new Date(y2.getFullYear() - 1, 11, 31);
              case 6:
                return new Date(y2.getFullYear() - 1, 11, 30);
            }
          }
          function p2(y2) {
            var N2 = y2.oe;
            for (y2 = new Date(new Date(y2.pe + 1900, 0, 1).getTime()); 0 < N2; ) {
              var T2 = y2.getMonth(), S2 = (Sd(y2.getFullYear()) ? Td : Ud)[T2];
              if (N2 > S2 - y2.getDate()) N2 -= S2 - y2.getDate() + 1, y2.setDate(1), 11 > T2 ? y2.setMonth(T2 + 1) : (y2.setMonth(0), y2.setFullYear(y2.getFullYear() + 1));
              else {
                y2.setDate(y2.getDate() + N2);
                break;
              }
            }
            T2 = new Date(y2.getFullYear() + 1, 0, 4);
            N2 = n2(new Date(
              y2.getFullYear(),
              0,
              4
            ));
            T2 = n2(T2);
            return 0 >= u2(N2, y2) ? 0 >= u2(T2, y2) ? y2.getFullYear() + 1 : y2.getFullYear() : y2.getFullYear() - 1;
          }
          var v2 = R2[f2 + 40 >> 2];
          f2 = { pg: R2[f2 >> 2], og: R2[f2 + 4 >> 2], Ze: R2[f2 + 8 >> 2], jf: R2[f2 + 12 >> 2], $e: R2[f2 + 16 >> 2], pe: R2[f2 + 20 >> 2], he: R2[f2 + 24 >> 2], oe: R2[f2 + 28 >> 2], vg: R2[f2 + 32 >> 2], ng: R2[f2 + 36 >> 2], qg: v2 ? v2 ? ub(K2, v2) : "" : "" };
          c2 = c2 ? ub(K2, c2) : "";
          v2 = {
            "%c": "%a %b %d %H:%M:%S %Y",
            "%D": "%m/%d/%y",
            "%F": "%Y-%m-%d",
            "%h": "%b",
            "%r": "%I:%M:%S %p",
            "%R": "%H:%M",
            "%T": "%H:%M:%S",
            "%x": "%m/%d/%y",
            "%X": "%H:%M:%S",
            "%Ec": "%c",
            "%EC": "%C",
            "%Ex": "%m/%d/%y",
            "%EX": "%H:%M:%S",
            "%Ey": "%y",
            "%EY": "%Y",
            "%Od": "%d",
            "%Oe": "%e",
            "%OH": "%H",
            "%OI": "%I",
            "%Om": "%m",
            "%OM": "%M",
            "%OS": "%S",
            "%Ou": "%u",
            "%OU": "%U",
            "%OV": "%V",
            "%Ow": "%w",
            "%OW": "%W",
            "%Oy": "%y"
          };
          for (var E2 in v2) c2 = c2.replace(new RegExp(E2, "g"), v2[E2]);
          var H2 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), L2 = "January February March April May June July August September October November December".split(" ");
          v2 = { "%a": (y2) => H2[y2.he].substring(0, 3), "%A": (y2) => H2[y2.he], "%b": (y2) => L2[y2.$e].substring(0, 3), "%B": (y2) => L2[y2.$e], "%C": (y2) => m2((y2.pe + 1900) / 100 | 0, 2), "%d": (y2) => m2(y2.jf, 2), "%e": (y2) => h2(y2.jf, 2, " "), "%g": (y2) => p2(y2).toString().substring(2), "%G": (y2) => p2(y2), "%H": (y2) => m2(y2.Ze, 2), "%I": (y2) => {
            y2 = y2.Ze;
            0 == y2 ? y2 = 12 : 12 < y2 && (y2 -= 12);
            return m2(y2, 2);
          }, "%j": (y2) => {
            for (var N2 = 0, T2 = 0; T2 <= y2.$e - 1; N2 += (Sd(y2.pe + 1900) ? Td : Ud)[T2++]) ;
            return m2(y2.jf + N2, 3);
          }, "%m": (y2) => m2(y2.$e + 1, 2), "%M": (y2) => m2(y2.og, 2), "%n": () => "\n", "%p": (y2) => 0 <= y2.Ze && 12 > y2.Ze ? "AM" : "PM", "%S": (y2) => m2(y2.pg, 2), "%t": () => "	", "%u": (y2) => y2.he || 7, "%U": (y2) => m2(Math.floor((y2.oe + 7 - y2.he) / 7), 2), "%V": (y2) => {
            var N2 = Math.floor((y2.oe + 7 - (y2.he + 6) % 7) / 7);
            2 >= (y2.he + 371 - y2.oe - 2) % 7 && N2++;
            if (N2) 53 == N2 && (T2 = (y2.he + 371 - y2.oe) % 7, 4 == T2 || 3 == T2 && Sd(y2.pe) || (N2 = 1));
            else {
              N2 = 52;
              var T2 = (y2.he + 7 - y2.oe - 1) % 7;
              (4 == T2 || 5 == T2 && Sd(y2.pe % 400 - 1)) && N2++;
            }
            return m2(N2, 2);
          }, "%w": (y2) => y2.he, "%W": (y2) => m2(Math.floor((y2.oe + 7 - (y2.he + 6) % 7) / 7), 2), "%y": (y2) => (y2.pe + 1900).toString().substring(2), "%Y": (y2) => y2.pe + 1900, "%z": (y2) => {
            y2 = y2.ng;
            var N2 = 0 <= y2;
            y2 = Math.abs(y2) / 60;
            return (N2 ? "+" : "-") + String("0000" + (y2 / 60 * 100 + y2 % 60)).slice(-4);
          }, "%Z": (y2) => y2.qg, "%%": () => "%" };
          c2 = c2.replace(/%%/g, "\0\0");
          for (E2 in v2) c2.includes(E2) && (c2 = c2.replace(new RegExp(E2, "g"), v2[E2](f2)));
          c2 = c2.replace(/\0\0/g, "%");
          E2 = Vd(c2);
          if (E2.length > b2) return 0;
          Qa.set(E2, a2);
          return E2.length - 1;
        };
        Cb = w2.InternalError = class extends Error {
          constructor(a2) {
            super(a2);
            this.name = "InternalError";
          }
        };
        for (var Xd = Array(256), Yd = 0; 256 > Yd; ++Yd) Xd[Yd] = String.fromCharCode(Yd);
        Hb = Xd;
        Jb = w2.BindingError = class extends Error {
          constructor(a2) {
            super(a2);
            this.name = "BindingError";
          }
        };
        dc.prototype.isAliasOf = function(a2) {
          if (!(this instanceof dc && a2 instanceof dc)) return false;
          var b2 = this.Jd.Vd.Pd, c2 = this.Jd.Rd, f2 = a2.Jd.Vd.Pd;
          for (a2 = a2.Jd.Rd; b2.$d; ) c2 = b2.Oe(c2), b2 = b2.$d;
          for (; f2.$d; ) a2 = f2.Oe(a2), f2 = f2.$d;
          return b2 === f2 && c2 === a2;
        };
        dc.prototype.clone = function() {
          this.Jd.Rd || Lb(this);
          if (this.Jd.Me) return this.Jd.count.value += 1, this;
          var a2 = cc, b2 = Object, c2 = b2.create, f2 = Object.getPrototypeOf(this), h2 = this.Jd;
          a2 = a2(c2.call(b2, f2, { Jd: { value: { count: h2.count, Ee: h2.Ee, Me: h2.Me, Rd: h2.Rd, Vd: h2.Vd, Yd: h2.Yd, ee: h2.ee } } }));
          a2.Jd.count.value += 1;
          a2.Jd.Ee = false;
          return a2;
        };
        dc.prototype["delete"] = function() {
          this.Jd.Rd || Lb(this);
          this.Jd.Ee && !this.Jd.Me && X2("Object already scheduled for deletion");
          Nb(this);
          Ob(this.Jd);
          this.Jd.Me || (this.Jd.Yd = void 0, this.Jd.Rd = void 0);
        };
        dc.prototype.isDeleted = function() {
          return !this.Jd.Rd;
        };
        dc.prototype.deleteLater = function() {
          this.Jd.Rd || Lb(this);
          this.Jd.Ee && !this.Jd.Me && X2("Object already scheduled for deletion");
          Rb.push(this);
          1 === Rb.length && Tb && Tb(Sb);
          this.Jd.Ee = true;
          return this;
        };
        w2.getInheritedInstanceCount = function() {
          return Object.keys(Ub).length;
        };
        w2.getLiveInheritedInstances = function() {
          var a2 = [], b2;
          for (b2 in Ub) Ub.hasOwnProperty(b2) && a2.push(Ub[b2]);
          return a2;
        };
        w2.flushPendingDeletes = Sb;
        w2.setDelayFunction = function(a2) {
          Tb = a2;
          Rb.length && Tb && Tb(Sb);
        };
        pc.prototype.Sf = function(a2) {
          this.vf && (a2 = this.vf(a2));
          return a2;
        };
        pc.prototype.nf = function(a2) {
          this.ke && this.ke(a2);
        };
        pc.prototype.argPackAdvance = 8;
        pc.prototype.readValueFromPointer = xb;
        pc.prototype.deleteObject = function(a2) {
          if (null !== a2) a2["delete"]();
        };
        pc.prototype.fromWireType = function(a2) {
          function b2() {
            return this.Ve ? bc(this.Pd.Fe, { Vd: this.bg, Rd: c2, ee: this, Yd: a2 }) : bc(this.Pd.Fe, { Vd: this, Rd: a2 });
          }
          var c2 = this.Sf(a2);
          if (!c2) return this.nf(a2), null;
          var f2 = ac(this.Pd, c2);
          if (void 0 !== f2) {
            if (0 === f2.Jd.count.value) return f2.Jd.Rd = c2, f2.Jd.Yd = a2, f2.clone();
            f2 = f2.clone();
            this.nf(a2);
            return f2;
          }
          f2 = this.Pd.Rf(c2);
          f2 = Qb[f2];
          if (!f2) return b2.call(this);
          f2 = this.Ue ? f2.If : f2.pointerType;
          var h2 = Pb(c2, this.Pd, f2.Pd);
          return null === h2 ? b2.call(this) : this.Ve ? bc(f2.Pd.Fe, { Vd: f2, Rd: h2, ee: this, Yd: a2 }) : bc(
            f2.Pd.Fe,
            { Vd: f2, Rd: h2 }
          );
        };
        tc = w2.UnboundTypeError = function(a2, b2) {
          var c2 = fc(b2, function(f2) {
            this.name = b2;
            this.message = f2;
            f2 = Error(f2).stack;
            void 0 !== f2 && (this.stack = this.toString() + "\n" + f2.replace(/^Error(:[^\n]*)?\n/, ""));
          });
          c2.prototype = Object.create(a2.prototype);
          c2.prototype.constructor = c2;
          c2.prototype.toString = function() {
            return void 0 === this.message ? this.name : `${this.name}: ${this.message}`;
          };
          return c2;
        }(Error, "UnboundTypeError");
        Object.assign(Gc.prototype, { get(a2) {
          return this.je[a2];
        }, has(a2) {
          return void 0 !== this.je[a2];
        }, Af(a2) {
          var b2 = this.sf.pop() || this.je.length;
          this.je[b2] = a2;
          return b2;
        }, Bf(a2) {
          this.je[a2] = void 0;
          this.sf.push(a2);
        } });
        Hc.je.push({ value: void 0 }, { value: null }, { value: true }, { value: false });
        Hc.Ge = Hc.je.length;
        w2.count_emval_handles = function() {
          for (var a2 = 0, b2 = Hc.Ge; b2 < Hc.je.length; ++b2) void 0 !== Hc.je[b2] && ++a2;
          return a2;
        };
        for (var Z2, Zd = 0; 32 > Zd; ++Zd) Fd.push(Array(Zd));
        var $d = new Float32Array(288);
        for (Zd = 0; 288 > Zd; ++Zd) Qd[Zd] = $d.subarray(0, Zd + 1);
        var ae2 = new Int32Array(288);
        for (Zd = 0; 288 > Zd; ++Zd) Rd[Zd] = ae2.subarray(0, Zd + 1);
        var qe2 = {
          T: function() {
            return 0;
          },
          Bb: () => {
          },
          Db: function() {
            return 0;
          },
          yb: () => {
          },
          zb: () => {
          },
          U: function() {
          },
          Ab: () => {
          },
          C: function(a2) {
            var b2 = vb[a2];
            delete vb[a2];
            var c2 = b2.hf, f2 = b2.ke, h2 = b2.rf, m2 = h2.map((u2) => u2.Vf).concat(h2.map((u2) => u2.fg));
            Eb([a2], m2, (u2) => {
              var n2 = {};
              h2.forEach((p2, v2) => {
                var E2 = u2[v2], H2 = p2.Tf, L2 = p2.Uf, y2 = u2[v2 + h2.length], N2 = p2.eg, T2 = p2.gg;
                n2[p2.Of] = { read: (S2) => E2.fromWireType(H2(L2, S2)), write: (S2, sa) => {
                  var ma = [];
                  N2(T2, S2, y2.toWireType(ma, sa));
                  wb(ma);
                } };
              });
              return [{ name: b2.name, fromWireType: function(p2) {
                var v2 = {}, E2;
                for (E2 in n2) v2[E2] = n2[E2].read(p2);
                f2(p2);
                return v2;
              }, toWireType: function(p2, v2) {
                for (var E2 in n2) if (!(E2 in v2)) throw new TypeError(`Missing field: "${E2}"`);
                var H2 = c2();
                for (E2 in n2) n2[E2].write(H2, v2[E2]);
                null !== p2 && p2.push(f2, H2);
                return H2;
              }, argPackAdvance: 8, readValueFromPointer: xb, de: f2 }];
            });
          },
          qb: function() {
          },
          Hb: function(a2, b2, c2, f2, h2) {
            var m2 = Gb(c2);
            b2 = Ib(b2);
            Fb(a2, { name: b2, fromWireType: function(u2) {
              return !!u2;
            }, toWireType: function(u2, n2) {
              return n2 ? f2 : h2;
            }, argPackAdvance: 8, readValueFromPointer: function(u2) {
              if (1 === c2) var n2 = Qa;
              else if (2 === c2) n2 = Ra;
              else if (4 === c2) n2 = R2;
              else throw new TypeError("Unknown boolean type size: " + b2);
              return this.fromWireType(n2[u2 >> m2]);
            }, de: null });
          },
          m: function(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2, E2, H2, L2) {
            E2 = Ib(E2);
            m2 = sc(h2, m2);
            n2 && (n2 = sc(u2, n2));
            v2 && (v2 = sc(p2, v2));
            L2 = sc(H2, L2);
            var y2 = ec(E2);
            hc(y2, function() {
              Dc(`Cannot construct ${E2} due to unbound types`, [f2]);
            });
            Eb([a2, b2, c2], f2 ? [f2] : [], function(N2) {
              N2 = N2[0];
              if (f2) {
                var T2 = N2.Pd;
                var S2 = T2.Fe;
              } else S2 = dc.prototype;
              N2 = fc(y2, function() {
                if (Object.getPrototypeOf(this) !== sa) throw new Jb("Use 'new' to construct " + E2);
                if (void 0 === ma.ne) throw new Jb(E2 + " has no accessible constructor");
                var hb = ma.ne[arguments.length];
                if (void 0 === hb) throw new Jb(`Tried to invoke ctor of ${E2} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(ma.ne).toString()}) parameters instead!`);
                return hb.apply(this, arguments);
              });
              var sa = Object.create(S2, { constructor: { value: N2 } });
              N2.prototype = sa;
              var ma = new ic(E2, N2, sa, L2, T2, m2, n2, v2);
              ma.$d && (void 0 === ma.$d.Pe && (ma.$d.Pe = []), ma.$d.Pe.push(ma));
              T2 = new pc(E2, ma, true, false, false);
              S2 = new pc(E2 + "*", ma, false, false, false);
              var gb = new pc(E2 + " const*", ma, false, true, false);
              Qb[a2] = { pointerType: S2, If: gb };
              qc(y2, N2);
              return [
                T2,
                S2,
                gb
              ];
            });
          },
          f: function(a2, b2, c2, f2, h2, m2, u2) {
            var n2 = Fc(c2, f2);
            b2 = Ib(b2);
            m2 = sc(h2, m2);
            Eb([], [a2], function(p2) {
              function v2() {
                Dc(`Cannot call ${E2} due to unbound types`, n2);
              }
              p2 = p2[0];
              var E2 = `${p2.name}.${b2}`;
              b2.startsWith("@@") && (b2 = Symbol[b2.substring(2)]);
              var H2 = p2.Pd.constructor;
              void 0 === H2[b2] ? (v2.Ce = c2 - 1, H2[b2] = v2) : (gc(H2, b2, E2), H2[b2].Xd[c2 - 1] = v2);
              Eb([], n2, function(L2) {
                L2 = [L2[0], null].concat(L2.slice(1));
                L2 = Ec(E2, L2, null, m2, u2);
                void 0 === H2[b2].Xd ? (L2.Ce = c2 - 1, H2[b2] = L2) : H2[b2].Xd[c2 - 1] = L2;
                if (p2.Pd.Pe) for (const y2 of p2.Pd.Pe) y2.constructor.hasOwnProperty(b2) || (y2.constructor[b2] = L2);
                return [];
              });
              return [];
            });
          },
          A: function(a2, b2, c2, f2, h2, m2) {
            var u2 = Fc(b2, c2);
            h2 = sc(f2, h2);
            Eb([], [a2], function(n2) {
              n2 = n2[0];
              var p2 = `constructor ${n2.name}`;
              void 0 === n2.Pd.ne && (n2.Pd.ne = []);
              if (void 0 !== n2.Pd.ne[b2 - 1]) throw new Jb(`Cannot register multiple constructors with identical number of parameters (${b2 - 1}) for class '${n2.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
              n2.Pd.ne[b2 - 1] = () => {
                Dc(`Cannot construct ${n2.name} due to unbound types`, u2);
              };
              Eb([], u2, function(v2) {
                v2.splice(
                  1,
                  0,
                  null
                );
                n2.Pd.ne[b2 - 1] = Ec(p2, v2, null, h2, m2);
                return [];
              });
              return [];
            });
          },
          b: function(a2, b2, c2, f2, h2, m2, u2, n2) {
            var p2 = Fc(c2, f2);
            b2 = Ib(b2);
            m2 = sc(h2, m2);
            Eb([], [a2], function(v2) {
              function E2() {
                Dc(`Cannot call ${H2} due to unbound types`, p2);
              }
              v2 = v2[0];
              var H2 = `${v2.name}.${b2}`;
              b2.startsWith("@@") && (b2 = Symbol[b2.substring(2)]);
              n2 && v2.Pd.cg.push(b2);
              var L2 = v2.Pd.Fe, y2 = L2[b2];
              void 0 === y2 || void 0 === y2.Xd && y2.className !== v2.name && y2.Ce === c2 - 2 ? (E2.Ce = c2 - 2, E2.className = v2.name, L2[b2] = E2) : (gc(L2, b2, H2), L2[b2].Xd[c2 - 2] = E2);
              Eb([], p2, function(N2) {
                N2 = Ec(H2, N2, v2, m2, u2);
                void 0 === L2[b2].Xd ? (N2.Ce = c2 - 2, L2[b2] = N2) : L2[b2].Xd[c2 - 2] = N2;
                return [];
              });
              return [];
            });
          },
          t: function(a2, b2, c2) {
            a2 = Ib(a2);
            Eb([], [b2], function(f2) {
              f2 = f2[0];
              w2[a2] = f2.fromWireType(c2);
              return [];
            });
          },
          Gb: function(a2, b2) {
            b2 = Ib(b2);
            Fb(a2, { name: b2, fromWireType: function(c2) {
              var f2 = Jc(c2);
              Ic(c2);
              return f2;
            }, toWireType: function(c2, f2) {
              return nc(f2);
            }, argPackAdvance: 8, readValueFromPointer: xb, de: null });
          },
          l: function(a2, b2, c2, f2) {
            function h2() {
            }
            c2 = Gb(c2);
            b2 = Ib(b2);
            h2.values = {};
            Fb(a2, {
              name: b2,
              constructor: h2,
              fromWireType: function(m2) {
                return this.constructor.values[m2];
              },
              toWireType: function(m2, u2) {
                return u2.value;
              },
              argPackAdvance: 8,
              readValueFromPointer: Kc(b2, c2, f2),
              de: null
            });
            hc(b2, h2);
          },
          c: function(a2, b2, c2) {
            var f2 = Lc(a2, "enum");
            b2 = Ib(b2);
            a2 = f2.constructor;
            f2 = Object.create(f2.constructor.prototype, { value: { value: c2 }, constructor: { value: fc(`${f2.name}_${b2}`, function() {
            }) } });
            a2.values[c2] = f2;
            a2[b2] = f2;
          },
          W: function(a2, b2, c2) {
            c2 = Gb(c2);
            b2 = Ib(b2);
            Fb(a2, { name: b2, fromWireType: function(f2) {
              return f2;
            }, toWireType: function(f2, h2) {
              return h2;
            }, argPackAdvance: 8, readValueFromPointer: Mc(b2, c2), de: null });
          },
          y: function(a2, b2, c2, f2, h2, m2) {
            var u2 = Fc(b2, c2);
            a2 = Ib(a2);
            h2 = sc(f2, h2);
            hc(a2, function() {
              Dc(
                `Cannot call ${a2} due to unbound types`,
                u2
              );
            }, b2 - 1);
            Eb([], u2, function(n2) {
              n2 = [n2[0], null].concat(n2.slice(1));
              qc(a2, Ec(a2, n2, null, h2, m2), b2 - 1);
              return [];
            });
          },
          E: function(a2, b2, c2, f2, h2) {
            b2 = Ib(b2);
            -1 === h2 && (h2 = 4294967295);
            h2 = Gb(c2);
            var m2 = (n2) => n2;
            if (0 === f2) {
              var u2 = 32 - 8 * c2;
              m2 = (n2) => n2 << u2 >>> u2;
            }
            c2 = b2.includes("unsigned") ? function(n2, p2) {
              return p2 >>> 0;
            } : function(n2, p2) {
              return p2;
            };
            Fb(a2, { name: b2, fromWireType: m2, toWireType: c2, argPackAdvance: 8, readValueFromPointer: Nc(b2, h2, 0 !== f2), de: null });
          },
          s: function(a2, b2, c2) {
            function f2(m2) {
              m2 >>= 2;
              var u2 = Ua;
              return new h2(u2.buffer, u2[m2 + 1], u2[m2]);
            }
            var h2 = [
              Int8Array,
              Uint8Array,
              Int16Array,
              Uint16Array,
              Int32Array,
              Uint32Array,
              Float32Array,
              Float64Array
            ][b2];
            c2 = Ib(c2);
            Fb(a2, { name: c2, fromWireType: f2, argPackAdvance: 8, readValueFromPointer: f2 }, { Wf: true });
          },
          q: function(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2, E2, H2) {
            c2 = Ib(c2);
            m2 = sc(h2, m2);
            n2 = sc(u2, n2);
            v2 = sc(p2, v2);
            H2 = sc(E2, H2);
            Eb([a2], [b2], function(L2) {
              L2 = L2[0];
              return [new pc(c2, L2.Pd, false, false, true, L2, f2, m2, n2, v2, H2)];
            });
          },
          V: function(a2, b2) {
            b2 = Ib(b2);
            var c2 = "std::string" === b2;
            Fb(a2, { name: b2, fromWireType: function(f2) {
              var h2 = Ua[f2 >> 2], m2 = f2 + 4;
              if (c2) for (var u2 = m2, n2 = 0; n2 <= h2; ++n2) {
                var p2 = m2 + n2;
                if (n2 == h2 || 0 == K2[p2]) {
                  u2 = u2 ? ub(
                    K2,
                    u2,
                    p2 - u2
                  ) : "";
                  if (void 0 === v2) var v2 = u2;
                  else v2 += String.fromCharCode(0), v2 += u2;
                  u2 = p2 + 1;
                }
              }
              else {
                v2 = Array(h2);
                for (n2 = 0; n2 < h2; ++n2) v2[n2] = String.fromCharCode(K2[m2 + n2]);
                v2 = v2.join("");
              }
              wc(f2);
              return v2;
            }, toWireType: function(f2, h2) {
              h2 instanceof ArrayBuffer && (h2 = new Uint8Array(h2));
              var m2 = "string" == typeof h2;
              m2 || h2 instanceof Uint8Array || h2 instanceof Uint8ClampedArray || h2 instanceof Int8Array || X2("Cannot pass non-string to std::string");
              var u2 = c2 && m2 ? qa(h2) : h2.length;
              var n2 = Kd(4 + u2 + 1), p2 = n2 + 4;
              Ua[n2 >> 2] = u2;
              if (c2 && m2) ra(h2, K2, p2, u2 + 1);
              else if (m2) for (m2 = 0; m2 < u2; ++m2) {
                var v2 = h2.charCodeAt(m2);
                255 < v2 && (wc(p2), X2("String has UTF-16 code units that do not fit in 8 bits"));
                K2[p2 + m2] = v2;
              }
              else for (m2 = 0; m2 < u2; ++m2) K2[p2 + m2] = h2[m2];
              null !== f2 && f2.push(wc, n2);
              return n2;
            }, argPackAdvance: 8, readValueFromPointer: xb, de: function(f2) {
              wc(f2);
            } });
          },
          N: function(a2, b2, c2) {
            c2 = Ib(c2);
            if (2 === b2) {
              var f2 = Pc;
              var h2 = Qc;
              var m2 = Rc;
              var u2 = () => Sa;
              var n2 = 1;
            } else 4 === b2 && (f2 = Sc, h2 = Tc, m2 = Uc, u2 = () => Ua, n2 = 2);
            Fb(a2, { name: c2, fromWireType: function(p2) {
              for (var v2 = Ua[p2 >> 2], E2 = u2(), H2, L2 = p2 + 4, y2 = 0; y2 <= v2; ++y2) {
                var N2 = p2 + 4 + y2 * b2;
                if (y2 == v2 || 0 == E2[N2 >> n2]) L2 = f2(L2, N2 - L2), void 0 === H2 ? H2 = L2 : (H2 += String.fromCharCode(0), H2 += L2), L2 = N2 + b2;
              }
              wc(p2);
              return H2;
            }, toWireType: function(p2, v2) {
              "string" != typeof v2 && X2(`Cannot pass non-string to C++ string type ${c2}`);
              var E2 = m2(v2), H2 = Kd(4 + E2 + b2);
              Ua[H2 >> 2] = E2 >> n2;
              h2(v2, H2 + 4, E2 + b2);
              null !== p2 && p2.push(wc, H2);
              return H2;
            }, argPackAdvance: 8, readValueFromPointer: xb, de: function(p2) {
              wc(p2);
            } });
          },
          D: function(a2, b2, c2, f2, h2, m2) {
            vb[a2] = { name: Ib(b2), hf: sc(c2, f2), ke: sc(h2, m2), rf: [] };
          },
          e: function(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2) {
            vb[a2].rf.push({ Of: Ib(b2), Vf: c2, Tf: sc(f2, h2), Uf: m2, fg: u2, eg: sc(n2, p2), gg: v2 });
          },
          Ib: function(a2, b2) {
            b2 = Ib(b2);
            Fb(a2, { Yf: true, name: b2, argPackAdvance: 0, fromWireType: function() {
            }, toWireType: function() {
            } });
          },
          Fb: () => true,
          ub: () => {
            throw Infinity;
          },
          F: function(a2, b2, c2) {
            a2 = Jc(a2);
            b2 = Lc(b2, "emval::as");
            var f2 = [], h2 = nc(f2);
            Ua[c2 >> 2] = h2;
            return b2.toWireType(f2, a2);
          },
          Z: function(a2, b2, c2, f2, h2) {
            a2 = Xc[a2];
            b2 = Jc(b2);
            c2 = Wc(c2);
            var m2 = [];
            Ua[f2 >> 2] = nc(m2);
            return a2(b2, c2, m2, h2);
          },
          w: function(a2, b2, c2, f2) {
            a2 = Xc[a2];
            b2 = Jc(b2);
            c2 = Wc(c2);
            a2(b2, c2, null, f2);
          },
          d: Ic,
          K: function(a2) {
            if (0 === a2) return nc(Yc());
            a2 = Wc(a2);
            return nc(Yc()[a2]);
          },
          u: function(a2, b2) {
            var c2 = $c(a2, b2), f2 = c2[0];
            b2 = f2.name + "_$" + c2.slice(1).map(function(u2) {
              return u2.name;
            }).join("_") + "$";
            var h2 = ad[b2];
            if (void 0 !== h2) return h2;
            var m2 = Array(a2 - 1);
            h2 = Zc((u2, n2, p2, v2) => {
              for (var E2 = 0, H2 = 0; H2 < a2 - 1; ++H2) m2[H2] = c2[H2 + 1].readValueFromPointer(v2 + E2), E2 += c2[H2 + 1].argPackAdvance;
              u2 = u2[n2].apply(u2, m2);
              for (H2 = 0; H2 < a2 - 1; ++H2) c2[H2 + 1].Lf && c2[H2 + 1].Lf(m2[H2]);
              if (!f2.Yf) return f2.toWireType(p2, u2);
            });
            return ad[b2] = h2;
          },
          z: function(a2, b2) {
            a2 = Jc(a2);
            b2 = Jc(b2);
            return nc(a2[b2]);
          },
          p: function(a2) {
            4 < a2 && (Hc.get(a2).wf += 1);
          },
          J: function(a2, b2, c2, f2) {
            a2 = Jc(a2);
            var h2 = cd[b2];
            h2 || (h2 = bd(b2), cd[b2] = h2);
            return h2(a2, c2, f2);
          },
          H: function() {
            return nc([]);
          },
          g: function(a2) {
            return nc(Wc(a2));
          },
          G: function() {
            return nc({});
          },
          kb: function(a2) {
            a2 = Jc(a2);
            return !a2;
          },
          B: function(a2) {
            var b2 = Jc(a2);
            wb(b2);
            Ic(a2);
          },
          i: function(a2, b2, c2) {
            a2 = Jc(a2);
            b2 = Jc(b2);
            c2 = Jc(c2);
            a2[b2] = c2;
          },
          h: function(a2, b2) {
            a2 = Lc(a2, "_emval_take_value");
            a2 = a2.readValueFromPointer(b2);
            return nc(a2);
          },
          nb: function() {
            return -52;
          },
          ob: function() {
          },
          a: () => {
            La("");
          },
          Eb: () => performance.now(),
          vb: (a2) => {
            var b2 = K2.length;
            a2 >>>= 0;
            if (2147483648 < a2) return false;
            for (var c2 = 1; 4 >= c2; c2 *= 2) {
              var f2 = b2 * (1 + 0.2 / c2);
              f2 = Math.min(f2, a2 + 100663296);
              var h2 = Math;
              f2 = Math.max(a2, f2);
              a: {
                h2 = h2.min.call(h2, 2147483648, f2 + (65536 - f2 % 65536) % 65536) - Ma.buffer.byteLength + 65535 >>> 16;
                try {
                  Ma.grow(h2);
                  Wa();
                  var m2 = 1;
                  break a;
                } catch (u2) {
                }
                m2 = void 0;
              }
              if (m2) return true;
            }
            return false;
          },
          lb: function() {
            return A2 ? A2.handle : 0;
          },
          wb: (a2, b2) => {
            var c2 = 0;
            Bd().forEach(function(f2, h2) {
              var m2 = b2 + c2;
              h2 = Ua[a2 + 4 * h2 >> 2] = m2;
              for (m2 = 0; m2 < f2.length; ++m2) Qa[h2++ >> 0] = f2.charCodeAt(m2);
              Qa[h2 >> 0] = 0;
              c2 += f2.length + 1;
            });
            return 0;
          },
          xb: (a2, b2) => {
            var c2 = Bd();
            Ua[a2 >> 2] = c2.length;
            var f2 = 0;
            c2.forEach(function(h2) {
              f2 += h2.length + 1;
            });
            Ua[b2 >> 2] = f2;
            return 0;
          },
          Jb: (a2) => {
            if (!noExitRuntime) {
              if (w2.onExit) w2.onExit(a2);
              Pa = true;
            }
            xa(a2, new rb(a2));
          },
          M: () => 52,
          mb: function() {
            return 52;
          },
          Cb: () => 52,
          pb: function() {
            return 70;
          },
          S: (a2, b2, c2, f2) => {
            for (var h2 = 0, m2 = 0; m2 < c2; m2++) {
              var u2 = Ua[b2 >> 2], n2 = Ua[b2 + 4 >> 2];
              b2 += 8;
              for (var p2 = 0; p2 < n2; p2++) {
                var v2 = K2[u2 + p2], E2 = Cd[a2];
                0 === v2 || 10 === v2 ? ((1 === a2 ? Ha : Ja)(ub(E2, 0)), E2.length = 0) : E2.push(v2);
              }
              h2 += n2;
            }
            Ua[f2 >> 2] = h2;
            return 0;
          },
          aa: function(a2) {
            Z2.activeTexture(a2);
          },
          ba: function(a2, b2) {
            Z2.attachShader(jd[a2], md[b2]);
          },
          ca: function(a2, b2, c2) {
            Z2.bindAttribLocation(jd[a2], b2, c2 ? ub(K2, c2) : "");
          },
          da: function(a2, b2) {
            35051 == a2 ? Z2.ef = b2 : 35052 == a2 && (Z2.De = b2);
            Z2.bindBuffer(a2, hd[b2]);
          },
          $: function(a2, b2) {
            Z2.bindFramebuffer(a2, kd[b2]);
          },
          fc: function(a2, b2) {
            Z2.bindRenderbuffer(a2, ld[b2]);
          },
          Rb: function(a2, b2) {
            Z2.bindSampler(a2, od[b2]);
          },
          ea: function(a2, b2) {
            Z2.bindTexture(a2, ia[b2]);
          },
          zc: Dd,
          Cc: Dd,
          fa: function(a2, b2, c2, f2) {
            Z2.blendColor(a2, b2, c2, f2);
          },
          ga: function(a2) {
            Z2.blendEquation(a2);
          },
          ha: function(a2, b2) {
            Z2.blendFunc(a2, b2);
          },
          $b: function(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2) {
            Z2.blitFramebuffer(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2);
          },
          ia: function(a2, b2, c2, f2) {
            2 <= A2.version ? c2 && b2 ? Z2.bufferData(a2, K2, f2, c2, b2) : Z2.bufferData(a2, b2, f2) : Z2.bufferData(a2, c2 ? K2.subarray(c2, c2 + b2) : b2, f2);
          },
          ja: function(a2, b2, c2, f2) {
            2 <= A2.version ? c2 && Z2.bufferSubData(a2, b2, K2, f2, c2) : Z2.bufferSubData(a2, b2, K2.subarray(f2, f2 + c2));
          },
          gc: function(a2) {
            return Z2.checkFramebufferStatus(a2);
          },
          Q: function(a2) {
            Z2.clear(a2);
          },
          _: function(a2, b2, c2, f2) {
            Z2.clearColor(a2, b2, c2, f2);
          },
          R: function(a2) {
            Z2.clearStencil(a2);
          },
          sb: function(a2, b2, c2, f2) {
            return Z2.clientWaitSync(pd[a2], b2, (c2 >>> 0) + 4294967296 * f2);
          },
          ka: function(a2, b2, c2, f2) {
            Z2.colorMask(!!a2, !!b2, !!c2, !!f2);
          },
          la: function(a2) {
            Z2.compileShader(md[a2]);
          },
          ma: function(a2, b2, c2, f2, h2, m2, u2, n2) {
            2 <= A2.version ? Z2.De || !u2 ? Z2.compressedTexImage2D(a2, b2, c2, f2, h2, m2, u2, n2) : Z2.compressedTexImage2D(
              a2,
              b2,
              c2,
              f2,
              h2,
              m2,
              K2,
              n2,
              u2
            ) : Z2.compressedTexImage2D(a2, b2, c2, f2, h2, m2, n2 ? K2.subarray(n2, n2 + u2) : null);
          },
          na: function(a2, b2, c2, f2, h2, m2, u2, n2, p2) {
            2 <= A2.version ? Z2.De || !n2 ? Z2.compressedTexSubImage2D(a2, b2, c2, f2, h2, m2, u2, n2, p2) : Z2.compressedTexSubImage2D(a2, b2, c2, f2, h2, m2, u2, K2, p2, n2) : Z2.compressedTexSubImage2D(a2, b2, c2, f2, h2, m2, u2, p2 ? K2.subarray(p2, p2 + n2) : null);
          },
          Zb: function(a2, b2, c2, f2, h2) {
            Z2.copyBufferSubData(a2, b2, c2, f2, h2);
          },
          oa: function(a2, b2, c2, f2, h2, m2, u2, n2) {
            Z2.copyTexSubImage2D(a2, b2, c2, f2, h2, m2, u2, n2);
          },
          pa: function() {
            var a2 = ha(jd), b2 = Z2.createProgram();
            b2.name = a2;
            b2.Ye = b2.We = b2.Xe = 0;
            b2.kf = 1;
            jd[a2] = b2;
            return a2;
          },
          qa: function(a2) {
            var b2 = ha(md);
            md[b2] = Z2.createShader(a2);
            return b2;
          },
          ra: function(a2) {
            Z2.cullFace(a2);
          },
          sa: function(a2, b2) {
            for (var c2 = 0; c2 < a2; c2++) {
              var f2 = R2[b2 + 4 * c2 >> 2], h2 = hd[f2];
              h2 && (Z2.deleteBuffer(h2), h2.name = 0, hd[f2] = null, f2 == Z2.ef && (Z2.ef = 0), f2 == Z2.De && (Z2.De = 0));
            }
          },
          hc: function(a2, b2) {
            for (var c2 = 0; c2 < a2; ++c2) {
              var f2 = R2[b2 + 4 * c2 >> 2], h2 = kd[f2];
              h2 && (Z2.deleteFramebuffer(h2), h2.name = 0, kd[f2] = null);
            }
          },
          ta: function(a2) {
            if (a2) {
              var b2 = jd[a2];
              b2 ? (Z2.deleteProgram(b2), b2.name = 0, jd[a2] = null) : td(1281);
            }
          },
          ic: function(a2, b2) {
            for (var c2 = 0; c2 < a2; c2++) {
              var f2 = R2[b2 + 4 * c2 >> 2], h2 = ld[f2];
              h2 && (Z2.deleteRenderbuffer(h2), h2.name = 0, ld[f2] = null);
            }
          },
          Sb: function(a2, b2) {
            for (var c2 = 0; c2 < a2; c2++) {
              var f2 = R2[b2 + 4 * c2 >> 2], h2 = od[f2];
              h2 && (Z2.deleteSampler(h2), h2.name = 0, od[f2] = null);
            }
          },
          ua: function(a2) {
            if (a2) {
              var b2 = md[a2];
              b2 ? (Z2.deleteShader(b2), md[a2] = null) : td(1281);
            }
          },
          _b: function(a2) {
            if (a2) {
              var b2 = pd[a2];
              b2 ? (Z2.deleteSync(b2), b2.name = 0, pd[a2] = null) : td(1281);
            }
          },
          va: function(a2, b2) {
            for (var c2 = 0; c2 < a2; c2++) {
              var f2 = R2[b2 + 4 * c2 >> 2], h2 = ia[f2];
              h2 && (Z2.deleteTexture(h2), h2.name = 0, ia[f2] = null);
            }
          },
          Ac: Ed,
          Dc: Ed,
          wa: function(a2) {
            Z2.depthMask(!!a2);
          },
          xa: function(a2) {
            Z2.disable(a2);
          },
          ya: function(a2) {
            Z2.disableVertexAttribArray(a2);
          },
          za: function(a2, b2, c2) {
            Z2.drawArrays(a2, b2, c2);
          },
          xc: function(a2, b2, c2, f2) {
            Z2.drawArraysInstanced(a2, b2, c2, f2);
          },
          vc: function(a2, b2, c2, f2, h2) {
            Z2.pf.drawArraysInstancedBaseInstanceWEBGL(a2, b2, c2, f2, h2);
          },
          tc: function(a2, b2) {
            for (var c2 = Fd[a2], f2 = 0; f2 < a2; f2++) c2[f2] = R2[b2 + 4 * f2 >> 2];
            Z2.drawBuffers(c2);
          },
          Aa: Gd,
          yc: function(a2, b2, c2, f2, h2) {
            Z2.drawElementsInstanced(a2, b2, c2, f2, h2);
          },
          wc: function(a2, b2, c2, f2, h2, m2, u2) {
            Z2.pf.drawElementsInstancedBaseVertexBaseInstanceWEBGL(a2, b2, c2, f2, h2, m2, u2);
          },
          nc: function(a2, b2, c2, f2, h2, m2) {
            Gd(a2, f2, h2, m2);
          },
          Ba: function(a2) {
            Z2.enable(a2);
          },
          Ca: function(a2) {
            Z2.enableVertexAttribArray(a2);
          },
          Xb: function(a2, b2) {
            return (a2 = Z2.fenceSync(a2, b2)) ? (b2 = ha(pd), a2.name = b2, pd[b2] = a2, b2) : 0;
          },
          Da: function() {
            Z2.finish();
          },
          Ea: function() {
            Z2.flush();
          },
          jc: function(a2, b2, c2, f2) {
            Z2.framebufferRenderbuffer(a2, b2, c2, ld[f2]);
          },
          kc: function(a2, b2, c2, f2, h2) {
            Z2.framebufferTexture2D(a2, b2, c2, ia[f2], h2);
          },
          Fa: function(a2) {
            Z2.frontFace(a2);
          },
          Ga: function(a2, b2) {
            Hd(a2, b2, "createBuffer", hd);
          },
          lc: function(a2, b2) {
            Hd(a2, b2, "createFramebuffer", kd);
          },
          mc: function(a2, b2) {
            Hd(a2, b2, "createRenderbuffer", ld);
          },
          Tb: function(a2, b2) {
            Hd(
              a2,
              b2,
              "createSampler",
              od
            );
          },
          Ha: function(a2, b2) {
            Hd(a2, b2, "createTexture", ia);
          },
          Bc: Id,
          Ec: Id,
          bc: function(a2) {
            Z2.generateMipmap(a2);
          },
          Ia: function(a2, b2, c2) {
            c2 ? R2[c2 >> 2] = Z2.getBufferParameter(a2, b2) : td(1281);
          },
          Ja: function() {
            var a2 = Z2.getError() || ud;
            ud = 0;
            return a2;
          },
          Ka: function(a2, b2) {
            Jd(a2, b2, 2);
          },
          cc: function(a2, b2, c2, f2) {
            a2 = Z2.getFramebufferAttachmentParameter(a2, b2, c2);
            if (a2 instanceof WebGLRenderbuffer || a2 instanceof WebGLTexture) a2 = a2.name | 0;
            R2[f2 >> 2] = a2;
          },
          L: function(a2, b2) {
            Jd(a2, b2, 0);
          },
          La: function(a2, b2, c2, f2) {
            a2 = Z2.getProgramInfoLog(jd[a2]);
            null === a2 && (a2 = "(unknown error)");
            b2 = 0 < b2 && f2 ? ra(a2, K2, f2, b2) : 0;
            c2 && (R2[c2 >> 2] = b2);
          },
          Ma: function(a2, b2, c2) {
            if (c2) if (a2 >= gd) td(1281);
            else if (a2 = jd[a2], 35716 == b2) a2 = Z2.getProgramInfoLog(a2), null === a2 && (a2 = "(unknown error)"), R2[c2 >> 2] = a2.length + 1;
            else if (35719 == b2) {
              if (!a2.Ye) for (b2 = 0; b2 < Z2.getProgramParameter(a2, 35718); ++b2) a2.Ye = Math.max(a2.Ye, Z2.getActiveUniform(a2, b2).name.length + 1);
              R2[c2 >> 2] = a2.Ye;
            } else if (35722 == b2) {
              if (!a2.We) for (b2 = 0; b2 < Z2.getProgramParameter(a2, 35721); ++b2) a2.We = Math.max(a2.We, Z2.getActiveAttrib(a2, b2).name.length + 1);
              R2[c2 >> 2] = a2.We;
            } else if (35381 == b2) {
              if (!a2.Xe) for (b2 = 0; b2 < Z2.getProgramParameter(a2, 35382); ++b2) a2.Xe = Math.max(a2.Xe, Z2.getActiveUniformBlockName(a2, b2).length + 1);
              R2[c2 >> 2] = a2.Xe;
            } else R2[c2 >> 2] = Z2.getProgramParameter(a2, b2);
            else td(1281);
          },
          dc: function(a2, b2, c2) {
            c2 ? R2[c2 >> 2] = Z2.getRenderbufferParameter(a2, b2) : td(1281);
          },
          Na: function(a2, b2, c2, f2) {
            a2 = Z2.getShaderInfoLog(md[a2]);
            null === a2 && (a2 = "(unknown error)");
            b2 = 0 < b2 && f2 ? ra(a2, K2, f2, b2) : 0;
            c2 && (R2[c2 >> 2] = b2);
          },
          Ob: function(a2, b2, c2, f2) {
            a2 = Z2.getShaderPrecisionFormat(a2, b2);
            R2[c2 >> 2] = a2.rangeMin;
            R2[c2 + 4 >> 2] = a2.rangeMax;
            R2[f2 >> 2] = a2.precision;
          },
          Oa: function(a2, b2, c2) {
            c2 ? 35716 == b2 ? (a2 = Z2.getShaderInfoLog(md[a2]), null === a2 && (a2 = "(unknown error)"), R2[c2 >> 2] = a2 ? a2.length + 1 : 0) : 35720 == b2 ? (a2 = Z2.getShaderSource(md[a2]), R2[c2 >> 2] = a2 ? a2.length + 1 : 0) : R2[c2 >> 2] = Z2.getShaderParameter(md[a2], b2) : td(1281);
          },
          P: function(a2) {
            var b2 = qd[a2];
            if (!b2) {
              switch (a2) {
                case 7939:
                  b2 = Z2.getSupportedExtensions() || [];
                  b2 = b2.concat(b2.map(function(f2) {
                    return "GL_" + f2;
                  }));
                  b2 = Ld(b2.join(" "));
                  break;
                case 7936:
                case 7937:
                case 37445:
                case 37446:
                  (b2 = Z2.getParameter(a2)) || td(1280);
                  b2 = b2 && Ld(b2);
                  break;
                case 7938:
                  b2 = Z2.getParameter(7938);
                  b2 = 2 <= A2.version ? "OpenGL ES 3.0 (" + b2 + ")" : "OpenGL ES 2.0 (" + b2 + ")";
                  b2 = Ld(b2);
                  break;
                case 35724:
                  b2 = Z2.getParameter(35724);
                  var c2 = b2.match(/^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/);
                  null !== c2 && (3 == c2[1].length && (c2[1] += "0"), b2 = "OpenGL ES GLSL ES " + c2[1] + " (" + b2 + ")");
                  b2 = Ld(b2);
                  break;
                default:
                  td(1280);
              }
              qd[a2] = b2;
            }
            return b2;
          },
          jb: function(a2, b2) {
            if (2 > A2.version) return td(1282), 0;
            var c2 = rd[a2];
            if (c2) return 0 > b2 || b2 >= c2.length ? (td(1281), 0) : c2[b2];
            switch (a2) {
              case 7939:
                return c2 = Z2.getSupportedExtensions() || [], c2 = c2.concat(c2.map(function(f2) {
                  return "GL_" + f2;
                })), c2 = c2.map(function(f2) {
                  return Ld(f2);
                }), c2 = rd[a2] = c2, 0 > b2 || b2 >= c2.length ? (td(1281), 0) : c2[b2];
              default:
                return td(1280), 0;
            }
          },
          Pa: function(a2, b2) {
            b2 = b2 ? ub(K2, b2) : "";
            if (a2 = jd[a2]) {
              var c2 = a2, f2 = c2.Ne, h2 = c2.yf, m2;
              if (!f2) for (c2.Ne = f2 = {}, c2.xf = {}, m2 = 0; m2 < Z2.getProgramParameter(c2, 35718); ++m2) {
                var u2 = Z2.getActiveUniform(c2, m2);
                var n2 = u2.name;
                u2 = u2.size;
                var p2 = Md(n2);
                p2 = 0 < p2 ? n2.slice(0, p2) : n2;
                var v2 = c2.kf;
                c2.kf += u2;
                h2[p2] = [u2, v2];
                for (n2 = 0; n2 < u2; ++n2) f2[v2] = n2, c2.xf[v2++] = p2;
              }
              c2 = a2.Ne;
              f2 = 0;
              h2 = b2;
              m2 = Md(b2);
              0 < m2 && (f2 = parseInt(b2.slice(m2 + 1)) >>> 0, h2 = b2.slice(0, m2));
              if ((h2 = a2.yf[h2]) && f2 < h2[0] && (f2 += h2[1], c2[f2] = c2[f2] || Z2.getUniformLocation(
                a2,
                b2
              ))) return f2;
            } else td(1281);
            return -1;
          },
          Pb: function(a2, b2, c2) {
            for (var f2 = Fd[b2], h2 = 0; h2 < b2; h2++) f2[h2] = R2[c2 + 4 * h2 >> 2];
            Z2.invalidateFramebuffer(a2, f2);
          },
          Qb: function(a2, b2, c2, f2, h2, m2, u2) {
            for (var n2 = Fd[b2], p2 = 0; p2 < b2; p2++) n2[p2] = R2[c2 + 4 * p2 >> 2];
            Z2.invalidateSubFramebuffer(a2, n2, f2, h2, m2, u2);
          },
          Yb: function(a2) {
            return Z2.isSync(pd[a2]);
          },
          Qa: function(a2) {
            return (a2 = ia[a2]) ? Z2.isTexture(a2) : 0;
          },
          Ra: function(a2) {
            Z2.lineWidth(a2);
          },
          Sa: function(a2) {
            a2 = jd[a2];
            Z2.linkProgram(a2);
            a2.Ne = 0;
            a2.yf = {};
          },
          rc: function(a2, b2, c2, f2, h2, m2) {
            Z2.uf.multiDrawArraysInstancedBaseInstanceWEBGL(
              a2,
              R2,
              b2 >> 2,
              R2,
              c2 >> 2,
              R2,
              f2 >> 2,
              Ua,
              h2 >> 2,
              m2
            );
          },
          sc: function(a2, b2, c2, f2, h2, m2, u2, n2) {
            Z2.uf.multiDrawElementsInstancedBaseVertexBaseInstanceWEBGL(a2, R2, b2 >> 2, c2, R2, f2 >> 2, R2, h2 >> 2, R2, m2 >> 2, Ua, u2 >> 2, n2);
          },
          Ta: function(a2, b2) {
            3317 == a2 && (sd = b2);
            Z2.pixelStorei(a2, b2);
          },
          uc: function(a2) {
            Z2.readBuffer(a2);
          },
          Ua: function(a2, b2, c2, f2, h2, m2, u2) {
            if (2 <= A2.version) if (Z2.ef) Z2.readPixels(a2, b2, c2, f2, h2, m2, u2);
            else {
              var n2 = Nd(m2);
              Z2.readPixels(a2, b2, c2, f2, h2, m2, n2, u2 >> 31 - Math.clz32(n2.BYTES_PER_ELEMENT));
            }
            else (u2 = Od(m2, h2, c2, f2, u2)) ? Z2.readPixels(a2, b2, c2, f2, h2, m2, u2) : td(1280);
          },
          ec: function(a2, b2, c2, f2) {
            Z2.renderbufferStorage(
              a2,
              b2,
              c2,
              f2
            );
          },
          ac: function(a2, b2, c2, f2, h2) {
            Z2.renderbufferStorageMultisample(a2, b2, c2, f2, h2);
          },
          Ub: function(a2, b2, c2) {
            Z2.samplerParameterf(od[a2], b2, c2);
          },
          Vb: function(a2, b2, c2) {
            Z2.samplerParameteri(od[a2], b2, c2);
          },
          Wb: function(a2, b2, c2) {
            Z2.samplerParameteri(od[a2], b2, R2[c2 >> 2]);
          },
          Va: function(a2, b2, c2, f2) {
            Z2.scissor(a2, b2, c2, f2);
          },
          Wa: function(a2, b2, c2, f2) {
            for (var h2 = "", m2 = 0; m2 < b2; ++m2) {
              var u2 = f2 ? R2[f2 + 4 * m2 >> 2] : -1, n2 = R2[c2 + 4 * m2 >> 2];
              u2 = n2 ? ub(K2, n2, 0 > u2 ? void 0 : u2) : "";
              h2 += u2;
            }
            Z2.shaderSource(md[a2], h2);
          },
          Xa: function(a2, b2, c2) {
            Z2.stencilFunc(a2, b2, c2);
          },
          Ya: function(a2, b2, c2, f2) {
            Z2.stencilFuncSeparate(
              a2,
              b2,
              c2,
              f2
            );
          },
          Za: function(a2) {
            Z2.stencilMask(a2);
          },
          _a: function(a2, b2) {
            Z2.stencilMaskSeparate(a2, b2);
          },
          $a: function(a2, b2, c2) {
            Z2.stencilOp(a2, b2, c2);
          },
          ab: function(a2, b2, c2, f2) {
            Z2.stencilOpSeparate(a2, b2, c2, f2);
          },
          bb: function(a2, b2, c2, f2, h2, m2, u2, n2, p2) {
            if (2 <= A2.version) if (Z2.De) Z2.texImage2D(a2, b2, c2, f2, h2, m2, u2, n2, p2);
            else if (p2) {
              var v2 = Nd(n2);
              Z2.texImage2D(a2, b2, c2, f2, h2, m2, u2, n2, v2, p2 >> 31 - Math.clz32(v2.BYTES_PER_ELEMENT));
            } else Z2.texImage2D(a2, b2, c2, f2, h2, m2, u2, n2, null);
            else Z2.texImage2D(a2, b2, c2, f2, h2, m2, u2, n2, p2 ? Od(n2, u2, f2, h2, p2) : null);
          },
          cb: function(a2, b2, c2) {
            Z2.texParameterf(a2, b2, c2);
          },
          db: function(a2, b2, c2) {
            Z2.texParameterf(a2, b2, V2[c2 >> 2]);
          },
          eb: function(a2, b2, c2) {
            Z2.texParameteri(a2, b2, c2);
          },
          fb: function(a2, b2, c2) {
            Z2.texParameteri(a2, b2, R2[c2 >> 2]);
          },
          oc: function(a2, b2, c2, f2, h2) {
            Z2.texStorage2D(a2, b2, c2, f2, h2);
          },
          gb: function(a2, b2, c2, f2, h2, m2, u2, n2, p2) {
            if (2 <= A2.version) if (Z2.De) Z2.texSubImage2D(a2, b2, c2, f2, h2, m2, u2, n2, p2);
            else if (p2) {
              var v2 = Nd(n2);
              Z2.texSubImage2D(a2, b2, c2, f2, h2, m2, u2, n2, v2, p2 >> 31 - Math.clz32(v2.BYTES_PER_ELEMENT));
            } else Z2.texSubImage2D(a2, b2, c2, f2, h2, m2, u2, n2, null);
            else v2 = null, p2 && (v2 = Od(n2, u2, h2, m2, p2)), Z2.texSubImage2D(a2, b2, c2, f2, h2, m2, u2, n2, v2);
          },
          hb: function(a2, b2) {
            Z2.uniform1f(
              Pd(a2),
              b2
            );
          },
          ib: function(a2, b2, c2) {
            if (2 <= A2.version) b2 && Z2.uniform1fv(Pd(a2), V2, c2 >> 2, b2);
            else {
              if (288 >= b2) for (var f2 = Qd[b2 - 1], h2 = 0; h2 < b2; ++h2) f2[h2] = V2[c2 + 4 * h2 >> 2];
              else f2 = V2.subarray(c2 >> 2, c2 + 4 * b2 >> 2);
              Z2.uniform1fv(Pd(a2), f2);
            }
          },
          Zc: function(a2, b2) {
            Z2.uniform1i(Pd(a2), b2);
          },
          _c: function(a2, b2, c2) {
            if (2 <= A2.version) b2 && Z2.uniform1iv(Pd(a2), R2, c2 >> 2, b2);
            else {
              if (288 >= b2) for (var f2 = Rd[b2 - 1], h2 = 0; h2 < b2; ++h2) f2[h2] = R2[c2 + 4 * h2 >> 2];
              else f2 = R2.subarray(c2 >> 2, c2 + 4 * b2 >> 2);
              Z2.uniform1iv(Pd(a2), f2);
            }
          },
          $c: function(a2, b2, c2) {
            Z2.uniform2f(Pd(a2), b2, c2);
          },
          ad: function(a2, b2, c2) {
            if (2 <= A2.version) b2 && Z2.uniform2fv(
              Pd(a2),
              V2,
              c2 >> 2,
              2 * b2
            );
            else {
              if (144 >= b2) for (var f2 = Qd[2 * b2 - 1], h2 = 0; h2 < 2 * b2; h2 += 2) f2[h2] = V2[c2 + 4 * h2 >> 2], f2[h2 + 1] = V2[c2 + (4 * h2 + 4) >> 2];
              else f2 = V2.subarray(c2 >> 2, c2 + 8 * b2 >> 2);
              Z2.uniform2fv(Pd(a2), f2);
            }
          },
          Yc: function(a2, b2, c2) {
            Z2.uniform2i(Pd(a2), b2, c2);
          },
          Xc: function(a2, b2, c2) {
            if (2 <= A2.version) b2 && Z2.uniform2iv(Pd(a2), R2, c2 >> 2, 2 * b2);
            else {
              if (144 >= b2) for (var f2 = Rd[2 * b2 - 1], h2 = 0; h2 < 2 * b2; h2 += 2) f2[h2] = R2[c2 + 4 * h2 >> 2], f2[h2 + 1] = R2[c2 + (4 * h2 + 4) >> 2];
              else f2 = R2.subarray(c2 >> 2, c2 + 8 * b2 >> 2);
              Z2.uniform2iv(Pd(a2), f2);
            }
          },
          Wc: function(a2, b2, c2, f2) {
            Z2.uniform3f(Pd(a2), b2, c2, f2);
          },
          Vc: function(a2, b2, c2) {
            if (2 <= A2.version) b2 && Z2.uniform3fv(Pd(a2), V2, c2 >> 2, 3 * b2);
            else {
              if (96 >= b2) for (var f2 = Qd[3 * b2 - 1], h2 = 0; h2 < 3 * b2; h2 += 3) f2[h2] = V2[c2 + 4 * h2 >> 2], f2[h2 + 1] = V2[c2 + (4 * h2 + 4) >> 2], f2[h2 + 2] = V2[c2 + (4 * h2 + 8) >> 2];
              else f2 = V2.subarray(c2 >> 2, c2 + 12 * b2 >> 2);
              Z2.uniform3fv(Pd(a2), f2);
            }
          },
          Uc: function(a2, b2, c2, f2) {
            Z2.uniform3i(Pd(a2), b2, c2, f2);
          },
          Tc: function(a2, b2, c2) {
            if (2 <= A2.version) b2 && Z2.uniform3iv(Pd(a2), R2, c2 >> 2, 3 * b2);
            else {
              if (96 >= b2) for (var f2 = Rd[3 * b2 - 1], h2 = 0; h2 < 3 * b2; h2 += 3) f2[h2] = R2[c2 + 4 * h2 >> 2], f2[h2 + 1] = R2[c2 + (4 * h2 + 4) >> 2], f2[h2 + 2] = R2[c2 + (4 * h2 + 8) >> 2];
              else f2 = R2.subarray(c2 >> 2, c2 + 12 * b2 >> 2);
              Z2.uniform3iv(Pd(a2), f2);
            }
          },
          Sc: function(a2, b2, c2, f2, h2) {
            Z2.uniform4f(Pd(a2), b2, c2, f2, h2);
          },
          Rc: function(a2, b2, c2) {
            if (2 <= A2.version) b2 && Z2.uniform4fv(Pd(a2), V2, c2 >> 2, 4 * b2);
            else {
              if (72 >= b2) {
                var f2 = Qd[4 * b2 - 1], h2 = V2;
                c2 >>= 2;
                for (var m2 = 0; m2 < 4 * b2; m2 += 4) {
                  var u2 = c2 + m2;
                  f2[m2] = h2[u2];
                  f2[m2 + 1] = h2[u2 + 1];
                  f2[m2 + 2] = h2[u2 + 2];
                  f2[m2 + 3] = h2[u2 + 3];
                }
              } else f2 = V2.subarray(c2 >> 2, c2 + 16 * b2 >> 2);
              Z2.uniform4fv(Pd(a2), f2);
            }
          },
          Fc: function(a2, b2, c2, f2, h2) {
            Z2.uniform4i(Pd(a2), b2, c2, f2, h2);
          },
          Gc: function(a2, b2, c2) {
            if (2 <= A2.version) b2 && Z2.uniform4iv(Pd(a2), R2, c2 >> 2, 4 * b2);
            else {
              if (72 >= b2) for (var f2 = Rd[4 * b2 - 1], h2 = 0; h2 < 4 * b2; h2 += 4) f2[h2] = R2[c2 + 4 * h2 >> 2], f2[h2 + 1] = R2[c2 + (4 * h2 + 4) >> 2], f2[h2 + 2] = R2[c2 + (4 * h2 + 8) >> 2], f2[h2 + 3] = R2[c2 + (4 * h2 + 12) >> 2];
              else f2 = R2.subarray(c2 >> 2, c2 + 16 * b2 >> 2);
              Z2.uniform4iv(Pd(a2), f2);
            }
          },
          Hc: function(a2, b2, c2, f2) {
            if (2 <= A2.version) b2 && Z2.uniformMatrix2fv(Pd(a2), !!c2, V2, f2 >> 2, 4 * b2);
            else {
              if (72 >= b2) for (var h2 = Qd[4 * b2 - 1], m2 = 0; m2 < 4 * b2; m2 += 4) h2[m2] = V2[f2 + 4 * m2 >> 2], h2[m2 + 1] = V2[f2 + (4 * m2 + 4) >> 2], h2[m2 + 2] = V2[f2 + (4 * m2 + 8) >> 2], h2[m2 + 3] = V2[f2 + (4 * m2 + 12) >> 2];
              else h2 = V2.subarray(f2 >> 2, f2 + 16 * b2 >> 2);
              Z2.uniformMatrix2fv(Pd(a2), !!c2, h2);
            }
          },
          Ic: function(a2, b2, c2, f2) {
            if (2 <= A2.version) b2 && Z2.uniformMatrix3fv(Pd(a2), !!c2, V2, f2 >> 2, 9 * b2);
            else {
              if (32 >= b2) for (var h2 = Qd[9 * b2 - 1], m2 = 0; m2 < 9 * b2; m2 += 9) h2[m2] = V2[f2 + 4 * m2 >> 2], h2[m2 + 1] = V2[f2 + (4 * m2 + 4) >> 2], h2[m2 + 2] = V2[f2 + (4 * m2 + 8) >> 2], h2[m2 + 3] = V2[f2 + (4 * m2 + 12) >> 2], h2[m2 + 4] = V2[f2 + (4 * m2 + 16) >> 2], h2[m2 + 5] = V2[f2 + (4 * m2 + 20) >> 2], h2[m2 + 6] = V2[f2 + (4 * m2 + 24) >> 2], h2[m2 + 7] = V2[f2 + (4 * m2 + 28) >> 2], h2[m2 + 8] = V2[f2 + (4 * m2 + 32) >> 2];
              else h2 = V2.subarray(f2 >> 2, f2 + 36 * b2 >> 2);
              Z2.uniformMatrix3fv(Pd(a2), !!c2, h2);
            }
          },
          Jc: function(a2, b2, c2, f2) {
            if (2 <= A2.version) b2 && Z2.uniformMatrix4fv(Pd(a2), !!c2, V2, f2 >> 2, 16 * b2);
            else {
              if (18 >= b2) {
                var h2 = Qd[16 * b2 - 1], m2 = V2;
                f2 >>= 2;
                for (var u2 = 0; u2 < 16 * b2; u2 += 16) {
                  var n2 = f2 + u2;
                  h2[u2] = m2[n2];
                  h2[u2 + 1] = m2[n2 + 1];
                  h2[u2 + 2] = m2[n2 + 2];
                  h2[u2 + 3] = m2[n2 + 3];
                  h2[u2 + 4] = m2[n2 + 4];
                  h2[u2 + 5] = m2[n2 + 5];
                  h2[u2 + 6] = m2[n2 + 6];
                  h2[u2 + 7] = m2[n2 + 7];
                  h2[u2 + 8] = m2[n2 + 8];
                  h2[u2 + 9] = m2[n2 + 9];
                  h2[u2 + 10] = m2[n2 + 10];
                  h2[u2 + 11] = m2[n2 + 11];
                  h2[u2 + 12] = m2[n2 + 12];
                  h2[u2 + 13] = m2[n2 + 13];
                  h2[u2 + 14] = m2[n2 + 14];
                  h2[u2 + 15] = m2[n2 + 15];
                }
              } else h2 = V2.subarray(f2 >> 2, f2 + 64 * b2 >> 2);
              Z2.uniformMatrix4fv(Pd(a2), !!c2, h2);
            }
          },
          Kc: function(a2) {
            a2 = jd[a2];
            Z2.useProgram(a2);
            Z2.Kf = a2;
          },
          Lc: function(a2, b2) {
            Z2.vertexAttrib1f(a2, b2);
          },
          Mc: function(a2, b2) {
            Z2.vertexAttrib2f(a2, V2[b2 >> 2], V2[b2 + 4 >> 2]);
          },
          Nc: function(a2, b2) {
            Z2.vertexAttrib3f(a2, V2[b2 >> 2], V2[b2 + 4 >> 2], V2[b2 + 8 >> 2]);
          },
          Oc: function(a2, b2) {
            Z2.vertexAttrib4f(a2, V2[b2 >> 2], V2[b2 + 4 >> 2], V2[b2 + 8 >> 2], V2[b2 + 12 >> 2]);
          },
          pc: function(a2, b2) {
            Z2.vertexAttribDivisor(a2, b2);
          },
          qc: function(a2, b2, c2, f2, h2) {
            Z2.vertexAttribIPointer(a2, b2, c2, f2, h2);
          },
          Pc: function(a2, b2, c2, f2, h2, m2) {
            Z2.vertexAttribPointer(a2, b2, c2, !!f2, h2, m2);
          },
          Qc: function(a2, b2, c2, f2) {
            Z2.viewport(a2, b2, c2, f2);
          },
          rb: function(a2, b2, c2, f2) {
            Z2.waitSync(pd[a2], b2, (c2 >>> 0) + 4294967296 * f2);
          },
          j: be2,
          n: ce2,
          k: de2,
          I: ee2,
          Lb: fe2,
          Y: ge2,
          X: he2,
          O: ie2,
          o: je2,
          x: ke2,
          r: le2,
          v: me2,
          Kb: ne2,
          Mb: oe2,
          Nb: pe2,
          tb: (a2, b2, c2, f2) => Wd(a2, b2, c2, f2)
        };
        (function() {
          function a2(c2) {
            Q2 = c2 = c2.exports;
            Ma = Q2.bd;
            Wa();
            Xa = Q2.dd;
            Za.unshift(Q2.cd);
            db--;
            w2.monitorRunDependencies && w2.monitorRunDependencies(db);
            if (0 == db && (null !== eb && (clearInterval(eb), eb = null), fb)) {
              var f2 = fb;
              fb = null;
              f2();
            }
            return c2;
          }
          var b2 = { a: qe2 };
          db++;
          w2.monitorRunDependencies && w2.monitorRunDependencies(db);
          if (w2.instantiateWasm) try {
            return w2.instantiateWasm(b2, a2);
          } catch (c2) {
            Ja("Module.instantiateWasm callback failed with error: " + c2), fa(c2);
          }
          qb(b2, function(c2) {
            a2(c2.instance);
          }).catch(fa);
          return {};
        })();
        var wc = w2._free = (a2) => (wc = w2._free = Q2.ed)(a2), Kd = w2._malloc = (a2) => (Kd = w2._malloc = Q2.fd)(a2), vc = (a2) => (vc = Q2.gd)(a2);
        w2.__embind_initialize_bindings = () => (w2.__embind_initialize_bindings = Q2.hd)();
        var re2 = (a2, b2) => (re2 = Q2.id)(a2, b2), se2 = () => (se2 = Q2.jd)(), te2 = (a2) => (te2 = Q2.kd)(a2);
        w2.dynCall_viji = (a2, b2, c2, f2, h2) => (w2.dynCall_viji = Q2.ld)(a2, b2, c2, f2, h2);
        w2.dynCall_vijiii = (a2, b2, c2, f2, h2, m2, u2) => (w2.dynCall_vijiii = Q2.md)(a2, b2, c2, f2, h2, m2, u2);
        w2.dynCall_viiiiij = (a2, b2, c2, f2, h2, m2, u2, n2) => (w2.dynCall_viiiiij = Q2.nd)(a2, b2, c2, f2, h2, m2, u2, n2);
        w2.dynCall_jiiiijiiiii = (a2, b2, c2, f2, h2, m2, u2, n2, p2, v2, E2, H2) => (w2.dynCall_jiiiijiiiii = Q2.od)(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2, E2, H2);
        w2.dynCall_viiij = (a2, b2, c2, f2, h2, m2) => (w2.dynCall_viiij = Q2.pd)(a2, b2, c2, f2, h2, m2);
        w2.dynCall_jii = (a2, b2, c2) => (w2.dynCall_jii = Q2.qd)(a2, b2, c2);
        w2.dynCall_vij = (a2, b2, c2, f2) => (w2.dynCall_vij = Q2.rd)(a2, b2, c2, f2);
        w2.dynCall_iiij = (a2, b2, c2, f2, h2) => (w2.dynCall_iiij = Q2.sd)(a2, b2, c2, f2, h2);
        w2.dynCall_iiiij = (a2, b2, c2, f2, h2, m2) => (w2.dynCall_iiiij = Q2.td)(a2, b2, c2, f2, h2, m2);
        w2.dynCall_viij = (a2, b2, c2, f2, h2) => (w2.dynCall_viij = Q2.ud)(a2, b2, c2, f2, h2);
        w2.dynCall_ji = (a2, b2) => (w2.dynCall_ji = Q2.vd)(a2, b2);
        w2.dynCall_iij = (a2, b2, c2, f2) => (w2.dynCall_iij = Q2.wd)(a2, b2, c2, f2);
        w2.dynCall_jiiiiii = (a2, b2, c2, f2, h2, m2, u2) => (w2.dynCall_jiiiiii = Q2.xd)(a2, b2, c2, f2, h2, m2, u2);
        w2.dynCall_jiiiiji = (a2, b2, c2, f2, h2, m2, u2, n2) => (w2.dynCall_jiiiiji = Q2.yd)(a2, b2, c2, f2, h2, m2, u2, n2);
        w2.dynCall_iijj = (a2, b2, c2, f2, h2, m2) => (w2.dynCall_iijj = Q2.zd)(a2, b2, c2, f2, h2, m2);
        w2.dynCall_iiiji = (a2, b2, c2, f2, h2, m2) => (w2.dynCall_iiiji = Q2.Ad)(a2, b2, c2, f2, h2, m2);
        w2.dynCall_iiji = (a2, b2, c2, f2, h2) => (w2.dynCall_iiji = Q2.Bd)(a2, b2, c2, f2, h2);
        w2.dynCall_iijjiii = (a2, b2, c2, f2, h2, m2, u2, n2, p2) => (w2.dynCall_iijjiii = Q2.Cd)(a2, b2, c2, f2, h2, m2, u2, n2, p2);
        w2.dynCall_vijjjii = (a2, b2, c2, f2, h2, m2, u2, n2, p2, v2) => (w2.dynCall_vijjjii = Q2.Dd)(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2);
        w2.dynCall_jiji = (a2, b2, c2, f2, h2) => (w2.dynCall_jiji = Q2.Ed)(a2, b2, c2, f2, h2);
        w2.dynCall_viijii = (a2, b2, c2, f2, h2, m2, u2) => (w2.dynCall_viijii = Q2.Fd)(a2, b2, c2, f2, h2, m2, u2);
        w2.dynCall_iiiiij = (a2, b2, c2, f2, h2, m2, u2) => (w2.dynCall_iiiiij = Q2.Gd)(a2, b2, c2, f2, h2, m2, u2);
        w2.dynCall_iiiiijj = (a2, b2, c2, f2, h2, m2, u2, n2, p2) => (w2.dynCall_iiiiijj = Q2.Hd)(a2, b2, c2, f2, h2, m2, u2, n2, p2);
        w2.dynCall_iiiiiijj = (a2, b2, c2, f2, h2, m2, u2, n2, p2, v2) => (w2.dynCall_iiiiiijj = Q2.Id)(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2);
        function de2(a2, b2, c2, f2) {
          var h2 = se2();
          try {
            return Xa.get(a2)(b2, c2, f2);
          } catch (m2) {
            te2(h2);
            if (m2 !== m2 + 0) throw m2;
            re2(1, 0);
          }
        }
        function be2(a2, b2) {
          var c2 = se2();
          try {
            return Xa.get(a2)(b2);
          } catch (f2) {
            te2(c2);
            if (f2 !== f2 + 0) throw f2;
            re2(1, 0);
          }
        }
        function pe2(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2) {
          var E2 = se2();
          try {
            Xa.get(a2)(b2, c2, f2, h2, m2, u2, n2, p2, v2);
          } catch (H2) {
            te2(E2);
            if (H2 !== H2 + 0) throw H2;
            re2(1, 0);
          }
        }
        function le2(a2, b2, c2, f2) {
          var h2 = se2();
          try {
            Xa.get(a2)(b2, c2, f2);
          } catch (m2) {
            te2(h2);
            if (m2 !== m2 + 0) throw m2;
            re2(1, 0);
          }
        }
        function ke2(a2, b2, c2) {
          var f2 = se2();
          try {
            Xa.get(a2)(b2, c2);
          } catch (h2) {
            te2(f2);
            if (h2 !== h2 + 0) throw h2;
            re2(1, 0);
          }
        }
        function ie2(a2) {
          var b2 = se2();
          try {
            Xa.get(a2)();
          } catch (c2) {
            te2(b2);
            if (c2 !== c2 + 0) throw c2;
            re2(1, 0);
          }
        }
        function me2(a2, b2, c2, f2, h2) {
          var m2 = se2();
          try {
            Xa.get(a2)(b2, c2, f2, h2);
          } catch (u2) {
            te2(m2);
            if (u2 !== u2 + 0) throw u2;
            re2(1, 0);
          }
        }
        function je2(a2, b2) {
          var c2 = se2();
          try {
            Xa.get(a2)(b2);
          } catch (f2) {
            te2(c2);
            if (f2 !== f2 + 0) throw f2;
            re2(1, 0);
          }
        }
        function ce2(a2, b2, c2) {
          var f2 = se2();
          try {
            return Xa.get(a2)(b2, c2);
          } catch (h2) {
            te2(f2);
            if (h2 !== h2 + 0) throw h2;
            re2(1, 0);
          }
        }
        function oe2(a2, b2, c2, f2, h2, m2, u2) {
          var n2 = se2();
          try {
            Xa.get(a2)(b2, c2, f2, h2, m2, u2);
          } catch (p2) {
            te2(n2);
            if (p2 !== p2 + 0) throw p2;
            re2(1, 0);
          }
        }
        function ee2(a2, b2, c2, f2, h2) {
          var m2 = se2();
          try {
            return Xa.get(a2)(b2, c2, f2, h2);
          } catch (u2) {
            te2(m2);
            if (u2 !== u2 + 0) throw u2;
            re2(1, 0);
          }
        }
        function fe2(a2, b2, c2, f2, h2, m2) {
          var u2 = se2();
          try {
            return Xa.get(a2)(b2, c2, f2, h2, m2);
          } catch (n2) {
            te2(u2);
            if (n2 !== n2 + 0) throw n2;
            re2(1, 0);
          }
        }
        function ge2(a2, b2, c2, f2, h2, m2, u2) {
          var n2 = se2();
          try {
            return Xa.get(a2)(b2, c2, f2, h2, m2, u2);
          } catch (p2) {
            te2(n2);
            if (p2 !== p2 + 0) throw p2;
            re2(1, 0);
          }
        }
        function ne2(a2, b2, c2, f2, h2, m2) {
          var u2 = se2();
          try {
            Xa.get(a2)(b2, c2, f2, h2, m2);
          } catch (n2) {
            te2(u2);
            if (n2 !== n2 + 0) throw n2;
            re2(1, 0);
          }
        }
        function he2(a2, b2, c2, f2, h2, m2, u2, n2, p2, v2) {
          var E2 = se2();
          try {
            return Xa.get(a2)(b2, c2, f2, h2, m2, u2, n2, p2, v2);
          } catch (H2) {
            te2(E2);
            if (H2 !== H2 + 0) throw H2;
            re2(1, 0);
          }
        }
        var ue2;
        fb = function ve2() {
          ue2 || we2();
          ue2 || (fb = ve2);
        };
        function we2() {
          function a2() {
            if (!ue2 && (ue2 = true, w2.calledRun = true, !Pa)) {
              sb(Za);
              ba(w2);
              if (w2.onRuntimeInitialized) w2.onRuntimeInitialized();
              if (w2.postRun) for ("function" == typeof w2.postRun && (w2.postRun = [w2.postRun]); w2.postRun.length; ) {
                var b2 = w2.postRun.shift();
                bb.unshift(b2);
              }
              sb(bb);
            }
          }
          if (!(0 < db)) {
            if (w2.preRun) for ("function" == typeof w2.preRun && (w2.preRun = [w2.preRun]); w2.preRun.length; ) cb();
            sb(Ya);
            0 < db || (w2.setStatus ? (w2.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                w2.setStatus("");
              }, 1);
              a2();
            }, 1)) : a2());
          }
        }
        if (w2.preInit) for ("function" == typeof w2.preInit && (w2.preInit = [w2.preInit]); 0 < w2.preInit.length; ) w2.preInit.pop()();
        we2();
        return moduleArg.ready;
      };
    })();
    if (typeof exports2 === "object" && typeof module === "object")
      module.exports = CanvasKitInit;
    else if (typeof define === "function" && define["amd"])
      define([], () => CanvasKitInit);
  }
});

// node_modules/scribe.js-ocr/tess/tesseract.esm.min.js
var tesseract_esm_min_exports = {};
__export(tesseract_esm_min_exports, {
  default: () => tesseract_min
});
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var tesseract_min$1, tesseract_minExports, tesseract_min;
var init_tesseract_esm_min = __esm({
  "node_modules/scribe.js-ocr/tess/tesseract.esm.min.js"() {
    tesseract_min$1 = { exports: {} };
    (function(module, exports2) {
      !function(t2, r2) {
        module.exports = r2();
      }(self, () => (() => {
        var t2 = { 30: (t3, r3, e4) => {
          function n2(t4) {
            return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, n2(t4);
          }
          var o2 = function(t4) {
            var r4, e5 = Object.prototype, o3 = e5.hasOwnProperty, i2 = Object.defineProperty || function(t5, r5, e6) {
              t5[r5] = e6.value;
            }, a2 = "function" == typeof Symbol ? Symbol : {}, c2 = a2.iterator || "@@iterator", u2 = a2.asyncIterator || "@@asyncIterator", f2 = a2.toStringTag || "@@toStringTag";
            function l2(t5, r5, e6) {
              return Object.defineProperty(t5, r5, { value: e6, enumerable: true, configurable: true, writable: true }), t5[r5];
            }
            try {
              l2({}, "");
            } catch (t5) {
              l2 = function(t6, r5, e6) {
                return t6[r5] = e6;
              };
            }
            function s2(t5, r5, e6, n3) {
              var o4 = r5 && r5.prototype instanceof m2 ? r5 : m2, a3 = Object.create(o4.prototype), c3 = new N2(n3 || []);
              return i2(a3, "_invoke", { value: P2(t5, e6, c3) }), a3;
            }
            function h2(t5, r5, e6) {
              try {
                return { type: "normal", arg: t5.call(r5, e6) };
              } catch (t6) {
                return { type: "throw", arg: t6 };
              }
            }
            t4.wrap = s2;
            var p2 = "suspendedStart", y2 = "suspendedYield", v2 = "executing", d2 = "completed", g2 = {};
            function m2() {
            }
            function b2() {
            }
            function w2() {
            }
            var L2 = {};
            l2(L2, c2, function() {
              return this;
            });
            var x2 = Object.getPrototypeOf, O2 = x2 && x2(x2(A2([])));
            O2 && O2 !== e5 && o3.call(O2, c2) && (L2 = O2);
            var E2 = w2.prototype = m2.prototype = Object.create(L2);
            function S2(t5) {
              ["next", "throw", "return"].forEach(function(r5) {
                l2(t5, r5, function(t6) {
                  return this._invoke(r5, t6);
                });
              });
            }
            function j2(t5, r5) {
              function e6(i3, a4, c3, u3) {
                var f3 = h2(t5[i3], t5, a4);
                if ("throw" !== f3.type) {
                  var l3 = f3.arg, s3 = l3.value;
                  return s3 && "object" === n2(s3) && o3.call(s3, "__await") ? r5.resolve(s3.__await).then(function(t6) {
                    e6("next", t6, c3, u3);
                  }, function(t6) {
                    e6("throw", t6, c3, u3);
                  }) : r5.resolve(s3).then(function(t6) {
                    l3.value = t6, c3(l3);
                  }, function(t6) {
                    return e6("throw", t6, c3, u3);
                  });
                }
                u3(f3.arg);
              }
              var a3;
              i2(this, "_invoke", { value: function(t6, n3) {
                function o4() {
                  return new r5(function(r6, o5) {
                    e6(t6, n3, r6, o5);
                  });
                }
                return a3 = a3 ? a3.then(o4, o4) : o4();
              } });
            }
            function P2(t5, r5, e6) {
              var n3 = p2;
              return function(o4, i3) {
                if (n3 === v2) throw new Error("Generator is already running");
                if (n3 === d2) {
                  if ("throw" === o4) throw i3;
                  return I2();
                }
                for (e6.method = o4, e6.arg = i3; ; ) {
                  var a3 = e6.delegate;
                  if (a3) {
                    var c3 = k2(a3, e6);
                    if (c3) {
                      if (c3 === g2) continue;
                      return c3;
                    }
                  }
                  if ("next" === e6.method) e6.sent = e6._sent = e6.arg;
                  else if ("throw" === e6.method) {
                    if (n3 === p2) throw n3 = d2, e6.arg;
                    e6.dispatchException(e6.arg);
                  } else "return" === e6.method && e6.abrupt("return", e6.arg);
                  n3 = v2;
                  var u3 = h2(t5, r5, e6);
                  if ("normal" === u3.type) {
                    if (n3 = e6.done ? d2 : y2, u3.arg === g2) continue;
                    return { value: u3.arg, done: e6.done };
                  }
                  "throw" === u3.type && (n3 = d2, e6.method = "throw", e6.arg = u3.arg);
                }
              };
            }
            function k2(t5, e6) {
              var n3 = e6.method, o4 = t5.iterator[n3];
              if (o4 === r4) return e6.delegate = null, "throw" === n3 && t5.iterator.return && (e6.method = "return", e6.arg = r4, k2(t5, e6), "throw" === e6.method) || "return" !== n3 && (e6.method = "throw", e6.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), g2;
              var i3 = h2(o4, t5.iterator, e6.arg);
              if ("throw" === i3.type) return e6.method = "throw", e6.arg = i3.arg, e6.delegate = null, g2;
              var a3 = i3.arg;
              return a3 ? a3.done ? (e6[t5.resultName] = a3.value, e6.next = t5.nextLoc, "return" !== e6.method && (e6.method = "next", e6.arg = r4), e6.delegate = null, g2) : a3 : (e6.method = "throw", e6.arg = new TypeError("iterator result is not an object"), e6.delegate = null, g2);
            }
            function _2(t5) {
              var r5 = { tryLoc: t5[0] };
              1 in t5 && (r5.catchLoc = t5[1]), 2 in t5 && (r5.finallyLoc = t5[2], r5.afterLoc = t5[3]), this.tryEntries.push(r5);
            }
            function T2(t5) {
              var r5 = t5.completion || {};
              r5.type = "normal", delete r5.arg, t5.completion = r5;
            }
            function N2(t5) {
              this.tryEntries = [{ tryLoc: "root" }], t5.forEach(_2, this), this.reset(true);
            }
            function A2(t5) {
              if (t5) {
                var e6 = t5[c2];
                if (e6) return e6.call(t5);
                if ("function" == typeof t5.next) return t5;
                if (!isNaN(t5.length)) {
                  var n3 = -1, i3 = function e7() {
                    for (; ++n3 < t5.length; ) if (o3.call(t5, n3)) return e7.value = t5[n3], e7.done = false, e7;
                    return e7.value = r4, e7.done = true, e7;
                  };
                  return i3.next = i3;
                }
              }
              return { next: I2 };
            }
            function I2() {
              return { value: r4, done: true };
            }
            return b2.prototype = w2, i2(E2, "constructor", { value: w2, configurable: true }), i2(w2, "constructor", { value: b2, configurable: true }), b2.displayName = l2(w2, f2, "GeneratorFunction"), t4.isGeneratorFunction = function(t5) {
              var r5 = "function" == typeof t5 && t5.constructor;
              return !!r5 && (r5 === b2 || "GeneratorFunction" === (r5.displayName || r5.name));
            }, t4.mark = function(t5) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(t5, w2) : (t5.__proto__ = w2, l2(t5, f2, "GeneratorFunction")), t5.prototype = Object.create(E2), t5;
            }, t4.awrap = function(t5) {
              return { __await: t5 };
            }, S2(j2.prototype), l2(j2.prototype, u2, function() {
              return this;
            }), t4.AsyncIterator = j2, t4.async = function(r5, e6, n3, o4, i3) {
              void 0 === i3 && (i3 = Promise);
              var a3 = new j2(s2(r5, e6, n3, o4), i3);
              return t4.isGeneratorFunction(e6) ? a3 : a3.next().then(function(t5) {
                return t5.done ? t5.value : a3.next();
              });
            }, S2(E2), l2(E2, f2, "Generator"), l2(E2, c2, function() {
              return this;
            }), l2(E2, "toString", function() {
              return "[object Generator]";
            }), t4.keys = function(t5) {
              var r5 = Object(t5), e6 = [];
              for (var n3 in r5) e6.push(n3);
              return e6.reverse(), function t6() {
                for (; e6.length; ) {
                  var n4 = e6.pop();
                  if (n4 in r5) return t6.value = n4, t6.done = false, t6;
                }
                return t6.done = true, t6;
              };
            }, t4.values = A2, N2.prototype = { constructor: N2, reset: function(t5) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = r4, this.done = false, this.delegate = null, this.method = "next", this.arg = r4, this.tryEntries.forEach(T2), !t5) for (var e6 in this) "t" === e6.charAt(0) && o3.call(this, e6) && !isNaN(+e6.slice(1)) && (this[e6] = r4);
            }, stop: function() {
              this.done = true;
              var t5 = this.tryEntries[0].completion;
              if ("throw" === t5.type) throw t5.arg;
              return this.rval;
            }, dispatchException: function(t5) {
              if (this.done) throw t5;
              var e6 = this;
              function n3(n4, o4) {
                return c3.type = "throw", c3.arg = t5, e6.next = n4, o4 && (e6.method = "next", e6.arg = r4), !!o4;
              }
              for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
                var a3 = this.tryEntries[i3], c3 = a3.completion;
                if ("root" === a3.tryLoc) return n3("end");
                if (a3.tryLoc <= this.prev) {
                  var u3 = o3.call(a3, "catchLoc"), f3 = o3.call(a3, "finallyLoc");
                  if (u3 && f3) {
                    if (this.prev < a3.catchLoc) return n3(a3.catchLoc, true);
                    if (this.prev < a3.finallyLoc) return n3(a3.finallyLoc);
                  } else if (u3) {
                    if (this.prev < a3.catchLoc) return n3(a3.catchLoc, true);
                  } else {
                    if (!f3) throw new Error("try statement without catch or finally");
                    if (this.prev < a3.finallyLoc) return n3(a3.finallyLoc);
                  }
                }
              }
            }, abrupt: function(t5, r5) {
              for (var e6 = this.tryEntries.length - 1; e6 >= 0; --e6) {
                var n3 = this.tryEntries[e6];
                if (n3.tryLoc <= this.prev && o3.call(n3, "finallyLoc") && this.prev < n3.finallyLoc) {
                  var i3 = n3;
                  break;
                }
              }
              i3 && ("break" === t5 || "continue" === t5) && i3.tryLoc <= r5 && r5 <= i3.finallyLoc && (i3 = null);
              var a3 = i3 ? i3.completion : {};
              return a3.type = t5, a3.arg = r5, i3 ? (this.method = "next", this.next = i3.finallyLoc, g2) : this.complete(a3);
            }, complete: function(t5, r5) {
              if ("throw" === t5.type) throw t5.arg;
              return "break" === t5.type || "continue" === t5.type ? this.next = t5.arg : "return" === t5.type ? (this.rval = this.arg = t5.arg, this.method = "return", this.next = "end") : "normal" === t5.type && r5 && (this.next = r5), g2;
            }, finish: function(t5) {
              for (var r5 = this.tryEntries.length - 1; r5 >= 0; --r5) {
                var e6 = this.tryEntries[r5];
                if (e6.finallyLoc === t5) return this.complete(e6.completion, e6.afterLoc), T2(e6), g2;
              }
            }, catch: function(t5) {
              for (var r5 = this.tryEntries.length - 1; r5 >= 0; --r5) {
                var e6 = this.tryEntries[r5];
                if (e6.tryLoc === t5) {
                  var n3 = e6.completion;
                  if ("throw" === n3.type) {
                    var o4 = n3.arg;
                    T2(e6);
                  }
                  return o4;
                }
              }
              throw new Error("illegal catch attempt");
            }, delegateYield: function(t5, e6, n3) {
              return this.delegate = { iterator: A2(t5), resultName: e6, nextLoc: n3 }, "next" === this.method && (this.arg = r4), g2;
            } }, t4;
          }("object" === n2(t3 = e4.nmd(t3)) ? t3.exports : {});
          try {
            regeneratorRuntime = o2;
          } catch (t4) {
            "object" === ("undefined" == typeof globalThis ? "undefined" : n2(globalThis)) ? globalThis.regeneratorRuntime = o2 : Function("r", "regeneratorRuntime = r")(o2);
          }
        }, 52: (t3, r3, e4) => {
          function n2(t4) {
            return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, n2(t4);
          }
          function o2() {
            o2 = function() {
              return r4;
            };
            var t4, r4 = {}, e5 = Object.prototype, i3 = e5.hasOwnProperty, a3 = Object.defineProperty || function(t5, r5, e6) {
              t5[r5] = e6.value;
            }, c3 = "function" == typeof Symbol ? Symbol : {}, u3 = c3.iterator || "@@iterator", f3 = c3.asyncIterator || "@@asyncIterator", l2 = c3.toStringTag || "@@toStringTag";
            function s2(t5, r5, e6) {
              return Object.defineProperty(t5, r5, { value: e6, enumerable: true, configurable: true, writable: true }), t5[r5];
            }
            try {
              s2({}, "");
            } catch (t5) {
              s2 = function(t6, r5, e6) {
                return t6[r5] = e6;
              };
            }
            function h2(t5, r5, e6, n3) {
              var o3 = r5 && r5.prototype instanceof b2 ? r5 : b2, i4 = Object.create(o3.prototype), c4 = new A2(n3 || []);
              return a3(i4, "_invoke", { value: k2(t5, e6, c4) }), i4;
            }
            function p2(t5, r5, e6) {
              try {
                return { type: "normal", arg: t5.call(r5, e6) };
              } catch (t6) {
                return { type: "throw", arg: t6 };
              }
            }
            r4.wrap = h2;
            var y2 = "suspendedStart", v2 = "suspendedYield", d2 = "executing", g2 = "completed", m2 = {};
            function b2() {
            }
            function w2() {
            }
            function L2() {
            }
            var x2 = {};
            s2(x2, u3, function() {
              return this;
            });
            var O2 = Object.getPrototypeOf, E2 = O2 && O2(O2(I2([])));
            E2 && E2 !== e5 && i3.call(E2, u3) && (x2 = E2);
            var S2 = L2.prototype = b2.prototype = Object.create(x2);
            function j2(t5) {
              ["next", "throw", "return"].forEach(function(r5) {
                s2(t5, r5, function(t6) {
                  return this._invoke(r5, t6);
                });
              });
            }
            function P2(t5, r5) {
              function e6(o4, a4, c4, u4) {
                var f4 = p2(t5[o4], t5, a4);
                if ("throw" !== f4.type) {
                  var l3 = f4.arg, s3 = l3.value;
                  return s3 && "object" == n2(s3) && i3.call(s3, "__await") ? r5.resolve(s3.__await).then(function(t6) {
                    e6("next", t6, c4, u4);
                  }, function(t6) {
                    e6("throw", t6, c4, u4);
                  }) : r5.resolve(s3).then(function(t6) {
                    l3.value = t6, c4(l3);
                  }, function(t6) {
                    return e6("throw", t6, c4, u4);
                  });
                }
                u4(f4.arg);
              }
              var o3;
              a3(this, "_invoke", { value: function(t6, n3) {
                function i4() {
                  return new r5(function(r6, o4) {
                    e6(t6, n3, r6, o4);
                  });
                }
                return o3 = o3 ? o3.then(i4, i4) : i4();
              } });
            }
            function k2(r5, e6, n3) {
              var o3 = y2;
              return function(i4, a4) {
                if (o3 === d2) throw Error("Generator is already running");
                if (o3 === g2) {
                  if ("throw" === i4) throw a4;
                  return { value: t4, done: true };
                }
                for (n3.method = i4, n3.arg = a4; ; ) {
                  var c4 = n3.delegate;
                  if (c4) {
                    var u4 = _2(c4, n3);
                    if (u4) {
                      if (u4 === m2) continue;
                      return u4;
                    }
                  }
                  if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
                  else if ("throw" === n3.method) {
                    if (o3 === y2) throw o3 = g2, n3.arg;
                    n3.dispatchException(n3.arg);
                  } else "return" === n3.method && n3.abrupt("return", n3.arg);
                  o3 = d2;
                  var f4 = p2(r5, e6, n3);
                  if ("normal" === f4.type) {
                    if (o3 = n3.done ? g2 : v2, f4.arg === m2) continue;
                    return { value: f4.arg, done: n3.done };
                  }
                  "throw" === f4.type && (o3 = g2, n3.method = "throw", n3.arg = f4.arg);
                }
              };
            }
            function _2(r5, e6) {
              var n3 = e6.method, o3 = r5.iterator[n3];
              if (o3 === t4) return e6.delegate = null, "throw" === n3 && r5.iterator.return && (e6.method = "return", e6.arg = t4, _2(r5, e6), "throw" === e6.method) || "return" !== n3 && (e6.method = "throw", e6.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), m2;
              var i4 = p2(o3, r5.iterator, e6.arg);
              if ("throw" === i4.type) return e6.method = "throw", e6.arg = i4.arg, e6.delegate = null, m2;
              var a4 = i4.arg;
              return a4 ? a4.done ? (e6[r5.resultName] = a4.value, e6.next = r5.nextLoc, "return" !== e6.method && (e6.method = "next", e6.arg = t4), e6.delegate = null, m2) : a4 : (e6.method = "throw", e6.arg = new TypeError("iterator result is not an object"), e6.delegate = null, m2);
            }
            function T2(t5) {
              var r5 = { tryLoc: t5[0] };
              1 in t5 && (r5.catchLoc = t5[1]), 2 in t5 && (r5.finallyLoc = t5[2], r5.afterLoc = t5[3]), this.tryEntries.push(r5);
            }
            function N2(t5) {
              var r5 = t5.completion || {};
              r5.type = "normal", delete r5.arg, t5.completion = r5;
            }
            function A2(t5) {
              this.tryEntries = [{ tryLoc: "root" }], t5.forEach(T2, this), this.reset(true);
            }
            function I2(r5) {
              if (r5 || "" === r5) {
                var e6 = r5[u3];
                if (e6) return e6.call(r5);
                if ("function" == typeof r5.next) return r5;
                if (!isNaN(r5.length)) {
                  var o3 = -1, a4 = function e7() {
                    for (; ++o3 < r5.length; ) if (i3.call(r5, o3)) return e7.value = r5[o3], e7.done = false, e7;
                    return e7.value = t4, e7.done = true, e7;
                  };
                  return a4.next = a4;
                }
              }
              throw new TypeError(n2(r5) + " is not iterable");
            }
            return w2.prototype = L2, a3(S2, "constructor", { value: L2, configurable: true }), a3(L2, "constructor", { value: w2, configurable: true }), w2.displayName = s2(L2, l2, "GeneratorFunction"), r4.isGeneratorFunction = function(t5) {
              var r5 = "function" == typeof t5 && t5.constructor;
              return !!r5 && (r5 === w2 || "GeneratorFunction" === (r5.displayName || r5.name));
            }, r4.mark = function(t5) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(t5, L2) : (t5.__proto__ = L2, s2(t5, l2, "GeneratorFunction")), t5.prototype = Object.create(S2), t5;
            }, r4.awrap = function(t5) {
              return { __await: t5 };
            }, j2(P2.prototype), s2(P2.prototype, f3, function() {
              return this;
            }), r4.AsyncIterator = P2, r4.async = function(t5, e6, n3, o3, i4) {
              void 0 === i4 && (i4 = Promise);
              var a4 = new P2(h2(t5, e6, n3, o3), i4);
              return r4.isGeneratorFunction(e6) ? a4 : a4.next().then(function(t6) {
                return t6.done ? t6.value : a4.next();
              });
            }, j2(S2), s2(S2, l2, "Generator"), s2(S2, u3, function() {
              return this;
            }), s2(S2, "toString", function() {
              return "[object Generator]";
            }), r4.keys = function(t5) {
              var r5 = Object(t5), e6 = [];
              for (var n3 in r5) e6.push(n3);
              return e6.reverse(), function t6() {
                for (; e6.length; ) {
                  var n4 = e6.pop();
                  if (n4 in r5) return t6.value = n4, t6.done = false, t6;
                }
                return t6.done = true, t6;
              };
            }, r4.values = I2, A2.prototype = { constructor: A2, reset: function(r5) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = t4, this.done = false, this.delegate = null, this.method = "next", this.arg = t4, this.tryEntries.forEach(N2), !r5) for (var e6 in this) "t" === e6.charAt(0) && i3.call(this, e6) && !isNaN(+e6.slice(1)) && (this[e6] = t4);
            }, stop: function() {
              this.done = true;
              var t5 = this.tryEntries[0].completion;
              if ("throw" === t5.type) throw t5.arg;
              return this.rval;
            }, dispatchException: function(r5) {
              if (this.done) throw r5;
              var e6 = this;
              function n3(n4, o4) {
                return c4.type = "throw", c4.arg = r5, e6.next = n4, o4 && (e6.method = "next", e6.arg = t4), !!o4;
              }
              for (var o3 = this.tryEntries.length - 1; o3 >= 0; --o3) {
                var a4 = this.tryEntries[o3], c4 = a4.completion;
                if ("root" === a4.tryLoc) return n3("end");
                if (a4.tryLoc <= this.prev) {
                  var u4 = i3.call(a4, "catchLoc"), f4 = i3.call(a4, "finallyLoc");
                  if (u4 && f4) {
                    if (this.prev < a4.catchLoc) return n3(a4.catchLoc, true);
                    if (this.prev < a4.finallyLoc) return n3(a4.finallyLoc);
                  } else if (u4) {
                    if (this.prev < a4.catchLoc) return n3(a4.catchLoc, true);
                  } else {
                    if (!f4) throw Error("try statement without catch or finally");
                    if (this.prev < a4.finallyLoc) return n3(a4.finallyLoc);
                  }
                }
              }
            }, abrupt: function(t5, r5) {
              for (var e6 = this.tryEntries.length - 1; e6 >= 0; --e6) {
                var n3 = this.tryEntries[e6];
                if (n3.tryLoc <= this.prev && i3.call(n3, "finallyLoc") && this.prev < n3.finallyLoc) {
                  var o3 = n3;
                  break;
                }
              }
              o3 && ("break" === t5 || "continue" === t5) && o3.tryLoc <= r5 && r5 <= o3.finallyLoc && (o3 = null);
              var a4 = o3 ? o3.completion : {};
              return a4.type = t5, a4.arg = r5, o3 ? (this.method = "next", this.next = o3.finallyLoc, m2) : this.complete(a4);
            }, complete: function(t5, r5) {
              if ("throw" === t5.type) throw t5.arg;
              return "break" === t5.type || "continue" === t5.type ? this.next = t5.arg : "return" === t5.type ? (this.rval = this.arg = t5.arg, this.method = "return", this.next = "end") : "normal" === t5.type && r5 && (this.next = r5), m2;
            }, finish: function(t5) {
              for (var r5 = this.tryEntries.length - 1; r5 >= 0; --r5) {
                var e6 = this.tryEntries[r5];
                if (e6.finallyLoc === t5) return this.complete(e6.completion, e6.afterLoc), N2(e6), m2;
              }
            }, catch: function(t5) {
              for (var r5 = this.tryEntries.length - 1; r5 >= 0; --r5) {
                var e6 = this.tryEntries[r5];
                if (e6.tryLoc === t5) {
                  var n3 = e6.completion;
                  if ("throw" === n3.type) {
                    var o3 = n3.arg;
                    N2(e6);
                  }
                  return o3;
                }
              }
              throw Error("illegal catch attempt");
            }, delegateYield: function(r5, e6, n3) {
              return this.delegate = { iterator: I2(r5), resultName: e6, nextLoc: n3 }, "next" === this.method && (this.arg = t4), m2;
            } }, r4;
          }
          function i2(t4, r4, e5, n3, o3, i3, a3) {
            try {
              var c3 = t4[i3](a3), u3 = c3.value;
            } catch (t5) {
              return void e5(t5);
            }
            c3.done ? r4(u3) : Promise.resolve(u3).then(n3, o3);
          }
          function a2(t4) {
            return function() {
              var r4 = this, e5 = arguments;
              return new Promise(function(n3, o3) {
                var a3 = t4.apply(r4, e5);
                function c3(t5) {
                  i2(a3, n3, o3, c3, u3, "next", t5);
                }
                function u3(t5) {
                  i2(a3, n3, o3, c3, u3, "throw", t5);
                }
                c3(void 0);
              });
            };
          }
          var c2 = e4(738), u2 = function() {
            var t4 = a2(o2().mark(function t5(r4, e5, n3) {
              var i3;
              return o2().wrap(function(t6) {
                for (; ; ) switch (t6.prev = t6.next) {
                  case 0:
                    return t6.next = 2, c2(e5, 1, n3);
                  case 2:
                    return i3 = t6.sent, t6.abrupt("return", i3.recognize(r4).finally(a2(o2().mark(function t7() {
                      return o2().wrap(function(t8) {
                        for (; ; ) switch (t8.prev = t8.next) {
                          case 0:
                            return t8.next = 2, i3.terminate();
                          case 2:
                          case "end":
                            return t8.stop();
                        }
                      }, t7);
                    }))));
                  case 4:
                  case "end":
                    return t6.stop();
                }
              }, t5);
            }));
            return function(r4, e5, n3) {
              return t4.apply(this, arguments);
            };
          }(), f2 = function() {
            var t4 = a2(o2().mark(function t5(r4, e5) {
              var n3;
              return o2().wrap(function(t6) {
                for (; ; ) switch (t6.prev = t6.next) {
                  case 0:
                    return t6.next = 2, c2("osd", 0, e5);
                  case 2:
                    return n3 = t6.sent, t6.abrupt("return", n3.detect(r4).finally(a2(o2().mark(function t7() {
                      return o2().wrap(function(t8) {
                        for (; ; ) switch (t8.prev = t8.next) {
                          case 0:
                            return t8.next = 2, n3.terminate();
                          case 2:
                          case "end":
                            return t8.stop();
                        }
                      }, t7);
                    }))));
                  case 4:
                  case "end":
                    return t6.stop();
                }
              }, t5);
            }));
            return function(r4, e5) {
              return t4.apply(this, arguments);
            };
          }();
          t3.exports = { recognize: u2, detect: f2 };
        }, 287: (t3) => {
          t3.exports = { TESSERACT_ONLY: 0, LSTM_ONLY: 1, TESSERACT_LSTM_COMBINED: 2, DEFAULT: 3 };
        }, 188: (t3) => {
          t3.exports = { OSD_ONLY: "0", AUTO_OSD: "1", AUTO_ONLY: "2", AUTO: "3", SINGLE_COLUMN: "4", SINGLE_BLOCK_VERT_TEXT: "5", SINGLE_BLOCK: "6", SINGLE_LINE: "7", SINGLE_WORD: "8", CIRCLE_WORD: "9", SINGLE_CHAR: "10", SPARSE_TEXT: "11", SPARSE_TEXT_OSD: "12", RAW_LINE: "13" };
        }, 491: (t3) => {
          t3.exports = { workerBlobURL: true, logger: function() {
          } };
        }, 11: (t3) => {
          t3.exports = { AFR: "afr", AMH: "amh", ARA: "ara", ASM: "asm", AZE: "aze", AZE_CYRL: "aze_cyrl", BEL: "bel", BEN: "ben", BOD: "bod", BOS: "bos", BUL: "bul", CAT: "cat", CEB: "ceb", CES: "ces", CHI_SIM: "chi_sim", CHI_TRA: "chi_tra", CHR: "chr", CYM: "cym", DAN: "dan", DEU: "deu", DZO: "dzo", ELL: "ell", ENG: "eng", ENM: "enm", EPO: "epo", EST: "est", EUS: "eus", FAS: "fas", FIN: "fin", FRA: "fra", FRK: "frk", FRM: "frm", GLE: "gle", GLG: "glg", GRC: "grc", GUJ: "guj", HAT: "hat", HEB: "heb", HIN: "hin", HRV: "hrv", HUN: "hun", IKU: "iku", IND: "ind", ISL: "isl", ITA: "ita", ITA_OLD: "ita_old", JAV: "jav", JPN: "jpn", KAN: "kan", KAT: "kat", KAT_OLD: "kat_old", KAZ: "kaz", KHM: "khm", KIR: "kir", KOR: "kor", KUR: "kur", LAO: "lao", LAT: "lat", LAV: "lav", LIT: "lit", MAL: "mal", MAR: "mar", MKD: "mkd", MLT: "mlt", MSA: "msa", MYA: "mya", NEP: "nep", NLD: "nld", NOR: "nor", ORI: "ori", PAN: "pan", POL: "pol", POR: "por", PUS: "pus", RON: "ron", RUS: "rus", SAN: "san", SIN: "sin", SLK: "slk", SLV: "slv", SPA: "spa", SPA_OLD: "spa_old", SQI: "sqi", SRP: "srp", SRP_LATN: "srp_latn", SWA: "swa", SWE: "swe", SYR: "syr", TAM: "tam", TEL: "tel", TGK: "tgk", TGL: "tgl", THA: "tha", TIR: "tir", TUR: "tur", UIG: "uig", UKR: "ukr", URD: "urd", UZB: "uzb", UZB_CYRL: "uzb_cyrl", VIE: "vie", YID: "yid" };
        }, 13: (t3, r3, e4) => {
          var n2 = e4(857), o2 = 0;
          t3.exports = function(t4) {
            var r4 = t4.id, e5 = t4.action, i2 = t4.payload, a2 = void 0 === i2 ? {} : i2, c2 = r4;
            return void 0 === c2 && (c2 = n2("Job", o2), o2 += 1), { id: c2, action: e5, payload: a2 };
          };
        }, 695: function(t3, r3, e4) {
          function n2(t4) {
            return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, n2(t4);
          }
          var o2 = this;
          function i2() {
            i2 = function() {
              return r4;
            };
            var t4, r4 = {}, e5 = Object.prototype, o3 = e5.hasOwnProperty, a3 = Object.defineProperty || function(t5, r5, e6) {
              t5[r5] = e6.value;
            }, c3 = "function" == typeof Symbol ? Symbol : {}, u3 = c3.iterator || "@@iterator", f3 = c3.asyncIterator || "@@asyncIterator", l3 = c3.toStringTag || "@@toStringTag";
            function s3(t5, r5, e6) {
              return Object.defineProperty(t5, r5, { value: e6, enumerable: true, configurable: true, writable: true }), t5[r5];
            }
            try {
              s3({}, "");
            } catch (t5) {
              s3 = function(t6, r5, e6) {
                return t6[r5] = e6;
              };
            }
            function h3(t5, r5, e6, n3) {
              var o4 = r5 && r5.prototype instanceof b2 ? r5 : b2, i3 = Object.create(o4.prototype), c4 = new A2(n3 || []);
              return a3(i3, "_invoke", { value: k2(t5, e6, c4) }), i3;
            }
            function p2(t5, r5, e6) {
              try {
                return { type: "normal", arg: t5.call(r5, e6) };
              } catch (t6) {
                return { type: "throw", arg: t6 };
              }
            }
            r4.wrap = h3;
            var y2 = "suspendedStart", v2 = "suspendedYield", d2 = "executing", g2 = "completed", m2 = {};
            function b2() {
            }
            function w2() {
            }
            function L2() {
            }
            var x2 = {};
            s3(x2, u3, function() {
              return this;
            });
            var O2 = Object.getPrototypeOf, E2 = O2 && O2(O2(I2([])));
            E2 && E2 !== e5 && o3.call(E2, u3) && (x2 = E2);
            var S2 = L2.prototype = b2.prototype = Object.create(x2);
            function j2(t5) {
              ["next", "throw", "return"].forEach(function(r5) {
                s3(t5, r5, function(t6) {
                  return this._invoke(r5, t6);
                });
              });
            }
            function P2(t5, r5) {
              function e6(i4, a4, c4, u4) {
                var f4 = p2(t5[i4], t5, a4);
                if ("throw" !== f4.type) {
                  var l4 = f4.arg, s4 = l4.value;
                  return s4 && "object" == n2(s4) && o3.call(s4, "__await") ? r5.resolve(s4.__await).then(function(t6) {
                    e6("next", t6, c4, u4);
                  }, function(t6) {
                    e6("throw", t6, c4, u4);
                  }) : r5.resolve(s4).then(function(t6) {
                    l4.value = t6, c4(l4);
                  }, function(t6) {
                    return e6("throw", t6, c4, u4);
                  });
                }
                u4(f4.arg);
              }
              var i3;
              a3(this, "_invoke", { value: function(t6, n3) {
                function o4() {
                  return new r5(function(r6, o5) {
                    e6(t6, n3, r6, o5);
                  });
                }
                return i3 = i3 ? i3.then(o4, o4) : o4();
              } });
            }
            function k2(r5, e6, n3) {
              var o4 = y2;
              return function(i3, a4) {
                if (o4 === d2) throw Error("Generator is already running");
                if (o4 === g2) {
                  if ("throw" === i3) throw a4;
                  return { value: t4, done: true };
                }
                for (n3.method = i3, n3.arg = a4; ; ) {
                  var c4 = n3.delegate;
                  if (c4) {
                    var u4 = _2(c4, n3);
                    if (u4) {
                      if (u4 === m2) continue;
                      return u4;
                    }
                  }
                  if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
                  else if ("throw" === n3.method) {
                    if (o4 === y2) throw o4 = g2, n3.arg;
                    n3.dispatchException(n3.arg);
                  } else "return" === n3.method && n3.abrupt("return", n3.arg);
                  o4 = d2;
                  var f4 = p2(r5, e6, n3);
                  if ("normal" === f4.type) {
                    if (o4 = n3.done ? g2 : v2, f4.arg === m2) continue;
                    return { value: f4.arg, done: n3.done };
                  }
                  "throw" === f4.type && (o4 = g2, n3.method = "throw", n3.arg = f4.arg);
                }
              };
            }
            function _2(r5, e6) {
              var n3 = e6.method, o4 = r5.iterator[n3];
              if (o4 === t4) return e6.delegate = null, "throw" === n3 && r5.iterator.return && (e6.method = "return", e6.arg = t4, _2(r5, e6), "throw" === e6.method) || "return" !== n3 && (e6.method = "throw", e6.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), m2;
              var i3 = p2(o4, r5.iterator, e6.arg);
              if ("throw" === i3.type) return e6.method = "throw", e6.arg = i3.arg, e6.delegate = null, m2;
              var a4 = i3.arg;
              return a4 ? a4.done ? (e6[r5.resultName] = a4.value, e6.next = r5.nextLoc, "return" !== e6.method && (e6.method = "next", e6.arg = t4), e6.delegate = null, m2) : a4 : (e6.method = "throw", e6.arg = new TypeError("iterator result is not an object"), e6.delegate = null, m2);
            }
            function T2(t5) {
              var r5 = { tryLoc: t5[0] };
              1 in t5 && (r5.catchLoc = t5[1]), 2 in t5 && (r5.finallyLoc = t5[2], r5.afterLoc = t5[3]), this.tryEntries.push(r5);
            }
            function N2(t5) {
              var r5 = t5.completion || {};
              r5.type = "normal", delete r5.arg, t5.completion = r5;
            }
            function A2(t5) {
              this.tryEntries = [{ tryLoc: "root" }], t5.forEach(T2, this), this.reset(true);
            }
            function I2(r5) {
              if (r5 || "" === r5) {
                var e6 = r5[u3];
                if (e6) return e6.call(r5);
                if ("function" == typeof r5.next) return r5;
                if (!isNaN(r5.length)) {
                  var i3 = -1, a4 = function e7() {
                    for (; ++i3 < r5.length; ) if (o3.call(r5, i3)) return e7.value = r5[i3], e7.done = false, e7;
                    return e7.value = t4, e7.done = true, e7;
                  };
                  return a4.next = a4;
                }
              }
              throw new TypeError(n2(r5) + " is not iterable");
            }
            return w2.prototype = L2, a3(S2, "constructor", { value: L2, configurable: true }), a3(L2, "constructor", { value: w2, configurable: true }), w2.displayName = s3(L2, l3, "GeneratorFunction"), r4.isGeneratorFunction = function(t5) {
              var r5 = "function" == typeof t5 && t5.constructor;
              return !!r5 && (r5 === w2 || "GeneratorFunction" === (r5.displayName || r5.name));
            }, r4.mark = function(t5) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(t5, L2) : (t5.__proto__ = L2, s3(t5, l3, "GeneratorFunction")), t5.prototype = Object.create(S2), t5;
            }, r4.awrap = function(t5) {
              return { __await: t5 };
            }, j2(P2.prototype), s3(P2.prototype, f3, function() {
              return this;
            }), r4.AsyncIterator = P2, r4.async = function(t5, e6, n3, o4, i3) {
              void 0 === i3 && (i3 = Promise);
              var a4 = new P2(h3(t5, e6, n3, o4), i3);
              return r4.isGeneratorFunction(e6) ? a4 : a4.next().then(function(t6) {
                return t6.done ? t6.value : a4.next();
              });
            }, j2(S2), s3(S2, l3, "Generator"), s3(S2, u3, function() {
              return this;
            }), s3(S2, "toString", function() {
              return "[object Generator]";
            }), r4.keys = function(t5) {
              var r5 = Object(t5), e6 = [];
              for (var n3 in r5) e6.push(n3);
              return e6.reverse(), function t6() {
                for (; e6.length; ) {
                  var n4 = e6.pop();
                  if (n4 in r5) return t6.value = n4, t6.done = false, t6;
                }
                return t6.done = true, t6;
              };
            }, r4.values = I2, A2.prototype = { constructor: A2, reset: function(r5) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = t4, this.done = false, this.delegate = null, this.method = "next", this.arg = t4, this.tryEntries.forEach(N2), !r5) for (var e6 in this) "t" === e6.charAt(0) && o3.call(this, e6) && !isNaN(+e6.slice(1)) && (this[e6] = t4);
            }, stop: function() {
              this.done = true;
              var t5 = this.tryEntries[0].completion;
              if ("throw" === t5.type) throw t5.arg;
              return this.rval;
            }, dispatchException: function(r5) {
              if (this.done) throw r5;
              var e6 = this;
              function n3(n4, o4) {
                return c4.type = "throw", c4.arg = r5, e6.next = n4, o4 && (e6.method = "next", e6.arg = t4), !!o4;
              }
              for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
                var a4 = this.tryEntries[i3], c4 = a4.completion;
                if ("root" === a4.tryLoc) return n3("end");
                if (a4.tryLoc <= this.prev) {
                  var u4 = o3.call(a4, "catchLoc"), f4 = o3.call(a4, "finallyLoc");
                  if (u4 && f4) {
                    if (this.prev < a4.catchLoc) return n3(a4.catchLoc, true);
                    if (this.prev < a4.finallyLoc) return n3(a4.finallyLoc);
                  } else if (u4) {
                    if (this.prev < a4.catchLoc) return n3(a4.catchLoc, true);
                  } else {
                    if (!f4) throw Error("try statement without catch or finally");
                    if (this.prev < a4.finallyLoc) return n3(a4.finallyLoc);
                  }
                }
              }
            }, abrupt: function(t5, r5) {
              for (var e6 = this.tryEntries.length - 1; e6 >= 0; --e6) {
                var n3 = this.tryEntries[e6];
                if (n3.tryLoc <= this.prev && o3.call(n3, "finallyLoc") && this.prev < n3.finallyLoc) {
                  var i3 = n3;
                  break;
                }
              }
              i3 && ("break" === t5 || "continue" === t5) && i3.tryLoc <= r5 && r5 <= i3.finallyLoc && (i3 = null);
              var a4 = i3 ? i3.completion : {};
              return a4.type = t5, a4.arg = r5, i3 ? (this.method = "next", this.next = i3.finallyLoc, m2) : this.complete(a4);
            }, complete: function(t5, r5) {
              if ("throw" === t5.type) throw t5.arg;
              return "break" === t5.type || "continue" === t5.type ? this.next = t5.arg : "return" === t5.type ? (this.rval = this.arg = t5.arg, this.method = "return", this.next = "end") : "normal" === t5.type && r5 && (this.next = r5), m2;
            }, finish: function(t5) {
              for (var r5 = this.tryEntries.length - 1; r5 >= 0; --r5) {
                var e6 = this.tryEntries[r5];
                if (e6.finallyLoc === t5) return this.complete(e6.completion, e6.afterLoc), N2(e6), m2;
              }
            }, catch: function(t5) {
              for (var r5 = this.tryEntries.length - 1; r5 >= 0; --r5) {
                var e6 = this.tryEntries[r5];
                if (e6.tryLoc === t5) {
                  var n3 = e6.completion;
                  if ("throw" === n3.type) {
                    var o4 = n3.arg;
                    N2(e6);
                  }
                  return o4;
                }
              }
              throw Error("illegal catch attempt");
            }, delegateYield: function(r5, e6, n3) {
              return this.delegate = { iterator: I2(r5), resultName: e6, nextLoc: n3 }, "next" === this.method && (this.arg = t4), m2;
            } }, r4;
          }
          function a2(t4, r4) {
            (null == r4 || r4 > t4.length) && (r4 = t4.length);
            for (var e5 = 0, n3 = Array(r4); e5 < r4; e5++) n3[e5] = t4[e5];
            return n3;
          }
          function c2(t4, r4, e5, n3, o3, i3, a3) {
            try {
              var c3 = t4[i3](a3), u3 = c3.value;
            } catch (t5) {
              return void e5(t5);
            }
            c3.done ? r4(u3) : Promise.resolve(u3).then(n3, o3);
          }
          function u2(t4) {
            return function() {
              var r4 = this, e5 = arguments;
              return new Promise(function(n3, o3) {
                var i3 = t4.apply(r4, e5);
                function a3(t5) {
                  c2(i3, n3, o3, a3, u3, "next", t5);
                }
                function u3(t5) {
                  c2(i3, n3, o3, a3, u3, "throw", t5);
                }
                a3(void 0);
              });
            };
          }
          var f2 = e4(13), l2 = e4(86).log, s2 = e4(857), h2 = 0;
          t3.exports = function() {
            var t4 = s2("Scheduler", h2), r4 = {}, e5 = {}, n3 = [];
            h2 += 1;
            var c3 = function() {
              return Object.keys(r4).length;
            }, p2 = function() {
              if (0 !== n3.length) {
                for (var t5 = Object.keys(r4), o3 = 0; o3 < t5.length; o3 += 1) if (void 0 === e5[t5[o3]]) {
                  n3[0](r4[t5[o3]]);
                  break;
                }
              }
            }, y2 = function(r5, c4) {
              return new Promise(function(s3, h3) {
                var y3 = f2({ action: r5, payload: c4 });
                n3.push(function() {
                  var t5 = u2(i2().mark(function t6(u3) {
                    var f3;
                    return i2().wrap(function(t7) {
                      for (; ; ) switch (t7.prev = t7.next) {
                        case 0:
                          return n3.shift(), e5[u3.id] = y3, t7.prev = 2, t7.next = 5, u3[r5].apply(o2, [].concat(function(t8) {
                            if (Array.isArray(t8)) return a2(t8);
                          }(i3 = c4) || function(t8) {
                            if ("undefined" != typeof Symbol && null != t8[Symbol.iterator] || null != t8["@@iterator"]) return Array.from(t8);
                          }(i3) || function(t8, r6) {
                            if (t8) {
                              if ("string" == typeof t8) return a2(t8, r6);
                              var e6 = {}.toString.call(t8).slice(8, -1);
                              return "Object" === e6 && t8.constructor && (e6 = t8.constructor.name), "Map" === e6 || "Set" === e6 ? Array.from(t8) : "Arguments" === e6 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e6) ? a2(t8, r6) : void 0;
                            }
                          }(i3) || function() {
                            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                          }(), [y3.id]));
                        case 5:
                          if (f3 = t7.sent, s3(f3), !Array.isArray(f3)) {
                            t7.next = 10;
                            break;
                          }
                          return t7.next = 10, Promise.allSettled(f3);
                        case 10:
                          t7.next = 15;
                          break;
                        case 12:
                          t7.prev = 12, t7.t0 = t7.catch(2), h3(t7.t0);
                        case 15:
                          return t7.prev = 15, delete e5[u3.id], p2(), t7.finish(15);
                        case 19:
                        case "end":
                          return t7.stop();
                      }
                      var i3;
                    }, t6, null, [[2, 12, 15, 19]]);
                  }));
                  return function(r6) {
                    return t5.apply(this, arguments);
                  };
                }()), l2("[".concat(t4, "]: Add ").concat(y3.id, " to JobQueue")), l2("[".concat(t4, "]: JobQueue length=").concat(n3.length)), p2();
              });
            }, v2 = function() {
              var r5 = u2(i2().mark(function r6(e6) {
                var n4, o3, a3, u3 = arguments;
                return i2().wrap(function(r7) {
                  for (; ; ) switch (r7.prev = r7.next) {
                    case 0:
                      if (0 !== c3()) {
                        r7.next = 2;
                        break;
                      }
                      throw Error("[".concat(t4, "]: You need to have at least one worker before adding jobs"));
                    case 2:
                      for (n4 = u3.length, o3 = new Array(n4 > 1 ? n4 - 1 : 0), a3 = 1; a3 < n4; a3++) o3[a3 - 1] = u3[a3];
                      return r7.abrupt("return", y2(e6, o3));
                    case 4:
                    case "end":
                      return r7.stop();
                  }
                }, r6);
              }));
              return function(t5) {
                return r5.apply(this, arguments);
              };
            }(), d2 = function() {
              var t5 = u2(i2().mark(function t6() {
                return i2().wrap(function(t7) {
                  for (; ; ) switch (t7.prev = t7.next) {
                    case 0:
                      Object.keys(r4).forEach(function() {
                        var t8 = u2(i2().mark(function t9(e6) {
                          return i2().wrap(function(t10) {
                            for (; ; ) switch (t10.prev = t10.next) {
                              case 0:
                                return t10.next = 2, r4[e6].terminate();
                              case 2:
                              case "end":
                                return t10.stop();
                            }
                          }, t9);
                        }));
                        return function(r5) {
                          return t8.apply(this, arguments);
                        };
                      }()), n3 = [];
                    case 2:
                    case "end":
                      return t7.stop();
                  }
                }, t6);
              }));
              return function() {
                return t5.apply(this, arguments);
              };
            }();
            return { addWorker: function(e6) {
              return r4[e6.id] = e6, l2("[".concat(t4, "]: Add ").concat(e6.id)), l2("[".concat(t4, "]: Number of workers=").concat(c3())), p2(), e6.id;
            }, addJob: v2, terminate: d2, getQueueLen: function() {
              return n3.length;
            }, getNumWorkers: c3 };
          };
        }, 738: (t3, r3, e4) => {
          function n2(t4) {
            return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, n2(t4);
          }
          var o2 = ["logger", "errorHandler"];
          function i2() {
            i2 = function() {
              return r4;
            };
            var t4, r4 = {}, e5 = Object.prototype, o3 = e5.hasOwnProperty, a3 = Object.defineProperty || function(t5, r5, e6) {
              t5[r5] = e6.value;
            }, c3 = "function" == typeof Symbol ? Symbol : {}, u3 = c3.iterator || "@@iterator", f3 = c3.asyncIterator || "@@asyncIterator", l3 = c3.toStringTag || "@@toStringTag";
            function s3(t5, r5, e6) {
              return Object.defineProperty(t5, r5, { value: e6, enumerable: true, configurable: true, writable: true }), t5[r5];
            }
            try {
              s3({}, "");
            } catch (t5) {
              s3 = function(t6, r5, e6) {
                return t6[r5] = e6;
              };
            }
            function h3(t5, r5, e6, n3) {
              var o4 = r5 && r5.prototype instanceof b3 ? r5 : b3, i3 = Object.create(o4.prototype), c4 = new A2(n3 || []);
              return a3(i3, "_invoke", { value: k2(t5, e6, c4) }), i3;
            }
            function p3(t5, r5, e6) {
              try {
                return { type: "normal", arg: t5.call(r5, e6) };
              } catch (t6) {
                return { type: "throw", arg: t6 };
              }
            }
            r4.wrap = h3;
            var y3 = "suspendedStart", v3 = "suspendedYield", d3 = "executing", g3 = "completed", m3 = {};
            function b3() {
            }
            function w3() {
            }
            function L3() {
            }
            var x3 = {};
            s3(x3, u3, function() {
              return this;
            });
            var O3 = Object.getPrototypeOf, E3 = O3 && O3(O3(I2([])));
            E3 && E3 !== e5 && o3.call(E3, u3) && (x3 = E3);
            var S3 = L3.prototype = b3.prototype = Object.create(x3);
            function j3(t5) {
              ["next", "throw", "return"].forEach(function(r5) {
                s3(t5, r5, function(t6) {
                  return this._invoke(r5, t6);
                });
              });
            }
            function P2(t5, r5) {
              function e6(i4, a4, c4, u4) {
                var f4 = p3(t5[i4], t5, a4);
                if ("throw" !== f4.type) {
                  var l4 = f4.arg, s4 = l4.value;
                  return s4 && "object" == n2(s4) && o3.call(s4, "__await") ? r5.resolve(s4.__await).then(function(t6) {
                    e6("next", t6, c4, u4);
                  }, function(t6) {
                    e6("throw", t6, c4, u4);
                  }) : r5.resolve(s4).then(function(t6) {
                    l4.value = t6, c4(l4);
                  }, function(t6) {
                    return e6("throw", t6, c4, u4);
                  });
                }
                u4(f4.arg);
              }
              var i3;
              a3(this, "_invoke", { value: function(t6, n3) {
                function o4() {
                  return new r5(function(r6, o5) {
                    e6(t6, n3, r6, o5);
                  });
                }
                return i3 = i3 ? i3.then(o4, o4) : o4();
              } });
            }
            function k2(r5, e6, n3) {
              var o4 = y3;
              return function(i3, a4) {
                if (o4 === d3) throw Error("Generator is already running");
                if (o4 === g3) {
                  if ("throw" === i3) throw a4;
                  return { value: t4, done: true };
                }
                for (n3.method = i3, n3.arg = a4; ; ) {
                  var c4 = n3.delegate;
                  if (c4) {
                    var u4 = _2(c4, n3);
                    if (u4) {
                      if (u4 === m3) continue;
                      return u4;
                    }
                  }
                  if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
                  else if ("throw" === n3.method) {
                    if (o4 === y3) throw o4 = g3, n3.arg;
                    n3.dispatchException(n3.arg);
                  } else "return" === n3.method && n3.abrupt("return", n3.arg);
                  o4 = d3;
                  var f4 = p3(r5, e6, n3);
                  if ("normal" === f4.type) {
                    if (o4 = n3.done ? g3 : v3, f4.arg === m3) continue;
                    return { value: f4.arg, done: n3.done };
                  }
                  "throw" === f4.type && (o4 = g3, n3.method = "throw", n3.arg = f4.arg);
                }
              };
            }
            function _2(r5, e6) {
              var n3 = e6.method, o4 = r5.iterator[n3];
              if (o4 === t4) return e6.delegate = null, "throw" === n3 && r5.iterator.return && (e6.method = "return", e6.arg = t4, _2(r5, e6), "throw" === e6.method) || "return" !== n3 && (e6.method = "throw", e6.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), m3;
              var i3 = p3(o4, r5.iterator, e6.arg);
              if ("throw" === i3.type) return e6.method = "throw", e6.arg = i3.arg, e6.delegate = null, m3;
              var a4 = i3.arg;
              return a4 ? a4.done ? (e6[r5.resultName] = a4.value, e6.next = r5.nextLoc, "return" !== e6.method && (e6.method = "next", e6.arg = t4), e6.delegate = null, m3) : a4 : (e6.method = "throw", e6.arg = new TypeError("iterator result is not an object"), e6.delegate = null, m3);
            }
            function T2(t5) {
              var r5 = { tryLoc: t5[0] };
              1 in t5 && (r5.catchLoc = t5[1]), 2 in t5 && (r5.finallyLoc = t5[2], r5.afterLoc = t5[3]), this.tryEntries.push(r5);
            }
            function N2(t5) {
              var r5 = t5.completion || {};
              r5.type = "normal", delete r5.arg, t5.completion = r5;
            }
            function A2(t5) {
              this.tryEntries = [{ tryLoc: "root" }], t5.forEach(T2, this), this.reset(true);
            }
            function I2(r5) {
              if (r5 || "" === r5) {
                var e6 = r5[u3];
                if (e6) return e6.call(r5);
                if ("function" == typeof r5.next) return r5;
                if (!isNaN(r5.length)) {
                  var i3 = -1, a4 = function e7() {
                    for (; ++i3 < r5.length; ) if (o3.call(r5, i3)) return e7.value = r5[i3], e7.done = false, e7;
                    return e7.value = t4, e7.done = true, e7;
                  };
                  return a4.next = a4;
                }
              }
              throw new TypeError(n2(r5) + " is not iterable");
            }
            return w3.prototype = L3, a3(S3, "constructor", { value: L3, configurable: true }), a3(L3, "constructor", { value: w3, configurable: true }), w3.displayName = s3(L3, l3, "GeneratorFunction"), r4.isGeneratorFunction = function(t5) {
              var r5 = "function" == typeof t5 && t5.constructor;
              return !!r5 && (r5 === w3 || "GeneratorFunction" === (r5.displayName || r5.name));
            }, r4.mark = function(t5) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(t5, L3) : (t5.__proto__ = L3, s3(t5, l3, "GeneratorFunction")), t5.prototype = Object.create(S3), t5;
            }, r4.awrap = function(t5) {
              return { __await: t5 };
            }, j3(P2.prototype), s3(P2.prototype, f3, function() {
              return this;
            }), r4.AsyncIterator = P2, r4.async = function(t5, e6, n3, o4, i3) {
              void 0 === i3 && (i3 = Promise);
              var a4 = new P2(h3(t5, e6, n3, o4), i3);
              return r4.isGeneratorFunction(e6) ? a4 : a4.next().then(function(t6) {
                return t6.done ? t6.value : a4.next();
              });
            }, j3(S3), s3(S3, l3, "Generator"), s3(S3, u3, function() {
              return this;
            }), s3(S3, "toString", function() {
              return "[object Generator]";
            }), r4.keys = function(t5) {
              var r5 = Object(t5), e6 = [];
              for (var n3 in r5) e6.push(n3);
              return e6.reverse(), function t6() {
                for (; e6.length; ) {
                  var n4 = e6.pop();
                  if (n4 in r5) return t6.value = n4, t6.done = false, t6;
                }
                return t6.done = true, t6;
              };
            }, r4.values = I2, A2.prototype = { constructor: A2, reset: function(r5) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = t4, this.done = false, this.delegate = null, this.method = "next", this.arg = t4, this.tryEntries.forEach(N2), !r5) for (var e6 in this) "t" === e6.charAt(0) && o3.call(this, e6) && !isNaN(+e6.slice(1)) && (this[e6] = t4);
            }, stop: function() {
              this.done = true;
              var t5 = this.tryEntries[0].completion;
              if ("throw" === t5.type) throw t5.arg;
              return this.rval;
            }, dispatchException: function(r5) {
              if (this.done) throw r5;
              var e6 = this;
              function n3(n4, o4) {
                return c4.type = "throw", c4.arg = r5, e6.next = n4, o4 && (e6.method = "next", e6.arg = t4), !!o4;
              }
              for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
                var a4 = this.tryEntries[i3], c4 = a4.completion;
                if ("root" === a4.tryLoc) return n3("end");
                if (a4.tryLoc <= this.prev) {
                  var u4 = o3.call(a4, "catchLoc"), f4 = o3.call(a4, "finallyLoc");
                  if (u4 && f4) {
                    if (this.prev < a4.catchLoc) return n3(a4.catchLoc, true);
                    if (this.prev < a4.finallyLoc) return n3(a4.finallyLoc);
                  } else if (u4) {
                    if (this.prev < a4.catchLoc) return n3(a4.catchLoc, true);
                  } else {
                    if (!f4) throw Error("try statement without catch or finally");
                    if (this.prev < a4.finallyLoc) return n3(a4.finallyLoc);
                  }
                }
              }
            }, abrupt: function(t5, r5) {
              for (var e6 = this.tryEntries.length - 1; e6 >= 0; --e6) {
                var n3 = this.tryEntries[e6];
                if (n3.tryLoc <= this.prev && o3.call(n3, "finallyLoc") && this.prev < n3.finallyLoc) {
                  var i3 = n3;
                  break;
                }
              }
              i3 && ("break" === t5 || "continue" === t5) && i3.tryLoc <= r5 && r5 <= i3.finallyLoc && (i3 = null);
              var a4 = i3 ? i3.completion : {};
              return a4.type = t5, a4.arg = r5, i3 ? (this.method = "next", this.next = i3.finallyLoc, m3) : this.complete(a4);
            }, complete: function(t5, r5) {
              if ("throw" === t5.type) throw t5.arg;
              return "break" === t5.type || "continue" === t5.type ? this.next = t5.arg : "return" === t5.type ? (this.rval = this.arg = t5.arg, this.method = "return", this.next = "end") : "normal" === t5.type && r5 && (this.next = r5), m3;
            }, finish: function(t5) {
              for (var r5 = this.tryEntries.length - 1; r5 >= 0; --r5) {
                var e6 = this.tryEntries[r5];
                if (e6.finallyLoc === t5) return this.complete(e6.completion, e6.afterLoc), N2(e6), m3;
              }
            }, catch: function(t5) {
              for (var r5 = this.tryEntries.length - 1; r5 >= 0; --r5) {
                var e6 = this.tryEntries[r5];
                if (e6.tryLoc === t5) {
                  var n3 = e6.completion;
                  if ("throw" === n3.type) {
                    var o4 = n3.arg;
                    N2(e6);
                  }
                  return o4;
                }
              }
              throw Error("illegal catch attempt");
            }, delegateYield: function(r5, e6, n3) {
              return this.delegate = { iterator: I2(r5), resultName: e6, nextLoc: n3 }, "next" === this.method && (this.arg = t4), m3;
            } }, r4;
          }
          function a2(t4, r4) {
            (null == r4 || r4 > t4.length) && (r4 = t4.length);
            for (var e5 = 0, n3 = Array(r4); e5 < r4; e5++) n3[e5] = t4[e5];
            return n3;
          }
          function c2(t4, r4) {
            var e5 = Object.keys(t4);
            if (Object.getOwnPropertySymbols) {
              var n3 = Object.getOwnPropertySymbols(t4);
              r4 && (n3 = n3.filter(function(r5) {
                return Object.getOwnPropertyDescriptor(t4, r5).enumerable;
              })), e5.push.apply(e5, n3);
            }
            return e5;
          }
          function u2(t4) {
            for (var r4 = 1; r4 < arguments.length; r4++) {
              var e5 = null != arguments[r4] ? arguments[r4] : {};
              r4 % 2 ? c2(Object(e5), true).forEach(function(r5) {
                f2(t4, r5, e5[r5]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(e5)) : c2(Object(e5)).forEach(function(r5) {
                Object.defineProperty(t4, r5, Object.getOwnPropertyDescriptor(e5, r5));
              });
            }
            return t4;
          }
          function f2(t4, r4, e5) {
            return (r4 = function(t5) {
              var r5 = function(t6) {
                if ("object" != n2(t6) || !t6) return t6;
                var r6 = t6[Symbol.toPrimitive];
                if (void 0 !== r6) {
                  var e6 = r6.call(t6, "string");
                  if ("object" != n2(e6)) return e6;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(t6);
              }(t5);
              return "symbol" == n2(r5) ? r5 : r5 + "";
            }(r4)) in t4 ? Object.defineProperty(t4, r4, { value: e5, enumerable: true, configurable: true, writable: true }) : t4[r4] = e5, t4;
          }
          function l2(t4, r4) {
            if (null == t4) return {};
            var e5, n3, o3 = function(t5, r5) {
              if (null == t5) return {};
              var e6 = {};
              for (var n4 in t5) if ({}.hasOwnProperty.call(t5, n4)) {
                if (r5.includes(n4)) continue;
                e6[n4] = t5[n4];
              }
              return e6;
            }(t4, r4);
            if (Object.getOwnPropertySymbols) {
              var i3 = Object.getOwnPropertySymbols(t4);
              for (n3 = 0; n3 < i3.length; n3++) e5 = i3[n3], r4.includes(e5) || {}.propertyIsEnumerable.call(t4, e5) && (o3[e5] = t4[e5]);
            }
            return o3;
          }
          function s2(t4, r4, e5, n3, o3, i3, a3) {
            try {
              var c3 = t4[i3](a3), u3 = c3.value;
            } catch (t5) {
              return void e5(t5);
            }
            c3.done ? r4(u3) : Promise.resolve(u3).then(n3, o3);
          }
          function h2(t4) {
            return function() {
              var r4 = this, e5 = arguments;
              return new Promise(function(n3, o3) {
                var i3 = t4.apply(r4, e5);
                function a3(t5) {
                  s2(i3, n3, o3, a3, c3, "next", t5);
                }
                function c3(t5) {
                  s2(i3, n3, o3, a3, c3, "throw", t5);
                }
                a3(void 0);
              });
            };
          }
          var p2 = e4(898), y2 = e4(825), v2 = e4(13), d2 = e4(86).log, g2 = e4(857), m2 = e4(287), b2 = e4(250), w2 = b2.defaultOptions, L2 = b2.spawnWorker, x2 = b2.terminateWorker, O2 = b2.onMessage, E2 = b2.loadImage, S2 = b2.send, j2 = 0;
          t3.exports = h2(i2().mark(function t4() {
            var r4, e5, n3, c3, f3, s3, b3, P2, k2, _2, T2, N2, A2, I2, G2, F2, R2, D2, M2, C2, U2, Y2, B2, z2, H2, K2, W2, J2, V2, Z2, Q2, q2, X2, $2, tt2, rt2, et2, nt2, ot2, it2 = arguments;
            return i2().wrap(function(t5) {
              for (; ; ) switch (t5.prev = t5.next) {
                case 0:
                  return r4 = it2.length > 0 && void 0 !== it2[0] ? it2[0] : "eng", e5 = it2.length > 1 && void 0 !== it2[1] ? it2[1] : m2.LSTM_ONLY, n3 = it2.length > 2 && void 0 !== it2[2] ? it2[2] : {}, c3 = it2.length > 3 && void 0 !== it2[3] ? it2[3] : {}, f3 = g2("Worker", j2), s3 = p2(u2(u2({}, w2), n3)), b3 = s3.logger, P2 = s3.errorHandler, k2 = l2(s3, o2), _2 = {}, T2 = "string" == typeof r4 ? r4.split("+") : r4, N2 = e5, A2 = c3, I2 = [m2.DEFAULT, m2.LSTM_ONLY].includes(e5) && !k2.legacyCore, R2 = new Promise(function(t6, r5) {
                    F2 = t6, G2 = r5;
                  }), D2 = function(t6) {
                    G2(t6.message);
                  }, (M2 = L2(k2)).onerror = D2, j2 += 1, C2 = function(t6) {
                    var r5 = t6.id, e6 = t6.action, n4 = t6.payload;
                    return new Promise(function(t7, o3) {
                      d2("[".concat(f3, "]: Start ").concat(r5, ", action=").concat(e6));
                      var i3 = "".concat(e6, "-").concat(r5);
                      _2[i3] = { resolve: t7, reject: o3 }, S2(M2, { workerId: f3, jobId: r5, action: e6, payload: n4 });
                    });
                  }, U2 = function(t6) {
                    var r5 = t6.id, e6 = t6.action, n4 = t6.payload, o3 = new Promise(function(t7, n5) {
                      d2("[".concat(f3, "]: Start ").concat(r5, ", action=").concat(e6));
                      var o4 = "".concat(e6, "-").concat(r5, "b");
                      _2[o4] = { resolve: t7, reject: n5 };
                    });
                    return [new Promise(function(t7, o4) {
                      d2("[".concat(f3, "]: Start ").concat(r5, ", action=").concat(e6));
                      var i3 = "".concat(e6, "-").concat(r5);
                      _2[i3] = { resolve: t7, reject: o4 }, S2(M2, { workerId: f3, jobId: r5, action: e6, payload: n4 });
                    }), o3];
                  }, Y2 = function() {
                    return console.warn("`load` is depreciated and should be removed from code (workers now come pre-loaded)");
                  }, B2 = function(t6) {
                    return C2(v2({ id: t6, action: "load", payload: { options: { lstmOnly: I2, corePath: k2.corePath, logging: k2.logging } } }));
                  }, z2 = function(t6, r5, e6) {
                    return C2(v2({ id: e6, action: "FS", payload: { method: "writeFile", args: [t6, r5] } }));
                  }, H2 = function(t6, r5) {
                    return C2(v2({ id: r5, action: "FS", payload: { method: "readFile", args: [t6, { encoding: "utf8" }] } }));
                  }, K2 = function(t6, r5) {
                    return C2(v2({ id: r5, action: "FS", payload: { method: "unlink", args: [t6] } }));
                  }, W2 = function(t6, r5, e6) {
                    return C2(v2({ id: e6, action: "FS", payload: { method: t6, args: r5 } }));
                  }, J2 = function() {
                    return console.warn("`loadLanguage` is depreciated and should be removed from code (workers now come with language pre-loaded)");
                  }, V2 = function(t6, r5) {
                    return C2(v2({ id: r5, action: "loadLanguage", payload: { langs: t6, options: { langPath: k2.langPath, dataPath: k2.dataPath, cachePath: k2.cachePath, cacheMethod: k2.cacheMethod, gzip: k2.gzip, lstmOnly: [m2.LSTM_ONLY, m2.TESSERACT_LSTM_COMBINED].includes(N2) && !k2.legacyLang } } }));
                  }, Z2 = function() {
                    return console.warn("`initialize` is depreciated and should be removed from code (workers now come pre-initialized)");
                  }, Q2 = function(t6, r5, e6, n4) {
                    return C2(v2({ id: n4, action: "initialize", payload: { langs: t6, oem: r5, config: e6 } }));
                  }, q2 = function() {
                    var t6 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "eng", r5 = arguments.length > 1 ? arguments[1] : void 0, e6 = arguments.length > 2 ? arguments[2] : void 0, n4 = arguments.length > 3 ? arguments[3] : void 0;
                    if (I2 && [m2.TESSERACT_ONLY, m2.TESSERACT_LSTM_COMBINED].includes(r5)) throw Error("Legacy model requested but code missing.");
                    var o3 = r5 || N2;
                    N2 = o3;
                    var i3 = e6 || A2;
                    A2 = i3;
                    var c4, u3 = ("string" == typeof t6 ? t6.split("+") : t6).filter(function(t7) {
                      return !T2.includes(t7);
                    });
                    return T2.push.apply(T2, function(t7) {
                      if (Array.isArray(t7)) return a2(t7);
                    }(c4 = u3) || function(t7) {
                      if ("undefined" != typeof Symbol && null != t7[Symbol.iterator] || null != t7["@@iterator"]) return Array.from(t7);
                    }(c4) || function(t7, r6) {
                      if (t7) {
                        if ("string" == typeof t7) return a2(t7, r6);
                        var e7 = {}.toString.call(t7).slice(8, -1);
                        return "Object" === e7 && t7.constructor && (e7 = t7.constructor.name), "Map" === e7 || "Set" === e7 ? Array.from(t7) : "Arguments" === e7 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e7) ? a2(t7, r6) : void 0;
                      }
                    }(c4) || function() {
                      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    }()), u3.length > 0 ? V2(u3, n4).then(function() {
                      return Q2(t6, o3, i3, n4);
                    }) : Q2(t6, o3, i3, n4);
                  }, X2 = function() {
                    return C2(v2({ id: arguments.length > 1 ? arguments[1] : void 0, action: "setParameters", payload: { params: arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {} } }));
                  }, $2 = function() {
                    var t6 = h2(i2().mark(function t7(r5) {
                      var e6, n4, o3, a3 = arguments;
                      return i2().wrap(function(t8) {
                        for (; ; ) switch (t8.prev = t8.next) {
                          case 0:
                            return e6 = a3.length > 1 && void 0 !== a3[1] ? a3[1] : {}, n4 = a3.length > 2 && void 0 !== a3[2] ? a3[2] : { blocks: true, text: true, hocr: true, tsv: true }, o3 = a3.length > 3 ? a3[3] : void 0, t8.t0 = C2, t8.t1 = v2, t8.t2 = o3, t8.next = 8, E2(r5);
                          case 8:
                            return t8.t3 = t8.sent, t8.t4 = e6, t8.t5 = n4, t8.t6 = { image: t8.t3, options: t8.t4, output: t8.t5 }, t8.t7 = { id: t8.t2, action: "recognize", payload: t8.t6 }, t8.t8 = (0, t8.t1)(t8.t7), t8.abrupt("return", (0, t8.t0)(t8.t8));
                          case 15:
                          case "end":
                            return t8.stop();
                        }
                      }, t7);
                    }));
                    return function(r5) {
                      return t6.apply(this, arguments);
                    };
                  }(), tt2 = function() {
                    var t6 = h2(i2().mark(function t7(r5) {
                      var e6, n4, o3, a3 = arguments;
                      return i2().wrap(function(t8) {
                        for (; ; ) switch (t8.prev = t8.next) {
                          case 0:
                            return e6 = a3.length > 1 && void 0 !== a3[1] ? a3[1] : {}, n4 = a3.length > 2 && void 0 !== a3[2] ? a3[2] : { blocks: true, text: true, hocr: true, tsv: true }, o3 = a3.length > 3 ? a3[3] : void 0, t8.t0 = U2, t8.t1 = v2, t8.t2 = o3, t8.next = 8, E2(r5);
                          case 8:
                            return t8.t3 = t8.sent, t8.t4 = e6, t8.t5 = n4, t8.t6 = { image: t8.t3, options: t8.t4, output: t8.t5 }, t8.t7 = { id: t8.t2, action: "recognize2", payload: t8.t6 }, t8.t8 = (0, t8.t1)(t8.t7), t8.abrupt("return", (0, t8.t0)(t8.t8));
                          case 15:
                          case "end":
                            return t8.stop();
                        }
                      }, t7);
                    }));
                    return function(r5) {
                      return t6.apply(this, arguments);
                    };
                  }(), rt2 = function() {
                    var t6 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "Tesseract OCR Result", r5 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], e6 = arguments.length > 2 ? arguments[2] : void 0;
                    return console.log("`getPDF` function is depreciated. `recognize` option `savePDF` should be used instead."), C2(v2({ id: e6, action: "getPDF", payload: { title: t6, textonly: r5 } }));
                  }, et2 = function() {
                    var t6 = h2(i2().mark(function t7(r5, e6) {
                      return i2().wrap(function(t8) {
                        for (; ; ) switch (t8.prev = t8.next) {
                          case 0:
                            if (!I2) {
                              t8.next = 2;
                              break;
                            }
                            throw Error("`worker.detect` requires Legacy model, which was not loaded.");
                          case 2:
                            return t8.t0 = C2, t8.t1 = v2, t8.t2 = e6, t8.next = 7, E2(r5);
                          case 7:
                            return t8.t3 = t8.sent, t8.t4 = { image: t8.t3 }, t8.t5 = { id: t8.t2, action: "detect", payload: t8.t4 }, t8.t6 = (0, t8.t1)(t8.t5), t8.abrupt("return", (0, t8.t0)(t8.t6));
                          case 12:
                          case "end":
                            return t8.stop();
                        }
                      }, t7);
                    }));
                    return function(r5, e6) {
                      return t6.apply(this, arguments);
                    };
                  }(), nt2 = function() {
                    var t6 = h2(i2().mark(function t7() {
                      return i2().wrap(function(t8) {
                        for (; ; ) switch (t8.prev = t8.next) {
                          case 0:
                            return null !== M2 && (x2(M2), M2 = null), t8.abrupt("return", Promise.resolve());
                          case 2:
                          case "end":
                            return t8.stop();
                        }
                      }, t7);
                    }));
                    return function() {
                      return t6.apply(this, arguments);
                    };
                  }(), O2(M2, function(t6) {
                    var r5 = t6.workerId, e6 = t6.jobId, n4 = t6.status, o3 = t6.action, i3 = t6.data, a3 = "".concat(o3, "-").concat(e6);
                    if ("resolve" === n4) {
                      d2("[".concat(r5, "]: Complete ").concat(e6));
                      var c4 = i3;
                      "recognize" === o3 ? c4 = y2(i3) : "getPDF" === o3 && (c4 = Array.from(u2(u2({}, i3), {}, { length: Object.keys(i3).length }))), _2[a3].resolve({ jobId: e6, data: c4 }), delete _2[a3];
                    } else if ("reject" === n4) {
                      if (_2[a3].reject(i3), delete _2[a3], "load" === o3 && G2(i3), !P2) throw Error(i3);
                      P2(i3);
                    } else "progress" === n4 && b3(u2(u2({}, i3), {}, { userJobId: e6 }));
                  }), ot2 = { id: f3, worker: M2, load: Y2, writeText: z2, readText: H2, removeFile: K2, FS: W2, loadLanguage: J2, initialize: Z2, reinitialize: q2, setParameters: X2, recognize: $2, recognize2: tt2, getPDF: rt2, detect: et2, terminate: nt2 }, B2().then(function() {
                    return V2(r4);
                  }).then(function() {
                    return Q2(r4, e5, c3);
                  }).then(function() {
                    return F2(ot2);
                  }).catch(function() {
                  }), t5.abrupt("return", R2);
                case 39:
                case "end":
                  return t5.stop();
              }
            }, t4);
          }));
        }, 954: (t3, r3, e4) => {
          function n2(t4) {
            return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, n2(t4);
          }
          function o2(t4, r4) {
            var e5 = Object.keys(t4);
            if (Object.getOwnPropertySymbols) {
              var n3 = Object.getOwnPropertySymbols(t4);
              r4 && (n3 = n3.filter(function(r5) {
                return Object.getOwnPropertyDescriptor(t4, r5).enumerable;
              })), e5.push.apply(e5, n3);
            }
            return e5;
          }
          function i2(t4, r4, e5) {
            return (r4 = function(t5) {
              var r5 = function(t6) {
                if ("object" != n2(t6) || !t6) return t6;
                var r6 = t6[Symbol.toPrimitive];
                if (void 0 !== r6) {
                  var e6 = r6.call(t6, "string");
                  if ("object" != n2(e6)) return e6;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(t6);
              }(t5);
              return "symbol" == n2(r5) ? r5 : r5 + "";
            }(r4)) in t4 ? Object.defineProperty(t4, r4, { value: e5, enumerable: true, configurable: true, writable: true }) : t4[r4] = e5, t4;
          }
          e4(30);
          var a2 = e4(695), c2 = e4(738), u2 = e4(52), f2 = e4(11), l2 = e4(287), s2 = e4(188), h2 = e4(86).setLogging;
          t3.exports = function(t4) {
            for (var r4 = 1; r4 < arguments.length; r4++) {
              var e5 = null != arguments[r4] ? arguments[r4] : {};
              r4 % 2 ? o2(Object(e5), true).forEach(function(r5) {
                i2(t4, r5, e5[r5]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(e5)) : o2(Object(e5)).forEach(function(r5) {
                Object.defineProperty(t4, r5, Object.getOwnPropertyDescriptor(e5, r5));
              });
            }
            return t4;
          }({ languages: f2, OEM: l2, PSM: s2, createScheduler: a2, createWorker: c2, setLogging: h2 }, u2);
        }, 825: (t3) => {
          function r3(t4) {
            return r3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, r3(t4);
          }
          function e4(t4, r4) {
            var e5 = Object.keys(t4);
            if (Object.getOwnPropertySymbols) {
              var n3 = Object.getOwnPropertySymbols(t4);
              r4 && (n3 = n3.filter(function(r5) {
                return Object.getOwnPropertyDescriptor(t4, r5).enumerable;
              })), e5.push.apply(e5, n3);
            }
            return e5;
          }
          function n2(t4) {
            for (var r4 = 1; r4 < arguments.length; r4++) {
              var n3 = null != arguments[r4] ? arguments[r4] : {};
              r4 % 2 ? e4(Object(n3), true).forEach(function(r5) {
                o2(t4, r5, n3[r5]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(n3)) : e4(Object(n3)).forEach(function(r5) {
                Object.defineProperty(t4, r5, Object.getOwnPropertyDescriptor(n3, r5));
              });
            }
            return t4;
          }
          function o2(t4, e5, n3) {
            return (e5 = function(t5) {
              var e6 = function(t6) {
                if ("object" != r3(t6) || !t6) return t6;
                var e7 = t6[Symbol.toPrimitive];
                if (void 0 !== e7) {
                  var n4 = e7.call(t6, "string");
                  if ("object" != r3(n4)) return n4;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(t6);
              }(t5);
              return "symbol" == r3(e6) ? e6 : e6 + "";
            }(e5)) in t4 ? Object.defineProperty(t4, e5, { value: n3, enumerable: true, configurable: true, writable: true }) : t4[e5] = n3, t4;
          }
          t3.exports = function(t4) {
            var r4 = [], e5 = [], o3 = [], i2 = [], a2 = [];
            return t4.blocks && t4.blocks.forEach(function(c2) {
              c2.paragraphs.forEach(function(r5) {
                r5.lines.forEach(function(e6) {
                  e6.words.forEach(function(o4) {
                    o4.symbols.forEach(function(i3) {
                      a2.push(n2(n2({}, i3), {}, { page: t4, block: c2, paragraph: r5, line: e6, word: o4 }));
                    }), i2.push(n2(n2({}, o4), {}, { page: t4, block: c2, paragraph: r5, line: e6 }));
                  }), o3.push(n2(n2({}, e6), {}, { page: t4, block: c2, paragraph: r5 }));
                }), e5.push(n2(n2({}, r5), {}, { page: t4, block: c2 }));
              }), r4.push(n2(n2({}, c2), {}, { page: t4 }));
            }), n2(n2({}, t4), {}, { blocks: r4, paragraphs: e5, lines: o3, words: i2, symbols: a2 });
          };
        }, 827: (t3) => {
          function r3(t4) {
            return r3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, r3(t4);
          }
          t3.exports = function(t4) {
            var e4 = {};
            return "undefined" != typeof WorkerGlobalScope ? e4.type = "webworker" : "object" === ("undefined" == typeof document ? "undefined" : r3(document)) ? e4.type = "browser" : "object" === ("undefined" == typeof process ? "undefined" : r3(process)) && (e4.type = "node"), void 0 === t4 ? e4 : e4[t4];
          };
        }, 857: (t3) => {
          t3.exports = function(t4, r3) {
            return "".concat(t4, "-").concat(r3, "-").concat(Math.random().toString(16).slice(3, 8));
          };
        }, 86: function(t3, r3) {
          var e4 = this, n2 = false;
          r3.logging = n2, r3.setLogging = function(t4) {
            n2 = t4;
          }, r3.log = function() {
            for (var t4 = arguments.length, r4 = new Array(t4), o2 = 0; o2 < t4; o2++) r4[o2] = arguments[o2];
            return n2 ? console.log.apply(e4, r4) : null;
          };
        }, 898: (t3, r3, e4) => {
          function n2(t4) {
            return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, n2(t4);
          }
          function o2(t4, r4) {
            var e5 = Object.keys(t4);
            if (Object.getOwnPropertySymbols) {
              var n3 = Object.getOwnPropertySymbols(t4);
              r4 && (n3 = n3.filter(function(r5) {
                return Object.getOwnPropertyDescriptor(t4, r5).enumerable;
              })), e5.push.apply(e5, n3);
            }
            return e5;
          }
          function i2(t4, r4, e5) {
            return (r4 = function(t5) {
              var r5 = function(t6) {
                if ("object" != n2(t6) || !t6) return t6;
                var r6 = t6[Symbol.toPrimitive];
                if (void 0 !== r6) {
                  var e6 = r6.call(t6, "string");
                  if ("object" != n2(e6)) return e6;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(t6);
              }(t5);
              return "symbol" == n2(r5) ? r5 : r5 + "";
            }(r4)) in t4 ? Object.defineProperty(t4, r4, { value: e5, enumerable: true, configurable: true, writable: true }) : t4[r4] = e5, t4;
          }
          var a2 = "browser" === e4(827)("type") ? function(t4) {
            return new URL(t4, window.location.href).href;
          } : function(t4) {
            return t4;
          };
          t3.exports = function(t4) {
            var r4 = function(t5) {
              for (var r5 = 1; r5 < arguments.length; r5++) {
                var e5 = null != arguments[r5] ? arguments[r5] : {};
                r5 % 2 ? o2(Object(e5), true).forEach(function(r6) {
                  i2(t5, r6, e5[r6]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t5, Object.getOwnPropertyDescriptors(e5)) : o2(Object(e5)).forEach(function(r6) {
                  Object.defineProperty(t5, r6, Object.getOwnPropertyDescriptor(e5, r6));
                });
              }
              return t5;
            }({}, t4);
            return ["corePath", "workerPath", "langPath"].forEach(function(e5) {
              t4[e5] && (r4[e5] = a2(r4[e5]));
            }), r4;
          };
        }, 989: (t3, r3, e4) => {
          function n2(t4) {
            return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, n2(t4);
          }
          function o2(t4, r4) {
            var e5 = Object.keys(t4);
            if (Object.getOwnPropertySymbols) {
              var n3 = Object.getOwnPropertySymbols(t4);
              r4 && (n3 = n3.filter(function(r5) {
                return Object.getOwnPropertyDescriptor(t4, r5).enumerable;
              })), e5.push.apply(e5, n3);
            }
            return e5;
          }
          function i2(t4) {
            for (var r4 = 1; r4 < arguments.length; r4++) {
              var e5 = null != arguments[r4] ? arguments[r4] : {};
              r4 % 2 ? o2(Object(e5), true).forEach(function(r5) {
                a2(t4, r5, e5[r5]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(e5)) : o2(Object(e5)).forEach(function(r5) {
                Object.defineProperty(t4, r5, Object.getOwnPropertyDescriptor(e5, r5));
              });
            }
            return t4;
          }
          function a2(t4, r4, e5) {
            return (r4 = function(t5) {
              var r5 = function(t6) {
                if ("object" != n2(t6) || !t6) return t6;
                var r6 = t6[Symbol.toPrimitive];
                if (void 0 !== r6) {
                  var e6 = r6.call(t6, "string");
                  if ("object" != n2(e6)) return e6;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(t6);
              }(t5);
              return "symbol" == n2(r5) ? r5 : r5 + "";
            }(r4)) in t4 ? Object.defineProperty(t4, r4, { value: e5, enumerable: true, configurable: true, writable: true }) : t4[r4] = e5, t4;
          }
          var c2 = e4(330).rE, u2 = e4(491);
          t3.exports = i2(i2({}, u2), {}, { workerPath: "https://cdn.jsdelivr.net/npm/tesseract.js@v".concat(c2, "/dist/worker.min.js") });
        }, 250: (t3, r3, e4) => {
          var n2 = e4(989), o2 = e4(423), i2 = e4(399), a2 = e4(278), c2 = e4(782), u2 = e4(383);
          t3.exports = { defaultOptions: n2, spawnWorker: o2, terminateWorker: i2, onMessage: a2, send: c2, loadImage: u2 };
        }, 383: (t3) => {
          function r3(t4) {
            return r3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, r3(t4);
          }
          function e4() {
            e4 = function() {
              return n3;
            };
            var t4, n3 = {}, o3 = Object.prototype, i3 = o3.hasOwnProperty, a3 = Object.defineProperty || function(t5, r4, e5) {
              t5[r4] = e5.value;
            }, c2 = "function" == typeof Symbol ? Symbol : {}, u2 = c2.iterator || "@@iterator", f2 = c2.asyncIterator || "@@asyncIterator", l2 = c2.toStringTag || "@@toStringTag";
            function s2(t5, r4, e5) {
              return Object.defineProperty(t5, r4, { value: e5, enumerable: true, configurable: true, writable: true }), t5[r4];
            }
            try {
              s2({}, "");
            } catch (t5) {
              s2 = function(t6, r4, e5) {
                return t6[r4] = e5;
              };
            }
            function h2(t5, r4, e5, n4) {
              var o4 = r4 && r4.prototype instanceof b2 ? r4 : b2, i4 = Object.create(o4.prototype), c3 = new A2(n4 || []);
              return a3(i4, "_invoke", { value: k2(t5, e5, c3) }), i4;
            }
            function p2(t5, r4, e5) {
              try {
                return { type: "normal", arg: t5.call(r4, e5) };
              } catch (t6) {
                return { type: "throw", arg: t6 };
              }
            }
            n3.wrap = h2;
            var y2 = "suspendedStart", v2 = "suspendedYield", d2 = "executing", g2 = "completed", m2 = {};
            function b2() {
            }
            function w2() {
            }
            function L2() {
            }
            var x2 = {};
            s2(x2, u2, function() {
              return this;
            });
            var O2 = Object.getPrototypeOf, E2 = O2 && O2(O2(I2([])));
            E2 && E2 !== o3 && i3.call(E2, u2) && (x2 = E2);
            var S2 = L2.prototype = b2.prototype = Object.create(x2);
            function j2(t5) {
              ["next", "throw", "return"].forEach(function(r4) {
                s2(t5, r4, function(t6) {
                  return this._invoke(r4, t6);
                });
              });
            }
            function P2(t5, e5) {
              function n4(o5, a4, c3, u3) {
                var f3 = p2(t5[o5], t5, a4);
                if ("throw" !== f3.type) {
                  var l3 = f3.arg, s3 = l3.value;
                  return s3 && "object" == r3(s3) && i3.call(s3, "__await") ? e5.resolve(s3.__await).then(function(t6) {
                    n4("next", t6, c3, u3);
                  }, function(t6) {
                    n4("throw", t6, c3, u3);
                  }) : e5.resolve(s3).then(function(t6) {
                    l3.value = t6, c3(l3);
                  }, function(t6) {
                    return n4("throw", t6, c3, u3);
                  });
                }
                u3(f3.arg);
              }
              var o4;
              a3(this, "_invoke", { value: function(t6, r4) {
                function i4() {
                  return new e5(function(e6, o5) {
                    n4(t6, r4, e6, o5);
                  });
                }
                return o4 = o4 ? o4.then(i4, i4) : i4();
              } });
            }
            function k2(r4, e5, n4) {
              var o4 = y2;
              return function(i4, a4) {
                if (o4 === d2) throw Error("Generator is already running");
                if (o4 === g2) {
                  if ("throw" === i4) throw a4;
                  return { value: t4, done: true };
                }
                for (n4.method = i4, n4.arg = a4; ; ) {
                  var c3 = n4.delegate;
                  if (c3) {
                    var u3 = _2(c3, n4);
                    if (u3) {
                      if (u3 === m2) continue;
                      return u3;
                    }
                  }
                  if ("next" === n4.method) n4.sent = n4._sent = n4.arg;
                  else if ("throw" === n4.method) {
                    if (o4 === y2) throw o4 = g2, n4.arg;
                    n4.dispatchException(n4.arg);
                  } else "return" === n4.method && n4.abrupt("return", n4.arg);
                  o4 = d2;
                  var f3 = p2(r4, e5, n4);
                  if ("normal" === f3.type) {
                    if (o4 = n4.done ? g2 : v2, f3.arg === m2) continue;
                    return { value: f3.arg, done: n4.done };
                  }
                  "throw" === f3.type && (o4 = g2, n4.method = "throw", n4.arg = f3.arg);
                }
              };
            }
            function _2(r4, e5) {
              var n4 = e5.method, o4 = r4.iterator[n4];
              if (o4 === t4) return e5.delegate = null, "throw" === n4 && r4.iterator.return && (e5.method = "return", e5.arg = t4, _2(r4, e5), "throw" === e5.method) || "return" !== n4 && (e5.method = "throw", e5.arg = new TypeError("The iterator does not provide a '" + n4 + "' method")), m2;
              var i4 = p2(o4, r4.iterator, e5.arg);
              if ("throw" === i4.type) return e5.method = "throw", e5.arg = i4.arg, e5.delegate = null, m2;
              var a4 = i4.arg;
              return a4 ? a4.done ? (e5[r4.resultName] = a4.value, e5.next = r4.nextLoc, "return" !== e5.method && (e5.method = "next", e5.arg = t4), e5.delegate = null, m2) : a4 : (e5.method = "throw", e5.arg = new TypeError("iterator result is not an object"), e5.delegate = null, m2);
            }
            function T2(t5) {
              var r4 = { tryLoc: t5[0] };
              1 in t5 && (r4.catchLoc = t5[1]), 2 in t5 && (r4.finallyLoc = t5[2], r4.afterLoc = t5[3]), this.tryEntries.push(r4);
            }
            function N2(t5) {
              var r4 = t5.completion || {};
              r4.type = "normal", delete r4.arg, t5.completion = r4;
            }
            function A2(t5) {
              this.tryEntries = [{ tryLoc: "root" }], t5.forEach(T2, this), this.reset(true);
            }
            function I2(e5) {
              if (e5 || "" === e5) {
                var n4 = e5[u2];
                if (n4) return n4.call(e5);
                if ("function" == typeof e5.next) return e5;
                if (!isNaN(e5.length)) {
                  var o4 = -1, a4 = function r4() {
                    for (; ++o4 < e5.length; ) if (i3.call(e5, o4)) return r4.value = e5[o4], r4.done = false, r4;
                    return r4.value = t4, r4.done = true, r4;
                  };
                  return a4.next = a4;
                }
              }
              throw new TypeError(r3(e5) + " is not iterable");
            }
            return w2.prototype = L2, a3(S2, "constructor", { value: L2, configurable: true }), a3(L2, "constructor", { value: w2, configurable: true }), w2.displayName = s2(L2, l2, "GeneratorFunction"), n3.isGeneratorFunction = function(t5) {
              var r4 = "function" == typeof t5 && t5.constructor;
              return !!r4 && (r4 === w2 || "GeneratorFunction" === (r4.displayName || r4.name));
            }, n3.mark = function(t5) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(t5, L2) : (t5.__proto__ = L2, s2(t5, l2, "GeneratorFunction")), t5.prototype = Object.create(S2), t5;
            }, n3.awrap = function(t5) {
              return { __await: t5 };
            }, j2(P2.prototype), s2(P2.prototype, f2, function() {
              return this;
            }), n3.AsyncIterator = P2, n3.async = function(t5, r4, e5, o4, i4) {
              void 0 === i4 && (i4 = Promise);
              var a4 = new P2(h2(t5, r4, e5, o4), i4);
              return n3.isGeneratorFunction(r4) ? a4 : a4.next().then(function(t6) {
                return t6.done ? t6.value : a4.next();
              });
            }, j2(S2), s2(S2, l2, "Generator"), s2(S2, u2, function() {
              return this;
            }), s2(S2, "toString", function() {
              return "[object Generator]";
            }), n3.keys = function(t5) {
              var r4 = Object(t5), e5 = [];
              for (var n4 in r4) e5.push(n4);
              return e5.reverse(), function t6() {
                for (; e5.length; ) {
                  var n5 = e5.pop();
                  if (n5 in r4) return t6.value = n5, t6.done = false, t6;
                }
                return t6.done = true, t6;
              };
            }, n3.values = I2, A2.prototype = { constructor: A2, reset: function(r4) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = t4, this.done = false, this.delegate = null, this.method = "next", this.arg = t4, this.tryEntries.forEach(N2), !r4) for (var e5 in this) "t" === e5.charAt(0) && i3.call(this, e5) && !isNaN(+e5.slice(1)) && (this[e5] = t4);
            }, stop: function() {
              this.done = true;
              var t5 = this.tryEntries[0].completion;
              if ("throw" === t5.type) throw t5.arg;
              return this.rval;
            }, dispatchException: function(r4) {
              if (this.done) throw r4;
              var e5 = this;
              function n4(n5, o5) {
                return c3.type = "throw", c3.arg = r4, e5.next = n5, o5 && (e5.method = "next", e5.arg = t4), !!o5;
              }
              for (var o4 = this.tryEntries.length - 1; o4 >= 0; --o4) {
                var a4 = this.tryEntries[o4], c3 = a4.completion;
                if ("root" === a4.tryLoc) return n4("end");
                if (a4.tryLoc <= this.prev) {
                  var u3 = i3.call(a4, "catchLoc"), f3 = i3.call(a4, "finallyLoc");
                  if (u3 && f3) {
                    if (this.prev < a4.catchLoc) return n4(a4.catchLoc, true);
                    if (this.prev < a4.finallyLoc) return n4(a4.finallyLoc);
                  } else if (u3) {
                    if (this.prev < a4.catchLoc) return n4(a4.catchLoc, true);
                  } else {
                    if (!f3) throw Error("try statement without catch or finally");
                    if (this.prev < a4.finallyLoc) return n4(a4.finallyLoc);
                  }
                }
              }
            }, abrupt: function(t5, r4) {
              for (var e5 = this.tryEntries.length - 1; e5 >= 0; --e5) {
                var n4 = this.tryEntries[e5];
                if (n4.tryLoc <= this.prev && i3.call(n4, "finallyLoc") && this.prev < n4.finallyLoc) {
                  var o4 = n4;
                  break;
                }
              }
              o4 && ("break" === t5 || "continue" === t5) && o4.tryLoc <= r4 && r4 <= o4.finallyLoc && (o4 = null);
              var a4 = o4 ? o4.completion : {};
              return a4.type = t5, a4.arg = r4, o4 ? (this.method = "next", this.next = o4.finallyLoc, m2) : this.complete(a4);
            }, complete: function(t5, r4) {
              if ("throw" === t5.type) throw t5.arg;
              return "break" === t5.type || "continue" === t5.type ? this.next = t5.arg : "return" === t5.type ? (this.rval = this.arg = t5.arg, this.method = "return", this.next = "end") : "normal" === t5.type && r4 && (this.next = r4), m2;
            }, finish: function(t5) {
              for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
                var e5 = this.tryEntries[r4];
                if (e5.finallyLoc === t5) return this.complete(e5.completion, e5.afterLoc), N2(e5), m2;
              }
            }, catch: function(t5) {
              for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
                var e5 = this.tryEntries[r4];
                if (e5.tryLoc === t5) {
                  var n4 = e5.completion;
                  if ("throw" === n4.type) {
                    var o4 = n4.arg;
                    N2(e5);
                  }
                  return o4;
                }
              }
              throw Error("illegal catch attempt");
            }, delegateYield: function(r4, e5, n4) {
              return this.delegate = { iterator: I2(r4), resultName: e5, nextLoc: n4 }, "next" === this.method && (this.arg = t4), m2;
            } }, n3;
          }
          function n2(t4, r4, e5, n3, o3, i3, a3) {
            try {
              var c2 = t4[i3](a3), u2 = c2.value;
            } catch (t5) {
              return void e5(t5);
            }
            c2.done ? r4(u2) : Promise.resolve(u2).then(n3, o3);
          }
          function o2(t4) {
            return function() {
              var r4 = this, e5 = arguments;
              return new Promise(function(o3, i3) {
                var a3 = t4.apply(r4, e5);
                function c2(t5) {
                  n2(a3, o3, i3, c2, u2, "next", t5);
                }
                function u2(t5) {
                  n2(a3, o3, i3, c2, u2, "throw", t5);
                }
                c2(void 0);
              });
            };
          }
          var i2 = function(t4) {
            return new Promise(function(r4, e5) {
              var n3 = new FileReader();
              n3.onload = function() {
                r4(n3.result);
              }, n3.onerror = function(t5) {
                var r5 = t5.target.error.code;
                e5(Error("File could not be read! Code=".concat(r5)));
              }, n3.readAsArrayBuffer(t4);
            });
          }, a2 = function() {
            var t4 = o2(e4().mark(function t5(r4) {
              var n3, c2, u2;
              return e4().wrap(function(t6) {
                for (; ; ) switch (t6.prev = t6.next) {
                  case 0:
                    if (n3 = r4, void 0 !== r4) {
                      t6.next = 3;
                      break;
                    }
                    return t6.abrupt("return", "undefined");
                  case 3:
                    if ("string" != typeof r4) {
                      t6.next = 16;
                      break;
                    }
                    if (!/data:image\/([a-zA-Z]*);base64,([^"]*)/.test(r4)) {
                      t6.next = 8;
                      break;
                    }
                    n3 = atob(r4.split(",")[1]).split("").map(function(t7) {
                      return t7.charCodeAt(0);
                    }), t6.next = 14;
                    break;
                  case 8:
                    return t6.next = 10, fetch(r4);
                  case 10:
                    return c2 = t6.sent, t6.next = 13, c2.arrayBuffer();
                  case 13:
                    n3 = t6.sent;
                  case 14:
                    t6.next = 43;
                    break;
                  case 16:
                    if (!("undefined" != typeof HTMLElement && r4 instanceof HTMLElement)) {
                      t6.next = 30;
                      break;
                    }
                    if ("IMG" !== r4.tagName) {
                      t6.next = 21;
                      break;
                    }
                    return t6.next = 20, a2(r4.src);
                  case 20:
                    n3 = t6.sent;
                  case 21:
                    if ("VIDEO" !== r4.tagName) {
                      t6.next = 25;
                      break;
                    }
                    return t6.next = 24, a2(r4.poster);
                  case 24:
                    n3 = t6.sent;
                  case 25:
                    if ("CANVAS" !== r4.tagName) {
                      t6.next = 28;
                      break;
                    }
                    return t6.next = 28, new Promise(function(t7) {
                      r4.toBlob(function() {
                        var r5 = o2(e4().mark(function r6(o3) {
                          return e4().wrap(function(r7) {
                            for (; ; ) switch (r7.prev = r7.next) {
                              case 0:
                                return r7.next = 2, i2(o3);
                              case 2:
                                n3 = r7.sent, t7();
                              case 4:
                              case "end":
                                return r7.stop();
                            }
                          }, r6);
                        }));
                        return function(t8) {
                          return r5.apply(this, arguments);
                        };
                      }());
                    });
                  case 28:
                    t6.next = 43;
                    break;
                  case 30:
                    if (!("undefined" != typeof OffscreenCanvas && r4 instanceof OffscreenCanvas)) {
                      t6.next = 39;
                      break;
                    }
                    return t6.next = 33, r4.convertToBlob();
                  case 33:
                    return u2 = t6.sent, t6.next = 36, i2(u2);
                  case 36:
                    n3 = t6.sent, t6.next = 43;
                    break;
                  case 39:
                    if (!(r4 instanceof File || r4 instanceof Blob)) {
                      t6.next = 43;
                      break;
                    }
                    return t6.next = 42, i2(r4);
                  case 42:
                    n3 = t6.sent;
                  case 43:
                    return t6.abrupt("return", new Uint8Array(n3));
                  case 44:
                  case "end":
                    return t6.stop();
                }
              }, t5);
            }));
            return function(r4) {
              return t4.apply(this, arguments);
            };
          }();
          t3.exports = a2;
        }, 278: (t3) => {
          t3.exports = function(t4, r3) {
            t4.onmessage = function(t5) {
              var e4 = t5.data;
              r3(e4);
            };
          };
        }, 782: (t3) => {
          function r3(t4) {
            return r3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
              return typeof t5;
            } : function(t5) {
              return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
            }, r3(t4);
          }
          function e4() {
            e4 = function() {
              return n3;
            };
            var t4, n3 = {}, o2 = Object.prototype, i2 = o2.hasOwnProperty, a2 = Object.defineProperty || function(t5, r4, e5) {
              t5[r4] = e5.value;
            }, c2 = "function" == typeof Symbol ? Symbol : {}, u2 = c2.iterator || "@@iterator", f2 = c2.asyncIterator || "@@asyncIterator", l2 = c2.toStringTag || "@@toStringTag";
            function s2(t5, r4, e5) {
              return Object.defineProperty(t5, r4, { value: e5, enumerable: true, configurable: true, writable: true }), t5[r4];
            }
            try {
              s2({}, "");
            } catch (t5) {
              s2 = function(t6, r4, e5) {
                return t6[r4] = e5;
              };
            }
            function h2(t5, r4, e5, n4) {
              var o3 = r4 && r4.prototype instanceof b2 ? r4 : b2, i3 = Object.create(o3.prototype), c3 = new A2(n4 || []);
              return a2(i3, "_invoke", { value: k2(t5, e5, c3) }), i3;
            }
            function p2(t5, r4, e5) {
              try {
                return { type: "normal", arg: t5.call(r4, e5) };
              } catch (t6) {
                return { type: "throw", arg: t6 };
              }
            }
            n3.wrap = h2;
            var y2 = "suspendedStart", v2 = "suspendedYield", d2 = "executing", g2 = "completed", m2 = {};
            function b2() {
            }
            function w2() {
            }
            function L2() {
            }
            var x2 = {};
            s2(x2, u2, function() {
              return this;
            });
            var O2 = Object.getPrototypeOf, E2 = O2 && O2(O2(I2([])));
            E2 && E2 !== o2 && i2.call(E2, u2) && (x2 = E2);
            var S2 = L2.prototype = b2.prototype = Object.create(x2);
            function j2(t5) {
              ["next", "throw", "return"].forEach(function(r4) {
                s2(t5, r4, function(t6) {
                  return this._invoke(r4, t6);
                });
              });
            }
            function P2(t5, e5) {
              function n4(o4, a3, c3, u3) {
                var f3 = p2(t5[o4], t5, a3);
                if ("throw" !== f3.type) {
                  var l3 = f3.arg, s3 = l3.value;
                  return s3 && "object" == r3(s3) && i2.call(s3, "__await") ? e5.resolve(s3.__await).then(function(t6) {
                    n4("next", t6, c3, u3);
                  }, function(t6) {
                    n4("throw", t6, c3, u3);
                  }) : e5.resolve(s3).then(function(t6) {
                    l3.value = t6, c3(l3);
                  }, function(t6) {
                    return n4("throw", t6, c3, u3);
                  });
                }
                u3(f3.arg);
              }
              var o3;
              a2(this, "_invoke", { value: function(t6, r4) {
                function i3() {
                  return new e5(function(e6, o4) {
                    n4(t6, r4, e6, o4);
                  });
                }
                return o3 = o3 ? o3.then(i3, i3) : i3();
              } });
            }
            function k2(r4, e5, n4) {
              var o3 = y2;
              return function(i3, a3) {
                if (o3 === d2) throw Error("Generator is already running");
                if (o3 === g2) {
                  if ("throw" === i3) throw a3;
                  return { value: t4, done: true };
                }
                for (n4.method = i3, n4.arg = a3; ; ) {
                  var c3 = n4.delegate;
                  if (c3) {
                    var u3 = _2(c3, n4);
                    if (u3) {
                      if (u3 === m2) continue;
                      return u3;
                    }
                  }
                  if ("next" === n4.method) n4.sent = n4._sent = n4.arg;
                  else if ("throw" === n4.method) {
                    if (o3 === y2) throw o3 = g2, n4.arg;
                    n4.dispatchException(n4.arg);
                  } else "return" === n4.method && n4.abrupt("return", n4.arg);
                  o3 = d2;
                  var f3 = p2(r4, e5, n4);
                  if ("normal" === f3.type) {
                    if (o3 = n4.done ? g2 : v2, f3.arg === m2) continue;
                    return { value: f3.arg, done: n4.done };
                  }
                  "throw" === f3.type && (o3 = g2, n4.method = "throw", n4.arg = f3.arg);
                }
              };
            }
            function _2(r4, e5) {
              var n4 = e5.method, o3 = r4.iterator[n4];
              if (o3 === t4) return e5.delegate = null, "throw" === n4 && r4.iterator.return && (e5.method = "return", e5.arg = t4, _2(r4, e5), "throw" === e5.method) || "return" !== n4 && (e5.method = "throw", e5.arg = new TypeError("The iterator does not provide a '" + n4 + "' method")), m2;
              var i3 = p2(o3, r4.iterator, e5.arg);
              if ("throw" === i3.type) return e5.method = "throw", e5.arg = i3.arg, e5.delegate = null, m2;
              var a3 = i3.arg;
              return a3 ? a3.done ? (e5[r4.resultName] = a3.value, e5.next = r4.nextLoc, "return" !== e5.method && (e5.method = "next", e5.arg = t4), e5.delegate = null, m2) : a3 : (e5.method = "throw", e5.arg = new TypeError("iterator result is not an object"), e5.delegate = null, m2);
            }
            function T2(t5) {
              var r4 = { tryLoc: t5[0] };
              1 in t5 && (r4.catchLoc = t5[1]), 2 in t5 && (r4.finallyLoc = t5[2], r4.afterLoc = t5[3]), this.tryEntries.push(r4);
            }
            function N2(t5) {
              var r4 = t5.completion || {};
              r4.type = "normal", delete r4.arg, t5.completion = r4;
            }
            function A2(t5) {
              this.tryEntries = [{ tryLoc: "root" }], t5.forEach(T2, this), this.reset(true);
            }
            function I2(e5) {
              if (e5 || "" === e5) {
                var n4 = e5[u2];
                if (n4) return n4.call(e5);
                if ("function" == typeof e5.next) return e5;
                if (!isNaN(e5.length)) {
                  var o3 = -1, a3 = function r4() {
                    for (; ++o3 < e5.length; ) if (i2.call(e5, o3)) return r4.value = e5[o3], r4.done = false, r4;
                    return r4.value = t4, r4.done = true, r4;
                  };
                  return a3.next = a3;
                }
              }
              throw new TypeError(r3(e5) + " is not iterable");
            }
            return w2.prototype = L2, a2(S2, "constructor", { value: L2, configurable: true }), a2(L2, "constructor", { value: w2, configurable: true }), w2.displayName = s2(L2, l2, "GeneratorFunction"), n3.isGeneratorFunction = function(t5) {
              var r4 = "function" == typeof t5 && t5.constructor;
              return !!r4 && (r4 === w2 || "GeneratorFunction" === (r4.displayName || r4.name));
            }, n3.mark = function(t5) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(t5, L2) : (t5.__proto__ = L2, s2(t5, l2, "GeneratorFunction")), t5.prototype = Object.create(S2), t5;
            }, n3.awrap = function(t5) {
              return { __await: t5 };
            }, j2(P2.prototype), s2(P2.prototype, f2, function() {
              return this;
            }), n3.AsyncIterator = P2, n3.async = function(t5, r4, e5, o3, i3) {
              void 0 === i3 && (i3 = Promise);
              var a3 = new P2(h2(t5, r4, e5, o3), i3);
              return n3.isGeneratorFunction(r4) ? a3 : a3.next().then(function(t6) {
                return t6.done ? t6.value : a3.next();
              });
            }, j2(S2), s2(S2, l2, "Generator"), s2(S2, u2, function() {
              return this;
            }), s2(S2, "toString", function() {
              return "[object Generator]";
            }), n3.keys = function(t5) {
              var r4 = Object(t5), e5 = [];
              for (var n4 in r4) e5.push(n4);
              return e5.reverse(), function t6() {
                for (; e5.length; ) {
                  var n5 = e5.pop();
                  if (n5 in r4) return t6.value = n5, t6.done = false, t6;
                }
                return t6.done = true, t6;
              };
            }, n3.values = I2, A2.prototype = { constructor: A2, reset: function(r4) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = t4, this.done = false, this.delegate = null, this.method = "next", this.arg = t4, this.tryEntries.forEach(N2), !r4) for (var e5 in this) "t" === e5.charAt(0) && i2.call(this, e5) && !isNaN(+e5.slice(1)) && (this[e5] = t4);
            }, stop: function() {
              this.done = true;
              var t5 = this.tryEntries[0].completion;
              if ("throw" === t5.type) throw t5.arg;
              return this.rval;
            }, dispatchException: function(r4) {
              if (this.done) throw r4;
              var e5 = this;
              function n4(n5, o4) {
                return c3.type = "throw", c3.arg = r4, e5.next = n5, o4 && (e5.method = "next", e5.arg = t4), !!o4;
              }
              for (var o3 = this.tryEntries.length - 1; o3 >= 0; --o3) {
                var a3 = this.tryEntries[o3], c3 = a3.completion;
                if ("root" === a3.tryLoc) return n4("end");
                if (a3.tryLoc <= this.prev) {
                  var u3 = i2.call(a3, "catchLoc"), f3 = i2.call(a3, "finallyLoc");
                  if (u3 && f3) {
                    if (this.prev < a3.catchLoc) return n4(a3.catchLoc, true);
                    if (this.prev < a3.finallyLoc) return n4(a3.finallyLoc);
                  } else if (u3) {
                    if (this.prev < a3.catchLoc) return n4(a3.catchLoc, true);
                  } else {
                    if (!f3) throw Error("try statement without catch or finally");
                    if (this.prev < a3.finallyLoc) return n4(a3.finallyLoc);
                  }
                }
              }
            }, abrupt: function(t5, r4) {
              for (var e5 = this.tryEntries.length - 1; e5 >= 0; --e5) {
                var n4 = this.tryEntries[e5];
                if (n4.tryLoc <= this.prev && i2.call(n4, "finallyLoc") && this.prev < n4.finallyLoc) {
                  var o3 = n4;
                  break;
                }
              }
              o3 && ("break" === t5 || "continue" === t5) && o3.tryLoc <= r4 && r4 <= o3.finallyLoc && (o3 = null);
              var a3 = o3 ? o3.completion : {};
              return a3.type = t5, a3.arg = r4, o3 ? (this.method = "next", this.next = o3.finallyLoc, m2) : this.complete(a3);
            }, complete: function(t5, r4) {
              if ("throw" === t5.type) throw t5.arg;
              return "break" === t5.type || "continue" === t5.type ? this.next = t5.arg : "return" === t5.type ? (this.rval = this.arg = t5.arg, this.method = "return", this.next = "end") : "normal" === t5.type && r4 && (this.next = r4), m2;
            }, finish: function(t5) {
              for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
                var e5 = this.tryEntries[r4];
                if (e5.finallyLoc === t5) return this.complete(e5.completion, e5.afterLoc), N2(e5), m2;
              }
            }, catch: function(t5) {
              for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
                var e5 = this.tryEntries[r4];
                if (e5.tryLoc === t5) {
                  var n4 = e5.completion;
                  if ("throw" === n4.type) {
                    var o3 = n4.arg;
                    N2(e5);
                  }
                  return o3;
                }
              }
              throw Error("illegal catch attempt");
            }, delegateYield: function(r4, e5, n4) {
              return this.delegate = { iterator: I2(r4), resultName: e5, nextLoc: n4 }, "next" === this.method && (this.arg = t4), m2;
            } }, n3;
          }
          function n2(t4, r4, e5, n3, o2, i2, a2) {
            try {
              var c2 = t4[i2](a2), u2 = c2.value;
            } catch (t5) {
              return void e5(t5);
            }
            c2.done ? r4(u2) : Promise.resolve(u2).then(n3, o2);
          }
          t3.exports = function() {
            var t4, r4 = (t4 = e4().mark(function t5(r5, n3) {
              return e4().wrap(function(t6) {
                for (; ; ) switch (t6.prev = t6.next) {
                  case 0:
                    r5.postMessage(n3);
                  case 1:
                  case "end":
                    return t6.stop();
                }
              }, t5);
            }), function() {
              var r5 = this, e5 = arguments;
              return new Promise(function(o2, i2) {
                var a2 = t4.apply(r5, e5);
                function c2(t5) {
                  n2(a2, o2, i2, c2, u2, "next", t5);
                }
                function u2(t5) {
                  n2(a2, o2, i2, c2, u2, "throw", t5);
                }
                c2(void 0);
              });
            });
            return function(t5, e5) {
              return r4.apply(this, arguments);
            };
          }();
        }, 423: (t3) => {
          t3.exports = function(t4) {
            var r3, e4 = t4.workerPath, n2 = t4.workerBlobURL;
            if (Blob && URL && n2) {
              var o2 = new Blob(['importScripts("'.concat(e4, '");')], { type: "application/javascript" });
              r3 = new Worker(URL.createObjectURL(o2));
            } else r3 = new Worker(e4);
            return r3;
          };
        }, 399: (t3) => {
          t3.exports = function(t4) {
            t4.terminate();
          };
        }, 330: (t3) => {
          t3.exports = { rE: "6.0.3" };
        } }, r2 = {};
        function e3(n2) {
          var o2 = r2[n2];
          if (void 0 !== o2) return o2.exports;
          var i2 = r2[n2] = { id: n2, loaded: false, exports: {} };
          return t2[n2].call(i2.exports, i2, i2.exports, e3), i2.loaded = true, i2.exports;
        }
        return e3.nmd = (t3) => (t3.paths = [], t3.children || (t3.children = []), t3), e3(954);
      })());
    })(tesseract_min$1);
    tesseract_minExports = tesseract_min$1.exports;
    tesseract_min = /* @__PURE__ */ getDefaultExportFromCjs(tesseract_minExports);
  }
});

// node_modules/regenerator-runtime/runtime.js
var require_runtime = __commonJS({
  "node_modules/regenerator-runtime/runtime.js"(exports2, module) {
    var runtime = function(exports3) {
      "use strict";
      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      };
      var undefined2;
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define2(obj, key, value) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }
      try {
        define2({}, "");
      } catch (err3) {
        define2 = function(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []);
        defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context) });
        return generator;
      }
      exports3.wrap = wrap;
      function tryCatch(fn2, obj, arg) {
        try {
          return { type: "normal", arg: fn2.call(obj, arg) };
        } catch (err3) {
          return { type: "throw", arg: err3 };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define2(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        IteratorPrototype = NativeIteratorPrototype;
      }
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
      defineProperty(
        GeneratorFunctionPrototype,
        "constructor",
        { value: GeneratorFunction, configurable: true }
      );
      GeneratorFunction.displayName = define2(
        GeneratorFunctionPrototype,
        toStringTagSymbol,
        "GeneratorFunction"
      );
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define2(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      exports3.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      exports3.mark = function(genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define2(genFun, toStringTagSymbol, "GeneratorFunction");
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };
      exports3.awrap = function(arg) {
        return { __await: arg };
      };
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;
            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve, reject);
              }, function(err3) {
                invoke("throw", err3, resolve, reject);
              });
            }
            return PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped;
              resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
        }
        var previousPromise;
        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
        }
        defineProperty(this, "_invoke", { value: enqueue });
      }
      defineIteratorMethods(AsyncIterator.prototype);
      define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      });
      exports3.AsyncIterator = AsyncIterator;
      exports3.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0) PromiseImpl = Promise;
        var iter = new AsyncIterator(
          wrap(innerFn, outerFn, self2, tryLocsList),
          PromiseImpl
        );
        return exports3.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self2, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          context.method = method;
          context.arg = arg;
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }
            if (context.method === "next") {
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }
              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self2, context);
            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              if (record.arg === ContinueSentinel) {
                continue;
              }
              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method;
        var method = delegate.iterator[methodName];
        if (method === undefined2) {
          context.delegate = null;
          if (methodName === "throw" && delegate.iterator["return"]) {
            context.method = "return";
            context.arg = undefined2;
            maybeInvokeDelegate(delegate, context);
            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }
          if (methodName !== "return") {
            context.method = "throw";
            context.arg = new TypeError(
              "The iterator does not provide a '" + methodName + "' method"
            );
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }
        var info = record.arg;
        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }
        if (info.done) {
          context[delegate.resultName] = info.value;
          context.next = delegate.nextLoc;
          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined2;
          }
        } else {
          return info;
        }
        context.delegate = null;
        return ContinueSentinel;
      }
      defineIteratorMethods(Gp);
      define2(Gp, toStringTagSymbol, "Generator");
      define2(Gp, iteratorSymbol, function() {
        return this;
      });
      define2(Gp, "toString", function() {
        return "[object Generator]";
      });
      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{ tryLoc: "root" }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      exports3.keys = function(val) {
        var object = Object(val);
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key2 = keys.pop();
            if (key2 in object) {
              next.value = key2;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i2 = -1, next = function next2() {
              while (++i2 < iterable.length) {
                if (hasOwn.call(iterable, i2)) {
                  next2.value = iterable[i2];
                  next2.done = false;
                  return next2;
                }
              }
              next2.value = undefined2;
              next2.done = true;
              return next2;
            };
            return next.next = next;
          }
        }
        return { next: doneResult };
      }
      exports3.values = values;
      function doneResult() {
        return { value: undefined2, done: true };
      }
      Context.prototype = {
        constructor: Context,
        reset: function(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined2;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined2;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined2;
              }
            }
          }
        },
        stop: function() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            if (caught) {
              context.method = "next";
              context.arg = undefined2;
            }
            return !!caught;
          }
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function(type, arg) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }
          return this.complete(record);
        },
        complete: function(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
          return ContinueSentinel;
        },
        finish: function(finallyLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function(tryLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          };
          if (this.method === "next") {
            this.arg = undefined2;
          }
          return ContinueSentinel;
        }
      };
      return exports3;
    }(
      // If this script is executing as a CommonJS module, use module.exports
      // as the regeneratorRuntime namespace. Otherwise create a new empty
      // object. Either way, the resulting object will be used to initialize
      // the regeneratorRuntime variable at the top of this file.
      typeof module === "object" ? module.exports : {}
    );
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@scribe.js/tesseract.js/src/utils/getId.js
var require_getId = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/utils/getId.js"(exports2, module) {
    module.exports = (prefix, cnt) => `${prefix}-${cnt}-${Math.random().toString(16).slice(3, 8)}`;
  }
});

// node_modules/@scribe.js/tesseract.js/src/createJob.js
var require_createJob = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/createJob.js"(exports2, module) {
    var getId = require_getId();
    var jobCounter = 0;
    module.exports = ({
      id: _id,
      action,
      payload = {},
      priorityJob = false
    }) => {
      let id = _id;
      if (typeof id === "undefined") {
        id = getId("Job", jobCounter);
        jobCounter += 1;
      }
      return {
        id,
        action,
        payload,
        priorityJob
      };
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/createScheduler.js
var require_createScheduler = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/createScheduler.js"(exports2, module) {
    var createJob = require_createJob();
    var getId = require_getId();
    var schedulerCounter = 0;
    module.exports = () => {
      const id = getId("Scheduler", schedulerCounter);
      const workers2 = {};
      const runningWorkers = {};
      let jobQueue = [];
      schedulerCounter += 1;
      const getQueueLen = () => jobQueue.length;
      const getNumWorkers = () => Object.keys(workers2).length;
      const dequeue = () => {
        if (jobQueue.length !== 0) {
          const wIds = Object.keys(workers2);
          for (let i2 = 0; i2 < wIds.length; i2 += 1) {
            if (typeof runningWorkers[wIds[i2]] === "undefined") {
              jobQueue[0](workers2[wIds[i2]]);
              break;
            }
          }
        }
      };
      const queue = (action, payload, priorityJob = false) => new Promise((resolve, reject) => {
        const job = createJob({ action, payload, priorityJob });
        const jobFunction = async (w2) => {
          jobQueue.shift();
          runningWorkers[w2.id] = job;
          try {
            const res1 = await w2[action].apply(exports2, [payload, job.id]);
            resolve(res1);
            if (Array.isArray(res1)) await Promise.allSettled(res1);
          } catch (err3) {
            reject(err3);
          } finally {
            delete runningWorkers[w2.id];
            dequeue();
          }
        };
        jobFunction.priorityJob = priorityJob;
        if (priorityJob) {
          let insertIndex = 0;
          for (let i2 = 0; i2 < jobQueue.length; i2 += 1) {
            if (!jobQueue[i2].priorityJob) {
              insertIndex = i2;
              break;
            }
            insertIndex = i2 + 1;
          }
          jobQueue.splice(insertIndex, 0, jobFunction);
        } else {
          jobQueue.push(jobFunction);
        }
        dequeue();
      });
      const addWorker = (w2) => {
        workers2[w2.id] = w2;
        dequeue();
        return w2.id;
      };
      const addJob = async (action, payload, priorityJob = false) => {
        if (getNumWorkers() === 0) {
          throw Error(`[${id}]: You need to have at least one worker before adding jobs`);
        }
        return queue(action, payload, priorityJob);
      };
      const terminate2 = async () => {
        Object.keys(workers2).forEach(async (wid) => {
          await workers2[wid].terminate();
        });
        jobQueue = [];
      };
      return {
        addWorker,
        addJob,
        terminate: terminate2,
        getQueueLen,
        getNumWorkers
      };
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/utils/getEnvironment.js
var require_getEnvironment = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/utils/getEnvironment.js"(exports2, module) {
    module.exports = (key) => {
      const env = {};
      if (typeof WorkerGlobalScope !== "undefined") {
        env.type = "webworker";
      } else if (typeof document === "object") {
        env.type = "browser";
      } else if (typeof process === "object" && typeof __require === "function") {
        env.type = "node";
      }
      if (typeof key === "undefined") {
        return env;
      }
      return env[key];
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/utils/resolvePaths.js
var require_resolvePaths = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/utils/resolvePaths.js"(exports2, module) {
    var isBrowser = require_getEnvironment()("type") === "browser";
    var resolveURL = isBrowser ? (s2) => new URL(s2, window.location.href).href : (s2) => s2;
    module.exports = (options) => {
      const opts = { ...options };
      ["corePath", "workerPath", "langPath"].forEach((key) => {
        if (options[key]) {
          opts[key] = resolveURL(opts[key]);
        }
      });
      return opts;
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/utils/circularize.js
var require_circularize = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/utils/circularize.js"(exports2, module) {
    module.exports = (page) => {
      const blocks = [];
      const paragraphs = [];
      const lines = [];
      const words = [];
      const symbols = [];
      if (page.blocks) {
        page.blocks.forEach((block) => {
          block.paragraphs.forEach((paragraph) => {
            paragraph.lines.forEach((line) => {
              line.words.forEach((word) => {
                word.symbols.forEach((sym) => {
                  symbols.push({
                    ...sym,
                    page,
                    block,
                    paragraph,
                    line,
                    word
                  });
                });
                words.push({
                  ...word,
                  page,
                  block,
                  paragraph,
                  line
                });
              });
              lines.push({
                ...line,
                page,
                block,
                paragraph
              });
            });
            paragraphs.push({
              ...paragraph,
              page,
              block
            });
          });
          blocks.push({
            ...block,
            page
          });
        });
      }
      return {
        ...page,
        blocks,
        paragraphs,
        lines,
        words,
        symbols
      };
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/utils/log.js
var require_log = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/utils/log.js"(exports2) {
    var logging = false;
    exports2.logging = logging;
    exports2.setLogging = (_logging) => {
      logging = _logging;
    };
    exports2.log = (...args) => logging ? console.log.apply(exports2, args) : null;
  }
});

// node_modules/@scribe.js/tesseract.js/src/constants/OEM.js
var require_OEM = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/constants/OEM.js"(exports2, module) {
    module.exports = {
      TESSERACT_ONLY: 0,
      LSTM_ONLY: 1,
      TESSERACT_LSTM_COMBINED: 2,
      DEFAULT: 3
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/constants/defaultOptions.js
var require_defaultOptions = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/constants/defaultOptions.js"(exports2, module) {
    module.exports = {
      /*
       * Use BlobURL for worker script by default
       * TODO: remove this option
       *
       */
      workerBlobURL: true,
      logger: () => {
      }
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/worker/node/defaultOptions.js
var require_defaultOptions2 = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/worker/node/defaultOptions.js"(exports2, module) {
    var path2 = __require("path");
    var defaultOptions = require_defaultOptions();
    module.exports = {
      ...defaultOptions,
      workerPath: path2.join(__dirname, "..", "..", "worker-script", "node", "index.js")
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/worker/node/spawnWorker.js
var require_spawnWorker = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/worker/node/spawnWorker.js"(exports2, module) {
    var { Worker: Worker2 } = __require("worker_threads");
    module.exports = ({ workerPath }) => new Worker2(workerPath);
  }
});

// node_modules/@scribe.js/tesseract.js/src/worker/node/terminateWorker.js
var require_terminateWorker = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/worker/node/terminateWorker.js"(exports2, module) {
    module.exports = (worker) => {
      worker.terminate();
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/worker/node/onMessage.js
var require_onMessage = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/worker/node/onMessage.js"(exports2, module) {
    module.exports = (worker, handler) => {
      worker.on("message", handler);
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/worker/node/send.js
var require_send = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/worker/node/send.js"(exports2, module) {
    module.exports = async (worker, packet) => {
      worker.postMessage(packet);
    };
  }
});

// node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS({
  "node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js"(exports2, module) {
    "use strict";
    var conversions = {};
    module.exports = conversions;
    function sign(x2) {
      return x2 < 0 ? -1 : 1;
    }
    function evenRound(x2) {
      if (x2 % 1 === 0.5 && (x2 & 1) === 0) {
        return Math.floor(x2);
      } else {
        return Math.round(x2);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V2, opts) {
        if (!opts) opts = {};
        let x2 = +V2;
        if (opts.enforceRange) {
          if (!Number.isFinite(x2)) {
            throw new TypeError("Argument is not a finite number");
          }
          x2 = sign(x2) * Math.floor(Math.abs(x2));
          if (x2 < lowerBound || x2 > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x2;
        }
        if (!isNaN(x2) && opts.clamp) {
          x2 = evenRound(x2);
          if (x2 < lowerBound) x2 = lowerBound;
          if (x2 > upperBound) x2 = upperBound;
          return x2;
        }
        if (!Number.isFinite(x2) || x2 === 0) {
          return 0;
        }
        x2 = sign(x2) * Math.floor(Math.abs(x2));
        x2 = x2 % moduloVal;
        if (!typeOpts.unsigned && x2 >= moduloBound) {
          return x2 - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x2 < 0) {
            x2 += moduloVal;
          } else if (x2 === -0) {
            return 0;
          }
        }
        return x2;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V2) {
      const x2 = +V2;
      if (!Number.isFinite(x2)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x2;
    };
    conversions["unrestricted double"] = function(V2) {
      const x2 = +V2;
      if (isNaN(x2)) {
        throw new TypeError("Argument is NaN");
      }
      return x2;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V2, opts) {
      if (!opts) opts = {};
      if (opts.treatNullAsEmptyString && V2 === null) {
        return "";
      }
      return String(V2);
    };
    conversions["ByteString"] = function(V2, opts) {
      const x2 = String(V2);
      let c2 = void 0;
      for (let i2 = 0; (c2 = x2.codePointAt(i2)) !== void 0; ++i2) {
        if (c2 > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x2;
    };
    conversions["USVString"] = function(V2) {
      const S2 = String(V2);
      const n2 = S2.length;
      const U2 = [];
      for (let i2 = 0; i2 < n2; ++i2) {
        const c2 = S2.charCodeAt(i2);
        if (c2 < 55296 || c2 > 57343) {
          U2.push(String.fromCodePoint(c2));
        } else if (56320 <= c2 && c2 <= 57343) {
          U2.push(String.fromCodePoint(65533));
        } else {
          if (i2 === n2 - 1) {
            U2.push(String.fromCodePoint(65533));
          } else {
            const d2 = S2.charCodeAt(i2 + 1);
            if (56320 <= d2 && d2 <= 57343) {
              const a2 = c2 & 1023;
              const b2 = d2 & 1023;
              U2.push(String.fromCodePoint((2 << 15) + (2 << 9) * a2 + b2));
              ++i2;
            } else {
              U2.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U2.join("");
    };
    conversions["Date"] = function(V2, opts) {
      if (!(V2 instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V2)) {
        return void 0;
      }
      return V2;
    };
    conversions["RegExp"] = function(V2, opts) {
      if (!(V2 instanceof RegExp)) {
        V2 = new RegExp(V2);
      }
      return V2;
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js
var require_utils = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js"(exports2, module) {
    "use strict";
    module.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i2 = 0; i2 < keys.length; ++i2) {
        Object.defineProperty(target, keys[i2], Object.getOwnPropertyDescriptor(source, keys[i2]));
      }
    };
    module.exports.wrapperSymbol = Symbol("wrapper");
    module.exports.implSymbol = Symbol("impl");
    module.exports.wrapperForImpl = function(impl) {
      return impl[module.exports.wrapperSymbol];
    };
    module.exports.implForWrapper = function(wrapper) {
      return wrapper[module.exports.implSymbol];
    };
  }
});

// node_modules/node-fetch/node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/node-fetch/node_modules/tr46/lib/mappingTable.json"(exports2, module) {
    module.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// node_modules/node-fetch/node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/node-fetch/node_modules/tr46/index.js"(exports2, module) {
    "use strict";
    var punycode = __require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s2) {
        return s2.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i2 = 0; i2 < len; ++i2) {
        var codePoint = domain_name.codePointAt(i2);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i2 = 0; i2 < len; ++i2) {
        var status = findStatus(label.codePointAt(i2));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error = true;
          break;
        }
      }
      return {
        label,
        error
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i2 = 0; i2 < labels.length; ++i2) {
        try {
          var validation = validateLabel(labels[i2]);
          labels[i2] = validation.label;
          result.error = result.error || validation.error;
        } catch (e3) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l2) {
        try {
          return punycode.toASCII(l2);
        } catch (e3) {
          result.error = true;
          return l2;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i2 = 0; i2 < labels.length; ++i2) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error) return null;
      return labels.join(".");
    };
    module.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js"(exports2, module) {
    "use strict";
    var punycode = __require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at2(input, idx) {
      const c2 = input[idx];
      return isNaN(c2) ? void 0 : String.fromCodePoint(c2);
    }
    function isASCIIDigit(c2) {
      return c2 >= 48 && c2 <= 57;
    }
    function isASCIIAlpha(c2) {
      return c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122;
    }
    function isASCIIAlphanumeric(c2) {
      return isASCIIAlpha(c2) || isASCIIDigit(c2);
    }
    function isASCIIHex(c2) {
      return isASCIIDigit(c2) || c2 >= 65 && c2 <= 70 || c2 >= 97 && c2 <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c2) {
      let hex2 = c2.toString(16).toUpperCase();
      if (hex2.length === 1) {
        hex2 = "0" + hex2;
      }
      return "%" + hex2;
    }
    function utf8PercentEncode(c2) {
      const buf = new Buffer(c2);
      let str = "";
      for (let i2 = 0; i2 < buf.length; ++i2) {
        str += percentEncode(buf[i2]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i2 = 0; i2 < input.length; ++i2) {
        if (input[i2] !== 37) {
          output.push(input[i2]);
        } else if (input[i2] === 37 && isASCIIHex(input[i2 + 1]) && isASCIIHex(input[i2 + 2])) {
          output.push(parseInt(input.slice(i2 + 1, i2 + 3).toString(), 16));
          i2 += 2;
        } else {
          output.push(input[i2]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c2) {
      return c2 <= 31 || c2 > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c2) {
      return isC0ControlPercentEncode(c2) || extraPathPercentEncodeSet.has(c2);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c2) {
      return isPathPercentEncode(c2) || extraUserinfoPercentEncodeSet.has(c2);
    }
    function percentEncodeChar(c2, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c2);
      if (encodeSetPredicate(c2)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R2 = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R2 = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R2 = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R2 === 10 ? /[^0-9]/ : R2 === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R2);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n2 = parseIPv4Number(part);
        if (n2 === failure) {
          return input;
        }
        numbers.push(n2);
      }
      for (let i2 = 0; i2 < numbers.length - 1; ++i2) {
        if (numbers[i2] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n2 of numbers) {
        ipv4 += n2 * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n2 = address;
      for (let i2 = 1; i2 <= 4; ++i2) {
        output = String(n2 % 256) + output;
        if (i2 !== 4) {
          output = "." + output;
        }
        n2 = Math.floor(n2 / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at2(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at2(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        output += percentEncodeChar(decoded[i2], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i2 = 0; i2 < arr.length; ++i2) {
        if (arr[i2] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i2;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path2 = url.path;
      if (path2.length === 0) {
        return;
      }
      if (url.scheme === "file" && path2.length === 1 && isNormalizedWindowsDriveLetter(path2[0])) {
        return;
      }
      path2.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c2 = this.input[this.pointer];
        const cStr = isNaN(c2) ? void 0 : String.fromCodePoint(c2);
        const ret = this["parse " + this.state](c2, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c2, cStr) {
      if (isASCIIAlpha(c2)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c2, cStr) {
      if (isASCIIAlphanumeric(c2) || c2 === 43 || c2 === 45 || c2 === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c2 === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c2) {
      if (this.base === null || this.base.cannotBeABaseURL && c2 !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c2 === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c2) {
      if (c2 === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c2) {
      if (c2 === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c2) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c2)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c2 === 47) {
        this.state = "relative slash";
      } else if (c2 === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c2 === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c2 === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c2) {
      if (isSpecial(this.url) && (c2 === 47 || c2 === 92)) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c2 === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c2) {
      if (c2 === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c2) {
      if (c2 !== 47 && c2 !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c2, cStr) {
      if (c2 === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c2) || c2 === 47 || c2 === 63 || c2 === 35 || isSpecial(this.url) && c2 === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c2, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c2 === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c2) || c2 === 47 || c2 === 63 || c2 === 35 || isSpecial(this.url) && c2 === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c2 === 91) {
          this.arrFlag = true;
        } else if (c2 === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c2, cStr) {
      if (isASCIIDigit(c2)) {
        this.buffer += cStr;
      } else if (isNaN(c2) || c2 === 47 || c2 === 63 || c2 === 35 || isSpecial(this.url) && c2 === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c2) {
      this.url.scheme = "file";
      if (c2 === 47 || c2 === 92) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c2)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c2 === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c2 === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c2, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c2) {
      if (c2 === 47 || c2 === 92) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c2, cStr) {
      if (isNaN(c2) || c2 === 47 || c2 === 92 || c2 === 63 || c2 === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c2) {
      if (isSpecial(this.url)) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c2 !== 47 && c2 !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c2 === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c2 === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c2 !== void 0) {
        this.state = "path";
        if (c2 !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c2) {
      if (isNaN(c2) || c2 === 47 || isSpecial(this.url) && c2 === 92 || !this.stateOverride && (c2 === 63 || c2 === 35)) {
        if (isSpecial(this.url) && c2 === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c2 !== 47 && !(isSpecial(this.url) && c2 === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c2 !== 47 && !(isSpecial(this.url) && c2 === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c2 === void 0 || c2 === 63 || c2 === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c2 === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c2 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c2, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c2) {
      if (c2 === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c2 === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c2) && c2 !== 37) {
          this.parseError = true;
        }
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c2)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c2, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c2, cStr) {
      if (isNaN(c2) || !this.stateOverride && c2 === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i2 = 0; i2 < buffer.length; ++i2) {
          if (buffer[i2] < 33 || buffer[i2] > 126 || buffer[i2] === 34 || buffer[i2] === 35 || buffer[i2] === 60 || buffer[i2] === 62) {
            this.url.query += percentEncode(buffer[i2]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i2]);
          }
        }
        this.buffer = "";
        if (c2 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c2) {
      if (isNaN(c2)) {
      } else if (c2 === 0) {
        this.parseError = true;
      } else {
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c2, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string of url.path) {
          output += "/" + string;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module.exports.serializeURL = serializeURL;
    module.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
          } catch (e3) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        url.username += percentEncodeChar(decoded[i2], isUserinfoPercentEncode);
      }
    };
    module.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        url.password += percentEncodeChar(decoded[i2], isUserinfoPercentEncode);
      }
    };
    module.exports.serializeHost = serializeHost;
    module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js"(exports2) {
    "use strict";
    var usm = require_url_state_machine();
    exports2.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v2) {
        const parsedURL = usm.basicURLParse(v2);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v2) {
        usm.basicURLParse(v2 + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v2);
      }
      get password() {
        return this._url.password;
      }
      set password(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v2);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v2) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v2, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v2) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v2, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v2 === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v2, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v2) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v2, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v2) {
        const url = this._url;
        if (v2 === "") {
          url.query = null;
          return;
        }
        const input = v2[0] === "?" ? v2.substring(1) : v2;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v2) {
        if (v2 === "") {
          this._url.fragment = null;
          return;
        }
        const input = v2[0] === "#" ? v2.substring(1) : v2;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js"(exports2, module) {
    "use strict";
    var conversions = require_lib();
    var utils2 = require_utils();
    var Impl = require_URL_impl();
    var impl = utils2.implSymbol;
    function URL2(url) {
      if (!this || this[impl] || !(this instanceof URL2)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i2 = 0; i2 < arguments.length && i2 < 2; ++i2) {
        args[i2] = arguments[i2];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module.exports.setup(this, args);
    }
    URL2.prototype.toJSON = function toJSON() {
      if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i2 = 0; i2 < arguments.length && i2 < 0; ++i2) {
        args[i2] = arguments[i2];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL2.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].href = V2;
      },
      enumerable: true,
      configurable: true
    });
    URL2.prototype.toString = function() {
      if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL2.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].protocol = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].username = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].password = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].host = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].hostname = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].port = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].pathname = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].search = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].hash = V2;
      },
      enumerable: true,
      configurable: true
    });
    module.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL2.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData) privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils2.wrapperSymbol] = obj;
      },
      interface: URL2,
      expose: {
        Window: { URL: URL2 },
        Worker: { URL: URL2 }
      }
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js"(exports2) {
    "use strict";
    exports2.URL = require_URL().interface;
    exports2.serializeURL = require_url_state_machine().serializeURL;
    exports2.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports2.basicURLParse = require_url_state_machine().basicURLParse;
    exports2.setTheUsername = require_url_state_machine().setTheUsername;
    exports2.setThePassword = require_url_state_machine().setThePassword;
    exports2.serializeHost = require_url_state_machine().serializeHost;
    exports2.serializeInteger = require_url_state_machine().serializeInteger;
    exports2.parseURL = require_url_state_machine().parseURL;
  }
});

// node_modules/node-fetch/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/node-fetch/lib/index.js"(exports2, module) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream2 = _interopDefault(__require("stream"));
    var http = _interopDefault(__require("http"));
    var Url = _interopDefault(__require("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https = _interopDefault(__require("https"));
    var zlib = _interopDefault(__require("zlib"));
    var Readable = Stream2.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE4 = Symbol("type");
    var Blob2 = class _Blob {
      constructor() {
        this[TYPE4] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a2 = blobParts;
          const length = Number(a2.length);
          for (let i2 = 0; i2 < length; i2++) {
            const element = a2[i2];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE4] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE4];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new _Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob2.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = __require("encoding").convert;
    } catch (e3) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough = Stream2.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob(body)) ;
      else if (Buffer.isBuffer(body)) ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream2) ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream2) {
        body.on("error", function(err3) {
          const error = err3.name === "AbortError" ? err3 : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err3.message}`, "system", err3);
          _this[INTERNALS].error = error;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct2 = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob2([], {
              type: ct2.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err3) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err3.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
      }
      if (!(body instanceof Stream2)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function(resolve, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err3) {
          if (err3.name === "AbortError") {
            abort = true;
            reject(err3);
          } else {
            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err3.message}`, "system", err3));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve(Buffer.concat(accum, accumBytes));
          } catch (err3) {
            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err3.message}`, "system", err3));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct2 = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct2) {
        res = /charset=([^;]*)/i.exec(ct2);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream2 && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream2) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name) {
      name = name.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init2 instanceof _Headers) {
          const rawHeaders = init2.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init2 == null) ;
        else if (typeof init2 === "object") {
          const method = init2[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init2) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init2)) {
              const value = init2[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders2(this);
        let i2 = 0;
        while (i2 < pairs.length) {
          var _pairs$i = pairs[i2];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders2(this);
          i2++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders2(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(kind === "key" ? function(k2) {
        return k2.toLowerCase();
      } : kind === "value" ? function(k2) {
        return headers[MAP][k2].join(", ");
      } : function(k2) {
        return [k2.toLowerCase(), headers[MAP][k2].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders2(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers();
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = http.STATUS_CODES;
    var Response2 = class _Response {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response2.prototype);
    Object.defineProperties(Response2.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response2.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var URL2 = Url.URL || whatwgUrl.URL;
    var parse_url = Url.parse;
    var format_url = Url.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL2(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream2.Readable.prototype;
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request = class _Request {
      constructor(input) {
        let init2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init2.body != null ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init2.timeout || input.timeout || 0,
          size: init2.size || input.size || 0
        });
        const headers = new Headers(init2.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) signal = init2.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init2.follow !== void 0 ? init2.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init2.compress !== void 0 ? init2.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream2.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var URL$1 = Url.URL || whatwgUrl.URL;
    var PassThrough$1 = Stream2.PassThrough;
    var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    var isSameProtocol = function isSameProtocol2(destination, original) {
      const orig = new URL$1(original).protocol;
      const dest = new URL$1(destination).protocol;
      return orig === dest;
    };
    function fetch2(url, opts) {
      if (!fetch2.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body.Promise = fetch2.Promise;
      return new fetch2.Promise(function(resolve, reject) {
        const request = new Request(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === "https:" ? https : http).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error = new AbortError("The user aborted a request.");
          reject(error);
          if (request.body && request.body instanceof Stream2.Readable) {
            destroyStream(request.body, error);
          }
          if (!response || !response.body) return;
          response.body.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal) signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err3) {
          reject(new FetchError(`request to ${request.url} failed, reason: ${err3.message}`, "system", err3));
          if (response && response.body) {
            destroyStream(response.body, err3);
          }
          finalize();
        });
        fixResponseChunkedTransferBadEnding(req, function(err3) {
          if (signal && signal.aborted) {
            return;
          }
          if (response && response.body) {
            destroyStream(response.body, err3);
          }
        });
        if (parseInt(process.version.substring(1)) < 14) {
          req.on("socket", function(s2) {
            s2.addListener("close", function(hadError) {
              const hasDataListener = s2.listenerCount("data") > 0;
              if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                const err3 = new Error("Premature close");
                err3.code = "ERR_STREAM_PREMATURE_CLOSE";
                response.body.emit("error", err3);
              }
            });
          });
        }
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch2.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location === null ? null : new URL$1(location, request.url).toString();
            } catch (err3) {
              if (request.redirect !== "manual") {
                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err3) {
                    reject(err3);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                  for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOpts.headers.delete(name);
                  }
                }
                if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve(fetch2(new Request(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal) signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response2(body, response_options);
            resolve(response);
            return;
          }
          const zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib.createGunzip(zlibOptions));
            response = new Response2(body, response_options);
            resolve(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib.createInflate());
              } else {
                body = body.pipe(zlib.createInflateRaw());
              }
              response = new Response2(body, response_options);
              resolve(response);
            });
            raw.on("end", function() {
              if (!response) {
                response = new Response2(body, response_options);
                resolve(response);
              }
            });
            return;
          }
          if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
            body = body.pipe(zlib.createBrotliDecompress());
            response = new Response2(body, response_options);
            resolve(response);
            return;
          }
          response = new Response2(body, response_options);
          resolve(response);
        });
        writeToStream(req, request);
      });
    }
    function fixResponseChunkedTransferBadEnding(request, errorCallback) {
      let socket;
      request.on("socket", function(s2) {
        socket = s2;
      });
      request.on("response", function(response) {
        const headers = response.headers;
        if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
          response.once("close", function(hadError) {
            const hasDataListener = socket && socket.listenerCount("data") > 0;
            if (hasDataListener && !hadError) {
              const err3 = new Error("Premature close");
              err3.code = "ERR_STREAM_PREMATURE_CLOSE";
              errorCallback(err3);
            }
          });
        }
      });
    }
    function destroyStream(stream, err3) {
      if (stream.destroy) {
        stream.destroy(err3);
      } else {
        stream.emit("error", err3);
        stream.end();
      }
    }
    fetch2.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch2.Promise = global.Promise;
    module.exports = exports2 = fetch2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = exports2;
    exports2.Headers = Headers;
    exports2.Request = Request;
    exports2.Response = Response2;
    exports2.FetchError = FetchError;
    exports2.AbortError = AbortError;
  }
});

// node_modules/is-url/index.js
var require_is_url = __commonJS({
  "node_modules/is-url/index.js"(exports2, module) {
    module.exports = isUrl;
    var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;
    var localhostDomainRE = /^localhost[\:?\d]*(?:[^\:?\d]\S*)?$/;
    var nonLocalhostDomainRE = /^[^\s\.]+\.\S{2,}$/;
    function isUrl(string) {
      if (typeof string !== "string") {
        return false;
      }
      var match = string.match(protocolAndDomainRE);
      if (!match) {
        return false;
      }
      var everythingAfterProtocol = match[1];
      if (!everythingAfterProtocol) {
        return false;
      }
      if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {
        return true;
      }
      return false;
    }
  }
});

// node_modules/@scribe.js/tesseract.js/src/worker/node/loadImage.js
var require_loadImage = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/worker/node/loadImage.js"(exports2, module) {
    var util = __require("util");
    var fs3 = __require("fs");
    var fetch2 = global.fetch || require_lib2();
    var isURL = require_is_url();
    var readFile = util.promisify(fs3.readFile);
    module.exports = async (image) => {
      let data2 = image;
      if (typeof image === "undefined") {
        return image;
      }
      if (typeof image === "string") {
        if (isURL(image) || image.startsWith("moz-extension://") || image.startsWith("chrome-extension://") || image.startsWith("file://")) {
          const resp = await fetch2(image);
          data2 = await resp.arrayBuffer();
        } else if (/data:image\/([a-zA-Z]*);base64,([^"]*)/.test(image)) {
          data2 = Buffer.from(image.split(",")[1], "base64");
        } else {
          data2 = await readFile(image);
        }
      } else if (Buffer.isBuffer(image)) {
        data2 = image;
      }
      return new Uint8Array(data2);
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/worker/node/index.js
var require_node = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/worker/node/index.js"(exports2, module) {
    var defaultOptions = require_defaultOptions2();
    var spawnWorker = require_spawnWorker();
    var terminateWorker = require_terminateWorker();
    var onMessage2 = require_onMessage();
    var send = require_send();
    var loadImage = require_loadImage();
    module.exports = {
      defaultOptions,
      spawnWorker,
      terminateWorker,
      onMessage: onMessage2,
      send,
      loadImage
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/createWorker.js
var require_createWorker = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/createWorker.js"(exports2, module) {
    var resolvePaths = require_resolvePaths();
    var circularize = require_circularize();
    var createJob = require_createJob();
    var { log } = require_log();
    var getId = require_getId();
    var OEM = require_OEM();
    var {
      defaultOptions,
      spawnWorker,
      terminateWorker,
      onMessage: onMessage2,
      loadImage,
      send
    } = require_node();
    var workerCounter = 0;
    module.exports = async (langs = "eng", oem = OEM.LSTM_ONLY, _options = {}, config2 = {}) => {
      const id = getId("Worker", workerCounter);
      const {
        logger,
        errorHandler,
        ...options
      } = resolvePaths({
        ...defaultOptions,
        ..._options
      });
      const promises = {};
      const currentLangs = typeof langs === "string" ? langs.split("+") : langs;
      let currentOem = oem;
      let currentConfig = config2;
      const lstmOnlyCore = [OEM.DEFAULT, OEM.LSTM_ONLY].includes(oem) && !options.legacyCore;
      let workerResReject;
      let workerResResolve;
      const workerRes = new Promise((resolve, reject) => {
        workerResResolve = resolve;
        workerResReject = reject;
      });
      const workerError = (event) => {
        workerResReject(event.message);
      };
      let worker = spawnWorker(options);
      worker.onerror = workerError;
      workerCounter += 1;
      const startJob = ({ id: jobId, action, payload }) => new Promise((resolve, reject) => {
        log(`[${id}]: Start ${jobId}, action=${action}`);
        const promiseId = `${action}-${jobId}`;
        promises[promiseId] = { resolve, reject };
        send(worker, {
          workerId: id,
          jobId,
          action,
          payload
        });
      });
      const startJob2 = ({ id: jobId, action, payload }) => {
        const promiseB = new Promise((resolve, reject) => {
          log(`[${id}]: Start ${jobId}, action=${action}`);
          const promiseId = `${action}-${jobId}b`;
          promises[promiseId] = { resolve, reject };
        });
        const promiseA = new Promise((resolve, reject) => {
          log(`[${id}]: Start ${jobId}, action=${action}`);
          const promiseId = `${action}-${jobId}`;
          promises[promiseId] = { resolve, reject };
          send(worker, {
            workerId: id,
            jobId,
            action,
            payload
          });
        });
        return [promiseA, promiseB];
      };
      const load = () => console.warn("`load` is depreciated and should be removed from code (workers now come pre-loaded)");
      const loadInternal = (jobId) => startJob(createJob({
        id: jobId,
        action: "load",
        payload: { options: { lstmOnly: lstmOnlyCore, corePath: options.corePath, logging: options.logging } }
      }));
      const writeText2 = (path2, text, jobId) => startJob(createJob({
        id: jobId,
        action: "FS",
        payload: { method: "writeFile", args: [path2, text] }
      }));
      const readText = (path2, jobId) => startJob(createJob({
        id: jobId,
        action: "FS",
        payload: { method: "readFile", args: [path2, { encoding: "utf8" }] }
      }));
      const removeFile = (path2, jobId) => startJob(createJob({
        id: jobId,
        action: "FS",
        payload: { method: "unlink", args: [path2] }
      }));
      const FS2 = (method, args, jobId) => startJob(createJob({
        id: jobId,
        action: "FS",
        payload: { method, args }
      }));
      const loadLanguage = () => console.warn("`loadLanguage` is depreciated and should be removed from code (workers now come with language pre-loaded)");
      const loadLanguageInternal = (_langs, jobId) => startJob(createJob({
        id: jobId,
        action: "loadLanguage",
        payload: {
          langs: _langs,
          options: {
            langPath: options.langPath,
            dataPath: options.dataPath,
            cachePath: options.cachePath,
            cacheMethod: options.cacheMethod,
            gzip: options.gzip,
            lstmOnly: [OEM.LSTM_ONLY, OEM.TESSERACT_LSTM_COMBINED].includes(currentOem) && !options.legacyLang
          }
        }
      }));
      const initialize = () => console.warn("`initialize` is depreciated and should be removed from code (workers now come pre-initialized)");
      const initializeInternal = (_langs, _oem, _config, jobId) => startJob(createJob({
        id: jobId,
        action: "initialize",
        payload: { langs: _langs, oem: _oem, config: _config }
      }));
      const reinitialize = (langs2 = "eng", oem2, config3, jobId) => {
        if (lstmOnlyCore && [OEM.TESSERACT_ONLY, OEM.TESSERACT_LSTM_COMBINED].includes(oem2)) throw Error("Legacy model requested but code missing.");
        const _oem = oem2 || currentOem;
        currentOem = _oem;
        const _config = config3 || currentConfig;
        currentConfig = _config;
        const langsArr = typeof langs2 === "string" ? langs2.split("+") : langs2;
        const _langs = langsArr.filter((x2) => !currentLangs.includes(x2));
        currentLangs.push(..._langs);
        if (_langs.length > 0) {
          return loadLanguageInternal(_langs, jobId).then(() => initializeInternal(langs2, _oem, _config, jobId));
        }
        return initializeInternal(langs2, _oem, _config, jobId);
      };
      const setParameters = (params = {}, jobId) => startJob(createJob({
        id: jobId,
        action: "setParameters",
        payload: { params }
      }));
      const recognize2 = async (image, opts = {}, output = {
        blocks: true,
        text: true,
        hocr: true,
        tsv: true
      }, jobId) => startJob(createJob({
        id: jobId,
        action: "recognize",
        payload: { image: await loadImage(image), options: opts, output }
      }));
      const recognize22 = async (image, opts = {}, output = {
        blocks: true,
        text: true,
        hocr: true,
        tsv: true
      }, jobId) => startJob2(createJob({
        id: jobId,
        action: "recognize2",
        payload: { image: await loadImage(image), options: opts, output }
      }));
      const getPDF = (title = "Tesseract OCR Result", textonly = false, jobId) => {
        console.log("`getPDF` function is depreciated. `recognize` option `savePDF` should be used instead.");
        return startJob(createJob({
          id: jobId,
          action: "getPDF",
          payload: { title, textonly }
        }));
      };
      const detect = async (image, jobId) => {
        if (lstmOnlyCore) throw Error("`worker.detect` requires Legacy model, which was not loaded.");
        return startJob(createJob({
          id: jobId,
          action: "detect",
          payload: { image: await loadImage(image) }
        }));
      };
      const terminate2 = async () => {
        if (worker !== null) {
          terminateWorker(worker);
          worker = null;
        }
        return Promise.resolve();
      };
      onMessage2(worker, ({
        workerId,
        jobId,
        status,
        action,
        data: data2
      }) => {
        const promiseId = `${action}-${jobId}`;
        if (status === "resolve") {
          log(`[${workerId}]: Complete ${jobId}`);
          let d2 = data2;
          if (action === "recognize") {
            d2 = circularize(data2);
          } else if (action === "getPDF") {
            d2 = Array.from({ ...data2, length: Object.keys(data2).length });
          }
          promises[promiseId].resolve({ jobId, data: d2 });
          delete promises[promiseId];
        } else if (status === "reject") {
          promises[promiseId].reject(data2);
          delete promises[promiseId];
          if (action === "load") workerResReject(data2);
          if (errorHandler) {
            errorHandler(data2);
          } else {
            throw Error(data2);
          }
        } else if (status === "progress") {
          logger({ ...data2, userJobId: jobId });
        }
      });
      const resolveObj = {
        id,
        worker,
        load,
        writeText: writeText2,
        readText,
        removeFile,
        FS: FS2,
        loadLanguage,
        initialize,
        reinitialize,
        setParameters,
        recognize: recognize2,
        recognize2: recognize22,
        getPDF,
        detect,
        terminate: terminate2
      };
      loadInternal().then(() => loadLanguageInternal(langs)).then(() => initializeInternal(langs, oem, config2)).then(() => workerResResolve(resolveObj)).catch(() => {
      });
      return workerRes;
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/Tesseract.js
var require_Tesseract = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/Tesseract.js"(exports2, module) {
    var createWorker = require_createWorker();
    var recognize2 = async (image, langs, options) => {
      const worker = await createWorker(langs, 1, options);
      return worker.recognize(image).finally(async () => {
        await worker.terminate();
      });
    };
    var detect = async (image, options) => {
      const worker = await createWorker("osd", 0, options);
      return worker.detect(image).finally(async () => {
        await worker.terminate();
      });
    };
    module.exports = {
      recognize: recognize2,
      detect
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/constants/languages.js
var require_languages = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/constants/languages.js"(exports2, module) {
    module.exports = {
      AFR: "afr",
      AMH: "amh",
      ARA: "ara",
      ASM: "asm",
      AZE: "aze",
      AZE_CYRL: "aze_cyrl",
      BEL: "bel",
      BEN: "ben",
      BOD: "bod",
      BOS: "bos",
      BUL: "bul",
      CAT: "cat",
      CEB: "ceb",
      CES: "ces",
      CHI_SIM: "chi_sim",
      CHI_TRA: "chi_tra",
      CHR: "chr",
      CYM: "cym",
      DAN: "dan",
      DEU: "deu",
      DZO: "dzo",
      ELL: "ell",
      ENG: "eng",
      ENM: "enm",
      EPO: "epo",
      EST: "est",
      EUS: "eus",
      FAS: "fas",
      FIN: "fin",
      FRA: "fra",
      FRK: "frk",
      FRM: "frm",
      GLE: "gle",
      GLG: "glg",
      GRC: "grc",
      GUJ: "guj",
      HAT: "hat",
      HEB: "heb",
      HIN: "hin",
      HRV: "hrv",
      HUN: "hun",
      IKU: "iku",
      IND: "ind",
      ISL: "isl",
      ITA: "ita",
      ITA_OLD: "ita_old",
      JAV: "jav",
      JPN: "jpn",
      KAN: "kan",
      KAT: "kat",
      KAT_OLD: "kat_old",
      KAZ: "kaz",
      KHM: "khm",
      KIR: "kir",
      KOR: "kor",
      KUR: "kur",
      LAO: "lao",
      LAT: "lat",
      LAV: "lav",
      LIT: "lit",
      MAL: "mal",
      MAR: "mar",
      MKD: "mkd",
      MLT: "mlt",
      MSA: "msa",
      MYA: "mya",
      NEP: "nep",
      NLD: "nld",
      NOR: "nor",
      ORI: "ori",
      PAN: "pan",
      POL: "pol",
      POR: "por",
      PUS: "pus",
      RON: "ron",
      RUS: "rus",
      SAN: "san",
      SIN: "sin",
      SLK: "slk",
      SLV: "slv",
      SPA: "spa",
      SPA_OLD: "spa_old",
      SQI: "sqi",
      SRP: "srp",
      SRP_LATN: "srp_latn",
      SWA: "swa",
      SWE: "swe",
      SYR: "syr",
      TAM: "tam",
      TEL: "tel",
      TGK: "tgk",
      TGL: "tgl",
      THA: "tha",
      TIR: "tir",
      TUR: "tur",
      UIG: "uig",
      UKR: "ukr",
      URD: "urd",
      UZB: "uzb",
      UZB_CYRL: "uzb_cyrl",
      VIE: "vie",
      YID: "yid"
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/constants/PSM.js
var require_PSM = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/constants/PSM.js"(exports2, module) {
    module.exports = {
      OSD_ONLY: "0",
      AUTO_OSD: "1",
      AUTO_ONLY: "2",
      AUTO: "3",
      SINGLE_COLUMN: "4",
      SINGLE_BLOCK_VERT_TEXT: "5",
      SINGLE_BLOCK: "6",
      SINGLE_LINE: "7",
      SINGLE_WORD: "8",
      CIRCLE_WORD: "9",
      SINGLE_CHAR: "10",
      SPARSE_TEXT: "11",
      SPARSE_TEXT_OSD: "12",
      RAW_LINE: "13"
    };
  }
});

// node_modules/@scribe.js/tesseract.js/src/index.js
var require_src = __commonJS({
  "node_modules/@scribe.js/tesseract.js/src/index.js"(exports2, module) {
    require_runtime();
    var createScheduler = require_createScheduler();
    var createWorker = require_createWorker();
    var Tesseract = require_Tesseract();
    var languages = require_languages();
    var OEM = require_OEM();
    var PSM = require_PSM();
    var { setLogging } = require_log();
    module.exports = {
      languages,
      OEM,
      PSM,
      createScheduler,
      createWorker,
      setLogging,
      ...Tesseract
    };
  }
});

// node_modules/scribe.js-ocr/js/objects/ocrObjects.js
function OcrPage(n2, dims) {
  this.n = n2;
  this.dims = dims;
  this.angle = 0;
  this.pars = [];
  this.lines = [];
  this.textSource = null;
}
function OcrPar(page, bbox) {
  this.page = page;
  this.bbox = bbox;
  this.lines = [];
  this.reason = "";
}
function OcrLine(page, bbox, baseline, ascHeight = null, xHeight = null) {
  this.bbox = bbox;
  this.baseline = baseline;
  this.ascHeight = ascHeight;
  this.xHeight = xHeight;
  this.words = [];
  this.page = page;
  this._sizeCalc = null;
  this._size = null;
  this.raw = null;
  this._angleAdj = null;
  this.par = null;
  this.orientation = 0;
}
function OcrWord(line, id, text, bbox, poly) {
  this.text = text;
  this.textAlt = null;
  this.style = {
    font: null,
    size: null,
    bold: false,
    italic: false,
    underline: false,
    smallCaps: false,
    sup: false,
    dropcap: false
  };
  this.lang = "eng";
  this.conf = 0;
  this.bbox = bbox;
  this.poly = poly || null;
  this.compTruth = false;
  this.matchTruth = false;
  this.id = id;
  this.line = line;
  this.raw = null;
  this.chars = null;
  this._angleAdj = null;
  this.visualCoords = true;
}
function OcrChar(text, bbox) {
  this.text = text;
  this.bbox = bbox;
}
function scaleChar(char, scale) {
  char.bbox.left *= scale;
  char.bbox.top *= scale;
  char.bbox.right *= scale;
  char.bbox.bottom *= scale;
}
function scaleWord(word, scale) {
  word.bbox.left *= scale;
  word.bbox.top *= scale;
  word.bbox.right *= scale;
  word.bbox.bottom *= scale;
  if (word.chars) {
    for (const char of word.chars) {
      scaleChar(char, scale);
    }
  }
}
function scaleLine(line, scale) {
  line.bbox.left *= scale;
  line.bbox.top *= scale;
  line.bbox.right *= scale;
  line.bbox.bottom *= scale;
  for (const word of line.words) {
    scaleWord(word, scale);
  }
  if (line.ascHeight) line.ascHeight *= scale;
  if (line.xHeight) line.xHeight *= scale;
  line.baseline[1] *= scale;
}
function scalePage(page, scale) {
  for (const line of page.lines) {
    scaleLine(line, scale);
  }
  page.dims.width *= scale;
  page.dims.height *= scale;
}
function calcLineStartAngleAdj(line) {
  if (!line.words[0]) {
    console.log("No words in line, report as bug.");
    return { x: 0, y: 0 };
  }
  const angle = line.page.angle * -1;
  const dims = line.page.dims;
  const sinAngle = Math.sin(angle * (Math.PI / 180));
  const cosAngle = Math.cos(angle * (Math.PI / 180));
  let bbox;
  const char0Bbox = line.words[0]?.chars?.[0]?.bbox;
  if (char0Bbox) {
    bbox = char0Bbox;
  } else {
    bbox = line.words[0].bbox;
  }
  const width = line.orientation % 2 === 0 ? dims.width : dims.height;
  const height = line.orientation % 2 === 0 ? dims.height : dims.width;
  const bboxRot = rotateBbox(bbox, cosAngle, sinAngle, width, height);
  line._angleAdj = { x: bboxRot.left - bbox.left, y: bboxRot.bottom - bbox.bottom };
  return line._angleAdj;
}
function calcWordAngleAdj(word) {
  if (true) {
    word._angleAdj = { x: 0, y: 0 };
    const { angle } = word.line.page;
    if (Math.abs(angle ?? 0) > 0.05) {
      const sinAngle = Math.sin(angle * (Math.PI / 180));
      const cosAngle = Math.cos(angle * (Math.PI / 180));
      const x2 = word.bbox.left - word.line.bbox.left;
      const y2 = word.bbox.bottom - (word.line.bbox.bottom + word.line.baseline[1]);
      if (word.style.sup || word.style.dropcap) {
        const tanAngle = sinAngle / cosAngle;
        const angleAdjYSup = (y2 - x2 * tanAngle) * cosAngle - y2;
        const angleAdjXSup = angle > 0 ? 0 : angleAdjYSup * tanAngle;
        word._angleAdj = { x: 0 - angleAdjXSup, y: angleAdjYSup };
      } else {
        const angleAdjXBaseline = x2 / cosAngle - x2;
        word._angleAdj = { x: angleAdjXBaseline, y: 0 };
      }
    }
  }
  return word._angleAdj;
}
function replaceLigatures(text) {
  return text.replace(//g, "IJ").replace(//g, "ij").replace(//g, "\u02BCn").replace(//g, "DZ").replace(//g, "Dz").replace(//g, "dz").replace(//g, "D\u017D").replace(//g, "D\u017E").replace(//g, "d\u017E").replace(//g, "LJ").replace(//g, "Lj").replace(//g, "lj").replace(//g, "NJ").replace(//g, "Nj").replace(//g, "nj").replace(//g, "ff").replace(//g, "fi").replace(//g, "fl").replace(//g, "ffi").replace(//g, "ffl").replace(//g, "\u017Ft").replace(//g, "st");
}
function escapeXml(string) {
  return string.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function updateLineBbox(line, adjustBaseline = true) {
  const lineboxBottomOrig = line.bbox.bottom;
  const wordBoxArr = line.words.map((x2) => x2.bbox);
  line.bbox = calcBboxUnion(wordBoxArr);
  if (adjustBaseline) line.baseline[1] += lineboxBottomOrig - line.bbox.bottom;
}
function calcWordBbox(word) {
  if (!word.chars || word.chars.length === 0) return;
  const charBoxArr = word.chars.map((x2) => x2.bbox);
  word.bbox = calcBboxUnion(charBoxArr);
}
function rotateBbox(bbox, cosAngle, sinAngle, width, height) {
  const bboxOut = { ...bbox };
  const xCenter = width / 2;
  const yCenter = height / 2;
  bboxOut.left = cosAngle * (bbox.left - xCenter) - sinAngle * (bbox.bottom - yCenter) + xCenter;
  bboxOut.right = cosAngle * (bbox.right - xCenter) - sinAngle * (bbox.bottom - yCenter) + xCenter;
  bboxOut.top = sinAngle * (bbox.left - xCenter) + cosAngle * (bbox.top - yCenter) + yCenter;
  bboxOut.bottom = sinAngle * (bbox.left - xCenter) + cosAngle * (bbox.bottom - yCenter) + yCenter;
  return bboxOut;
}
function rotateLine(line, angle, dims = null, useCharLevel = false) {
  if (Math.abs(angle) <= 0.05) return;
  const dims1 = dims || line.page.dims;
  const sinAngle = Math.sin(angle * (Math.PI / 180));
  const cosAngle = Math.cos(angle * (Math.PI / 180));
  const { baseline } = line;
  const baselineAngleRadXML = Math.atan(baseline[0]);
  const baselineAngleRadAdj = angle * (Math.PI / 180);
  const baselineAngleRadTotal = Math.tan(baselineAngleRadXML + baselineAngleRadAdj);
  for (let i2 = 0; i2 < line.words.length; i2++) {
    const word = line.words[i2];
    if (useCharLevel && word.chars && word.chars.length > 0) {
      for (let j2 = 0; j2 < word.chars.length; j2++) {
        const char = word.chars[j2];
        char.bbox = rotateBbox(char.bbox, cosAngle, sinAngle, dims1.width, dims1.height);
      }
      ocr.calcWordBbox(word);
    } else {
      word.bbox = rotateBbox(word.bbox, cosAngle, sinAngle, dims1.width, dims1.height);
    }
  }
  const lineBoxRot = rotateBbox(line.bbox, cosAngle, sinAngle, dims1.width, dims1.height);
  updateLineBbox(line, false);
  const baselineOffsetAdj = lineBoxRot.bottom - line.bbox.bottom;
  const baselineOffsetTotal = baseline[1] + baselineOffsetAdj;
  line.baseline[0] = baselineAngleRadTotal;
  line.baseline[1] = baselineOffsetTotal;
}
function clonePage(page) {
  const pageNew = new OcrPage(page.n, { ...page.dims });
  for (const line of page.lines) {
    const lineNew = cloneLine(line);
    lineNew.page = pageNew;
    pageNew.lines.push(lineNew);
  }
  return pageNew;
}
function cloneLine(line) {
  const lineNew = new OcrLine(line.page, { ...line.bbox }, line.baseline.slice(), line.ascHeight, line.xHeight);
  for (const word of line.words) {
    const wordNew = cloneWord(word);
    wordNew.line = lineNew;
    lineNew.words.push(wordNew);
  }
  return lineNew;
}
function cloneWord(word) {
  const wordNew = new OcrWord(word.line, word.id, word.text, { ...word.bbox });
  if (word.poly) wordNew.poly = { ...word.poly };
  wordNew.conf = word.conf;
  wordNew.style = { ...word.style };
  wordNew.lang = word.lang;
  wordNew.compTruth = word.compTruth;
  wordNew.matchTruth = word.matchTruth;
  wordNew.visualCoords = word.visualCoords;
  wordNew.raw = word.raw;
  if (word.chars) {
    wordNew.chars = [];
    for (const char of word.chars) {
      wordNew.chars.push(cloneChar(char));
    }
  }
  return wordNew;
}
function cloneChar(char) {
  const charNew = new OcrChar(char.text, { ...char.bbox });
  return charNew;
}
function getMatchingWords(text, ocrPage) {
  text = text.trim().toLowerCase();
  if (!text) return [];
  const textArr = text.split(" ");
  const wordArr = ocr.getPageWords(ocrPage);
  const matchArr = [];
  for (let i2 = 0; i2 < wordArr.length - (textArr.length - 1); i2++) {
    const word = wordArr[i2];
    if (!word.text.toLowerCase().includes(textArr[0])) continue;
    const candArr = wordArr.slice(i2, i2 + textArr.length);
    const candText = candArr.map((x2) => x2.text).join(" ").toLowerCase();
    if (candText.toLowerCase().includes(text)) {
      matchArr.push(...candArr);
    }
  }
  return matchArr;
}
function getMatchingWordIds(text, ocrPage) {
  text = text.trim().toLowerCase();
  if (!text) return [];
  const textArr = text.split(" ");
  const wordArr = ocr.getPageWords(ocrPage);
  const matchIdArr = [];
  for (let i2 = 0; i2 < wordArr.length - (textArr.length - 1); i2++) {
    const word = wordArr[i2];
    if (!word.text.toLowerCase().includes(textArr[0])) continue;
    const candArr = wordArr.slice(i2, i2 + textArr.length);
    const candText = candArr.map((x2) => x2.text).join(" ").toLowerCase();
    if (candText.toLowerCase().includes(text)) {
      matchIdArr.push(...candArr.map((x2) => x2.id));
    }
  }
  return matchIdArr;
}
function getWordFillOpacity(word, displayMode, confThreshMed = 75, confThreshHigh = 85, overlayOpacity = 80) {
  let fillColorHex;
  if (word.conf > confThreshHigh) {
    fillColorHex = "#00ff7b";
  } else if (word.conf > confThreshMed) {
    fillColorHex = "#ffc800";
  } else {
    fillColorHex = "#ff0000";
  }
  const fillColorHexMatch = word.matchTruth ? "#00ff7b" : "#ff0000";
  let opacity;
  let fill;
  if (displayMode === "invis") {
    opacity = 0;
    fill = "black";
  } else if (displayMode === "ebook") {
    opacity = 1;
    fill = "black";
  } else if (displayMode === "eval") {
    opacity = overlayOpacity / 100;
    fill = fillColorHexMatch;
  } else {
    opacity = overlayOpacity / 100;
    fill = fillColorHex;
  }
  return { opacity, fill };
}
var getPrevLine, getNextLine, getPageWord, deletePageWords, getPageWords, getDistinctChars, getLineText, getParText, getPageText, removeCircularRefsOcr, addCircularRefsOcr, ocr, ocrObjects_default;
var init_ocrObjects = __esm({
  "node_modules/scribe.js-ocr/js/objects/ocrObjects.js"() {
    init_miscUtils();
    getPrevLine = (lineObj) => {
      if (!lineObj.words[0]) throw new Error("All lines must contain >=1 word");
      const lineIndex = lineObj.page.lines.findIndex((elem) => elem.words?.[0]?.id === lineObj.words[0].id);
      if (lineIndex < 1) return null;
      return lineObj.page.lines[lineIndex - 1];
    };
    getNextLine = (lineObj) => {
      if (!lineObj.words[0]) throw new Error("All lines must contain >=1 word");
      const lineIndex = lineObj.page.lines.findIndex((elem) => elem.words?.[0]?.id === lineObj.words[0].id);
      if (lineIndex + 1 >= lineObj.page.lines.length) return null;
      return lineObj.page.lines[lineIndex + 1];
    };
    getPageWord = (page, id) => {
      for (let i2 = 0; i2 < page.lines.length; i2++) {
        for (let j2 = 0; j2 < page.lines[i2].words.length; j2++) {
          if (page.lines[i2].words[j2].id === id) return page.lines[i2].words[j2];
        }
      }
      return null;
    };
    deletePageWords = (page, ids) => {
      for (let i2 = 0; i2 < page.lines.length; i2++) {
        for (let j2 = 0; j2 < page.lines[i2].words.length; j2++) {
          const idsIndex = ids.indexOf(page.lines[i2].words[j2].id);
          if (idsIndex >= 0) {
            ids.splice(idsIndex, 1);
            page.lines[i2].words.splice(j2, 1);
            j2--;
            if (page.lines[i2].words.length === 0) {
              page.lines.splice(i2, 1);
              i2--;
              break;
            } else if (j2 + 1 === page.lines[i2].words.length || ids.length === 0) {
              ocr.updateLineBbox(page.lines[i2]);
            }
            if (ids.length === 0) return;
          }
        }
      }
    };
    getPageWords = (page) => {
      const words = [];
      for (let i2 = 0; i2 < page.lines.length; i2++) {
        words.push(...page.lines[i2].words);
      }
      return words;
    };
    getDistinctChars = (ocrPageArr) => {
      const charsAll = {};
      for (const ocrPage of ocrPageArr) {
        for (const ocrLine of ocrPage.lines) {
          for (const ocrWord of ocrLine.words) {
            ocrWord.text.split("").forEach((x2) => {
              charsAll[x2] = true;
            });
          }
        }
      }
      return Object.keys(charsAll);
    };
    getLineText = (line) => {
      let text = "";
      for (let i2 = 0; i2 < line.words.length; i2++) {
        text += `${line.words[i2].text}`;
        if (i2 < line.words.length - 1) text += " ";
      }
      return text;
    };
    getParText = (par) => {
      let text = "";
      for (let i2 = 0; i2 < par.lines.length; i2++) {
        if (i2 > 0) text += " ";
        text += getLineText(par.lines[i2]);
      }
      return text;
    };
    getPageText = (page) => {
      let text = "";
      for (let i2 = 0; i2 < page.lines.length; i2++) {
        if (i2 > 0) text += "\n";
        text += getLineText(page.lines[i2]);
      }
      return text;
    };
    removeCircularRefsOcr = (pages) => {
      const pagesClone = structuredClone(pages);
      pagesClone.forEach((page) => {
        page.pars.length = 0;
        page.lines.forEach((line) => {
          delete line.page;
          delete line.par;
          line.words.forEach((word) => {
            delete word.line;
          });
        });
      });
      return pagesClone;
    };
    addCircularRefsOcr = (pages) => {
      pages.forEach(
        (page) => {
          page.lines.forEach((line) => {
            line.page = page;
            line.words.forEach((word) => {
              word.line = line;
            });
          });
        }
      );
      return pages;
    };
    ocr = {
      OcrPage,
      OcrPar,
      OcrLine,
      OcrWord,
      OcrChar,
      calcLineStartAngleAdj,
      updateLineBbox,
      calcBboxUnion,
      calcWordBbox,
      calcWordAngleAdj,
      getPageWord,
      getPageWords,
      getDistinctChars,
      getMatchingWords,
      getMatchingWordIds,
      getPageText,
      getParText,
      getLineText,
      getPrevLine,
      getNextLine,
      getWordFillOpacity,
      clonePage,
      cloneLine,
      cloneWord,
      cloneChar,
      rotateLine,
      deletePageWords,
      replaceLigatures,
      scaleLine,
      scalePage,
      escapeXml
    };
    ocrObjects_default = ocr;
  }
});

// node_modules/scribe.js-ocr/js/utils/reflowPars.js
function assignParagraphs(page, angle) {
  let endsEarlyPrev = false;
  let startsLatePrev = false;
  let bulletPrev = false;
  let letterEndPrev = false;
  let newPar = true;
  let reason = "first line";
  const sinAngle = Math.sin(angle * (Math.PI / 180));
  const cosAngle = Math.cos(angle * (Math.PI / 180));
  const parArr = [];
  const lineLeftArr = (
    /** @type {Array<number>} */
    []
  );
  const lineRightArr = (
    /** @type {Array<number>} */
    []
  );
  const lineWidthArr = (
    /** @type {Array<number>} */
    []
  );
  const lineCenterArr = (
    /** @type {Array<number>} */
    []
  );
  const lineSpaceArr = (
    /** @type {Array<number>} */
    []
  );
  let y2Prev = null;
  for (let h2 = 0; h2 < page.lines.length; h2++) {
    const line = page.lines[h2];
    if (!line) continue;
    lineSpaceArr.push(line.bbox.bottom - y2Prev);
    const x1Rot = line.bbox.left * cosAngle - sinAngle * line.bbox.bottom;
    const x2Rot = line.bbox.right * cosAngle - sinAngle * line.bbox.bottom;
    lineLeftArr.push(x1Rot);
    lineRightArr.push(x2Rot);
    lineWidthArr.push(line.bbox.right - line.bbox.left);
    lineCenterArr.push((x1Rot + x2Rot) / 2);
    y2Prev = line.bbox.bottom;
  }
  const calcExpected = (lineIndex) => {
    const windowSize = 5;
    const linesPrev = page.lines.slice(Math.max(0, lineIndex - windowSize), lineIndex).filter((x2) => x2.bbox.bottom <= page.lines[lineIndex].bbox.bottom);
    const linesNext = page.lines.slice(lineIndex + 1, lineIndex + windowSize + 1).filter((x2) => x2.bbox.bottom >= page.lines[lineIndex].bbox.bottom);
    const linesNextN = linesNext.length;
    const linesPrevN = Math.min(windowSize - linesNextN, linesPrev.length);
    const compIndices = [];
    if (linesPrevN) compIndices.push(...range(lineIndex - linesPrevN, lineIndex - 1));
    if (linesNextN) compIndices.push(...range(lineIndex + 1, lineIndex + linesNextN));
    if (!compIndices.length) return null;
    const lineLeftMedian = quantile(compIndices.map((x2) => lineLeftArr[x2]), 0.5);
    const lineRightMedian = quantile(compIndices.map((x2) => lineRightArr[x2]), 0.5);
    const lineWidthMedian = quantile(compIndices.map((x2) => lineWidthArr[x2]), 0.5);
    const lineSpaceMedian = quantile(compIndices.map((x2) => lineSpaceArr[x2]), 0.5);
    if (lineLeftMedian === null || lineRightMedian === null || lineWidthMedian === null || lineSpaceMedian === null) return null;
    return {
      lineLeftMedian,
      lineRightMedian,
      lineWidthMedian,
      lineSpaceMedian
    };
  };
  for (let h2 = 0; h2 < page.lines.length; h2++) {
    const line = page.lines[h2];
    let endsEarlyInt = false;
    let startsLate = false;
    const bullet = /^([]|((i+|\d+|[a-z])(\.|\)))$)/.test(line.words[0].text);
    const lowerStart = /[a-z]/.test(line.words[0].text.slice(0, 1));
    const letterEnd = /\w/.test(line.words[line.words.length - 1].text.slice(-1));
    const lowerConnection = lowerStart && letterEndPrev;
    let parLineIndices = (
      /** @type {?Array<number>} */
      []
    );
    if (parArr[parArr.length - 1] && parArr[parArr.length - 1].lines.length > 0) {
      parLineIndices = parArr[parArr.length - 1].lines.map((line2) => page.lines.indexOf(line2));
      if (parArr[parArr.length - 1].lines.length > 2 && !bulletPrev) {
        const parLeftMedian = quantile(parLineIndices.map((x2) => lineLeftArr[x2]), 0.5);
        const parWidthMedian = quantile(parLineIndices.map((x2) => lineWidthArr[x2]), 0.5);
        const leftChangeThresh = Math.max(parWidthMedian * 0.05, 50);
        if (parLeftMedian && parWidthMedian && lineLeftArr[h2] && Math.abs(lineLeftArr[h2] - lineLeftArr[h2 - 1]) > leftChangeThresh && Math.abs(lineLeftArr[h2] - parLeftMedian) > leftChangeThresh && Math.abs(lineLeftArr[h2 + 1] - parLeftMedian) > leftChangeThresh) {
          newPar = true;
          reason = "left change";
        }
      }
    }
    const expected = calcExpected(h2);
    if (!expected) {
      newPar = true;
      reason = "default value (unable to calculate)";
    } else {
      const {
        lineLeftMedian,
        lineRightMedian,
        lineWidthMedian,
        lineSpaceMedian
      } = expected;
      const indented = lineLeftMedian && h2 + 1 < page.lines.length && lineLeftArr[h2] > lineLeftMedian + lineWidthMedian * 0.025 && lineLeftArr[h2] > lineLeftArr[h2 - 1] + 1 && lineLeftArr[h2] > lineLeftArr[h2 + 1];
      const centerAlignedPrev = parLineIndices && parLineIndices.map((x2) => lineCenterArr[x2]).every((x2) => Math.abs(x2 - lineCenterArr[h2 - 1]) < lineWidthMedian * 0.0125);
      const centerAligned = lineCenterArr[h2 - 1] && Math.abs(lineCenterArr[h2 - 1] - lineCenterArr[h2]) < lineWidthMedian * 0.0125;
      const centerAlignedNext = lineCenterArr[h2 + 1] && Math.abs(lineCenterArr[h2 + 1] - lineCenterArr[h2]) < lineWidthMedian * 0.0125;
      const centerAlignedStart = !centerAlignedPrev && !centerAligned && centerAlignedNext;
      const centerAlignedEnd = centerAlignedPrev && !centerAligned;
      if (parLineIndices && lineCenterArr[h2 - 1] && (centerAlignedStart || centerAlignedEnd)) {
        const widthVariationPrev = parLineIndices && parLineIndices.length > 1 && parLineIndices.map((x2) => lineWidthArr[x2]).some((x2) => Math.abs(x2 - lineWidthArr[h2 - 1]) > lineWidthMedian * 0.05);
        const widthVariation = lineRightArr[h2 - 1] && Math.abs(lineRightArr[h2] - lineRightArr[h2 - 1]) > lineWidthMedian * 0.05;
        const widthVariationNext = lineRightArr[h2 + 1] && Math.abs(lineRightArr[h2] - lineRightArr[h2 + 1]) > lineWidthMedian * 0.05;
        const leftChange = lineLeftArr[h2 - 1] && Math.abs(lineLeftArr[h2 - 1] - lineLeftArr[h2]) > lineWidthMedian * 0.025;
        const rightChange = lineRightArr[h2 - 1] && Math.abs(lineRightArr[h2 - 1] - lineRightArr[h2]) > lineWidthMedian * 0.025;
        if (leftChange && rightChange && widthVariationPrev && widthVariation && widthVariationNext) {
          newPar = true;
          reason = "alignment change";
        }
      }
      const indentedWeak = lineLeftArr[h2] > lineLeftArr[h2 - 1] + 1;
      const lineSpaceWeak = lineSpaceArr[h2 - 1] > 0 && lineSpaceArr[h2] > 1.1 * lineSpaceArr[h2 - 1];
      const lineNextFirstWord = page.lines[h2 + 1] && page.lines[h2 + 1].words[0];
      endsEarlyInt = lineRightMedian - lineRightArr[h2] > lineWidthMedian * 0.1 && !!lineRightArr[h2 - 1] && lineRightArr[h2 - 1] - lineRightArr[h2] > lineWidthMedian * 0.1 && lineNextFirstWord && lineNextFirstWord.bbox.right - lineNextFirstWord.bbox.left < lineRightMedian - lineRightArr[h2];
      startsLate = lineLeftArr[h2] > lineLeftMedian + lineWidthMedian * 0.2 && !!lineLeftArr[h2 - 1] && lineLeftArr[h2] - lineLeftArr[h2 - 1] > lineWidthMedian * 0.2;
      if (endsEarlyPrev && !lowerConnection && (lineSpaceWeak || indentedWeak)) {
        newPar = true;
        reason = "prev line ends early";
      } else if (startsLatePrev && !lowerConnection && !centerAlignedPrev) {
        newPar = true;
        reason = "prev line starts late";
      } else if (indented && !bulletPrev && !lowerConnection && !centerAlignedPrev) {
        newPar = true;
        reason = "indentation";
      } else if (h2 === 1 && lineSpaceArr[h2] > 1.5 * lineSpaceMedian) {
        newPar = true;
        reason = "large space (first line)";
      }
    }
    const lineHeight = line.bbox.bottom - line.bbox.top;
    if (lineSpaceArr[h2] && lineSpaceArr[h2] < lineHeight * -1) {
      newPar = true;
      reason = "new column";
    }
    const lineSpaceIncrease = lineSpaceArr[h2 - 1] > 0 && lineSpaceArr[h2] > 1.5 * lineSpaceArr[h2 - 1];
    const lineSpaceDecrease = lineSpaceArr[h2 + 1] > 0 && lineSpaceArr[h2] > 1.5 * lineSpaceArr[h2 + 1];
    if (lineSpaceIncrease || lineSpaceDecrease) {
      newPar = true;
      reason = "large space (relative)";
    }
    const bbox = line.bbox;
    const bboxPrev = page.lines[h2 - 1]?.bbox;
    const height = bbox.bottom - bbox.top;
    const width = bbox.right - bbox.left;
    const heightRot = height * cosAngle - sinAngle * width;
    if (lineSpaceArr[h2] && lineSpaceArr[h2] > 3 * heightRot) {
      newPar = true;
      reason = "large space (absolute)";
    }
    if (bboxPrev && (bboxPrev.right < bbox.left || bboxPrev.left > bbox.right) && (bboxPrev.bottom < bbox.top || bboxPrev.top > bbox.bottom)) {
      newPar = true;
      reason = "no overlap";
    }
    if (newPar) {
      const par = new OcrPar(page, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
      par.reason = reason;
      parArr.push(par);
      reason = "";
    }
    parArr[parArr.length - 1].lines.push(line);
    endsEarlyPrev = endsEarlyInt && !newPar;
    startsLatePrev = startsLate;
    bulletPrev = bullet;
    letterEndPrev = letterEnd;
    newPar = false;
  }
  parArr.forEach((parObj) => {
    parObj.lines.forEach((lineObj) => {
      lineObj.par = parObj;
    });
    parObj.bbox = calcBboxUnion(parObj.lines.map((x2) => x2.bbox));
  });
  page.pars = parArr;
}
var init_reflowPars = __esm({
  "node_modules/scribe.js-ocr/js/utils/reflowPars.js"() {
    init_ocrObjects();
    init_miscUtils();
  }
});

// node_modules/scribe.js-ocr/js/export/resources/docxFiles.js
var rels, contentTypes, app, core, fontTable, settings, styles, webSettings, rels2, theme, docxStrings, documentStart, documentEnd;
var init_docxFiles = __esm({
  "node_modules/scribe.js-ocr/js/export/resources/docxFiles.js"() {
    rels = String.raw`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/></Relationships>`;
    contentTypes = String.raw`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/><Default Extension="xml" ContentType="application/xml"/><Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/><Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/><Override PartName="/word/settings.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml"/><Override PartName="/word/webSettings.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml"/><Override PartName="/word/fontTable.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml"/><Override PartName="/word/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/><Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/><Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/></Types>`;
    app = String.raw`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"><Template>Normal.dotm</Template><TotalTime>1</TotalTime><Pages>1</Pages><Words>0</Words><Characters>0</Characters><Application>Microsoft Office Word</Application><DocSecurity>0</DocSecurity><Lines>0</Lines><Paragraphs>0</Paragraphs><ScaleCrop>false</ScaleCrop><Company></Company><LinksUpToDate>false</LinksUpToDate><CharactersWithSpaces>0</CharactersWithSpaces><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0000</AppVersion></Properties>`;
    core = String.raw`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dc:title></dc:title><dc:subject></dc:subject><dc:creator></dc:creator><cp:keywords></cp:keywords><dc:description></dc:description><cp:lastModifiedBy></cp:lastModifiedBy><cp:revision>1</cp:revision><dcterms:created xsi:type="dcterms:W3CDTF">2023-04-15T00:37:00Z</dcterms:created><dcterms:modified xsi:type="dcterms:W3CDTF">2023-04-15T00:38:00Z</dcterms:modified></cp:coreProperties>`;
    fontTable = String.raw`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:fonts xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml" xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml" xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex" xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid" xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml" xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash" xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex" mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh"><w:font w:name="Calibri"><w:panose1 w:val="020F0502020204030204"/><w:charset w:val="00"/><w:family w:val="swiss"/><w:pitch w:val="variable"/><w:sig w:usb0="E4002EFF" w:usb1="C000247B" w:usb2="00000009" w:usb3="00000000" w:csb0="000001FF" w:csb1="00000000"/></w:font><w:font w:name="Times New Roman"><w:panose1 w:val="02020603050405020304"/><w:charset w:val="00"/><w:family w:val="roman"/><w:pitch w:val="variable"/><w:sig w:usb0="E0002EFF" w:usb1="C000785B" w:usb2="00000009" w:usb3="00000000" w:csb0="000001FF" w:csb1="00000000"/></w:font><w:font w:name="Calibri Light"><w:panose1 w:val="020F0302020204030204"/><w:charset w:val="00"/><w:family w:val="swiss"/><w:pitch w:val="variable"/><w:sig w:usb0="E4002EFF" w:usb1="C000247B" w:usb2="00000009" w:usb3="00000000" w:csb0="000001FF" w:csb1="00000000"/></w:font></w:fonts>`;
    settings = String.raw`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:settings xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:w10="urn:schemas-microsoft-com:office:word" xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml" xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml" xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex" xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid" xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml" xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash" xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex" xmlns:sl="http://schemas.openxmlformats.org/schemaLibrary/2006/main" mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh"><w:zoom w:percent="100"/><w:defaultTabStop w:val="720"/><w:characterSpacingControl w:val="doNotCompress"/><w:compat><w:compatSetting w:name="compatibilityMode" w:uri="http://schemas.microsoft.com/office/word" w:val="15"/><w:compatSetting w:name="overrideTableStyleFontSizeAndJustification" w:uri="http://schemas.microsoft.com/office/word" w:val="1"/><w:compatSetting w:name="enableOpenTypeFeatures" w:uri="http://schemas.microsoft.com/office/word" w:val="1"/><w:compatSetting w:name="doNotFlipMirrorIndents" w:uri="http://schemas.microsoft.com/office/word" w:val="1"/><w:compatSetting w:name="differentiateMultirowTableHeaders" w:uri="http://schemas.microsoft.com/office/word" w:val="1"/><w:compatSetting w:name="useWord2013TrackBottomHyphenation" w:uri="http://schemas.microsoft.com/office/word" w:val="0"/></w:compat><w:rsids><w:rsidRoot w:val="00865E20"/><w:rsid w:val="00080B46"/><w:rsid w:val="00865E20"/><w:rsid w:val="00BE4E21"/><w:rsid w:val="00EA156F"/></w:rsids><m:mathPr><m:mathFont m:val="Cambria Math"/><m:brkBin m:val="before"/><m:brkBinSub m:val="--"/><m:smallFrac m:val="0"/><m:dispDef/><m:lMargin m:val="0"/><m:rMargin m:val="0"/><m:defJc m:val="centerGroup"/><m:wrapIndent m:val="1440"/><m:intLim m:val="subSup"/><m:naryLim m:val="undOvr"/></m:mathPr><w:themeFontLang w:val="en-US"/><w:clrSchemeMapping w:bg1="light1" w:t1="dark1" w:bg2="light2" w:t2="dark2" w:accent1="accent1" w:accent2="accent2" w:accent3="accent3" w:accent4="accent4" w:accent5="accent5" w:accent6="accent6" w:hyperlink="hyperlink" w:followedHyperlink="followedHyperlink"/><w:shapeDefaults><o:shapedefaults v:ext="edit" spidmax="1026"/><o:shapelayout v:ext="edit"><o:idmap v:ext="edit" data="1"/></o:shapelayout></w:shapeDefaults><w:decimalSymbol w:val="."/><w:listSeparator w:val=","/><w14:docId w14:val="79551B09"/><w15:chartTrackingRefBased/><w15:docId w15:val="{360233D5-D0EB-4A45-BE67-A083148A9867}"/></w:settings>`;
    styles = String.raw`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:styles xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml" xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml" xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex" xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid" xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml" xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash" xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex" mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh"><w:docDefaults><w:rPrDefault><w:rPr><w:rFonts w:asciiTheme="minorHAnsi" w:eastAsiaTheme="minorHAnsi" w:hAnsiTheme="minorHAnsi" w:cstheme="minorBidi"/><w:sz w:val="22"/><w:szCs w:val="22"/><w:lang w:val="en-US" w:eastAsia="en-US" w:bidi="ar-SA"/></w:rPr></w:rPrDefault><w:pPrDefault><w:pPr><w:spacing w:after="160" w:line="259" w:lineRule="auto"/></w:pPr></w:pPrDefault></w:docDefaults><w:style w:type="paragraph" w:default="1" w:styleId="Normal"><w:name w:val="Normal"/><w:qFormat/></w:style><w:style w:type="character" w:default="1" w:styleId="DefaultParagraphFont"><w:name w:val="Default Paragraph Font"/><w:uiPriority w:val="1"/><w:semiHidden/><w:unhideWhenUsed/></w:style><w:style w:type="table" w:default="1" w:styleId="TableNormal"><w:name w:val="Normal Table"/><w:uiPriority w:val="99"/><w:semiHidden/><w:unhideWhenUsed/><w:tblPr><w:tblInd w:w="0" w:type="dxa"/><w:tblCellMar><w:top w:w="0" w:type="dxa"/><w:left w:w="108" w:type="dxa"/><w:bottom w:w="0" w:type="dxa"/><w:right w:w="108" w:type="dxa"/></w:tblCellMar></w:tblPr></w:style><w:style w:type="numbering" w:default="1" w:styleId="NoList"><w:name w:val="No List"/><w:uiPriority w:val="99"/><w:semiHidden/><w:unhideWhenUsed/></w:style></w:styles>`;
    webSettings = String.raw`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:webSettings xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml" xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml" xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex" xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid" xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml" xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash" xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex" mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh"><w:optimizeForBrowser/><w:allowPNG/></w:webSettings>`;
    rels2 = String.raw`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings" Target="webSettings.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings" Target="settings.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId5" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/><Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable" Target="fontTable.xml"/></Relationships>`;
    theme = String.raw`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="4472C4"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="5B9BD5"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface=" Light"/><a:font script="Hang" typeface=" "/><a:font script="Hans" typeface=" Light"/><a:font script="Hant" typeface=""/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Angsana New"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface=""/><a:font script="Hang" typeface=" "/><a:font script="Hans" typeface=""/><a:font script="Hant" typeface=""/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Cordia New"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>`;
    docxStrings = [
      { path: "_rels/.rels", content: rels },
      { path: "[Content_Types].xml", content: contentTypes },
      { path: "docProps/app.xml", content: app },
      { path: "docProps/core.xml", content: core },
      { path: "word/fontTable.xml", content: fontTable },
      { path: "word/settings.xml", content: settings },
      { path: "word/styles.xml", content: styles },
      { path: "word/webSettings.xml", content: webSettings },
      { path: "word/_rels/document.xml.rels", content: rels2 },
      { path: "word/theme/theme1.xml", content: theme }
    ];
    documentStart = '<w:document xmlns:wpc="http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas" xmlns:cx="http://schemas.microsoft.com/office/drawing/2014/chartex" xmlns:cx1="http://schemas.microsoft.com/office/drawing/2015/9/8/chartex" xmlns:cx2="http://schemas.microsoft.com/office/drawing/2015/10/21/chartex" xmlns:cx3="http://schemas.microsoft.com/office/drawing/2016/5/9/chartex" xmlns:cx4="http://schemas.microsoft.com/office/drawing/2016/5/10/chartex" xmlns:cx5="http://schemas.microsoft.com/office/drawing/2016/5/11/chartex" xmlns:cx6="http://schemas.microsoft.com/office/drawing/2016/5/12/chartex" xmlns:cx7="http://schemas.microsoft.com/office/drawing/2016/5/13/chartex" xmlns:cx8="http://schemas.microsoft.com/office/drawing/2016/5/14/chartex" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:aink="http://schemas.microsoft.com/office/drawing/2016/ink" xmlns:am3d="http://schemas.microsoft.com/office/drawing/2017/model3d" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:oel="http://schemas.microsoft.com/office/2019/extlst" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:wp14="http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing" xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing" xmlns:w10="urn:schemas-microsoft-com:office:word" xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml" xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml" xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex" xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid" xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml" xmlns:w16du="http://schemas.microsoft.com/office/word/2023/wordml/word16du" xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash" xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex" xmlns:wpg="http://schemas.microsoft.com/office/word/2010/wordprocessingGroup" xmlns:wpi="http://schemas.microsoft.com/office/word/2010/wordprocessingInk" xmlns:wne="http://schemas.microsoft.com/office/word/2006/wordml" xmlns:wps="http://schemas.microsoft.com/office/word/2010/wordprocessingShape" mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh wp14"><w:body>';
    documentEnd = `</w:body>
</w:document>`;
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/codecs/deflate.js
function extractArray(array) {
  return flatArray(array.map(([length, value]) => new Array(length).fill(value, 0, length)));
}
function flatArray(array) {
  return array.reduce((a2, b2) => a2.concat(Array.isArray(b2) ? flatArray(b2) : b2), []);
}
function Tree() {
  const that = this;
  function gen_bitlen3(s2) {
    const tree = that.dyn_tree;
    const stree = that.stat_desc.static_tree;
    const extra = that.stat_desc.extra_bits;
    const base = that.stat_desc.extra_base;
    const max_length = that.stat_desc.max_length;
    let h2;
    let n2, m2;
    let bits;
    let xbits;
    let f2;
    let overflow = 0;
    for (bits = 0; bits <= MAX_BITS2; bits++)
      s2.bl_count[bits] = 0;
    tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
    for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE2; h2++) {
      n2 = s2.heap[h2];
      bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n2 * 2 + 1] = bits;
      if (n2 > that.max_code)
        continue;
      s2.bl_count[bits]++;
      xbits = 0;
      if (n2 >= base)
        xbits = extra[n2 - base];
      f2 = tree[n2 * 2];
      s2.opt_len += f2 * (bits + xbits);
      if (stree)
        s2.static_len += f2 * (stree[n2 * 2 + 1] + xbits);
    }
    if (overflow === 0)
      return;
    do {
      bits = max_length - 1;
      while (s2.bl_count[bits] === 0)
        bits--;
      s2.bl_count[bits]--;
      s2.bl_count[bits + 1] += 2;
      s2.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n2 = s2.bl_count[bits];
      while (n2 !== 0) {
        m2 = s2.heap[--h2];
        if (m2 > that.max_code)
          continue;
        if (tree[m2 * 2 + 1] != bits) {
          s2.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
          tree[m2 * 2 + 1] = bits;
        }
        n2--;
      }
    }
  }
  function bi_reverse3(code, len) {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  function gen_codes3(tree, max_code, bl_count) {
    const next_code = [];
    let code = 0;
    let bits;
    let n2;
    let len;
    for (bits = 1; bits <= MAX_BITS2; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n2 = 0; n2 <= max_code; n2++) {
      len = tree[n2 * 2 + 1];
      if (len === 0)
        continue;
      tree[n2 * 2] = bi_reverse3(next_code[len]++, len);
    }
  }
  that.build_tree = function(s2) {
    const tree = that.dyn_tree;
    const stree = that.stat_desc.static_tree;
    const elems = that.stat_desc.elems;
    let n2, m2;
    let max_code = -1;
    let node;
    s2.heap_len = 0;
    s2.heap_max = HEAP_SIZE2;
    for (n2 = 0; n2 < elems; n2++) {
      if (tree[n2 * 2] !== 0) {
        s2.heap[++s2.heap_len] = max_code = n2;
        s2.depth[n2] = 0;
      } else {
        tree[n2 * 2 + 1] = 0;
      }
    }
    while (s2.heap_len < 2) {
      node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s2.depth[node] = 0;
      s2.opt_len--;
      if (stree)
        s2.static_len -= stree[node * 2 + 1];
    }
    that.max_code = max_code;
    for (n2 = Math.floor(s2.heap_len / 2); n2 >= 1; n2--)
      s2.pqdownheap(tree, n2);
    node = elems;
    do {
      n2 = s2.heap[1];
      s2.heap[1] = s2.heap[s2.heap_len--];
      s2.pqdownheap(tree, 1);
      m2 = s2.heap[1];
      s2.heap[--s2.heap_max] = n2;
      s2.heap[--s2.heap_max] = m2;
      tree[node * 2] = tree[n2 * 2] + tree[m2 * 2];
      s2.depth[node] = Math.max(s2.depth[n2], s2.depth[m2]) + 1;
      tree[n2 * 2 + 1] = tree[m2 * 2 + 1] = node;
      s2.heap[1] = node++;
      s2.pqdownheap(tree, 1);
    } while (s2.heap_len >= 2);
    s2.heap[--s2.heap_max] = s2.heap[1];
    gen_bitlen3(s2);
    gen_codes3(tree, that.max_code, s2.bl_count);
  };
}
function StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {
  const that = this;
  that.static_tree = static_tree;
  that.extra_bits = extra_bits;
  that.extra_base = extra_base;
  that.elems = elems;
  that.max_length = max_length;
}
function Config2(good_length, max_lazy, nice_length, max_chain, func) {
  const that = this;
  that.good_length = good_length;
  that.max_lazy = max_lazy;
  that.nice_length = nice_length;
  that.max_chain = max_chain;
  that.func = func;
}
function smaller2(tree, n2, m2, depth) {
  const tn2 = tree[n2 * 2];
  const tm2 = tree[m2 * 2];
  return tn2 < tm2 || tn2 == tm2 && depth[n2] <= depth[m2];
}
function Deflate2() {
  const that = this;
  let strm;
  let status;
  let pending_buf_size;
  let last_flush;
  let w_size;
  let w_bits;
  let w_mask;
  let win;
  let window_size;
  let prev;
  let head;
  let ins_h;
  let hash_size;
  let hash_bits;
  let hash_mask;
  let hash_shift;
  let block_start;
  let match_length;
  let prev_match;
  let match_available;
  let strstart;
  let match_start;
  let lookahead;
  let prev_length;
  let max_chain_length;
  let max_lazy_match;
  let level;
  let strategy;
  let good_match;
  let nice_match;
  let dyn_ltree;
  let dyn_dtree;
  let bl_tree;
  const l_desc = new Tree();
  const d_desc = new Tree();
  const bl_desc = new Tree();
  that.depth = [];
  let lit_bufsize;
  let last_lit;
  let matches;
  let last_eob_len;
  let bi_buf;
  let bi_valid;
  that.bl_count = [];
  that.heap = [];
  dyn_ltree = [];
  dyn_dtree = [];
  bl_tree = [];
  function lm_init3() {
    window_size = 2 * w_size;
    head[hash_size - 1] = 0;
    for (let i2 = 0; i2 < hash_size - 1; i2++) {
      head[i2] = 0;
    }
    max_lazy_match = config_table[level].max_lazy;
    good_match = config_table[level].good_length;
    nice_match = config_table[level].nice_length;
    max_chain_length = config_table[level].max_chain;
    strstart = 0;
    block_start = 0;
    lookahead = 0;
    match_length = prev_length = MIN_MATCH2 - 1;
    match_available = 0;
    ins_h = 0;
  }
  function init_block3() {
    let i2;
    for (i2 = 0; i2 < L_CODES2; i2++)
      dyn_ltree[i2 * 2] = 0;
    for (i2 = 0; i2 < D_CODES2; i2++)
      dyn_dtree[i2 * 2] = 0;
    for (i2 = 0; i2 < BL_CODES2; i2++)
      bl_tree[i2 * 2] = 0;
    dyn_ltree[END_BLOCK2 * 2] = 1;
    that.opt_len = that.static_len = 0;
    last_lit = matches = 0;
  }
  function tr_init() {
    l_desc.dyn_tree = dyn_ltree;
    l_desc.stat_desc = StaticTree.static_l_desc;
    d_desc.dyn_tree = dyn_dtree;
    d_desc.stat_desc = StaticTree.static_d_desc;
    bl_desc.dyn_tree = bl_tree;
    bl_desc.stat_desc = StaticTree.static_bl_desc;
    bi_buf = 0;
    bi_valid = 0;
    last_eob_len = 8;
    init_block3();
  }
  that.pqdownheap = function(tree, k2) {
    const heap = that.heap;
    const v2 = heap[k2];
    let j2 = k2 << 1;
    while (j2 <= that.heap_len) {
      if (j2 < that.heap_len && smaller2(tree, heap[j2 + 1], heap[j2], that.depth)) {
        j2++;
      }
      if (smaller2(tree, v2, heap[j2], that.depth))
        break;
      heap[k2] = heap[j2];
      k2 = j2;
      j2 <<= 1;
    }
    heap[k2] = v2;
  };
  function scan_tree3(tree, max_code) {
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (let n2 = 0; n2 <= max_code; n2++) {
      curlen = nextlen;
      nextlen = tree[(n2 + 1) * 2 + 1];
      if (++count < max_count && curlen == nextlen) {
        continue;
      } else if (count < min_count) {
        bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen != prevlen)
          bl_tree[curlen * 2]++;
        bl_tree[REP_3_62 * 2]++;
      } else if (count <= 10) {
        bl_tree[REPZ_3_102 * 2]++;
      } else {
        bl_tree[REPZ_11_1382 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen == nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function build_bl_tree3() {
    let max_blindex;
    scan_tree3(dyn_ltree, l_desc.max_code);
    scan_tree3(dyn_dtree, d_desc.max_code);
    bl_desc.build_tree(that);
    for (max_blindex = BL_CODES2 - 1; max_blindex >= 3; max_blindex--) {
      if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0)
        break;
    }
    that.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  function put_byte3(p2) {
    that.pending_buf[that.pending++] = p2;
  }
  function put_short3(w2) {
    put_byte3(w2 & 255);
    put_byte3(w2 >>> 8 & 255);
  }
  function putShortMSB3(b2) {
    put_byte3(b2 >> 8 & 255);
    put_byte3(b2 & 255 & 255);
  }
  function send_bits3(value, length) {
    let val;
    const len = length;
    if (bi_valid > Buf_size2 - len) {
      val = value;
      bi_buf |= val << bi_valid & 65535;
      put_short3(bi_buf);
      bi_buf = val >>> Buf_size2 - bi_valid;
      bi_valid += len - Buf_size2;
    } else {
      bi_buf |= value << bi_valid & 65535;
      bi_valid += len;
    }
  }
  function send_code3(c2, tree) {
    const c22 = c2 * 2;
    send_bits3(tree[c22] & 65535, tree[c22 + 1] & 65535);
  }
  function send_tree3(tree, max_code) {
    let n2;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n2 = 0; n2 <= max_code; n2++) {
      curlen = nextlen;
      nextlen = tree[(n2 + 1) * 2 + 1];
      if (++count < max_count && curlen == nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code3(curlen, bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen != prevlen) {
          send_code3(curlen, bl_tree);
          count--;
        }
        send_code3(REP_3_62, bl_tree);
        send_bits3(count - 3, 2);
      } else if (count <= 10) {
        send_code3(REPZ_3_102, bl_tree);
        send_bits3(count - 3, 3);
      } else {
        send_code3(REPZ_11_1382, bl_tree);
        send_bits3(count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen == nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function send_all_trees3(lcodes, dcodes, blcodes) {
    let rank3;
    send_bits3(lcodes - 257, 5);
    send_bits3(dcodes - 1, 5);
    send_bits3(blcodes - 4, 4);
    for (rank3 = 0; rank3 < blcodes; rank3++) {
      send_bits3(bl_tree[Tree.bl_order[rank3] * 2 + 1], 3);
    }
    send_tree3(dyn_ltree, lcodes - 1);
    send_tree3(dyn_dtree, dcodes - 1);
  }
  function bi_flush3() {
    if (bi_valid == 16) {
      put_short3(bi_buf);
      bi_buf = 0;
      bi_valid = 0;
    } else if (bi_valid >= 8) {
      put_byte3(bi_buf & 255);
      bi_buf >>>= 8;
      bi_valid -= 8;
    }
  }
  function _tr_align3() {
    send_bits3(STATIC_TREES2 << 1, 3);
    send_code3(END_BLOCK2, StaticTree.static_ltree);
    bi_flush3();
    if (1 + last_eob_len + 10 - bi_valid < 9) {
      send_bits3(STATIC_TREES2 << 1, 3);
      send_code3(END_BLOCK2, StaticTree.static_ltree);
      bi_flush3();
    }
    last_eob_len = 7;
  }
  function _tr_tally3(dist, lc) {
    let out_length, in_length, dcode;
    that.dist_buf[last_lit] = dist;
    that.lc_buf[last_lit] = lc & 255;
    last_lit++;
    if (dist === 0) {
      dyn_ltree[lc * 2]++;
    } else {
      matches++;
      dist--;
      dyn_ltree[(Tree._length_code[lc] + LITERALS2 + 1) * 2]++;
      dyn_dtree[Tree.d_code(dist) * 2]++;
    }
    if ((last_lit & 8191) === 0 && level > 2) {
      out_length = last_lit * 8;
      in_length = strstart - block_start;
      for (dcode = 0; dcode < D_CODES2; dcode++) {
        out_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);
      }
      out_length >>>= 3;
      if (matches < Math.floor(last_lit / 2) && out_length < Math.floor(in_length / 2))
        return true;
    }
    return last_lit == lit_bufsize - 1;
  }
  function compress_block3(ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (last_lit !== 0) {
      do {
        dist = that.dist_buf[lx];
        lc = that.lc_buf[lx];
        lx++;
        if (dist === 0) {
          send_code3(lc, ltree);
        } else {
          code = Tree._length_code[lc];
          send_code3(code + LITERALS2 + 1, ltree);
          extra = Tree.extra_lbits[code];
          if (extra !== 0) {
            lc -= Tree.base_length[code];
            send_bits3(lc, extra);
          }
          dist--;
          code = Tree.d_code(dist);
          send_code3(code, dtree);
          extra = Tree.extra_dbits[code];
          if (extra !== 0) {
            dist -= Tree.base_dist[code];
            send_bits3(dist, extra);
          }
        }
      } while (lx < last_lit);
    }
    send_code3(END_BLOCK2, ltree);
    last_eob_len = ltree[END_BLOCK2 * 2 + 1];
  }
  function bi_windup3() {
    if (bi_valid > 8) {
      put_short3(bi_buf);
    } else if (bi_valid > 0) {
      put_byte3(bi_buf & 255);
    }
    bi_buf = 0;
    bi_valid = 0;
  }
  function copy_block3(buf, len, header) {
    bi_windup3();
    last_eob_len = 8;
    if (header) {
      put_short3(len);
      put_short3(~len);
    }
    that.pending_buf.set(win.subarray(buf, buf + len), that.pending);
    that.pending += len;
  }
  function _tr_stored_block3(buf, stored_len, eof) {
    send_bits3((STORED_BLOCK2 << 1) + (eof ? 1 : 0), 3);
    copy_block3(buf, stored_len, true);
  }
  function _tr_flush_block3(buf, stored_len, eof) {
    let opt_lenb, static_lenb;
    let max_blindex = 0;
    if (level > 0) {
      l_desc.build_tree(that);
      d_desc.build_tree(that);
      max_blindex = build_bl_tree3();
      opt_lenb = that.opt_len + 3 + 7 >>> 3;
      static_lenb = that.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb)
        opt_lenb = static_lenb;
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf != -1) {
      _tr_stored_block3(buf, stored_len, eof);
    } else if (static_lenb == opt_lenb) {
      send_bits3((STATIC_TREES2 << 1) + (eof ? 1 : 0), 3);
      compress_block3(StaticTree.static_ltree, StaticTree.static_dtree);
    } else {
      send_bits3((DYN_TREES2 << 1) + (eof ? 1 : 0), 3);
      send_all_trees3(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
      compress_block3(dyn_ltree, dyn_dtree);
    }
    init_block3();
    if (eof) {
      bi_windup3();
    }
  }
  function flush_block_only3(eof) {
    _tr_flush_block3(block_start >= 0 ? block_start : -1, strstart - block_start, eof);
    block_start = strstart;
    strm.flush_pending();
  }
  function fill_window3() {
    let n2, m2;
    let p2;
    let more;
    do {
      more = window_size - lookahead - strstart;
      if (more === 0 && strstart === 0 && lookahead === 0) {
        more = w_size;
      } else if (more == -1) {
        more--;
      } else if (strstart >= w_size + w_size - MIN_LOOKAHEAD2) {
        win.set(win.subarray(w_size, w_size + w_size), 0);
        match_start -= w_size;
        strstart -= w_size;
        block_start -= w_size;
        n2 = hash_size;
        p2 = n2;
        do {
          m2 = head[--p2] & 65535;
          head[p2] = m2 >= w_size ? m2 - w_size : 0;
        } while (--n2 !== 0);
        n2 = w_size;
        p2 = n2;
        do {
          m2 = prev[--p2] & 65535;
          prev[p2] = m2 >= w_size ? m2 - w_size : 0;
        } while (--n2 !== 0);
        more += w_size;
      }
      if (strm.avail_in === 0)
        return;
      n2 = strm.read_buf(win, strstart + lookahead, more);
      lookahead += n2;
      if (lookahead >= MIN_MATCH2) {
        ins_h = win[strstart] & 255;
        ins_h = (ins_h << hash_shift ^ win[strstart + 1] & 255) & hash_mask;
      }
    } while (lookahead < MIN_LOOKAHEAD2 && strm.avail_in !== 0);
  }
  function deflate_stored3(flush) {
    let max_block_size = 65535;
    let max_start;
    if (max_block_size > pending_buf_size - 5) {
      max_block_size = pending_buf_size - 5;
    }
    while (true) {
      if (lookahead <= 1) {
        fill_window3();
        if (lookahead === 0 && flush == Z_NO_FLUSH2)
          return NeedMore;
        if (lookahead === 0)
          break;
      }
      strstart += lookahead;
      lookahead = 0;
      max_start = block_start + max_block_size;
      if (strstart === 0 || strstart >= max_start) {
        lookahead = strstart - max_start;
        strstart = max_start;
        flush_block_only3(false);
        if (strm.avail_out === 0)
          return NeedMore;
      }
      if (strstart - block_start >= w_size - MIN_LOOKAHEAD2) {
        flush_block_only3(false);
        if (strm.avail_out === 0)
          return NeedMore;
      }
    }
    flush_block_only3(flush == Z_FINISH2);
    if (strm.avail_out === 0)
      return flush == Z_FINISH2 ? FinishStarted : NeedMore;
    return flush == Z_FINISH2 ? FinishDone : BlockDone;
  }
  function longest_match3(cur_match) {
    let chain_length = max_chain_length;
    let scan = strstart;
    let match;
    let len;
    let best_len = prev_length;
    const limit = strstart > w_size - MIN_LOOKAHEAD2 ? strstart - (w_size - MIN_LOOKAHEAD2) : 0;
    let _nice_match = nice_match;
    const wmask = w_mask;
    const strend = strstart + MAX_MATCH2;
    let scan_end1 = win[scan + best_len - 1];
    let scan_end = win[scan + best_len];
    if (prev_length >= good_match) {
      chain_length >>= 2;
    }
    if (_nice_match > lookahead)
      _nice_match = lookahead;
    do {
      match = cur_match;
      if (win[match + best_len] != scan_end || win[match + best_len - 1] != scan_end1 || win[match] != win[scan] || win[++match] != win[scan + 1])
        continue;
      scan += 2;
      match++;
      do {
      } while (win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && scan < strend);
      len = MAX_MATCH2 - (strend - scan);
      scan = strend - MAX_MATCH2;
      if (len > best_len) {
        match_start = cur_match;
        best_len = len;
        if (len >= _nice_match)
          break;
        scan_end1 = win[scan + best_len - 1];
        scan_end = win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask] & 65535) > limit && --chain_length !== 0);
    if (best_len <= lookahead)
      return best_len;
    return lookahead;
  }
  function deflate_fast3(flush) {
    let hash_head = 0;
    let bflush;
    while (true) {
      if (lookahead < MIN_LOOKAHEAD2) {
        fill_window3();
        if (lookahead < MIN_LOOKAHEAD2 && flush == Z_NO_FLUSH2) {
          return NeedMore;
        }
        if (lookahead === 0)
          break;
      }
      if (lookahead >= MIN_MATCH2) {
        ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH2 - 1)] & 255) & hash_mask;
        hash_head = head[ins_h] & 65535;
        prev[strstart & w_mask] = head[ins_h];
        head[ins_h] = strstart;
      }
      if (hash_head !== 0 && (strstart - hash_head & 65535) <= w_size - MIN_LOOKAHEAD2) {
        if (strategy != Z_HUFFMAN_ONLY2) {
          match_length = longest_match3(hash_head);
        }
      }
      if (match_length >= MIN_MATCH2) {
        bflush = _tr_tally3(strstart - match_start, match_length - MIN_MATCH2);
        lookahead -= match_length;
        if (match_length <= max_lazy_match && lookahead >= MIN_MATCH2) {
          match_length--;
          do {
            strstart++;
            ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH2 - 1)] & 255) & hash_mask;
            hash_head = head[ins_h] & 65535;
            prev[strstart & w_mask] = head[ins_h];
            head[ins_h] = strstart;
          } while (--match_length !== 0);
          strstart++;
        } else {
          strstart += match_length;
          match_length = 0;
          ins_h = win[strstart] & 255;
          ins_h = (ins_h << hash_shift ^ win[strstart + 1] & 255) & hash_mask;
        }
      } else {
        bflush = _tr_tally3(0, win[strstart] & 255);
        lookahead--;
        strstart++;
      }
      if (bflush) {
        flush_block_only3(false);
        if (strm.avail_out === 0)
          return NeedMore;
      }
    }
    flush_block_only3(flush == Z_FINISH2);
    if (strm.avail_out === 0) {
      if (flush == Z_FINISH2)
        return FinishStarted;
      else
        return NeedMore;
    }
    return flush == Z_FINISH2 ? FinishDone : BlockDone;
  }
  function deflate_slow3(flush) {
    let hash_head = 0;
    let bflush;
    let max_insert;
    while (true) {
      if (lookahead < MIN_LOOKAHEAD2) {
        fill_window3();
        if (lookahead < MIN_LOOKAHEAD2 && flush == Z_NO_FLUSH2) {
          return NeedMore;
        }
        if (lookahead === 0)
          break;
      }
      if (lookahead >= MIN_MATCH2) {
        ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH2 - 1)] & 255) & hash_mask;
        hash_head = head[ins_h] & 65535;
        prev[strstart & w_mask] = head[ins_h];
        head[ins_h] = strstart;
      }
      prev_length = match_length;
      prev_match = match_start;
      match_length = MIN_MATCH2 - 1;
      if (hash_head !== 0 && prev_length < max_lazy_match && (strstart - hash_head & 65535) <= w_size - MIN_LOOKAHEAD2) {
        if (strategy != Z_HUFFMAN_ONLY2) {
          match_length = longest_match3(hash_head);
        }
        if (match_length <= 5 && (strategy == Z_FILTERED2 || match_length == MIN_MATCH2 && strstart - match_start > 4096)) {
          match_length = MIN_MATCH2 - 1;
        }
      }
      if (prev_length >= MIN_MATCH2 && match_length <= prev_length) {
        max_insert = strstart + lookahead - MIN_MATCH2;
        bflush = _tr_tally3(strstart - 1 - prev_match, prev_length - MIN_MATCH2);
        lookahead -= prev_length - 1;
        prev_length -= 2;
        do {
          if (++strstart <= max_insert) {
            ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH2 - 1)] & 255) & hash_mask;
            hash_head = head[ins_h] & 65535;
            prev[strstart & w_mask] = head[ins_h];
            head[ins_h] = strstart;
          }
        } while (--prev_length !== 0);
        match_available = 0;
        match_length = MIN_MATCH2 - 1;
        strstart++;
        if (bflush) {
          flush_block_only3(false);
          if (strm.avail_out === 0)
            return NeedMore;
        }
      } else if (match_available !== 0) {
        bflush = _tr_tally3(0, win[strstart - 1] & 255);
        if (bflush) {
          flush_block_only3(false);
        }
        strstart++;
        lookahead--;
        if (strm.avail_out === 0)
          return NeedMore;
      } else {
        match_available = 1;
        strstart++;
        lookahead--;
      }
    }
    if (match_available !== 0) {
      bflush = _tr_tally3(0, win[strstart - 1] & 255);
      match_available = 0;
    }
    flush_block_only3(flush == Z_FINISH2);
    if (strm.avail_out === 0) {
      if (flush == Z_FINISH2)
        return FinishStarted;
      else
        return NeedMore;
    }
    return flush == Z_FINISH2 ? FinishDone : BlockDone;
  }
  function deflateReset3(strm2) {
    strm2.total_in = strm2.total_out = 0;
    strm2.msg = null;
    that.pending = 0;
    that.pending_out = 0;
    status = BUSY_STATE2;
    last_flush = Z_NO_FLUSH2;
    tr_init();
    lm_init3();
    return Z_OK2;
  }
  that.deflateInit = function(strm2, _level, bits, _method, memLevel, _strategy) {
    if (!_method)
      _method = Z_DEFLATED2;
    if (!memLevel)
      memLevel = DEF_MEM_LEVEL2;
    if (!_strategy)
      _strategy = Z_DEFAULT_STRATEGY2;
    strm2.msg = null;
    if (_level == Z_DEFAULT_COMPRESSION2)
      _level = 6;
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL2 || _method != Z_DEFLATED2 || bits < 9 || bits > 15 || _level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY2) {
      return Z_STREAM_ERROR2;
    }
    strm2.dstate = that;
    w_bits = bits;
    w_size = 1 << w_bits;
    w_mask = w_size - 1;
    hash_bits = memLevel + 7;
    hash_size = 1 << hash_bits;
    hash_mask = hash_size - 1;
    hash_shift = Math.floor((hash_bits + MIN_MATCH2 - 1) / MIN_MATCH2);
    win = new Uint8Array(w_size * 2);
    prev = [];
    head = [];
    lit_bufsize = 1 << memLevel + 6;
    that.pending_buf = new Uint8Array(lit_bufsize * 4);
    pending_buf_size = lit_bufsize * 4;
    that.dist_buf = new Uint16Array(lit_bufsize);
    that.lc_buf = new Uint8Array(lit_bufsize);
    level = _level;
    strategy = _strategy;
    return deflateReset3(strm2);
  };
  that.deflateEnd = function() {
    if (status != INIT_STATE2 && status != BUSY_STATE2 && status != FINISH_STATE2) {
      return Z_STREAM_ERROR2;
    }
    that.lc_buf = null;
    that.dist_buf = null;
    that.pending_buf = null;
    head = null;
    prev = null;
    win = null;
    that.dstate = null;
    return status == BUSY_STATE2 ? Z_DATA_ERROR2 : Z_OK2;
  };
  that.deflateParams = function(strm2, _level, _strategy) {
    let err3 = Z_OK2;
    if (_level == Z_DEFAULT_COMPRESSION2) {
      _level = 6;
    }
    if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY2) {
      return Z_STREAM_ERROR2;
    }
    if (config_table[level].func != config_table[_level].func && strm2.total_in !== 0) {
      err3 = strm2.deflate(Z_PARTIAL_FLUSH2);
    }
    if (level != _level) {
      level = _level;
      max_lazy_match = config_table[level].max_lazy;
      good_match = config_table[level].good_length;
      nice_match = config_table[level].nice_length;
      max_chain_length = config_table[level].max_chain;
    }
    strategy = _strategy;
    return err3;
  };
  that.deflateSetDictionary = function(_strm, dictionary, dictLength) {
    let length = dictLength;
    let n2, index = 0;
    if (!dictionary || status != INIT_STATE2)
      return Z_STREAM_ERROR2;
    if (length < MIN_MATCH2)
      return Z_OK2;
    if (length > w_size - MIN_LOOKAHEAD2) {
      length = w_size - MIN_LOOKAHEAD2;
      index = dictLength - length;
    }
    win.set(dictionary.subarray(index, index + length), 0);
    strstart = length;
    block_start = length;
    ins_h = win[0] & 255;
    ins_h = (ins_h << hash_shift ^ win[1] & 255) & hash_mask;
    for (n2 = 0; n2 <= length - MIN_MATCH2; n2++) {
      ins_h = (ins_h << hash_shift ^ win[n2 + (MIN_MATCH2 - 1)] & 255) & hash_mask;
      prev[n2 & w_mask] = head[ins_h];
      head[ins_h] = n2;
    }
    return Z_OK2;
  };
  that.deflate = function(_strm, flush) {
    let i2, header, level_flags, old_flush, bstate;
    if (flush > Z_FINISH2 || flush < 0) {
      return Z_STREAM_ERROR2;
    }
    if (!_strm.next_out || !_strm.next_in && _strm.avail_in !== 0 || status == FINISH_STATE2 && flush != Z_FINISH2) {
      _strm.msg = z_errmsg[Z_NEED_DICT2 - Z_STREAM_ERROR2];
      return Z_STREAM_ERROR2;
    }
    if (_strm.avail_out === 0) {
      _strm.msg = z_errmsg[Z_NEED_DICT2 - Z_BUF_ERROR2];
      return Z_BUF_ERROR2;
    }
    strm = _strm;
    old_flush = last_flush;
    last_flush = flush;
    if (status == INIT_STATE2) {
      header = Z_DEFLATED2 + (w_bits - 8 << 4) << 8;
      level_flags = (level - 1 & 255) >> 1;
      if (level_flags > 3)
        level_flags = 3;
      header |= level_flags << 6;
      if (strstart !== 0)
        header |= PRESET_DICT2;
      header += 31 - header % 31;
      status = BUSY_STATE2;
      putShortMSB3(header);
    }
    if (that.pending !== 0) {
      strm.flush_pending();
      if (strm.avail_out === 0) {
        last_flush = -1;
        return Z_OK2;
      }
    } else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH2) {
      strm.msg = z_errmsg[Z_NEED_DICT2 - Z_BUF_ERROR2];
      return Z_BUF_ERROR2;
    }
    if (status == FINISH_STATE2 && strm.avail_in !== 0) {
      _strm.msg = z_errmsg[Z_NEED_DICT2 - Z_BUF_ERROR2];
      return Z_BUF_ERROR2;
    }
    if (strm.avail_in !== 0 || lookahead !== 0 || flush != Z_NO_FLUSH2 && status != FINISH_STATE2) {
      bstate = -1;
      switch (config_table[level].func) {
        case STORED2:
          bstate = deflate_stored3(flush);
          break;
        case FAST:
          bstate = deflate_fast3(flush);
          break;
        case SLOW:
          bstate = deflate_slow3(flush);
          break;
        default:
      }
      if (bstate == FinishStarted || bstate == FinishDone) {
        status = FINISH_STATE2;
      }
      if (bstate == NeedMore || bstate == FinishStarted) {
        if (strm.avail_out === 0) {
          last_flush = -1;
        }
        return Z_OK2;
      }
      if (bstate == BlockDone) {
        if (flush == Z_PARTIAL_FLUSH2) {
          _tr_align3();
        } else {
          _tr_stored_block3(0, 0, false);
          if (flush == Z_FULL_FLUSH2) {
            for (i2 = 0; i2 < hash_size; i2++)
              head[i2] = 0;
          }
        }
        strm.flush_pending();
        if (strm.avail_out === 0) {
          last_flush = -1;
          return Z_OK2;
        }
      }
    }
    if (flush != Z_FINISH2)
      return Z_OK2;
    return Z_STREAM_END2;
  };
}
function ZStream2() {
  const that = this;
  that.next_in_index = 0;
  that.next_out_index = 0;
  that.avail_in = 0;
  that.total_in = 0;
  that.avail_out = 0;
  that.total_out = 0;
}
function ZipDeflate(options) {
  const that = this;
  const z2 = new ZStream2();
  const bufsize = getMaximumCompressedSize(options && options.chunkSize ? options.chunkSize : 64 * 1024);
  const flush = Z_NO_FLUSH2;
  const buf = new Uint8Array(bufsize);
  let level = options ? options.level : Z_DEFAULT_COMPRESSION2;
  if (typeof level == "undefined")
    level = Z_DEFAULT_COMPRESSION2;
  z2.deflateInit(level);
  z2.next_out = buf;
  that.append = function(data2, onprogress) {
    let err3, array, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
    const buffers = [];
    if (!data2.length)
      return;
    z2.next_in_index = 0;
    z2.next_in = data2;
    z2.avail_in = data2.length;
    do {
      z2.next_out_index = 0;
      z2.avail_out = bufsize;
      err3 = z2.deflate(flush);
      if (err3 != Z_OK2)
        throw new Error("deflating: " + z2.msg);
      if (z2.next_out_index)
        if (z2.next_out_index == bufsize)
          buffers.push(new Uint8Array(buf));
        else
          buffers.push(buf.slice(0, z2.next_out_index));
      bufferSize += z2.next_out_index;
      if (onprogress && z2.next_in_index > 0 && z2.next_in_index != lastIndex) {
        onprogress(z2.next_in_index);
        lastIndex = z2.next_in_index;
      }
    } while (z2.avail_in > 0 || z2.avail_out === 0);
    if (buffers.length > 1) {
      array = new Uint8Array(bufferSize);
      buffers.forEach(function(chunk) {
        array.set(chunk, bufferIndex);
        bufferIndex += chunk.length;
      });
    } else {
      array = buffers[0] || new Uint8Array();
    }
    return array;
  };
  that.flush = function() {
    let err3, array, bufferIndex = 0, bufferSize = 0;
    const buffers = [];
    do {
      z2.next_out_index = 0;
      z2.avail_out = bufsize;
      err3 = z2.deflate(Z_FINISH2);
      if (err3 != Z_STREAM_END2 && err3 != Z_OK2)
        throw new Error("deflating: " + z2.msg);
      if (bufsize - z2.avail_out > 0)
        buffers.push(buf.slice(0, z2.next_out_index));
      bufferSize += z2.next_out_index;
    } while (z2.avail_in > 0 || z2.avail_out === 0);
    z2.deflateEnd();
    array = new Uint8Array(bufferSize);
    buffers.forEach(function(chunk) {
      array.set(chunk, bufferIndex);
      bufferIndex += chunk.length;
    });
    return array;
  };
}
function getMaximumCompressedSize(uncompressedSize) {
  return uncompressedSize + 5 * (Math.floor(uncompressedSize / 16383) + 1);
}
var MAX_BITS2, D_CODES2, BL_CODES2, LENGTH_CODES2, LITERALS2, L_CODES2, HEAP_SIZE2, END_BLOCK2, MAX_BL_BITS2, REP_3_62, REPZ_3_102, REPZ_11_1382, Buf_size2, Z_DEFAULT_COMPRESSION2, Z_FILTERED2, Z_HUFFMAN_ONLY2, Z_DEFAULT_STRATEGY2, Z_NO_FLUSH2, Z_PARTIAL_FLUSH2, Z_FULL_FLUSH2, Z_FINISH2, Z_OK2, Z_STREAM_END2, Z_NEED_DICT2, Z_STREAM_ERROR2, Z_DATA_ERROR2, Z_BUF_ERROR2, _dist_code2, static_ltree2_first_part, static_ltree2_second_part, static_dtree_first_part, static_dtree_second_part, MAX_MEM_LEVEL2, DEF_MEM_LEVEL2, STORED2, FAST, SLOW, config_table, z_errmsg, NeedMore, BlockDone, FinishStarted, FinishDone, PRESET_DICT2, INIT_STATE2, BUSY_STATE2, FINISH_STATE2, Z_DEFLATED2, STORED_BLOCK2, STATIC_TREES2, DYN_TREES2, MIN_MATCH2, MAX_MATCH2, MIN_LOOKAHEAD2;
var init_deflate = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/codecs/deflate.js"() {
    MAX_BITS2 = 15;
    D_CODES2 = 30;
    BL_CODES2 = 19;
    LENGTH_CODES2 = 29;
    LITERALS2 = 256;
    L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2;
    HEAP_SIZE2 = 2 * L_CODES2 + 1;
    END_BLOCK2 = 256;
    MAX_BL_BITS2 = 7;
    REP_3_62 = 16;
    REPZ_3_102 = 17;
    REPZ_11_1382 = 18;
    Buf_size2 = 8 * 2;
    Z_DEFAULT_COMPRESSION2 = -1;
    Z_FILTERED2 = 1;
    Z_HUFFMAN_ONLY2 = 2;
    Z_DEFAULT_STRATEGY2 = 0;
    Z_NO_FLUSH2 = 0;
    Z_PARTIAL_FLUSH2 = 1;
    Z_FULL_FLUSH2 = 3;
    Z_FINISH2 = 4;
    Z_OK2 = 0;
    Z_STREAM_END2 = 1;
    Z_NEED_DICT2 = 2;
    Z_STREAM_ERROR2 = -2;
    Z_DATA_ERROR2 = -3;
    Z_BUF_ERROR2 = -5;
    _dist_code2 = [0, 1, 2, 3].concat(...extractArray([
      [2, 4],
      [2, 5],
      [4, 6],
      [4, 7],
      [8, 8],
      [8, 9],
      [16, 10],
      [16, 11],
      [32, 12],
      [32, 13],
      [64, 14],
      [64, 15],
      [2, 0],
      [1, 16],
      [1, 17],
      [2, 18],
      [2, 19],
      [4, 20],
      [4, 21],
      [8, 22],
      [8, 23],
      [16, 24],
      [16, 25],
      [32, 26],
      [32, 27],
      [64, 28],
      [64, 29]
    ]));
    Tree._length_code = [0, 1, 2, 3, 4, 5, 6, 7].concat(...extractArray([
      [2, 8],
      [2, 9],
      [2, 10],
      [2, 11],
      [4, 12],
      [4, 13],
      [4, 14],
      [4, 15],
      [8, 16],
      [8, 17],
      [8, 18],
      [8, 19],
      [16, 20],
      [16, 21],
      [16, 22],
      [16, 23],
      [32, 24],
      [32, 25],
      [32, 26],
      [31, 27],
      [1, 28]
    ]));
    Tree.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0];
    Tree.base_dist = [
      0,
      1,
      2,
      3,
      4,
      6,
      8,
      12,
      16,
      24,
      32,
      48,
      64,
      96,
      128,
      192,
      256,
      384,
      512,
      768,
      1024,
      1536,
      2048,
      3072,
      4096,
      6144,
      8192,
      12288,
      16384,
      24576
    ];
    Tree.d_code = function(dist) {
      return dist < 256 ? _dist_code2[dist] : _dist_code2[256 + (dist >>> 7)];
    };
    Tree.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
    Tree.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    Tree.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
    Tree.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    static_ltree2_first_part = [
      12,
      140,
      76,
      204,
      44,
      172,
      108,
      236,
      28,
      156,
      92,
      220,
      60,
      188,
      124,
      252,
      2,
      130,
      66,
      194,
      34,
      162,
      98,
      226,
      18,
      146,
      82,
      210,
      50,
      178,
      114,
      242,
      10,
      138,
      74,
      202,
      42,
      170,
      106,
      234,
      26,
      154,
      90,
      218,
      58,
      186,
      122,
      250,
      6,
      134,
      70,
      198,
      38,
      166,
      102,
      230,
      22,
      150,
      86,
      214,
      54,
      182,
      118,
      246,
      14,
      142,
      78,
      206,
      46,
      174,
      110,
      238,
      30,
      158,
      94,
      222,
      62,
      190,
      126,
      254,
      1,
      129,
      65,
      193,
      33,
      161,
      97,
      225,
      17,
      145,
      81,
      209,
      49,
      177,
      113,
      241,
      9,
      137,
      73,
      201,
      41,
      169,
      105,
      233,
      25,
      153,
      89,
      217,
      57,
      185,
      121,
      249,
      5,
      133,
      69,
      197,
      37,
      165,
      101,
      229,
      21,
      149,
      85,
      213,
      53,
      181,
      117,
      245,
      13,
      141,
      77,
      205,
      45,
      173,
      109,
      237,
      29,
      157,
      93,
      221,
      61,
      189,
      125,
      253,
      19,
      275,
      147,
      403,
      83,
      339,
      211,
      467,
      51,
      307,
      179,
      435,
      115,
      371,
      243,
      499,
      11,
      267,
      139,
      395,
      75,
      331,
      203,
      459,
      43,
      299,
      171,
      427,
      107,
      363,
      235,
      491,
      27,
      283,
      155,
      411,
      91,
      347,
      219,
      475,
      59,
      315,
      187,
      443,
      123,
      379,
      251,
      507,
      7,
      263,
      135,
      391,
      71,
      327,
      199,
      455,
      39,
      295,
      167,
      423,
      103,
      359,
      231,
      487,
      23,
      279,
      151,
      407,
      87,
      343,
      215,
      471,
      55,
      311,
      183,
      439,
      119,
      375,
      247,
      503,
      15,
      271,
      143,
      399,
      79,
      335,
      207,
      463,
      47,
      303,
      175,
      431,
      111,
      367,
      239,
      495,
      31,
      287,
      159,
      415,
      95,
      351,
      223,
      479,
      63,
      319,
      191,
      447,
      127,
      383,
      255,
      511,
      0,
      64,
      32,
      96,
      16,
      80,
      48,
      112,
      8,
      72,
      40,
      104,
      24,
      88,
      56,
      120,
      4,
      68,
      36,
      100,
      20,
      84,
      52,
      116,
      3,
      131,
      67,
      195,
      35,
      163,
      99,
      227
    ];
    static_ltree2_second_part = extractArray([[144, 8], [112, 9], [24, 7], [8, 8]]);
    StaticTree.static_ltree = flatArray(static_ltree2_first_part.map((value, index) => [value, static_ltree2_second_part[index]]));
    static_dtree_first_part = [0, 16, 8, 24, 4, 20, 12, 28, 2, 18, 10, 26, 6, 22, 14, 30, 1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 7, 23];
    static_dtree_second_part = extractArray([[30, 5]]);
    StaticTree.static_dtree = flatArray(static_dtree_first_part.map((value, index) => [value, static_dtree_second_part[index]]));
    StaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS2 + 1, L_CODES2, MAX_BITS2);
    StaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES2, MAX_BITS2);
    StaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES2, MAX_BL_BITS2);
    MAX_MEM_LEVEL2 = 9;
    DEF_MEM_LEVEL2 = 8;
    STORED2 = 0;
    FAST = 1;
    SLOW = 2;
    config_table = [
      new Config2(0, 0, 0, 0, STORED2),
      new Config2(4, 4, 8, 4, FAST),
      new Config2(4, 5, 16, 8, FAST),
      new Config2(4, 6, 32, 32, FAST),
      new Config2(4, 4, 16, 16, SLOW),
      new Config2(8, 16, 32, 32, SLOW),
      new Config2(8, 16, 128, 128, SLOW),
      new Config2(8, 32, 128, 256, SLOW),
      new Config2(32, 128, 258, 1024, SLOW),
      new Config2(32, 258, 258, 4096, SLOW)
    ];
    z_errmsg = [
      "need dictionary",
      // Z_NEED_DICT
      // 2
      "stream end",
      // Z_STREAM_END 1
      "",
      // Z_OK 0
      "",
      // Z_ERRNO (-1)
      "stream error",
      // Z_STREAM_ERROR (-2)
      "data error",
      // Z_DATA_ERROR (-3)
      "",
      // Z_MEM_ERROR (-4)
      "buffer error",
      // Z_BUF_ERROR (-5)
      "",
      // Z_VERSION_ERROR (-6)
      ""
    ];
    NeedMore = 0;
    BlockDone = 1;
    FinishStarted = 2;
    FinishDone = 3;
    PRESET_DICT2 = 32;
    INIT_STATE2 = 42;
    BUSY_STATE2 = 113;
    FINISH_STATE2 = 666;
    Z_DEFLATED2 = 8;
    STORED_BLOCK2 = 0;
    STATIC_TREES2 = 1;
    DYN_TREES2 = 2;
    MIN_MATCH2 = 3;
    MAX_MATCH2 = 258;
    MIN_LOOKAHEAD2 = MAX_MATCH2 + MIN_MATCH2 + 1;
    ZStream2.prototype = {
      deflateInit(level, bits) {
        const that = this;
        that.dstate = new Deflate2();
        if (!bits)
          bits = MAX_BITS2;
        return that.dstate.deflateInit(that, level, bits);
      },
      deflate(flush) {
        const that = this;
        if (!that.dstate) {
          return Z_STREAM_ERROR2;
        }
        return that.dstate.deflate(that, flush);
      },
      deflateEnd() {
        const that = this;
        if (!that.dstate)
          return Z_STREAM_ERROR2;
        const ret = that.dstate.deflateEnd();
        that.dstate = null;
        return ret;
      },
      deflateParams(level, strategy) {
        const that = this;
        if (!that.dstate)
          return Z_STREAM_ERROR2;
        return that.dstate.deflateParams(that, level, strategy);
      },
      deflateSetDictionary(dictionary, dictLength) {
        const that = this;
        if (!that.dstate)
          return Z_STREAM_ERROR2;
        return that.dstate.deflateSetDictionary(that, dictionary, dictLength);
      },
      // Read a new buffer from the current input stream, update the
      // total number of bytes read. All deflate() input goes through
      // this function so some applications may wish to modify it to avoid
      // allocating a large strm->next_in buffer and copying from it.
      // (See also flush_pending()).
      read_buf(buf, start, size) {
        const that = this;
        let len = that.avail_in;
        if (len > size)
          len = size;
        if (len === 0)
          return 0;
        that.avail_in -= len;
        buf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);
        that.next_in_index += len;
        that.total_in += len;
        return len;
      },
      // Flush as much pending output as possible. All deflate() output goes
      // through this function so some applications may wish to modify it
      // to avoid allocating a large strm->next_out buffer and copying into it.
      // (See also read_buf()).
      flush_pending() {
        const that = this;
        let len = that.dstate.pending;
        if (len > that.avail_out)
          len = that.avail_out;
        if (len === 0)
          return;
        that.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);
        that.next_out_index += len;
        that.dstate.pending_out += len;
        that.total_out += len;
        that.avail_out -= len;
        that.dstate.pending -= len;
        if (that.dstate.pending === 0) {
          that.dstate.pending_out = 0;
        }
      }
    };
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/codecs/inflate.js
function InfTree() {
  const that = this;
  let hn2;
  let v2;
  let c2;
  let r2;
  let u2;
  let x2;
  function huft_build(b2, bindex, n2, s2, d2, e3, t2, m2, hp, hn3, v3) {
    let a2;
    let f2;
    let g2;
    let h2;
    let i2;
    let j2;
    let k2;
    let l2;
    let mask;
    let p2;
    let q2;
    let w2;
    let xp;
    let y2;
    let z2;
    p2 = 0;
    i2 = n2;
    do {
      c2[b2[bindex + p2]]++;
      p2++;
      i2--;
    } while (i2 !== 0);
    if (c2[0] == n2) {
      t2[0] = -1;
      m2[0] = 0;
      return Z_OK3;
    }
    l2 = m2[0];
    for (j2 = 1; j2 <= BMAX; j2++)
      if (c2[j2] !== 0)
        break;
    k2 = j2;
    if (l2 < j2) {
      l2 = j2;
    }
    for (i2 = BMAX; i2 !== 0; i2--) {
      if (c2[i2] !== 0)
        break;
    }
    g2 = i2;
    if (l2 > i2) {
      l2 = i2;
    }
    m2[0] = l2;
    for (y2 = 1 << j2; j2 < i2; j2++, y2 <<= 1) {
      if ((y2 -= c2[j2]) < 0) {
        return Z_DATA_ERROR3;
      }
    }
    if ((y2 -= c2[i2]) < 0) {
      return Z_DATA_ERROR3;
    }
    c2[i2] += y2;
    x2[1] = j2 = 0;
    p2 = 1;
    xp = 2;
    while (--i2 !== 0) {
      x2[xp] = j2 += c2[p2];
      xp++;
      p2++;
    }
    i2 = 0;
    p2 = 0;
    do {
      if ((j2 = b2[bindex + p2]) !== 0) {
        v3[x2[j2]++] = i2;
      }
      p2++;
    } while (++i2 < n2);
    n2 = x2[g2];
    x2[0] = i2 = 0;
    p2 = 0;
    h2 = -1;
    w2 = -l2;
    u2[0] = 0;
    q2 = 0;
    z2 = 0;
    for (; k2 <= g2; k2++) {
      a2 = c2[k2];
      while (a2-- !== 0) {
        while (k2 > w2 + l2) {
          h2++;
          w2 += l2;
          z2 = g2 - w2;
          z2 = z2 > l2 ? l2 : z2;
          if ((f2 = 1 << (j2 = k2 - w2)) > a2 + 1) {
            f2 -= a2 + 1;
            xp = k2;
            if (j2 < z2) {
              while (++j2 < z2) {
                if ((f2 <<= 1) <= c2[++xp])
                  break;
                f2 -= c2[xp];
              }
            }
          }
          z2 = 1 << j2;
          if (hn3[0] + z2 > MANY) {
            return Z_DATA_ERROR3;
          }
          u2[h2] = q2 = /* hp+ */
          hn3[0];
          hn3[0] += z2;
          if (h2 !== 0) {
            x2[h2] = i2;
            r2[0] = /* (byte) */
            j2;
            r2[1] = /* (byte) */
            l2;
            j2 = i2 >>> w2 - l2;
            r2[2] = /* (int) */
            q2 - u2[h2 - 1] - j2;
            hp.set(r2, (u2[h2 - 1] + j2) * 3);
          } else {
            t2[0] = q2;
          }
        }
        r2[1] = /* (byte) */
        k2 - w2;
        if (p2 >= n2) {
          r2[0] = 128 + 64;
        } else if (v3[p2] < s2) {
          r2[0] = /* (byte) */
          v3[p2] < 256 ? 0 : 32 + 64;
          r2[2] = v3[p2++];
        } else {
          r2[0] = /* (byte) */
          e3[v3[p2] - s2] + 16 + 64;
          r2[2] = d2[v3[p2++] - s2];
        }
        f2 = 1 << k2 - w2;
        for (j2 = i2 >>> w2; j2 < z2; j2 += f2) {
          hp.set(r2, (q2 + j2) * 3);
        }
        for (j2 = 1 << k2 - 1; (i2 & j2) !== 0; j2 >>>= 1) {
          i2 ^= j2;
        }
        i2 ^= j2;
        mask = (1 << w2) - 1;
        while ((i2 & mask) != x2[h2]) {
          h2--;
          w2 -= l2;
          mask = (1 << w2) - 1;
        }
      }
    }
    return y2 !== 0 && g2 != 1 ? Z_BUF_ERROR3 : Z_OK3;
  }
  function initWorkArea(vsize) {
    let i2;
    if (!hn2) {
      hn2 = [];
      v2 = [];
      c2 = new Int32Array(BMAX + 1);
      r2 = [];
      u2 = new Int32Array(BMAX);
      x2 = new Int32Array(BMAX + 1);
    }
    if (v2.length < vsize) {
      v2 = [];
    }
    for (i2 = 0; i2 < vsize; i2++) {
      v2[i2] = 0;
    }
    for (i2 = 0; i2 < BMAX + 1; i2++) {
      c2[i2] = 0;
    }
    for (i2 = 0; i2 < 3; i2++) {
      r2[i2] = 0;
    }
    u2.set(c2.subarray(0, BMAX), 0);
    x2.set(c2.subarray(0, BMAX + 1), 0);
  }
  that.inflate_trees_bits = function(c3, bb, tb, hp, z2) {
    let result;
    initWorkArea(19);
    hn2[0] = 0;
    result = huft_build(c3, 0, 19, 19, null, null, tb, bb, hp, hn2, v2);
    if (result == Z_DATA_ERROR3) {
      z2.msg = "oversubscribed dynamic bit lengths tree";
    } else if (result == Z_BUF_ERROR3 || bb[0] === 0) {
      z2.msg = "incomplete dynamic bit lengths tree";
      result = Z_DATA_ERROR3;
    }
    return result;
  };
  that.inflate_trees_dynamic = function(nl, nd, c3, bl, bd, tl, td, hp, z2) {
    let result;
    initWorkArea(288);
    hn2[0] = 0;
    result = huft_build(c3, 0, nl, 257, cplens, cplext, tl, bl, hp, hn2, v2);
    if (result != Z_OK3 || bl[0] === 0) {
      if (result == Z_DATA_ERROR3) {
        z2.msg = "oversubscribed literal/length tree";
      } else if (result != Z_MEM_ERROR2) {
        z2.msg = "incomplete literal/length tree";
        result = Z_DATA_ERROR3;
      }
      return result;
    }
    initWorkArea(288);
    result = huft_build(c3, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn2, v2);
    if (result != Z_OK3 || bd[0] === 0 && nl > 257) {
      if (result == Z_DATA_ERROR3) {
        z2.msg = "oversubscribed distance tree";
      } else if (result == Z_BUF_ERROR3) {
        z2.msg = "incomplete distance tree";
        result = Z_DATA_ERROR3;
      } else if (result != Z_MEM_ERROR2) {
        z2.msg = "empty distance tree with lengths";
        result = Z_DATA_ERROR3;
      }
      return result;
    }
    return Z_OK3;
  };
}
function InfCodes() {
  const that = this;
  let mode2;
  let len = 0;
  let tree;
  let tree_index = 0;
  let need = 0;
  let lit = 0;
  let get = 0;
  let dist = 0;
  let lbits = 0;
  let dbits = 0;
  let ltree;
  let ltree_index = 0;
  let dtree;
  let dtree_index = 0;
  function inflate_fast3(bl, bd, tl, tl_index, td, td_index, s2, z2) {
    let t2;
    let tp;
    let tp_index;
    let e3;
    let b2;
    let k2;
    let p2;
    let n2;
    let q2;
    let m2;
    let ml;
    let md;
    let c2;
    let d2;
    let r2;
    let tp_index_t_3;
    p2 = z2.next_in_index;
    n2 = z2.avail_in;
    b2 = s2.bitb;
    k2 = s2.bitk;
    q2 = s2.write;
    m2 = q2 < s2.read ? s2.read - q2 - 1 : s2.end - q2;
    ml = inflate_mask[bl];
    md = inflate_mask[bd];
    do {
      while (k2 < 20) {
        n2--;
        b2 |= (z2.read_byte(p2++) & 255) << k2;
        k2 += 8;
      }
      t2 = b2 & ml;
      tp = tl;
      tp_index = tl_index;
      tp_index_t_3 = (tp_index + t2) * 3;
      if ((e3 = tp[tp_index_t_3]) === 0) {
        b2 >>= tp[tp_index_t_3 + 1];
        k2 -= tp[tp_index_t_3 + 1];
        s2.win[q2++] = /* (byte) */
        tp[tp_index_t_3 + 2];
        m2--;
        continue;
      }
      do {
        b2 >>= tp[tp_index_t_3 + 1];
        k2 -= tp[tp_index_t_3 + 1];
        if ((e3 & 16) !== 0) {
          e3 &= 15;
          c2 = tp[tp_index_t_3 + 2] + /* (int) */
          (b2 & inflate_mask[e3]);
          b2 >>= e3;
          k2 -= e3;
          while (k2 < 15) {
            n2--;
            b2 |= (z2.read_byte(p2++) & 255) << k2;
            k2 += 8;
          }
          t2 = b2 & md;
          tp = td;
          tp_index = td_index;
          tp_index_t_3 = (tp_index + t2) * 3;
          e3 = tp[tp_index_t_3];
          do {
            b2 >>= tp[tp_index_t_3 + 1];
            k2 -= tp[tp_index_t_3 + 1];
            if ((e3 & 16) !== 0) {
              e3 &= 15;
              while (k2 < e3) {
                n2--;
                b2 |= (z2.read_byte(p2++) & 255) << k2;
                k2 += 8;
              }
              d2 = tp[tp_index_t_3 + 2] + (b2 & inflate_mask[e3]);
              b2 >>= e3;
              k2 -= e3;
              m2 -= c2;
              if (q2 >= d2) {
                r2 = q2 - d2;
                if (q2 - r2 > 0 && 2 > q2 - r2) {
                  s2.win[q2++] = s2.win[r2++];
                  s2.win[q2++] = s2.win[r2++];
                  c2 -= 2;
                } else {
                  s2.win.set(s2.win.subarray(r2, r2 + 2), q2);
                  q2 += 2;
                  r2 += 2;
                  c2 -= 2;
                }
              } else {
                r2 = q2 - d2;
                do {
                  r2 += s2.end;
                } while (r2 < 0);
                e3 = s2.end - r2;
                if (c2 > e3) {
                  c2 -= e3;
                  if (q2 - r2 > 0 && e3 > q2 - r2) {
                    do {
                      s2.win[q2++] = s2.win[r2++];
                    } while (--e3 !== 0);
                  } else {
                    s2.win.set(s2.win.subarray(r2, r2 + e3), q2);
                    q2 += e3;
                    r2 += e3;
                    e3 = 0;
                  }
                  r2 = 0;
                }
              }
              if (q2 - r2 > 0 && c2 > q2 - r2) {
                do {
                  s2.win[q2++] = s2.win[r2++];
                } while (--c2 !== 0);
              } else {
                s2.win.set(s2.win.subarray(r2, r2 + c2), q2);
                q2 += c2;
                r2 += c2;
                c2 = 0;
              }
              break;
            } else if ((e3 & 64) === 0) {
              t2 += tp[tp_index_t_3 + 2];
              t2 += b2 & inflate_mask[e3];
              tp_index_t_3 = (tp_index + t2) * 3;
              e3 = tp[tp_index_t_3];
            } else {
              z2.msg = "invalid distance code";
              c2 = z2.avail_in - n2;
              c2 = k2 >> 3 < c2 ? k2 >> 3 : c2;
              n2 += c2;
              p2 -= c2;
              k2 -= c2 << 3;
              s2.bitb = b2;
              s2.bitk = k2;
              z2.avail_in = n2;
              z2.total_in += p2 - z2.next_in_index;
              z2.next_in_index = p2;
              s2.write = q2;
              return Z_DATA_ERROR3;
            }
          } while (true);
          break;
        }
        if ((e3 & 64) === 0) {
          t2 += tp[tp_index_t_3 + 2];
          t2 += b2 & inflate_mask[e3];
          tp_index_t_3 = (tp_index + t2) * 3;
          if ((e3 = tp[tp_index_t_3]) === 0) {
            b2 >>= tp[tp_index_t_3 + 1];
            k2 -= tp[tp_index_t_3 + 1];
            s2.win[q2++] = /* (byte) */
            tp[tp_index_t_3 + 2];
            m2--;
            break;
          }
        } else if ((e3 & 32) !== 0) {
          c2 = z2.avail_in - n2;
          c2 = k2 >> 3 < c2 ? k2 >> 3 : c2;
          n2 += c2;
          p2 -= c2;
          k2 -= c2 << 3;
          s2.bitb = b2;
          s2.bitk = k2;
          z2.avail_in = n2;
          z2.total_in += p2 - z2.next_in_index;
          z2.next_in_index = p2;
          s2.write = q2;
          return Z_STREAM_END3;
        } else {
          z2.msg = "invalid literal/length code";
          c2 = z2.avail_in - n2;
          c2 = k2 >> 3 < c2 ? k2 >> 3 : c2;
          n2 += c2;
          p2 -= c2;
          k2 -= c2 << 3;
          s2.bitb = b2;
          s2.bitk = k2;
          z2.avail_in = n2;
          z2.total_in += p2 - z2.next_in_index;
          z2.next_in_index = p2;
          s2.write = q2;
          return Z_DATA_ERROR3;
        }
      } while (true);
    } while (m2 >= 258 && n2 >= 10);
    c2 = z2.avail_in - n2;
    c2 = k2 >> 3 < c2 ? k2 >> 3 : c2;
    n2 += c2;
    p2 -= c2;
    k2 -= c2 << 3;
    s2.bitb = b2;
    s2.bitk = k2;
    z2.avail_in = n2;
    z2.total_in += p2 - z2.next_in_index;
    z2.next_in_index = p2;
    s2.write = q2;
    return Z_OK3;
  }
  that.init = function(bl, bd, tl, tl_index, td, td_index) {
    mode2 = START;
    lbits = /* (byte) */
    bl;
    dbits = /* (byte) */
    bd;
    ltree = tl;
    ltree_index = tl_index;
    dtree = td;
    dtree_index = td_index;
    tree = null;
  };
  that.proc = function(s2, z2, r2) {
    let j2;
    let tindex;
    let e3;
    let b2 = 0;
    let k2 = 0;
    let p2 = 0;
    let n2;
    let q2;
    let m2;
    let f2;
    p2 = z2.next_in_index;
    n2 = z2.avail_in;
    b2 = s2.bitb;
    k2 = s2.bitk;
    q2 = s2.write;
    m2 = q2 < s2.read ? s2.read - q2 - 1 : s2.end - q2;
    while (true) {
      switch (mode2) {
        // waiting for "i:"=input, "o:"=output, "x:"=nothing
        case START:
          if (m2 >= 258 && n2 >= 10) {
            s2.bitb = b2;
            s2.bitk = k2;
            z2.avail_in = n2;
            z2.total_in += p2 - z2.next_in_index;
            z2.next_in_index = p2;
            s2.write = q2;
            r2 = inflate_fast3(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s2, z2);
            p2 = z2.next_in_index;
            n2 = z2.avail_in;
            b2 = s2.bitb;
            k2 = s2.bitk;
            q2 = s2.write;
            m2 = q2 < s2.read ? s2.read - q2 - 1 : s2.end - q2;
            if (r2 != Z_OK3) {
              mode2 = r2 == Z_STREAM_END3 ? WASH : BADCODE;
              break;
            }
          }
          need = lbits;
          tree = ltree;
          tree_index = ltree_index;
          mode2 = LEN2;
        /* falls through */
        case LEN2:
          j2 = need;
          while (k2 < j2) {
            if (n2 !== 0)
              r2 = Z_OK3;
            else {
              s2.bitb = b2;
              s2.bitk = k2;
              z2.avail_in = n2;
              z2.total_in += p2 - z2.next_in_index;
              z2.next_in_index = p2;
              s2.write = q2;
              return s2.inflate_flush(z2, r2);
            }
            n2--;
            b2 |= (z2.read_byte(p2++) & 255) << k2;
            k2 += 8;
          }
          tindex = (tree_index + (b2 & inflate_mask[j2])) * 3;
          b2 >>>= tree[tindex + 1];
          k2 -= tree[tindex + 1];
          e3 = tree[tindex];
          if (e3 === 0) {
            lit = tree[tindex + 2];
            mode2 = LIT2;
            break;
          }
          if ((e3 & 16) !== 0) {
            get = e3 & 15;
            len = tree[tindex + 2];
            mode2 = LENEXT2;
            break;
          }
          if ((e3 & 64) === 0) {
            need = e3;
            tree_index = tindex / 3 + tree[tindex + 2];
            break;
          }
          if ((e3 & 32) !== 0) {
            mode2 = WASH;
            break;
          }
          mode2 = BADCODE;
          z2.msg = "invalid literal/length code";
          r2 = Z_DATA_ERROR3;
          s2.bitb = b2;
          s2.bitk = k2;
          z2.avail_in = n2;
          z2.total_in += p2 - z2.next_in_index;
          z2.next_in_index = p2;
          s2.write = q2;
          return s2.inflate_flush(z2, r2);
        case LENEXT2:
          j2 = get;
          while (k2 < j2) {
            if (n2 !== 0)
              r2 = Z_OK3;
            else {
              s2.bitb = b2;
              s2.bitk = k2;
              z2.avail_in = n2;
              z2.total_in += p2 - z2.next_in_index;
              z2.next_in_index = p2;
              s2.write = q2;
              return s2.inflate_flush(z2, r2);
            }
            n2--;
            b2 |= (z2.read_byte(p2++) & 255) << k2;
            k2 += 8;
          }
          len += b2 & inflate_mask[j2];
          b2 >>= j2;
          k2 -= j2;
          need = dbits;
          tree = dtree;
          tree_index = dtree_index;
          mode2 = DIST2;
        /* falls through */
        case DIST2:
          j2 = need;
          while (k2 < j2) {
            if (n2 !== 0)
              r2 = Z_OK3;
            else {
              s2.bitb = b2;
              s2.bitk = k2;
              z2.avail_in = n2;
              z2.total_in += p2 - z2.next_in_index;
              z2.next_in_index = p2;
              s2.write = q2;
              return s2.inflate_flush(z2, r2);
            }
            n2--;
            b2 |= (z2.read_byte(p2++) & 255) << k2;
            k2 += 8;
          }
          tindex = (tree_index + (b2 & inflate_mask[j2])) * 3;
          b2 >>= tree[tindex + 1];
          k2 -= tree[tindex + 1];
          e3 = tree[tindex];
          if ((e3 & 16) !== 0) {
            get = e3 & 15;
            dist = tree[tindex + 2];
            mode2 = DISTEXT2;
            break;
          }
          if ((e3 & 64) === 0) {
            need = e3;
            tree_index = tindex / 3 + tree[tindex + 2];
            break;
          }
          mode2 = BADCODE;
          z2.msg = "invalid distance code";
          r2 = Z_DATA_ERROR3;
          s2.bitb = b2;
          s2.bitk = k2;
          z2.avail_in = n2;
          z2.total_in += p2 - z2.next_in_index;
          z2.next_in_index = p2;
          s2.write = q2;
          return s2.inflate_flush(z2, r2);
        case DISTEXT2:
          j2 = get;
          while (k2 < j2) {
            if (n2 !== 0)
              r2 = Z_OK3;
            else {
              s2.bitb = b2;
              s2.bitk = k2;
              z2.avail_in = n2;
              z2.total_in += p2 - z2.next_in_index;
              z2.next_in_index = p2;
              s2.write = q2;
              return s2.inflate_flush(z2, r2);
            }
            n2--;
            b2 |= (z2.read_byte(p2++) & 255) << k2;
            k2 += 8;
          }
          dist += b2 & inflate_mask[j2];
          b2 >>= j2;
          k2 -= j2;
          mode2 = COPY2;
        /* falls through */
        case COPY2:
          f2 = q2 - dist;
          while (f2 < 0) {
            f2 += s2.end;
          }
          while (len !== 0) {
            if (m2 === 0) {
              if (q2 == s2.end && s2.read !== 0) {
                q2 = 0;
                m2 = q2 < s2.read ? s2.read - q2 - 1 : s2.end - q2;
              }
              if (m2 === 0) {
                s2.write = q2;
                r2 = s2.inflate_flush(z2, r2);
                q2 = s2.write;
                m2 = q2 < s2.read ? s2.read - q2 - 1 : s2.end - q2;
                if (q2 == s2.end && s2.read !== 0) {
                  q2 = 0;
                  m2 = q2 < s2.read ? s2.read - q2 - 1 : s2.end - q2;
                }
                if (m2 === 0) {
                  s2.bitb = b2;
                  s2.bitk = k2;
                  z2.avail_in = n2;
                  z2.total_in += p2 - z2.next_in_index;
                  z2.next_in_index = p2;
                  s2.write = q2;
                  return s2.inflate_flush(z2, r2);
                }
              }
            }
            s2.win[q2++] = s2.win[f2++];
            m2--;
            if (f2 == s2.end)
              f2 = 0;
            len--;
          }
          mode2 = START;
          break;
        case LIT2:
          if (m2 === 0) {
            if (q2 == s2.end && s2.read !== 0) {
              q2 = 0;
              m2 = q2 < s2.read ? s2.read - q2 - 1 : s2.end - q2;
            }
            if (m2 === 0) {
              s2.write = q2;
              r2 = s2.inflate_flush(z2, r2);
              q2 = s2.write;
              m2 = q2 < s2.read ? s2.read - q2 - 1 : s2.end - q2;
              if (q2 == s2.end && s2.read !== 0) {
                q2 = 0;
                m2 = q2 < s2.read ? s2.read - q2 - 1 : s2.end - q2;
              }
              if (m2 === 0) {
                s2.bitb = b2;
                s2.bitk = k2;
                z2.avail_in = n2;
                z2.total_in += p2 - z2.next_in_index;
                z2.next_in_index = p2;
                s2.write = q2;
                return s2.inflate_flush(z2, r2);
              }
            }
          }
          r2 = Z_OK3;
          s2.win[q2++] = /* (byte) */
          lit;
          m2--;
          mode2 = START;
          break;
        case WASH:
          if (k2 > 7) {
            k2 -= 8;
            n2++;
            p2--;
          }
          s2.write = q2;
          r2 = s2.inflate_flush(z2, r2);
          q2 = s2.write;
          m2 = q2 < s2.read ? s2.read - q2 - 1 : s2.end - q2;
          if (s2.read != s2.write) {
            s2.bitb = b2;
            s2.bitk = k2;
            z2.avail_in = n2;
            z2.total_in += p2 - z2.next_in_index;
            z2.next_in_index = p2;
            s2.write = q2;
            return s2.inflate_flush(z2, r2);
          }
          mode2 = END;
        /* falls through */
        case END:
          r2 = Z_STREAM_END3;
          s2.bitb = b2;
          s2.bitk = k2;
          z2.avail_in = n2;
          z2.total_in += p2 - z2.next_in_index;
          z2.next_in_index = p2;
          s2.write = q2;
          return s2.inflate_flush(z2, r2);
        case BADCODE:
          r2 = Z_DATA_ERROR3;
          s2.bitb = b2;
          s2.bitk = k2;
          z2.avail_in = n2;
          z2.total_in += p2 - z2.next_in_index;
          z2.next_in_index = p2;
          s2.write = q2;
          return s2.inflate_flush(z2, r2);
        default:
          r2 = Z_STREAM_ERROR3;
          s2.bitb = b2;
          s2.bitk = k2;
          z2.avail_in = n2;
          z2.total_in += p2 - z2.next_in_index;
          z2.next_in_index = p2;
          s2.write = q2;
          return s2.inflate_flush(z2, r2);
      }
    }
  };
  that.free = function() {
  };
}
function InfBlocks(z2, w2) {
  const that = this;
  let mode2 = TYPE2;
  let left = 0;
  let table3 = 0;
  let index = 0;
  let blens;
  const bb = [0];
  const tb = [0];
  const codes = new InfCodes();
  let last = 0;
  let hufts = new Int32Array(MANY * 3);
  const check = 0;
  const inftree = new InfTree();
  that.bitk = 0;
  that.bitb = 0;
  that.win = new Uint8Array(w2);
  that.end = w2;
  that.read = 0;
  that.write = 0;
  that.reset = function(z3, c2) {
    if (c2)
      c2[0] = check;
    if (mode2 == CODES2) {
      codes.free(z3);
    }
    mode2 = TYPE2;
    that.bitk = 0;
    that.bitb = 0;
    that.read = that.write = 0;
  };
  that.reset(z2, null);
  that.inflate_flush = function(z3, r2) {
    let n2;
    let p2;
    let q2;
    p2 = z3.next_out_index;
    q2 = that.read;
    n2 = /* (int) */
    (q2 <= that.write ? that.write : that.end) - q2;
    if (n2 > z3.avail_out)
      n2 = z3.avail_out;
    if (n2 !== 0 && r2 == Z_BUF_ERROR3)
      r2 = Z_OK3;
    z3.avail_out -= n2;
    z3.total_out += n2;
    z3.next_out.set(that.win.subarray(q2, q2 + n2), p2);
    p2 += n2;
    q2 += n2;
    if (q2 == that.end) {
      q2 = 0;
      if (that.write == that.end)
        that.write = 0;
      n2 = that.write - q2;
      if (n2 > z3.avail_out)
        n2 = z3.avail_out;
      if (n2 !== 0 && r2 == Z_BUF_ERROR3)
        r2 = Z_OK3;
      z3.avail_out -= n2;
      z3.total_out += n2;
      z3.next_out.set(that.win.subarray(q2, q2 + n2), p2);
      p2 += n2;
      q2 += n2;
    }
    z3.next_out_index = p2;
    that.read = q2;
    return r2;
  };
  that.proc = function(z3, r2) {
    let t2;
    let b2;
    let k2;
    let p2;
    let n2;
    let q2;
    let m2;
    let i2;
    p2 = z3.next_in_index;
    n2 = z3.avail_in;
    b2 = that.bitb;
    k2 = that.bitk;
    q2 = that.write;
    m2 = /* (int) */
    q2 < that.read ? that.read - q2 - 1 : that.end - q2;
    while (true) {
      let bl, bd, tl, td, bl_, bd_, tl_, td_;
      switch (mode2) {
        case TYPE2:
          while (k2 < 3) {
            if (n2 !== 0) {
              r2 = Z_OK3;
            } else {
              that.bitb = b2;
              that.bitk = k2;
              z3.avail_in = n2;
              z3.total_in += p2 - z3.next_in_index;
              z3.next_in_index = p2;
              that.write = q2;
              return that.inflate_flush(z3, r2);
            }
            n2--;
            b2 |= (z3.read_byte(p2++) & 255) << k2;
            k2 += 8;
          }
          t2 = /* (int) */
          b2 & 7;
          last = t2 & 1;
          switch (t2 >>> 1) {
            case 0:
              b2 >>>= 3;
              k2 -= 3;
              t2 = k2 & 7;
              b2 >>>= t2;
              k2 -= t2;
              mode2 = LENS2;
              break;
            case 1:
              bl = [];
              bd = [];
              tl = [[]];
              td = [[]];
              InfTree.inflate_trees_fixed(bl, bd, tl, td);
              codes.init(bl[0], bd[0], tl[0], 0, td[0], 0);
              b2 >>>= 3;
              k2 -= 3;
              mode2 = CODES2;
              break;
            case 2:
              b2 >>>= 3;
              k2 -= 3;
              mode2 = TABLE2;
              break;
            case 3:
              b2 >>>= 3;
              k2 -= 3;
              mode2 = BADBLOCKS;
              z3.msg = "invalid block type";
              r2 = Z_DATA_ERROR3;
              that.bitb = b2;
              that.bitk = k2;
              z3.avail_in = n2;
              z3.total_in += p2 - z3.next_in_index;
              z3.next_in_index = p2;
              that.write = q2;
              return that.inflate_flush(z3, r2);
          }
          break;
        case LENS2:
          while (k2 < 32) {
            if (n2 !== 0) {
              r2 = Z_OK3;
            } else {
              that.bitb = b2;
              that.bitk = k2;
              z3.avail_in = n2;
              z3.total_in += p2 - z3.next_in_index;
              z3.next_in_index = p2;
              that.write = q2;
              return that.inflate_flush(z3, r2);
            }
            n2--;
            b2 |= (z3.read_byte(p2++) & 255) << k2;
            k2 += 8;
          }
          if ((~b2 >>> 16 & 65535) != (b2 & 65535)) {
            mode2 = BADBLOCKS;
            z3.msg = "invalid stored block lengths";
            r2 = Z_DATA_ERROR3;
            that.bitb = b2;
            that.bitk = k2;
            z3.avail_in = n2;
            z3.total_in += p2 - z3.next_in_index;
            z3.next_in_index = p2;
            that.write = q2;
            return that.inflate_flush(z3, r2);
          }
          left = b2 & 65535;
          b2 = k2 = 0;
          mode2 = left !== 0 ? STORED3 : last !== 0 ? DRY : TYPE2;
          break;
        case STORED3:
          if (n2 === 0) {
            that.bitb = b2;
            that.bitk = k2;
            z3.avail_in = n2;
            z3.total_in += p2 - z3.next_in_index;
            z3.next_in_index = p2;
            that.write = q2;
            return that.inflate_flush(z3, r2);
          }
          if (m2 === 0) {
            if (q2 == that.end && that.read !== 0) {
              q2 = 0;
              m2 = /* (int) */
              q2 < that.read ? that.read - q2 - 1 : that.end - q2;
            }
            if (m2 === 0) {
              that.write = q2;
              r2 = that.inflate_flush(z3, r2);
              q2 = that.write;
              m2 = /* (int) */
              q2 < that.read ? that.read - q2 - 1 : that.end - q2;
              if (q2 == that.end && that.read !== 0) {
                q2 = 0;
                m2 = /* (int) */
                q2 < that.read ? that.read - q2 - 1 : that.end - q2;
              }
              if (m2 === 0) {
                that.bitb = b2;
                that.bitk = k2;
                z3.avail_in = n2;
                z3.total_in += p2 - z3.next_in_index;
                z3.next_in_index = p2;
                that.write = q2;
                return that.inflate_flush(z3, r2);
              }
            }
          }
          r2 = Z_OK3;
          t2 = left;
          if (t2 > n2)
            t2 = n2;
          if (t2 > m2)
            t2 = m2;
          that.win.set(z3.read_buf(p2, t2), q2);
          p2 += t2;
          n2 -= t2;
          q2 += t2;
          m2 -= t2;
          if ((left -= t2) !== 0)
            break;
          mode2 = last !== 0 ? DRY : TYPE2;
          break;
        case TABLE2:
          while (k2 < 14) {
            if (n2 !== 0) {
              r2 = Z_OK3;
            } else {
              that.bitb = b2;
              that.bitk = k2;
              z3.avail_in = n2;
              z3.total_in += p2 - z3.next_in_index;
              z3.next_in_index = p2;
              that.write = q2;
              return that.inflate_flush(z3, r2);
            }
            n2--;
            b2 |= (z3.read_byte(p2++) & 255) << k2;
            k2 += 8;
          }
          table3 = t2 = b2 & 16383;
          if ((t2 & 31) > 29 || (t2 >> 5 & 31) > 29) {
            mode2 = BADBLOCKS;
            z3.msg = "too many length or distance symbols";
            r2 = Z_DATA_ERROR3;
            that.bitb = b2;
            that.bitk = k2;
            z3.avail_in = n2;
            z3.total_in += p2 - z3.next_in_index;
            z3.next_in_index = p2;
            that.write = q2;
            return that.inflate_flush(z3, r2);
          }
          t2 = 258 + (t2 & 31) + (t2 >> 5 & 31);
          if (!blens || blens.length < t2) {
            blens = [];
          } else {
            for (i2 = 0; i2 < t2; i2++) {
              blens[i2] = 0;
            }
          }
          b2 >>>= 14;
          k2 -= 14;
          index = 0;
          mode2 = BTREE;
        /* falls through */
        case BTREE:
          while (index < 4 + (table3 >>> 10)) {
            while (k2 < 3) {
              if (n2 !== 0) {
                r2 = Z_OK3;
              } else {
                that.bitb = b2;
                that.bitk = k2;
                z3.avail_in = n2;
                z3.total_in += p2 - z3.next_in_index;
                z3.next_in_index = p2;
                that.write = q2;
                return that.inflate_flush(z3, r2);
              }
              n2--;
              b2 |= (z3.read_byte(p2++) & 255) << k2;
              k2 += 8;
            }
            blens[border[index++]] = b2 & 7;
            b2 >>>= 3;
            k2 -= 3;
          }
          while (index < 19) {
            blens[border[index++]] = 0;
          }
          bb[0] = 7;
          t2 = inftree.inflate_trees_bits(blens, bb, tb, hufts, z3);
          if (t2 != Z_OK3) {
            r2 = t2;
            if (r2 == Z_DATA_ERROR3) {
              blens = null;
              mode2 = BADBLOCKS;
            }
            that.bitb = b2;
            that.bitk = k2;
            z3.avail_in = n2;
            z3.total_in += p2 - z3.next_in_index;
            z3.next_in_index = p2;
            that.write = q2;
            return that.inflate_flush(z3, r2);
          }
          index = 0;
          mode2 = DTREE;
        /* falls through */
        case DTREE:
          while (true) {
            t2 = table3;
            if (index >= 258 + (t2 & 31) + (t2 >> 5 & 31)) {
              break;
            }
            let j2, c2;
            t2 = bb[0];
            while (k2 < t2) {
              if (n2 !== 0) {
                r2 = Z_OK3;
              } else {
                that.bitb = b2;
                that.bitk = k2;
                z3.avail_in = n2;
                z3.total_in += p2 - z3.next_in_index;
                z3.next_in_index = p2;
                that.write = q2;
                return that.inflate_flush(z3, r2);
              }
              n2--;
              b2 |= (z3.read_byte(p2++) & 255) << k2;
              k2 += 8;
            }
            t2 = hufts[(tb[0] + (b2 & inflate_mask[t2])) * 3 + 1];
            c2 = hufts[(tb[0] + (b2 & inflate_mask[t2])) * 3 + 2];
            if (c2 < 16) {
              b2 >>>= t2;
              k2 -= t2;
              blens[index++] = c2;
            } else {
              i2 = c2 == 18 ? 7 : c2 - 14;
              j2 = c2 == 18 ? 11 : 3;
              while (k2 < t2 + i2) {
                if (n2 !== 0) {
                  r2 = Z_OK3;
                } else {
                  that.bitb = b2;
                  that.bitk = k2;
                  z3.avail_in = n2;
                  z3.total_in += p2 - z3.next_in_index;
                  z3.next_in_index = p2;
                  that.write = q2;
                  return that.inflate_flush(z3, r2);
                }
                n2--;
                b2 |= (z3.read_byte(p2++) & 255) << k2;
                k2 += 8;
              }
              b2 >>>= t2;
              k2 -= t2;
              j2 += b2 & inflate_mask[i2];
              b2 >>>= i2;
              k2 -= i2;
              i2 = index;
              t2 = table3;
              if (i2 + j2 > 258 + (t2 & 31) + (t2 >> 5 & 31) || c2 == 16 && i2 < 1) {
                blens = null;
                mode2 = BADBLOCKS;
                z3.msg = "invalid bit length repeat";
                r2 = Z_DATA_ERROR3;
                that.bitb = b2;
                that.bitk = k2;
                z3.avail_in = n2;
                z3.total_in += p2 - z3.next_in_index;
                z3.next_in_index = p2;
                that.write = q2;
                return that.inflate_flush(z3, r2);
              }
              c2 = c2 == 16 ? blens[i2 - 1] : 0;
              do {
                blens[i2++] = c2;
              } while (--j2 !== 0);
              index = i2;
            }
          }
          tb[0] = -1;
          bl_ = [];
          bd_ = [];
          tl_ = [];
          td_ = [];
          bl_[0] = 9;
          bd_[0] = 6;
          t2 = table3;
          t2 = inftree.inflate_trees_dynamic(257 + (t2 & 31), 1 + (t2 >> 5 & 31), blens, bl_, bd_, tl_, td_, hufts, z3);
          if (t2 != Z_OK3) {
            if (t2 == Z_DATA_ERROR3) {
              blens = null;
              mode2 = BADBLOCKS;
            }
            r2 = t2;
            that.bitb = b2;
            that.bitk = k2;
            z3.avail_in = n2;
            z3.total_in += p2 - z3.next_in_index;
            z3.next_in_index = p2;
            that.write = q2;
            return that.inflate_flush(z3, r2);
          }
          codes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);
          mode2 = CODES2;
        /* falls through */
        case CODES2:
          that.bitb = b2;
          that.bitk = k2;
          z3.avail_in = n2;
          z3.total_in += p2 - z3.next_in_index;
          z3.next_in_index = p2;
          that.write = q2;
          if ((r2 = codes.proc(that, z3, r2)) != Z_STREAM_END3) {
            return that.inflate_flush(z3, r2);
          }
          r2 = Z_OK3;
          codes.free(z3);
          p2 = z3.next_in_index;
          n2 = z3.avail_in;
          b2 = that.bitb;
          k2 = that.bitk;
          q2 = that.write;
          m2 = /* (int) */
          q2 < that.read ? that.read - q2 - 1 : that.end - q2;
          if (last === 0) {
            mode2 = TYPE2;
            break;
          }
          mode2 = DRY;
        /* falls through */
        case DRY:
          that.write = q2;
          r2 = that.inflate_flush(z3, r2);
          q2 = that.write;
          m2 = /* (int) */
          q2 < that.read ? that.read - q2 - 1 : that.end - q2;
          if (that.read != that.write) {
            that.bitb = b2;
            that.bitk = k2;
            z3.avail_in = n2;
            z3.total_in += p2 - z3.next_in_index;
            z3.next_in_index = p2;
            that.write = q2;
            return that.inflate_flush(z3, r2);
          }
          mode2 = DONELOCKS;
        /* falls through */
        case DONELOCKS:
          r2 = Z_STREAM_END3;
          that.bitb = b2;
          that.bitk = k2;
          z3.avail_in = n2;
          z3.total_in += p2 - z3.next_in_index;
          z3.next_in_index = p2;
          that.write = q2;
          return that.inflate_flush(z3, r2);
        case BADBLOCKS:
          r2 = Z_DATA_ERROR3;
          that.bitb = b2;
          that.bitk = k2;
          z3.avail_in = n2;
          z3.total_in += p2 - z3.next_in_index;
          z3.next_in_index = p2;
          that.write = q2;
          return that.inflate_flush(z3, r2);
        default:
          r2 = Z_STREAM_ERROR3;
          that.bitb = b2;
          that.bitk = k2;
          z3.avail_in = n2;
          z3.total_in += p2 - z3.next_in_index;
          z3.next_in_index = p2;
          that.write = q2;
          return that.inflate_flush(z3, r2);
      }
    }
  };
  that.free = function(z3) {
    that.reset(z3, null);
    that.win = null;
    hufts = null;
  };
  that.set_dictionary = function(d2, start, n2) {
    that.win.set(d2.subarray(start, start + n2), 0);
    that.read = that.write = n2;
  };
  that.sync_point = function() {
    return mode2 == LENS2 ? 1 : 0;
  };
}
function Inflate2() {
  const that = this;
  that.mode = 0;
  that.method = 0;
  that.was = [0];
  that.need = 0;
  that.marker = 0;
  that.wbits = 0;
  function inflateReset4(z2) {
    if (!z2 || !z2.istate)
      return Z_STREAM_ERROR3;
    z2.total_in = z2.total_out = 0;
    z2.msg = null;
    z2.istate.mode = BLOCKS;
    z2.istate.blocks.reset(z2, null);
    return Z_OK3;
  }
  that.inflateEnd = function(z2) {
    if (that.blocks)
      that.blocks.free(z2);
    that.blocks = null;
    return Z_OK3;
  };
  that.inflateInit = function(z2, w2) {
    z2.msg = null;
    that.blocks = null;
    if (w2 < 8 || w2 > 15) {
      that.inflateEnd(z2);
      return Z_STREAM_ERROR3;
    }
    that.wbits = w2;
    z2.istate.blocks = new InfBlocks(z2, 1 << w2);
    inflateReset4(z2);
    return Z_OK3;
  };
  that.inflate = function(z2, f2) {
    let r2;
    let b2;
    if (!z2 || !z2.istate || !z2.next_in)
      return Z_STREAM_ERROR3;
    const istate = z2.istate;
    f2 = f2 == Z_FINISH3 ? Z_BUF_ERROR3 : Z_OK3;
    r2 = Z_BUF_ERROR3;
    while (true) {
      switch (istate.mode) {
        case METHOD:
          if (z2.avail_in === 0)
            return r2;
          r2 = f2;
          z2.avail_in--;
          z2.total_in++;
          if (((istate.method = z2.read_byte(z2.next_in_index++)) & 15) != Z_DEFLATED3) {
            istate.mode = BAD2;
            z2.msg = "unknown compression method";
            istate.marker = 5;
            break;
          }
          if ((istate.method >> 4) + 8 > istate.wbits) {
            istate.mode = BAD2;
            z2.msg = "invalid win size";
            istate.marker = 5;
            break;
          }
          istate.mode = FLAG;
        /* falls through */
        case FLAG:
          if (z2.avail_in === 0)
            return r2;
          r2 = f2;
          z2.avail_in--;
          z2.total_in++;
          b2 = z2.read_byte(z2.next_in_index++) & 255;
          if (((istate.method << 8) + b2) % 31 !== 0) {
            istate.mode = BAD2;
            z2.msg = "incorrect header check";
            istate.marker = 5;
            break;
          }
          if ((b2 & PRESET_DICT3) === 0) {
            istate.mode = BLOCKS;
            break;
          }
          istate.mode = DICT4;
        /* falls through */
        case DICT4:
          if (z2.avail_in === 0)
            return r2;
          r2 = f2;
          z2.avail_in--;
          z2.total_in++;
          istate.need = (z2.read_byte(z2.next_in_index++) & 255) << 24 & 4278190080;
          istate.mode = DICT3;
        /* falls through */
        case DICT3:
          if (z2.avail_in === 0)
            return r2;
          r2 = f2;
          z2.avail_in--;
          z2.total_in++;
          istate.need += (z2.read_byte(z2.next_in_index++) & 255) << 16 & 16711680;
          istate.mode = DICT2;
        /* falls through */
        case DICT2:
          if (z2.avail_in === 0)
            return r2;
          r2 = f2;
          z2.avail_in--;
          z2.total_in++;
          istate.need += (z2.read_byte(z2.next_in_index++) & 255) << 8 & 65280;
          istate.mode = DICT1;
        /* falls through */
        case DICT1:
          if (z2.avail_in === 0)
            return r2;
          r2 = f2;
          z2.avail_in--;
          z2.total_in++;
          istate.need += z2.read_byte(z2.next_in_index++) & 255;
          istate.mode = DICT0;
          return Z_NEED_DICT3;
        case DICT0:
          istate.mode = BAD2;
          z2.msg = "need dictionary";
          istate.marker = 0;
          return Z_STREAM_ERROR3;
        case BLOCKS:
          r2 = istate.blocks.proc(z2, r2);
          if (r2 == Z_DATA_ERROR3) {
            istate.mode = BAD2;
            istate.marker = 0;
            break;
          }
          if (r2 == Z_OK3) {
            r2 = f2;
          }
          if (r2 != Z_STREAM_END3) {
            return r2;
          }
          r2 = f2;
          istate.blocks.reset(z2, istate.was);
          istate.mode = DONE2;
        /* falls through */
        case DONE2:
          z2.avail_in = 0;
          return Z_STREAM_END3;
        case BAD2:
          return Z_DATA_ERROR3;
        default:
          return Z_STREAM_ERROR3;
      }
    }
  };
  that.inflateSetDictionary = function(z2, dictionary, dictLength) {
    let index = 0, length = dictLength;
    if (!z2 || !z2.istate || z2.istate.mode != DICT0)
      return Z_STREAM_ERROR3;
    const istate = z2.istate;
    if (length >= 1 << istate.wbits) {
      length = (1 << istate.wbits) - 1;
      index = dictLength - length;
    }
    istate.blocks.set_dictionary(dictionary, index, length);
    istate.mode = BLOCKS;
    return Z_OK3;
  };
  that.inflateSync = function(z2) {
    let n2;
    let p2;
    let m2;
    let r2, w2;
    if (!z2 || !z2.istate)
      return Z_STREAM_ERROR3;
    const istate = z2.istate;
    if (istate.mode != BAD2) {
      istate.mode = BAD2;
      istate.marker = 0;
    }
    if ((n2 = z2.avail_in) === 0)
      return Z_BUF_ERROR3;
    p2 = z2.next_in_index;
    m2 = istate.marker;
    while (n2 !== 0 && m2 < 4) {
      if (z2.read_byte(p2) == mark[m2]) {
        m2++;
      } else if (z2.read_byte(p2) !== 0) {
        m2 = 0;
      } else {
        m2 = 4 - m2;
      }
      p2++;
      n2--;
    }
    z2.total_in += p2 - z2.next_in_index;
    z2.next_in_index = p2;
    z2.avail_in = n2;
    istate.marker = m2;
    if (m2 != 4) {
      return Z_DATA_ERROR3;
    }
    r2 = z2.total_in;
    w2 = z2.total_out;
    inflateReset4(z2);
    z2.total_in = r2;
    z2.total_out = w2;
    istate.mode = BLOCKS;
    return Z_OK3;
  };
  that.inflateSyncPoint = function(z2) {
    if (!z2 || !z2.istate || !z2.istate.blocks)
      return Z_STREAM_ERROR3;
    return z2.istate.blocks.sync_point();
  };
}
function ZStream3() {
}
function ZipInflate(options) {
  const that = this;
  const z2 = new ZStream3();
  const bufsize = options && options.chunkSize ? Math.floor(options.chunkSize * 2) : 128 * 1024;
  const flush = Z_NO_FLUSH3;
  const buf = new Uint8Array(bufsize);
  let nomoreinput = false;
  z2.inflateInit();
  z2.next_out = buf;
  that.append = function(data2, onprogress) {
    const buffers = [];
    let err3, array, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
    if (data2.length === 0)
      return;
    z2.next_in_index = 0;
    z2.next_in = data2;
    z2.avail_in = data2.length;
    do {
      z2.next_out_index = 0;
      z2.avail_out = bufsize;
      if (z2.avail_in === 0 && !nomoreinput) {
        z2.next_in_index = 0;
        nomoreinput = true;
      }
      err3 = z2.inflate(flush);
      if (nomoreinput && err3 === Z_BUF_ERROR3) {
        if (z2.avail_in !== 0)
          throw new Error("inflating: bad input");
      } else if (err3 !== Z_OK3 && err3 !== Z_STREAM_END3)
        throw new Error("inflating: " + z2.msg);
      if ((nomoreinput || err3 === Z_STREAM_END3) && z2.avail_in === data2.length)
        throw new Error("inflating: bad input");
      if (z2.next_out_index)
        if (z2.next_out_index === bufsize)
          buffers.push(new Uint8Array(buf));
        else
          buffers.push(buf.slice(0, z2.next_out_index));
      bufferSize += z2.next_out_index;
      if (onprogress && z2.next_in_index > 0 && z2.next_in_index != lastIndex) {
        onprogress(z2.next_in_index);
        lastIndex = z2.next_in_index;
      }
    } while (z2.avail_in > 0 || z2.avail_out === 0);
    if (buffers.length > 1) {
      array = new Uint8Array(bufferSize);
      buffers.forEach(function(chunk) {
        array.set(chunk, bufferIndex);
        bufferIndex += chunk.length;
      });
    } else {
      array = buffers[0] || new Uint8Array();
    }
    return array;
  };
  that.flush = function() {
    z2.inflateEnd();
  };
}
var MAX_BITS3, Z_OK3, Z_STREAM_END3, Z_NEED_DICT3, Z_STREAM_ERROR3, Z_DATA_ERROR3, Z_MEM_ERROR2, Z_BUF_ERROR3, inflate_mask, MANY, Z_NO_FLUSH3, Z_FINISH3, fixed_bl, fixed_bd, fixed_tl, fixed_td, cplens, cplext, cpdist, cpdext, BMAX, START, LEN2, LENEXT2, DIST2, DISTEXT2, COPY2, LIT2, WASH, END, BADCODE, border, TYPE2, LENS2, STORED3, TABLE2, BTREE, DTREE, CODES2, DRY, DONELOCKS, BADBLOCKS, PRESET_DICT3, Z_DEFLATED3, METHOD, FLAG, DICT4, DICT3, DICT2, DICT1, DICT0, BLOCKS, DONE2, BAD2, mark;
var init_inflate = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/codecs/inflate.js"() {
    MAX_BITS3 = 15;
    Z_OK3 = 0;
    Z_STREAM_END3 = 1;
    Z_NEED_DICT3 = 2;
    Z_STREAM_ERROR3 = -2;
    Z_DATA_ERROR3 = -3;
    Z_MEM_ERROR2 = -4;
    Z_BUF_ERROR3 = -5;
    inflate_mask = [
      0,
      1,
      3,
      7,
      15,
      31,
      63,
      127,
      255,
      511,
      1023,
      2047,
      4095,
      8191,
      16383,
      32767,
      65535
    ];
    MANY = 1440;
    Z_NO_FLUSH3 = 0;
    Z_FINISH3 = 4;
    fixed_bl = 9;
    fixed_bd = 5;
    fixed_tl = [
      96,
      7,
      256,
      0,
      8,
      80,
      0,
      8,
      16,
      84,
      8,
      115,
      82,
      7,
      31,
      0,
      8,
      112,
      0,
      8,
      48,
      0,
      9,
      192,
      80,
      7,
      10,
      0,
      8,
      96,
      0,
      8,
      32,
      0,
      9,
      160,
      0,
      8,
      0,
      0,
      8,
      128,
      0,
      8,
      64,
      0,
      9,
      224,
      80,
      7,
      6,
      0,
      8,
      88,
      0,
      8,
      24,
      0,
      9,
      144,
      83,
      7,
      59,
      0,
      8,
      120,
      0,
      8,
      56,
      0,
      9,
      208,
      81,
      7,
      17,
      0,
      8,
      104,
      0,
      8,
      40,
      0,
      9,
      176,
      0,
      8,
      8,
      0,
      8,
      136,
      0,
      8,
      72,
      0,
      9,
      240,
      80,
      7,
      4,
      0,
      8,
      84,
      0,
      8,
      20,
      85,
      8,
      227,
      83,
      7,
      43,
      0,
      8,
      116,
      0,
      8,
      52,
      0,
      9,
      200,
      81,
      7,
      13,
      0,
      8,
      100,
      0,
      8,
      36,
      0,
      9,
      168,
      0,
      8,
      4,
      0,
      8,
      132,
      0,
      8,
      68,
      0,
      9,
      232,
      80,
      7,
      8,
      0,
      8,
      92,
      0,
      8,
      28,
      0,
      9,
      152,
      84,
      7,
      83,
      0,
      8,
      124,
      0,
      8,
      60,
      0,
      9,
      216,
      82,
      7,
      23,
      0,
      8,
      108,
      0,
      8,
      44,
      0,
      9,
      184,
      0,
      8,
      12,
      0,
      8,
      140,
      0,
      8,
      76,
      0,
      9,
      248,
      80,
      7,
      3,
      0,
      8,
      82,
      0,
      8,
      18,
      85,
      8,
      163,
      83,
      7,
      35,
      0,
      8,
      114,
      0,
      8,
      50,
      0,
      9,
      196,
      81,
      7,
      11,
      0,
      8,
      98,
      0,
      8,
      34,
      0,
      9,
      164,
      0,
      8,
      2,
      0,
      8,
      130,
      0,
      8,
      66,
      0,
      9,
      228,
      80,
      7,
      7,
      0,
      8,
      90,
      0,
      8,
      26,
      0,
      9,
      148,
      84,
      7,
      67,
      0,
      8,
      122,
      0,
      8,
      58,
      0,
      9,
      212,
      82,
      7,
      19,
      0,
      8,
      106,
      0,
      8,
      42,
      0,
      9,
      180,
      0,
      8,
      10,
      0,
      8,
      138,
      0,
      8,
      74,
      0,
      9,
      244,
      80,
      7,
      5,
      0,
      8,
      86,
      0,
      8,
      22,
      192,
      8,
      0,
      83,
      7,
      51,
      0,
      8,
      118,
      0,
      8,
      54,
      0,
      9,
      204,
      81,
      7,
      15,
      0,
      8,
      102,
      0,
      8,
      38,
      0,
      9,
      172,
      0,
      8,
      6,
      0,
      8,
      134,
      0,
      8,
      70,
      0,
      9,
      236,
      80,
      7,
      9,
      0,
      8,
      94,
      0,
      8,
      30,
      0,
      9,
      156,
      84,
      7,
      99,
      0,
      8,
      126,
      0,
      8,
      62,
      0,
      9,
      220,
      82,
      7,
      27,
      0,
      8,
      110,
      0,
      8,
      46,
      0,
      9,
      188,
      0,
      8,
      14,
      0,
      8,
      142,
      0,
      8,
      78,
      0,
      9,
      252,
      96,
      7,
      256,
      0,
      8,
      81,
      0,
      8,
      17,
      85,
      8,
      131,
      82,
      7,
      31,
      0,
      8,
      113,
      0,
      8,
      49,
      0,
      9,
      194,
      80,
      7,
      10,
      0,
      8,
      97,
      0,
      8,
      33,
      0,
      9,
      162,
      0,
      8,
      1,
      0,
      8,
      129,
      0,
      8,
      65,
      0,
      9,
      226,
      80,
      7,
      6,
      0,
      8,
      89,
      0,
      8,
      25,
      0,
      9,
      146,
      83,
      7,
      59,
      0,
      8,
      121,
      0,
      8,
      57,
      0,
      9,
      210,
      81,
      7,
      17,
      0,
      8,
      105,
      0,
      8,
      41,
      0,
      9,
      178,
      0,
      8,
      9,
      0,
      8,
      137,
      0,
      8,
      73,
      0,
      9,
      242,
      80,
      7,
      4,
      0,
      8,
      85,
      0,
      8,
      21,
      80,
      8,
      258,
      83,
      7,
      43,
      0,
      8,
      117,
      0,
      8,
      53,
      0,
      9,
      202,
      81,
      7,
      13,
      0,
      8,
      101,
      0,
      8,
      37,
      0,
      9,
      170,
      0,
      8,
      5,
      0,
      8,
      133,
      0,
      8,
      69,
      0,
      9,
      234,
      80,
      7,
      8,
      0,
      8,
      93,
      0,
      8,
      29,
      0,
      9,
      154,
      84,
      7,
      83,
      0,
      8,
      125,
      0,
      8,
      61,
      0,
      9,
      218,
      82,
      7,
      23,
      0,
      8,
      109,
      0,
      8,
      45,
      0,
      9,
      186,
      0,
      8,
      13,
      0,
      8,
      141,
      0,
      8,
      77,
      0,
      9,
      250,
      80,
      7,
      3,
      0,
      8,
      83,
      0,
      8,
      19,
      85,
      8,
      195,
      83,
      7,
      35,
      0,
      8,
      115,
      0,
      8,
      51,
      0,
      9,
      198,
      81,
      7,
      11,
      0,
      8,
      99,
      0,
      8,
      35,
      0,
      9,
      166,
      0,
      8,
      3,
      0,
      8,
      131,
      0,
      8,
      67,
      0,
      9,
      230,
      80,
      7,
      7,
      0,
      8,
      91,
      0,
      8,
      27,
      0,
      9,
      150,
      84,
      7,
      67,
      0,
      8,
      123,
      0,
      8,
      59,
      0,
      9,
      214,
      82,
      7,
      19,
      0,
      8,
      107,
      0,
      8,
      43,
      0,
      9,
      182,
      0,
      8,
      11,
      0,
      8,
      139,
      0,
      8,
      75,
      0,
      9,
      246,
      80,
      7,
      5,
      0,
      8,
      87,
      0,
      8,
      23,
      192,
      8,
      0,
      83,
      7,
      51,
      0,
      8,
      119,
      0,
      8,
      55,
      0,
      9,
      206,
      81,
      7,
      15,
      0,
      8,
      103,
      0,
      8,
      39,
      0,
      9,
      174,
      0,
      8,
      7,
      0,
      8,
      135,
      0,
      8,
      71,
      0,
      9,
      238,
      80,
      7,
      9,
      0,
      8,
      95,
      0,
      8,
      31,
      0,
      9,
      158,
      84,
      7,
      99,
      0,
      8,
      127,
      0,
      8,
      63,
      0,
      9,
      222,
      82,
      7,
      27,
      0,
      8,
      111,
      0,
      8,
      47,
      0,
      9,
      190,
      0,
      8,
      15,
      0,
      8,
      143,
      0,
      8,
      79,
      0,
      9,
      254,
      96,
      7,
      256,
      0,
      8,
      80,
      0,
      8,
      16,
      84,
      8,
      115,
      82,
      7,
      31,
      0,
      8,
      112,
      0,
      8,
      48,
      0,
      9,
      193,
      80,
      7,
      10,
      0,
      8,
      96,
      0,
      8,
      32,
      0,
      9,
      161,
      0,
      8,
      0,
      0,
      8,
      128,
      0,
      8,
      64,
      0,
      9,
      225,
      80,
      7,
      6,
      0,
      8,
      88,
      0,
      8,
      24,
      0,
      9,
      145,
      83,
      7,
      59,
      0,
      8,
      120,
      0,
      8,
      56,
      0,
      9,
      209,
      81,
      7,
      17,
      0,
      8,
      104,
      0,
      8,
      40,
      0,
      9,
      177,
      0,
      8,
      8,
      0,
      8,
      136,
      0,
      8,
      72,
      0,
      9,
      241,
      80,
      7,
      4,
      0,
      8,
      84,
      0,
      8,
      20,
      85,
      8,
      227,
      83,
      7,
      43,
      0,
      8,
      116,
      0,
      8,
      52,
      0,
      9,
      201,
      81,
      7,
      13,
      0,
      8,
      100,
      0,
      8,
      36,
      0,
      9,
      169,
      0,
      8,
      4,
      0,
      8,
      132,
      0,
      8,
      68,
      0,
      9,
      233,
      80,
      7,
      8,
      0,
      8,
      92,
      0,
      8,
      28,
      0,
      9,
      153,
      84,
      7,
      83,
      0,
      8,
      124,
      0,
      8,
      60,
      0,
      9,
      217,
      82,
      7,
      23,
      0,
      8,
      108,
      0,
      8,
      44,
      0,
      9,
      185,
      0,
      8,
      12,
      0,
      8,
      140,
      0,
      8,
      76,
      0,
      9,
      249,
      80,
      7,
      3,
      0,
      8,
      82,
      0,
      8,
      18,
      85,
      8,
      163,
      83,
      7,
      35,
      0,
      8,
      114,
      0,
      8,
      50,
      0,
      9,
      197,
      81,
      7,
      11,
      0,
      8,
      98,
      0,
      8,
      34,
      0,
      9,
      165,
      0,
      8,
      2,
      0,
      8,
      130,
      0,
      8,
      66,
      0,
      9,
      229,
      80,
      7,
      7,
      0,
      8,
      90,
      0,
      8,
      26,
      0,
      9,
      149,
      84,
      7,
      67,
      0,
      8,
      122,
      0,
      8,
      58,
      0,
      9,
      213,
      82,
      7,
      19,
      0,
      8,
      106,
      0,
      8,
      42,
      0,
      9,
      181,
      0,
      8,
      10,
      0,
      8,
      138,
      0,
      8,
      74,
      0,
      9,
      245,
      80,
      7,
      5,
      0,
      8,
      86,
      0,
      8,
      22,
      192,
      8,
      0,
      83,
      7,
      51,
      0,
      8,
      118,
      0,
      8,
      54,
      0,
      9,
      205,
      81,
      7,
      15,
      0,
      8,
      102,
      0,
      8,
      38,
      0,
      9,
      173,
      0,
      8,
      6,
      0,
      8,
      134,
      0,
      8,
      70,
      0,
      9,
      237,
      80,
      7,
      9,
      0,
      8,
      94,
      0,
      8,
      30,
      0,
      9,
      157,
      84,
      7,
      99,
      0,
      8,
      126,
      0,
      8,
      62,
      0,
      9,
      221,
      82,
      7,
      27,
      0,
      8,
      110,
      0,
      8,
      46,
      0,
      9,
      189,
      0,
      8,
      14,
      0,
      8,
      142,
      0,
      8,
      78,
      0,
      9,
      253,
      96,
      7,
      256,
      0,
      8,
      81,
      0,
      8,
      17,
      85,
      8,
      131,
      82,
      7,
      31,
      0,
      8,
      113,
      0,
      8,
      49,
      0,
      9,
      195,
      80,
      7,
      10,
      0,
      8,
      97,
      0,
      8,
      33,
      0,
      9,
      163,
      0,
      8,
      1,
      0,
      8,
      129,
      0,
      8,
      65,
      0,
      9,
      227,
      80,
      7,
      6,
      0,
      8,
      89,
      0,
      8,
      25,
      0,
      9,
      147,
      83,
      7,
      59,
      0,
      8,
      121,
      0,
      8,
      57,
      0,
      9,
      211,
      81,
      7,
      17,
      0,
      8,
      105,
      0,
      8,
      41,
      0,
      9,
      179,
      0,
      8,
      9,
      0,
      8,
      137,
      0,
      8,
      73,
      0,
      9,
      243,
      80,
      7,
      4,
      0,
      8,
      85,
      0,
      8,
      21,
      80,
      8,
      258,
      83,
      7,
      43,
      0,
      8,
      117,
      0,
      8,
      53,
      0,
      9,
      203,
      81,
      7,
      13,
      0,
      8,
      101,
      0,
      8,
      37,
      0,
      9,
      171,
      0,
      8,
      5,
      0,
      8,
      133,
      0,
      8,
      69,
      0,
      9,
      235,
      80,
      7,
      8,
      0,
      8,
      93,
      0,
      8,
      29,
      0,
      9,
      155,
      84,
      7,
      83,
      0,
      8,
      125,
      0,
      8,
      61,
      0,
      9,
      219,
      82,
      7,
      23,
      0,
      8,
      109,
      0,
      8,
      45,
      0,
      9,
      187,
      0,
      8,
      13,
      0,
      8,
      141,
      0,
      8,
      77,
      0,
      9,
      251,
      80,
      7,
      3,
      0,
      8,
      83,
      0,
      8,
      19,
      85,
      8,
      195,
      83,
      7,
      35,
      0,
      8,
      115,
      0,
      8,
      51,
      0,
      9,
      199,
      81,
      7,
      11,
      0,
      8,
      99,
      0,
      8,
      35,
      0,
      9,
      167,
      0,
      8,
      3,
      0,
      8,
      131,
      0,
      8,
      67,
      0,
      9,
      231,
      80,
      7,
      7,
      0,
      8,
      91,
      0,
      8,
      27,
      0,
      9,
      151,
      84,
      7,
      67,
      0,
      8,
      123,
      0,
      8,
      59,
      0,
      9,
      215,
      82,
      7,
      19,
      0,
      8,
      107,
      0,
      8,
      43,
      0,
      9,
      183,
      0,
      8,
      11,
      0,
      8,
      139,
      0,
      8,
      75,
      0,
      9,
      247,
      80,
      7,
      5,
      0,
      8,
      87,
      0,
      8,
      23,
      192,
      8,
      0,
      83,
      7,
      51,
      0,
      8,
      119,
      0,
      8,
      55,
      0,
      9,
      207,
      81,
      7,
      15,
      0,
      8,
      103,
      0,
      8,
      39,
      0,
      9,
      175,
      0,
      8,
      7,
      0,
      8,
      135,
      0,
      8,
      71,
      0,
      9,
      239,
      80,
      7,
      9,
      0,
      8,
      95,
      0,
      8,
      31,
      0,
      9,
      159,
      84,
      7,
      99,
      0,
      8,
      127,
      0,
      8,
      63,
      0,
      9,
      223,
      82,
      7,
      27,
      0,
      8,
      111,
      0,
      8,
      47,
      0,
      9,
      191,
      0,
      8,
      15,
      0,
      8,
      143,
      0,
      8,
      79,
      0,
      9,
      255
    ];
    fixed_td = [
      80,
      5,
      1,
      87,
      5,
      257,
      83,
      5,
      17,
      91,
      5,
      4097,
      81,
      5,
      5,
      89,
      5,
      1025,
      85,
      5,
      65,
      93,
      5,
      16385,
      80,
      5,
      3,
      88,
      5,
      513,
      84,
      5,
      33,
      92,
      5,
      8193,
      82,
      5,
      9,
      90,
      5,
      2049,
      86,
      5,
      129,
      192,
      5,
      24577,
      80,
      5,
      2,
      87,
      5,
      385,
      83,
      5,
      25,
      91,
      5,
      6145,
      81,
      5,
      7,
      89,
      5,
      1537,
      85,
      5,
      97,
      93,
      5,
      24577,
      80,
      5,
      4,
      88,
      5,
      769,
      84,
      5,
      49,
      92,
      5,
      12289,
      82,
      5,
      13,
      90,
      5,
      3073,
      86,
      5,
      193,
      192,
      5,
      24577
    ];
    cplens = [
      // Copy lengths for literal codes 257..285
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    cplext = [
      // Extra bits for literal codes 257..285
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      0,
      112,
      112
      // 112==invalid
    ];
    cpdist = [
      // Copy offsets for distance codes 0..29
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577
    ];
    cpdext = [
      // Extra bits for distance codes
      0,
      0,
      0,
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      4,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      8,
      8,
      9,
      9,
      10,
      10,
      11,
      11,
      12,
      12,
      13,
      13
    ];
    BMAX = 15;
    InfTree.inflate_trees_fixed = function(bl, bd, tl, td) {
      bl[0] = fixed_bl;
      bd[0] = fixed_bd;
      tl[0] = fixed_tl;
      td[0] = fixed_td;
      return Z_OK3;
    };
    START = 0;
    LEN2 = 1;
    LENEXT2 = 2;
    DIST2 = 3;
    DISTEXT2 = 4;
    COPY2 = 5;
    LIT2 = 6;
    WASH = 7;
    END = 8;
    BADCODE = 9;
    border = [
      // Order of the bit length code lengths
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15
    ];
    TYPE2 = 0;
    LENS2 = 1;
    STORED3 = 2;
    TABLE2 = 3;
    BTREE = 4;
    DTREE = 5;
    CODES2 = 6;
    DRY = 7;
    DONELOCKS = 8;
    BADBLOCKS = 9;
    PRESET_DICT3 = 32;
    Z_DEFLATED3 = 8;
    METHOD = 0;
    FLAG = 1;
    DICT4 = 2;
    DICT3 = 3;
    DICT2 = 4;
    DICT1 = 5;
    DICT0 = 6;
    BLOCKS = 7;
    DONE2 = 12;
    BAD2 = 13;
    mark = [0, 0, 255, 255];
    ZStream3.prototype = {
      inflateInit(bits) {
        const that = this;
        that.istate = new Inflate2();
        if (!bits)
          bits = MAX_BITS3;
        return that.istate.inflateInit(that, bits);
      },
      inflate(f2) {
        const that = this;
        if (!that.istate)
          return Z_STREAM_ERROR3;
        return that.istate.inflate(that, f2);
      },
      inflateEnd() {
        const that = this;
        if (!that.istate)
          return Z_STREAM_ERROR3;
        const ret = that.istate.inflateEnd(that);
        that.istate = null;
        return ret;
      },
      inflateSync() {
        const that = this;
        if (!that.istate)
          return Z_STREAM_ERROR3;
        return that.istate.inflateSync(that);
      },
      inflateSetDictionary(dictionary, dictLength) {
        const that = this;
        if (!that.istate)
          return Z_STREAM_ERROR3;
        return that.istate.inflateSetDictionary(that, dictionary, dictLength);
      },
      read_byte(start) {
        const that = this;
        return that.next_in[start];
      },
      read_buf(start, size) {
        const that = this;
        return that.next_in.subarray(start, start + size);
      }
    };
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/constants.js
var MAX_32_BITS, MAX_16_BITS, COMPRESSION_METHOD_DEFLATE, COMPRESSION_METHOD_STORE, COMPRESSION_METHOD_AES, LOCAL_FILE_HEADER_SIGNATURE, SPLIT_ZIP_FILE_SIGNATURE, DATA_DESCRIPTOR_RECORD_SIGNATURE, CENTRAL_FILE_HEADER_SIGNATURE, END_OF_CENTRAL_DIR_SIGNATURE, ZIP64_END_OF_CENTRAL_DIR_SIGNATURE, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE, END_OF_CENTRAL_DIR_LENGTH, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH, ZIP64_END_OF_CENTRAL_DIR_LENGTH, ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH, EXTRAFIELD_TYPE_ZIP64, EXTRAFIELD_TYPE_AES, EXTRAFIELD_TYPE_NTFS, EXTRAFIELD_TYPE_NTFS_TAG1, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP, EXTRAFIELD_TYPE_UNICODE_PATH, EXTRAFIELD_TYPE_UNICODE_COMMENT, BITFLAG_ENCRYPTED, BITFLAG_LEVEL, BITFLAG_DATA_DESCRIPTOR, BITFLAG_LANG_ENCODING_FLAG, FILE_ATTR_MSDOS_DIR_MASK, VERSION_DEFLATE, VERSION_ZIP64, VERSION_AES, DIRECTORY_SIGNATURE, MAX_DATE, MIN_DATE, UNDEFINED_VALUE, UNDEFINED_TYPE, FUNCTION_TYPE;
var init_constants = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/constants.js"() {
    MAX_32_BITS = 4294967295;
    MAX_16_BITS = 65535;
    COMPRESSION_METHOD_DEFLATE = 8;
    COMPRESSION_METHOD_STORE = 0;
    COMPRESSION_METHOD_AES = 99;
    LOCAL_FILE_HEADER_SIGNATURE = 67324752;
    SPLIT_ZIP_FILE_SIGNATURE = 134695760;
    DATA_DESCRIPTOR_RECORD_SIGNATURE = SPLIT_ZIP_FILE_SIGNATURE;
    CENTRAL_FILE_HEADER_SIGNATURE = 33639248;
    END_OF_CENTRAL_DIR_SIGNATURE = 101010256;
    ZIP64_END_OF_CENTRAL_DIR_SIGNATURE = 101075792;
    ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE = 117853008;
    END_OF_CENTRAL_DIR_LENGTH = 22;
    ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH = 20;
    ZIP64_END_OF_CENTRAL_DIR_LENGTH = 56;
    ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH = END_OF_CENTRAL_DIR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LENGTH;
    EXTRAFIELD_TYPE_ZIP64 = 1;
    EXTRAFIELD_TYPE_AES = 39169;
    EXTRAFIELD_TYPE_NTFS = 10;
    EXTRAFIELD_TYPE_NTFS_TAG1 = 1;
    EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP = 21589;
    EXTRAFIELD_TYPE_UNICODE_PATH = 28789;
    EXTRAFIELD_TYPE_UNICODE_COMMENT = 25461;
    BITFLAG_ENCRYPTED = 1;
    BITFLAG_LEVEL = 6;
    BITFLAG_DATA_DESCRIPTOR = 8;
    BITFLAG_LANG_ENCODING_FLAG = 2048;
    FILE_ATTR_MSDOS_DIR_MASK = 16;
    VERSION_DEFLATE = 20;
    VERSION_ZIP64 = 45;
    VERSION_AES = 51;
    DIRECTORY_SIGNATURE = "/";
    MAX_DATE = new Date(2107, 11, 31);
    MIN_DATE = new Date(1980, 0, 1);
    UNDEFINED_VALUE = void 0;
    UNDEFINED_TYPE = "undefined";
    FUNCTION_TYPE = "function";
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/stream-adapter.js
var StreamAdapter;
var init_stream_adapter = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/stream-adapter.js"() {
    StreamAdapter = class {
      constructor(Codec) {
        return class extends TransformStream {
          constructor(_format, options) {
            const codec2 = new Codec(options);
            super({
              transform(chunk, controller) {
                controller.enqueue(codec2.append(chunk));
              },
              flush(controller) {
                const chunk = codec2.flush();
                if (chunk) {
                  controller.enqueue(chunk);
                }
              }
            });
          }
        };
      }
    };
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/configuration.js
function getConfiguration() {
  return config;
}
function getChunkSize(config2) {
  return Math.max(config2.chunkSize, MINIMUM_CHUNK_SIZE);
}
function configure(configuration) {
  const {
    baseURL: baseURL2,
    chunkSize,
    maxWorkers: maxWorkers2,
    terminateWorkerTimeout,
    useCompressionStream,
    useWebWorkers,
    Deflate: Deflate4,
    Inflate: Inflate4,
    CompressionStream: CompressionStream2,
    DecompressionStream: DecompressionStream2,
    workerScripts
  } = configuration;
  setIfDefined("baseURL", baseURL2);
  setIfDefined("chunkSize", chunkSize);
  setIfDefined("maxWorkers", maxWorkers2);
  setIfDefined("terminateWorkerTimeout", terminateWorkerTimeout);
  setIfDefined("useCompressionStream", useCompressionStream);
  setIfDefined("useWebWorkers", useWebWorkers);
  if (Deflate4) {
    config.CompressionStream = new StreamAdapter(Deflate4);
  }
  if (Inflate4) {
    config.DecompressionStream = new StreamAdapter(Inflate4);
  }
  setIfDefined("CompressionStream", CompressionStream2);
  setIfDefined("DecompressionStream", DecompressionStream2);
  if (workerScripts !== UNDEFINED_VALUE) {
    const { deflate: deflate3, inflate: inflate3 } = workerScripts;
    if (deflate3 || inflate3) {
      if (!config.workerScripts) {
        config.workerScripts = {};
      }
    }
    if (deflate3) {
      if (!Array.isArray(deflate3)) {
        throw new Error("workerScripts.deflate must be an array");
      }
      config.workerScripts.deflate = deflate3;
    }
    if (inflate3) {
      if (!Array.isArray(inflate3)) {
        throw new Error("workerScripts.inflate must be an array");
      }
      config.workerScripts.inflate = inflate3;
    }
  }
}
function setIfDefined(propertyName, propertyValue) {
  if (propertyValue !== UNDEFINED_VALUE) {
    config[propertyName] = propertyValue;
  }
}
var MINIMUM_CHUNK_SIZE, maxWorkers, DEFAULT_CONFIGURATION, config;
var init_configuration = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/configuration.js"() {
    init_constants();
    init_stream_adapter();
    MINIMUM_CHUNK_SIZE = 64;
    maxWorkers = 2;
    try {
      if (typeof navigator != UNDEFINED_TYPE && navigator.hardwareConcurrency) {
        maxWorkers = navigator.hardwareConcurrency;
      }
    } catch (_error) {
    }
    DEFAULT_CONFIGURATION = {
      chunkSize: 512 * 1024,
      maxWorkers,
      terminateWorkerTimeout: 5e3,
      useWebWorkers: true,
      useCompressionStream: true,
      workerScripts: UNDEFINED_VALUE,
      CompressionStreamNative: typeof CompressionStream != UNDEFINED_TYPE && CompressionStream,
      DecompressionStreamNative: typeof DecompressionStream != UNDEFINED_TYPE && DecompressionStream
    };
    config = Object.assign({}, DEFAULT_CONFIGURATION);
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/util/default-mime-type.js
function getMimeType() {
  return "application/octet-stream";
}
var init_default_mime_type = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/util/default-mime-type.js"() {
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/util/mime-type.js
function getMimeType2(filename) {
  return filename && mimeTypes[filename.split(".").pop().toLowerCase()] || getMimeType();
}
var table, mimeTypes;
var init_mime_type = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/util/mime-type.js"() {
    init_default_mime_type();
    table = {
      "application": {
        "andrew-inset": "ez",
        "annodex": "anx",
        "atom+xml": "atom",
        "atomcat+xml": "atomcat",
        "atomserv+xml": "atomsrv",
        "bbolin": "lin",
        "cap": ["cap", "pcap"],
        "cu-seeme": "cu",
        "davmount+xml": "davmount",
        "dsptype": "tsp",
        "ecmascript": ["es", "ecma"],
        "futuresplash": "spl",
        "hta": "hta",
        "java-archive": "jar",
        "java-serialized-object": "ser",
        "java-vm": "class",
        "javascript": "js",
        "m3g": "m3g",
        "mac-binhex40": "hqx",
        "mathematica": ["nb", "ma", "mb"],
        "msaccess": "mdb",
        "msword": ["doc", "dot"],
        "mxf": "mxf",
        "oda": "oda",
        "ogg": "ogx",
        "pdf": "pdf",
        "pgp-keys": "key",
        "pgp-signature": ["asc", "sig"],
        "pics-rules": "prf",
        "postscript": ["ps", "ai", "eps", "epsi", "epsf", "eps2", "eps3"],
        "rar": "rar",
        "rdf+xml": "rdf",
        "rss+xml": "rss",
        "rtf": "rtf",
        "smil": ["smi", "smil"],
        "xhtml+xml": ["xhtml", "xht"],
        "xml": ["xml", "xsl", "xsd"],
        "xspf+xml": "xspf",
        "zip": "zip",
        "vnd.android.package-archive": "apk",
        "vnd.cinderella": "cdy",
        "vnd.google-earth.kml+xml": "kml",
        "vnd.google-earth.kmz": "kmz",
        "vnd.mozilla.xul+xml": "xul",
        "vnd.ms-excel": ["xls", "xlb", "xlt", "xlm", "xla", "xlc", "xlw"],
        "vnd.ms-pki.seccat": "cat",
        "vnd.ms-pki.stl": "stl",
        "vnd.ms-powerpoint": ["ppt", "pps", "pot"],
        "vnd.oasis.opendocument.chart": "odc",
        "vnd.oasis.opendocument.database": "odb",
        "vnd.oasis.opendocument.formula": "odf",
        "vnd.oasis.opendocument.graphics": "odg",
        "vnd.oasis.opendocument.graphics-template": "otg",
        "vnd.oasis.opendocument.image": "odi",
        "vnd.oasis.opendocument.presentation": "odp",
        "vnd.oasis.opendocument.presentation-template": "otp",
        "vnd.oasis.opendocument.spreadsheet": "ods",
        "vnd.oasis.opendocument.spreadsheet-template": "ots",
        "vnd.oasis.opendocument.text": "odt",
        "vnd.oasis.opendocument.text-master": "odm",
        "vnd.oasis.opendocument.text-template": "ott",
        "vnd.oasis.opendocument.text-web": "oth",
        "vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
        "vnd.openxmlformats-officedocument.spreadsheetml.template": "xltx",
        "vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
        "vnd.openxmlformats-officedocument.presentationml.slideshow": "ppsx",
        "vnd.openxmlformats-officedocument.presentationml.template": "potx",
        "vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
        "vnd.openxmlformats-officedocument.wordprocessingml.template": "dotx",
        "vnd.smaf": "mmf",
        "vnd.stardivision.calc": "sdc",
        "vnd.stardivision.chart": "sds",
        "vnd.stardivision.draw": "sda",
        "vnd.stardivision.impress": "sdd",
        "vnd.stardivision.math": ["sdf", "smf"],
        "vnd.stardivision.writer": ["sdw", "vor"],
        "vnd.stardivision.writer-global": "sgl",
        "vnd.sun.xml.calc": "sxc",
        "vnd.sun.xml.calc.template": "stc",
        "vnd.sun.xml.draw": "sxd",
        "vnd.sun.xml.draw.template": "std",
        "vnd.sun.xml.impress": "sxi",
        "vnd.sun.xml.impress.template": "sti",
        "vnd.sun.xml.math": "sxm",
        "vnd.sun.xml.writer": "sxw",
        "vnd.sun.xml.writer.global": "sxg",
        "vnd.sun.xml.writer.template": "stw",
        "vnd.symbian.install": ["sis", "sisx"],
        "vnd.visio": ["vsd", "vst", "vss", "vsw"],
        "vnd.wap.wbxml": "wbxml",
        "vnd.wap.wmlc": "wmlc",
        "vnd.wap.wmlscriptc": "wmlsc",
        "vnd.wordperfect": "wpd",
        "vnd.wordperfect5.1": "wp5",
        "x-123": "wk",
        "x-7z-compressed": "7z",
        "x-abiword": "abw",
        "x-apple-diskimage": "dmg",
        "x-bcpio": "bcpio",
        "x-bittorrent": "torrent",
        "x-cbr": ["cbr", "cba", "cbt", "cb7"],
        "x-cbz": "cbz",
        "x-cdf": ["cdf", "cda"],
        "x-cdlink": "vcd",
        "x-chess-pgn": "pgn",
        "x-cpio": "cpio",
        "x-csh": "csh",
        "x-debian-package": ["deb", "udeb"],
        "x-director": ["dcr", "dir", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"],
        "x-dms": "dms",
        "x-doom": "wad",
        "x-dvi": "dvi",
        "x-httpd-eruby": "rhtml",
        "x-font": "pcf.Z",
        "x-freemind": "mm",
        "x-gnumeric": "gnumeric",
        "x-go-sgf": "sgf",
        "x-graphing-calculator": "gcf",
        "x-gtar": ["gtar", "taz"],
        "x-hdf": "hdf",
        "x-httpd-php": ["phtml", "pht", "php"],
        "x-httpd-php-source": "phps",
        "x-httpd-php3": "php3",
        "x-httpd-php3-preprocessed": "php3p",
        "x-httpd-php4": "php4",
        "x-httpd-php5": "php5",
        "x-ica": "ica",
        "x-info": "info",
        "x-internet-signup": ["ins", "isp"],
        "x-iphone": "iii",
        "x-iso9660-image": "iso",
        "x-java-jnlp-file": "jnlp",
        "x-jmol": "jmz",
        "x-killustrator": "kil",
        "x-koan": ["skp", "skd", "skt", "skm"],
        "x-kpresenter": ["kpr", "kpt"],
        "x-kword": ["kwd", "kwt"],
        "x-latex": "latex",
        "x-lha": "lha",
        "x-lyx": "lyx",
        "x-lzh": "lzh",
        "x-lzx": "lzx",
        "x-maker": ["frm", "maker", "frame", "fm", "fb", "book", "fbdoc"],
        "x-ms-wmd": "wmd",
        "x-ms-wmz": "wmz",
        "x-msdos-program": ["com", "exe", "bat", "dll"],
        "x-msi": "msi",
        "x-netcdf": ["nc", "cdf"],
        "x-ns-proxy-autoconfig": ["pac", "dat"],
        "x-nwc": "nwc",
        "x-object": "o",
        "x-oz-application": "oza",
        "x-pkcs7-certreqresp": "p7r",
        "x-python-code": ["pyc", "pyo"],
        "x-qgis": ["qgs", "shp", "shx"],
        "x-quicktimeplayer": "qtl",
        "x-redhat-package-manager": "rpm",
        "x-ruby": "rb",
        "x-sh": "sh",
        "x-shar": "shar",
        "x-shockwave-flash": ["swf", "swfl"],
        "x-silverlight": "scr",
        "x-stuffit": "sit",
        "x-sv4cpio": "sv4cpio",
        "x-sv4crc": "sv4crc",
        "x-tar": "tar",
        "x-tcl": "tcl",
        "x-tex-gf": "gf",
        "x-tex-pk": "pk",
        "x-texinfo": ["texinfo", "texi"],
        "x-trash": ["~", "%", "bak", "old", "sik"],
        "x-troff": ["t", "tr", "roff"],
        "x-troff-man": "man",
        "x-troff-me": "me",
        "x-troff-ms": "ms",
        "x-ustar": "ustar",
        "x-wais-source": "src",
        "x-wingz": "wz",
        "x-x509-ca-cert": ["crt", "der", "cer"],
        "x-xcf": "xcf",
        "x-xfig": "fig",
        "x-xpinstall": "xpi",
        "applixware": "aw",
        "atomsvc+xml": "atomsvc",
        "ccxml+xml": "ccxml",
        "cdmi-capability": "cdmia",
        "cdmi-container": "cdmic",
        "cdmi-domain": "cdmid",
        "cdmi-object": "cdmio",
        "cdmi-queue": "cdmiq",
        "docbook+xml": "dbk",
        "dssc+der": "dssc",
        "dssc+xml": "xdssc",
        "emma+xml": "emma",
        "epub+zip": "epub",
        "exi": "exi",
        "font-tdpfr": "pfr",
        "gml+xml": "gml",
        "gpx+xml": "gpx",
        "gxf": "gxf",
        "hyperstudio": "stk",
        "inkml+xml": ["ink", "inkml"],
        "ipfix": "ipfix",
        "json": "json",
        "jsonml+json": "jsonml",
        "lost+xml": "lostxml",
        "mads+xml": "mads",
        "marc": "mrc",
        "marcxml+xml": "mrcx",
        "mathml+xml": "mathml",
        "mbox": "mbox",
        "mediaservercontrol+xml": "mscml",
        "metalink+xml": "metalink",
        "metalink4+xml": "meta4",
        "mets+xml": "mets",
        "mods+xml": "mods",
        "mp21": ["m21", "mp21"],
        "mp4": "mp4s",
        "oebps-package+xml": "opf",
        "omdoc+xml": "omdoc",
        "onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"],
        "oxps": "oxps",
        "patch-ops-error+xml": "xer",
        "pgp-encrypted": "pgp",
        "pkcs10": "p10",
        "pkcs7-mime": ["p7m", "p7c"],
        "pkcs7-signature": "p7s",
        "pkcs8": "p8",
        "pkix-attr-cert": "ac",
        "pkix-crl": "crl",
        "pkix-pkipath": "pkipath",
        "pkixcmp": "pki",
        "pls+xml": "pls",
        "prs.cww": "cww",
        "pskc+xml": "pskcxml",
        "reginfo+xml": "rif",
        "relax-ng-compact-syntax": "rnc",
        "resource-lists+xml": "rl",
        "resource-lists-diff+xml": "rld",
        "rls-services+xml": "rs",
        "rpki-ghostbusters": "gbr",
        "rpki-manifest": "mft",
        "rpki-roa": "roa",
        "rsd+xml": "rsd",
        "sbml+xml": "sbml",
        "scvp-cv-request": "scq",
        "scvp-cv-response": "scs",
        "scvp-vp-request": "spq",
        "scvp-vp-response": "spp",
        "sdp": "sdp",
        "set-payment-initiation": "setpay",
        "set-registration-initiation": "setreg",
        "shf+xml": "shf",
        "sparql-query": "rq",
        "sparql-results+xml": "srx",
        "srgs": "gram",
        "srgs+xml": "grxml",
        "sru+xml": "sru",
        "ssdl+xml": "ssdl",
        "ssml+xml": "ssml",
        "tei+xml": ["tei", "teicorpus"],
        "thraud+xml": "tfi",
        "timestamped-data": "tsd",
        "vnd.3gpp.pic-bw-large": "plb",
        "vnd.3gpp.pic-bw-small": "psb",
        "vnd.3gpp.pic-bw-var": "pvb",
        "vnd.3gpp2.tcap": "tcap",
        "vnd.3m.post-it-notes": "pwn",
        "vnd.accpac.simply.aso": "aso",
        "vnd.accpac.simply.imp": "imp",
        "vnd.acucobol": "acu",
        "vnd.acucorp": ["atc", "acutc"],
        "vnd.adobe.air-application-installer-package+zip": "air",
        "vnd.adobe.formscentral.fcdt": "fcdt",
        "vnd.adobe.fxp": ["fxp", "fxpl"],
        "vnd.adobe.xdp+xml": "xdp",
        "vnd.adobe.xfdf": "xfdf",
        "vnd.ahead.space": "ahead",
        "vnd.airzip.filesecure.azf": "azf",
        "vnd.airzip.filesecure.azs": "azs",
        "vnd.amazon.ebook": "azw",
        "vnd.americandynamics.acc": "acc",
        "vnd.amiga.ami": "ami",
        "vnd.anser-web-certificate-issue-initiation": "cii",
        "vnd.anser-web-funds-transfer-initiation": "fti",
        "vnd.antix.game-component": "atx",
        "vnd.apple.installer+xml": "mpkg",
        "vnd.apple.mpegurl": "m3u8",
        "vnd.aristanetworks.swi": "swi",
        "vnd.astraea-software.iota": "iota",
        "vnd.audiograph": "aep",
        "vnd.blueice.multipass": "mpm",
        "vnd.bmi": "bmi",
        "vnd.businessobjects": "rep",
        "vnd.chemdraw+xml": "cdxml",
        "vnd.chipnuts.karaoke-mmd": "mmd",
        "vnd.claymore": "cla",
        "vnd.cloanto.rp9": "rp9",
        "vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"],
        "vnd.cluetrust.cartomobile-config": "c11amc",
        "vnd.cluetrust.cartomobile-config-pkg": "c11amz",
        "vnd.commonspace": "csp",
        "vnd.contact.cmsg": "cdbcmsg",
        "vnd.cosmocaller": "cmc",
        "vnd.crick.clicker": "clkx",
        "vnd.crick.clicker.keyboard": "clkk",
        "vnd.crick.clicker.palette": "clkp",
        "vnd.crick.clicker.template": "clkt",
        "vnd.crick.clicker.wordbank": "clkw",
        "vnd.criticaltools.wbs+xml": "wbs",
        "vnd.ctc-posml": "pml",
        "vnd.cups-ppd": "ppd",
        "vnd.curl.car": "car",
        "vnd.curl.pcurl": "pcurl",
        "vnd.dart": "dart",
        "vnd.data-vision.rdz": "rdz",
        "vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"],
        "vnd.dece.ttml+xml": ["uvt", "uvvt"],
        "vnd.dece.unspecified": ["uvx", "uvvx"],
        "vnd.dece.zip": ["uvz", "uvvz"],
        "vnd.denovo.fcselayout-link": "fe_launch",
        "vnd.dna": "dna",
        "vnd.dolby.mlp": "mlp",
        "vnd.dpgraph": "dpg",
        "vnd.dreamfactory": "dfac",
        "vnd.ds-keypoint": "kpxx",
        "vnd.dvb.ait": "ait",
        "vnd.dvb.service": "svc",
        "vnd.dynageo": "geo",
        "vnd.ecowin.chart": "mag",
        "vnd.enliven": "nml",
        "vnd.epson.esf": "esf",
        "vnd.epson.msf": "msf",
        "vnd.epson.quickanime": "qam",
        "vnd.epson.salt": "slt",
        "vnd.epson.ssf": "ssf",
        "vnd.eszigno3+xml": ["es3", "et3"],
        "vnd.ezpix-album": "ez2",
        "vnd.ezpix-package": "ez3",
        "vnd.fdf": "fdf",
        "vnd.fdsn.mseed": "mseed",
        "vnd.fdsn.seed": ["seed", "dataless"],
        "vnd.flographit": "gph",
        "vnd.fluxtime.clip": "ftc",
        "vnd.framemaker": ["fm", "frame", "maker", "book"],
        "vnd.frogans.fnc": "fnc",
        "vnd.frogans.ltf": "ltf",
        "vnd.fsc.weblaunch": "fsc",
        "vnd.fujitsu.oasys": "oas",
        "vnd.fujitsu.oasys2": "oa2",
        "vnd.fujitsu.oasys3": "oa3",
        "vnd.fujitsu.oasysgp": "fg5",
        "vnd.fujitsu.oasysprs": "bh2",
        "vnd.fujixerox.ddd": "ddd",
        "vnd.fujixerox.docuworks": "xdw",
        "vnd.fujixerox.docuworks.binder": "xbd",
        "vnd.fuzzysheet": "fzs",
        "vnd.genomatix.tuxedo": "txd",
        "vnd.geogebra.file": "ggb",
        "vnd.geogebra.tool": "ggt",
        "vnd.geometry-explorer": ["gex", "gre"],
        "vnd.geonext": "gxt",
        "vnd.geoplan": "g2w",
        "vnd.geospace": "g3w",
        "vnd.gmx": "gmx",
        "vnd.grafeq": ["gqf", "gqs"],
        "vnd.groove-account": "gac",
        "vnd.groove-help": "ghf",
        "vnd.groove-identity-message": "gim",
        "vnd.groove-injector": "grv",
        "vnd.groove-tool-message": "gtm",
        "vnd.groove-tool-template": "tpl",
        "vnd.groove-vcard": "vcg",
        "vnd.hal+xml": "hal",
        "vnd.handheld-entertainment+xml": "zmm",
        "vnd.hbci": "hbci",
        "vnd.hhe.lesson-player": "les",
        "vnd.hp-hpgl": "hpgl",
        "vnd.hp-hpid": "hpid",
        "vnd.hp-hps": "hps",
        "vnd.hp-jlyt": "jlt",
        "vnd.hp-pcl": "pcl",
        "vnd.hp-pclxl": "pclxl",
        "vnd.hydrostatix.sof-data": "sfd-hdstx",
        "vnd.ibm.minipay": "mpy",
        "vnd.ibm.modcap": ["afp", "listafp", "list3820"],
        "vnd.ibm.rights-management": "irm",
        "vnd.ibm.secure-container": "sc",
        "vnd.iccprofile": ["icc", "icm"],
        "vnd.igloader": "igl",
        "vnd.immervision-ivp": "ivp",
        "vnd.immervision-ivu": "ivu",
        "vnd.insors.igm": "igm",
        "vnd.intercon.formnet": ["xpw", "xpx"],
        "vnd.intergeo": "i2g",
        "vnd.intu.qbo": "qbo",
        "vnd.intu.qfx": "qfx",
        "vnd.ipunplugged.rcprofile": "rcprofile",
        "vnd.irepository.package+xml": "irp",
        "vnd.is-xpr": "xpr",
        "vnd.isac.fcs": "fcs",
        "vnd.jam": "jam",
        "vnd.jcp.javame.midlet-rms": "rms",
        "vnd.jisp": "jisp",
        "vnd.joost.joda-archive": "joda",
        "vnd.kahootz": ["ktz", "ktr"],
        "vnd.kde.karbon": "karbon",
        "vnd.kde.kchart": "chrt",
        "vnd.kde.kformula": "kfo",
        "vnd.kde.kivio": "flw",
        "vnd.kde.kontour": "kon",
        "vnd.kde.kpresenter": ["kpr", "kpt"],
        "vnd.kde.kspread": "ksp",
        "vnd.kde.kword": ["kwd", "kwt"],
        "vnd.kenameaapp": "htke",
        "vnd.kidspiration": "kia",
        "vnd.kinar": ["kne", "knp"],
        "vnd.koan": ["skp", "skd", "skt", "skm"],
        "vnd.kodak-descriptor": "sse",
        "vnd.las.las+xml": "lasxml",
        "vnd.llamagraphics.life-balance.desktop": "lbd",
        "vnd.llamagraphics.life-balance.exchange+xml": "lbe",
        "vnd.lotus-1-2-3": "123",
        "vnd.lotus-approach": "apr",
        "vnd.lotus-freelance": "pre",
        "vnd.lotus-notes": "nsf",
        "vnd.lotus-organizer": "org",
        "vnd.lotus-screencam": "scm",
        "vnd.lotus-wordpro": "lwp",
        "vnd.macports.portpkg": "portpkg",
        "vnd.mcd": "mcd",
        "vnd.medcalcdata": "mc1",
        "vnd.mediastation.cdkey": "cdkey",
        "vnd.mfer": "mwf",
        "vnd.mfmp": "mfm",
        "vnd.micrografx.flo": "flo",
        "vnd.micrografx.igx": "igx",
        "vnd.mif": "mif",
        "vnd.mobius.daf": "daf",
        "vnd.mobius.dis": "dis",
        "vnd.mobius.mbk": "mbk",
        "vnd.mobius.mqy": "mqy",
        "vnd.mobius.msl": "msl",
        "vnd.mobius.plc": "plc",
        "vnd.mobius.txf": "txf",
        "vnd.mophun.application": "mpn",
        "vnd.mophun.certificate": "mpc",
        "vnd.ms-artgalry": "cil",
        "vnd.ms-cab-compressed": "cab",
        "vnd.ms-excel.addin.macroenabled.12": "xlam",
        "vnd.ms-excel.sheet.binary.macroenabled.12": "xlsb",
        "vnd.ms-excel.sheet.macroenabled.12": "xlsm",
        "vnd.ms-excel.template.macroenabled.12": "xltm",
        "vnd.ms-fontobject": "eot",
        "vnd.ms-htmlhelp": "chm",
        "vnd.ms-ims": "ims",
        "vnd.ms-lrm": "lrm",
        "vnd.ms-officetheme": "thmx",
        "vnd.ms-powerpoint.addin.macroenabled.12": "ppam",
        "vnd.ms-powerpoint.presentation.macroenabled.12": "pptm",
        "vnd.ms-powerpoint.slide.macroenabled.12": "sldm",
        "vnd.ms-powerpoint.slideshow.macroenabled.12": "ppsm",
        "vnd.ms-powerpoint.template.macroenabled.12": "potm",
        "vnd.ms-project": ["mpp", "mpt"],
        "vnd.ms-word.document.macroenabled.12": "docm",
        "vnd.ms-word.template.macroenabled.12": "dotm",
        "vnd.ms-works": ["wps", "wks", "wcm", "wdb"],
        "vnd.ms-wpl": "wpl",
        "vnd.ms-xpsdocument": "xps",
        "vnd.mseq": "mseq",
        "vnd.musician": "mus",
        "vnd.muvee.style": "msty",
        "vnd.mynfc": "taglet",
        "vnd.neurolanguage.nlu": "nlu",
        "vnd.nitf": ["ntf", "nitf"],
        "vnd.noblenet-directory": "nnd",
        "vnd.noblenet-sealer": "nns",
        "vnd.noblenet-web": "nnw",
        "vnd.nokia.n-gage.data": "ngdat",
        "vnd.nokia.n-gage.symbian.install": "n-gage",
        "vnd.nokia.radio-preset": "rpst",
        "vnd.nokia.radio-presets": "rpss",
        "vnd.novadigm.edm": "edm",
        "vnd.novadigm.edx": "edx",
        "vnd.novadigm.ext": "ext",
        "vnd.oasis.opendocument.chart-template": "otc",
        "vnd.oasis.opendocument.formula-template": "odft",
        "vnd.oasis.opendocument.image-template": "oti",
        "vnd.olpc-sugar": "xo",
        "vnd.oma.dd2+xml": "dd2",
        "vnd.openofficeorg.extension": "oxt",
        "vnd.openxmlformats-officedocument.presentationml.slide": "sldx",
        "vnd.osgeo.mapguide.package": "mgp",
        "vnd.osgi.dp": "dp",
        "vnd.osgi.subsystem": "esa",
        "vnd.palm": ["pdb", "pqa", "oprc"],
        "vnd.pawaafile": "paw",
        "vnd.pg.format": "str",
        "vnd.pg.osasli": "ei6",
        "vnd.picsel": "efif",
        "vnd.pmi.widget": "wg",
        "vnd.pocketlearn": "plf",
        "vnd.powerbuilder6": "pbd",
        "vnd.previewsystems.box": "box",
        "vnd.proteus.magazine": "mgz",
        "vnd.publishare-delta-tree": "qps",
        "vnd.pvi.ptid1": "ptid",
        "vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"],
        "vnd.realvnc.bed": "bed",
        "vnd.recordare.musicxml": "mxl",
        "vnd.recordare.musicxml+xml": "musicxml",
        "vnd.rig.cryptonote": "cryptonote",
        "vnd.rn-realmedia": "rm",
        "vnd.rn-realmedia-vbr": "rmvb",
        "vnd.route66.link66+xml": "link66",
        "vnd.sailingtracker.track": "st",
        "vnd.seemail": "see",
        "vnd.sema": "sema",
        "vnd.semd": "semd",
        "vnd.semf": "semf",
        "vnd.shana.informed.formdata": "ifm",
        "vnd.shana.informed.formtemplate": "itp",
        "vnd.shana.informed.interchange": "iif",
        "vnd.shana.informed.package": "ipk",
        "vnd.simtech-mindmapper": ["twd", "twds"],
        "vnd.smart.teacher": "teacher",
        "vnd.solent.sdkm+xml": ["sdkm", "sdkd"],
        "vnd.spotfire.dxp": "dxp",
        "vnd.spotfire.sfs": "sfs",
        "vnd.stepmania.package": "smzip",
        "vnd.stepmania.stepchart": "sm",
        "vnd.sus-calendar": ["sus", "susp"],
        "vnd.svd": "svd",
        "vnd.syncml+xml": "xsm",
        "vnd.syncml.dm+wbxml": "bdm",
        "vnd.syncml.dm+xml": "xdm",
        "vnd.tao.intent-module-archive": "tao",
        "vnd.tcpdump.pcap": ["pcap", "cap", "dmp"],
        "vnd.tmobile-livetv": "tmo",
        "vnd.trid.tpt": "tpt",
        "vnd.triscape.mxs": "mxs",
        "vnd.trueapp": "tra",
        "vnd.ufdl": ["ufd", "ufdl"],
        "vnd.uiq.theme": "utz",
        "vnd.umajin": "umj",
        "vnd.unity": "unityweb",
        "vnd.uoml+xml": "uoml",
        "vnd.vcx": "vcx",
        "vnd.visionary": "vis",
        "vnd.vsf": "vsf",
        "vnd.webturbo": "wtb",
        "vnd.wolfram.player": "nbp",
        "vnd.wqd": "wqd",
        "vnd.wt.stf": "stf",
        "vnd.xara": "xar",
        "vnd.xfdl": "xfdl",
        "vnd.yamaha.hv-dic": "hvd",
        "vnd.yamaha.hv-script": "hvs",
        "vnd.yamaha.hv-voice": "hvp",
        "vnd.yamaha.openscoreformat": "osf",
        "vnd.yamaha.openscoreformat.osfpvg+xml": "osfpvg",
        "vnd.yamaha.smaf-audio": "saf",
        "vnd.yamaha.smaf-phrase": "spf",
        "vnd.yellowriver-custom-menu": "cmp",
        "vnd.zul": ["zir", "zirz"],
        "vnd.zzazz.deck+xml": "zaz",
        "voicexml+xml": "vxml",
        "widget": "wgt",
        "winhlp": "hlp",
        "wsdl+xml": "wsdl",
        "wspolicy+xml": "wspolicy",
        "x-ace-compressed": "ace",
        "x-authorware-bin": ["aab", "x32", "u32", "vox"],
        "x-authorware-map": "aam",
        "x-authorware-seg": "aas",
        "x-blorb": ["blb", "blorb"],
        "x-bzip": "bz",
        "x-bzip2": ["bz2", "boz"],
        "x-cfs-compressed": "cfs",
        "x-chat": "chat",
        "x-conference": "nsc",
        "x-dgc-compressed": "dgc",
        "x-dtbncx+xml": "ncx",
        "x-dtbook+xml": "dtb",
        "x-dtbresource+xml": "res",
        "x-eva": "eva",
        "x-font-bdf": "bdf",
        "x-font-ghostscript": "gsf",
        "x-font-linux-psf": "psf",
        "x-font-otf": "otf",
        "x-font-pcf": "pcf",
        "x-font-snf": "snf",
        "x-font-ttf": ["ttf", "ttc"],
        "x-font-type1": ["pfa", "pfb", "pfm", "afm"],
        "x-font-woff": "woff",
        "x-freearc": "arc",
        "x-gca-compressed": "gca",
        "x-glulx": "ulx",
        "x-gramps-xml": "gramps",
        "x-install-instructions": "install",
        "x-lzh-compressed": ["lzh", "lha"],
        "x-mie": "mie",
        "x-mobipocket-ebook": ["prc", "mobi"],
        "x-ms-application": "application",
        "x-ms-shortcut": "lnk",
        "x-ms-xbap": "xbap",
        "x-msbinder": "obd",
        "x-mscardfile": "crd",
        "x-msclip": "clp",
        "x-msdownload": ["exe", "dll", "com", "bat", "msi"],
        "x-msmediaview": ["mvb", "m13", "m14"],
        "x-msmetafile": ["wmf", "wmz", "emf", "emz"],
        "x-msmoney": "mny",
        "x-mspublisher": "pub",
        "x-msschedule": "scd",
        "x-msterminal": "trm",
        "x-mswrite": "wri",
        "x-nzb": "nzb",
        "x-pkcs12": ["p12", "pfx"],
        "x-pkcs7-certificates": ["p7b", "spc"],
        "x-research-info-systems": "ris",
        "x-silverlight-app": "xap",
        "x-sql": "sql",
        "x-stuffitx": "sitx",
        "x-subrip": "srt",
        "x-t3vm-image": "t3",
        "x-tads": "gam",
        "x-tex": "tex",
        "x-tex-tfm": "tfm",
        "x-tgif": "obj",
        "x-xliff+xml": "xlf",
        "x-xz": "xz",
        "x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
        "xaml+xml": "xaml",
        "xcap-diff+xml": "xdf",
        "xenc+xml": "xenc",
        "xml-dtd": "dtd",
        "xop+xml": "xop",
        "xproc+xml": "xpl",
        "xslt+xml": "xslt",
        "xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
        "yang": "yang",
        "yin+xml": "yin",
        "envoy": "evy",
        "fractals": "fif",
        "internet-property-stream": "acx",
        "olescript": "axs",
        "vnd.ms-outlook": "msg",
        "vnd.ms-pkicertstore": "sst",
        "x-compress": "z",
        "x-compressed": "tgz",
        "x-gzip": "gz",
        "x-perfmon": ["pma", "pmc", "pml", "pmr", "pmw"],
        "x-pkcs7-mime": ["p7c", "p7m"],
        "ynd.ms-pkipko": "pko"
      },
      "audio": {
        "amr": "amr",
        "amr-wb": "awb",
        "annodex": "axa",
        "basic": ["au", "snd"],
        "flac": "flac",
        "midi": ["mid", "midi", "kar", "rmi"],
        "mpeg": ["mpga", "mpega", "mp2", "mp3", "m4a", "mp2a", "m2a", "m3a"],
        "mpegurl": "m3u",
        "ogg": ["oga", "ogg", "spx"],
        "prs.sid": "sid",
        "x-aiff": ["aif", "aiff", "aifc"],
        "x-gsm": "gsm",
        "x-ms-wma": "wma",
        "x-ms-wax": "wax",
        "x-pn-realaudio": "ram",
        "x-realaudio": "ra",
        "x-sd2": "sd2",
        "x-wav": "wav",
        "adpcm": "adp",
        "mp4": "mp4a",
        "s3m": "s3m",
        "silk": "sil",
        "vnd.dece.audio": ["uva", "uvva"],
        "vnd.digital-winds": "eol",
        "vnd.dra": "dra",
        "vnd.dts": "dts",
        "vnd.dts.hd": "dtshd",
        "vnd.lucent.voice": "lvp",
        "vnd.ms-playready.media.pya": "pya",
        "vnd.nuera.ecelp4800": "ecelp4800",
        "vnd.nuera.ecelp7470": "ecelp7470",
        "vnd.nuera.ecelp9600": "ecelp9600",
        "vnd.rip": "rip",
        "webm": "weba",
        "x-aac": "aac",
        "x-caf": "caf",
        "x-matroska": "mka",
        "x-pn-realaudio-plugin": "rmp",
        "xm": "xm",
        "mid": ["mid", "rmi"]
      },
      "chemical": {
        "x-alchemy": "alc",
        "x-cache": ["cac", "cache"],
        "x-cache-csf": "csf",
        "x-cactvs-binary": ["cbin", "cascii", "ctab"],
        "x-cdx": "cdx",
        "x-chem3d": "c3d",
        "x-cif": "cif",
        "x-cmdf": "cmdf",
        "x-cml": "cml",
        "x-compass": "cpa",
        "x-crossfire": "bsd",
        "x-csml": ["csml", "csm"],
        "x-ctx": "ctx",
        "x-cxf": ["cxf", "cef"],
        "x-embl-dl-nucleotide": ["emb", "embl"],
        "x-gamess-input": ["inp", "gam", "gamin"],
        "x-gaussian-checkpoint": ["fch", "fchk"],
        "x-gaussian-cube": "cub",
        "x-gaussian-input": ["gau", "gjc", "gjf"],
        "x-gaussian-log": "gal",
        "x-gcg8-sequence": "gcg",
        "x-genbank": "gen",
        "x-hin": "hin",
        "x-isostar": ["istr", "ist"],
        "x-jcamp-dx": ["jdx", "dx"],
        "x-kinemage": "kin",
        "x-macmolecule": "mcm",
        "x-macromodel-input": ["mmd", "mmod"],
        "x-mdl-molfile": "mol",
        "x-mdl-rdfile": "rd",
        "x-mdl-rxnfile": "rxn",
        "x-mdl-sdfile": ["sd", "sdf"],
        "x-mdl-tgf": "tgf",
        "x-mmcif": "mcif",
        "x-mol2": "mol2",
        "x-molconn-Z": "b",
        "x-mopac-graph": "gpt",
        "x-mopac-input": ["mop", "mopcrt", "mpc", "zmt"],
        "x-mopac-out": "moo",
        "x-ncbi-asn1": "asn",
        "x-ncbi-asn1-ascii": ["prt", "ent"],
        "x-ncbi-asn1-binary": ["val", "aso"],
        "x-pdb": ["pdb", "ent"],
        "x-rosdal": "ros",
        "x-swissprot": "sw",
        "x-vamas-iso14976": "vms",
        "x-vmd": "vmd",
        "x-xtel": "xtel",
        "x-xyz": "xyz"
      },
      "image": {
        "gif": "gif",
        "ief": "ief",
        "jpeg": ["jpeg", "jpg", "jpe"],
        "pcx": "pcx",
        "png": "png",
        "svg+xml": ["svg", "svgz"],
        "tiff": ["tiff", "tif"],
        "vnd.djvu": ["djvu", "djv"],
        "vnd.wap.wbmp": "wbmp",
        "x-canon-cr2": "cr2",
        "x-canon-crw": "crw",
        "x-cmu-raster": "ras",
        "x-coreldraw": "cdr",
        "x-coreldrawpattern": "pat",
        "x-coreldrawtemplate": "cdt",
        "x-corelphotopaint": "cpt",
        "x-epson-erf": "erf",
        "x-icon": "ico",
        "x-jg": "art",
        "x-jng": "jng",
        "x-nikon-nef": "nef",
        "x-olympus-orf": "orf",
        "x-photoshop": "psd",
        "x-portable-anymap": "pnm",
        "x-portable-bitmap": "pbm",
        "x-portable-graymap": "pgm",
        "x-portable-pixmap": "ppm",
        "x-rgb": "rgb",
        "x-xbitmap": "xbm",
        "x-xpixmap": "xpm",
        "x-xwindowdump": "xwd",
        "bmp": "bmp",
        "cgm": "cgm",
        "g3fax": "g3",
        "ktx": "ktx",
        "prs.btif": "btif",
        "sgi": "sgi",
        "vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"],
        "vnd.dwg": "dwg",
        "vnd.dxf": "dxf",
        "vnd.fastbidsheet": "fbs",
        "vnd.fpx": "fpx",
        "vnd.fst": "fst",
        "vnd.fujixerox.edmics-mmr": "mmr",
        "vnd.fujixerox.edmics-rlc": "rlc",
        "vnd.ms-modi": "mdi",
        "vnd.ms-photo": "wdp",
        "vnd.net-fpx": "npx",
        "vnd.xiff": "xif",
        "webp": "webp",
        "x-3ds": "3ds",
        "x-cmx": "cmx",
        "x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"],
        "x-pict": ["pic", "pct"],
        "x-tga": "tga",
        "cis-cod": "cod",
        "pipeg": "jfif"
      },
      "message": {
        "rfc822": ["eml", "mime", "mht", "mhtml", "nws"]
      },
      "model": {
        "iges": ["igs", "iges"],
        "mesh": ["msh", "mesh", "silo"],
        "vrml": ["wrl", "vrml"],
        "x3d+vrml": ["x3dv", "x3dvz"],
        "x3d+xml": ["x3d", "x3dz"],
        "x3d+binary": ["x3db", "x3dbz"],
        "vnd.collada+xml": "dae",
        "vnd.dwf": "dwf",
        "vnd.gdl": "gdl",
        "vnd.gtw": "gtw",
        "vnd.mts": "mts",
        "vnd.vtu": "vtu"
      },
      "text": {
        "cache-manifest": ["manifest", "appcache"],
        "calendar": ["ics", "icz", "ifb"],
        "css": "css",
        "csv": "csv",
        "h323": "323",
        "html": ["html", "htm", "shtml", "stm"],
        "iuls": "uls",
        "mathml": "mml",
        "plain": ["txt", "text", "brf", "conf", "def", "list", "log", "in", "bas"],
        "richtext": "rtx",
        "scriptlet": ["sct", "wsc"],
        "texmacs": ["tm", "ts"],
        "tab-separated-values": "tsv",
        "vnd.sun.j2me.app-descriptor": "jad",
        "vnd.wap.wml": "wml",
        "vnd.wap.wmlscript": "wmls",
        "x-bibtex": "bib",
        "x-boo": "boo",
        "x-c++hdr": ["h++", "hpp", "hxx", "hh"],
        "x-c++src": ["c++", "cpp", "cxx", "cc"],
        "x-component": "htc",
        "x-dsrc": "d",
        "x-diff": ["diff", "patch"],
        "x-haskell": "hs",
        "x-java": "java",
        "x-literate-haskell": "lhs",
        "x-moc": "moc",
        "x-pascal": ["p", "pas"],
        "x-pcs-gcd": "gcd",
        "x-perl": ["pl", "pm"],
        "x-python": "py",
        "x-scala": "scala",
        "x-setext": "etx",
        "x-tcl": ["tcl", "tk"],
        "x-tex": ["tex", "ltx", "sty", "cls"],
        "x-vcalendar": "vcs",
        "x-vcard": "vcf",
        "n3": "n3",
        "prs.lines.tag": "dsc",
        "sgml": ["sgml", "sgm"],
        "troff": ["t", "tr", "roff", "man", "me", "ms"],
        "turtle": "ttl",
        "uri-list": ["uri", "uris", "urls"],
        "vcard": "vcard",
        "vnd.curl": "curl",
        "vnd.curl.dcurl": "dcurl",
        "vnd.curl.scurl": "scurl",
        "vnd.curl.mcurl": "mcurl",
        "vnd.dvb.subtitle": "sub",
        "vnd.fly": "fly",
        "vnd.fmi.flexstor": "flx",
        "vnd.graphviz": "gv",
        "vnd.in3d.3dml": "3dml",
        "vnd.in3d.spot": "spot",
        "x-asm": ["s", "asm"],
        "x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
        "x-fortran": ["f", "for", "f77", "f90"],
        "x-opml": "opml",
        "x-nfo": "nfo",
        "x-sfv": "sfv",
        "x-uuencode": "uu",
        "webviewhtml": "htt"
      },
      "video": {
        "avif": ".avif",
        "3gpp": "3gp",
        "annodex": "axv",
        "dl": "dl",
        "dv": ["dif", "dv"],
        "fli": "fli",
        "gl": "gl",
        "mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v", "mp2", "mpa", "mpv2"],
        "mp4": ["mp4", "mp4v", "mpg4"],
        "quicktime": ["qt", "mov"],
        "ogg": "ogv",
        "vnd.mpegurl": ["mxu", "m4u"],
        "x-flv": "flv",
        "x-la-asf": ["lsf", "lsx"],
        "x-mng": "mng",
        "x-ms-asf": ["asf", "asx", "asr"],
        "x-ms-wm": "wm",
        "x-ms-wmv": "wmv",
        "x-ms-wmx": "wmx",
        "x-ms-wvx": "wvx",
        "x-msvideo": "avi",
        "x-sgi-movie": "movie",
        "x-matroska": ["mpv", "mkv", "mk3d", "mks"],
        "3gpp2": "3g2",
        "h261": "h261",
        "h263": "h263",
        "h264": "h264",
        "jpeg": "jpgv",
        "jpm": ["jpm", "jpgm"],
        "mj2": ["mj2", "mjp2"],
        "vnd.dece.hd": ["uvh", "uvvh"],
        "vnd.dece.mobile": ["uvm", "uvvm"],
        "vnd.dece.pd": ["uvp", "uvvp"],
        "vnd.dece.sd": ["uvs", "uvvs"],
        "vnd.dece.video": ["uvv", "uvvv"],
        "vnd.dvb.file": "dvb",
        "vnd.fvt": "fvt",
        "vnd.ms-playready.media.pyv": "pyv",
        "vnd.uvvu.mp4": ["uvu", "uvvu"],
        "vnd.vivo": "viv",
        "webm": "webm",
        "x-f4v": "f4v",
        "x-m4v": "m4v",
        "x-ms-vob": "vob",
        "x-smv": "smv"
      },
      "x-conference": {
        "x-cooltalk": "ice"
      },
      "x-world": {
        "x-vrml": ["vrm", "vrml", "wrl", "flr", "wrz", "xaf", "xof"]
      }
    };
    mimeTypes = (() => {
      const mimeTypes2 = {};
      for (const type in table) {
        if (table.hasOwnProperty(type)) {
          for (const subtype in table[type]) {
            if (table[type].hasOwnProperty(subtype)) {
              const value = table[type][subtype];
              if (typeof value == "string") {
                mimeTypes2[value] = type + "/" + subtype;
              } else {
                for (let indexMimeType = 0; indexMimeType < value.length; indexMimeType++) {
                  mimeTypes2[value[indexMimeType]] = type + "/" + subtype;
                }
              }
            }
          }
        }
      }
      return mimeTypes2;
    })();
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/codecs/crc32.js
var table2, Crc32;
var init_crc32 = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/codecs/crc32.js"() {
    table2 = [];
    for (let i2 = 0; i2 < 256; i2++) {
      let t2 = i2;
      for (let j2 = 0; j2 < 8; j2++) {
        if (t2 & 1) {
          t2 = t2 >>> 1 ^ 3988292384;
        } else {
          t2 = t2 >>> 1;
        }
      }
      table2[i2] = t2;
    }
    Crc32 = class {
      constructor(crc) {
        this.crc = crc || -1;
      }
      append(data2) {
        let crc = this.crc | 0;
        for (let offset = 0, length = data2.length | 0; offset < length; offset++) {
          crc = crc >>> 8 ^ table2[(crc ^ data2[offset]) & 255];
        }
        this.crc = crc;
      }
      get() {
        return ~this.crc;
      }
    };
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/crc32-stream.js
var Crc32Stream;
var init_crc32_stream = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/crc32-stream.js"() {
    init_crc32();
    Crc32Stream = class extends TransformStream {
      constructor() {
        const crc323 = new Crc32();
        super({
          transform(chunk) {
            crc323.append(chunk);
          },
          flush(controller) {
            const value = new Uint8Array(4);
            const dataView = new DataView(value.buffer);
            dataView.setUint32(0, crc323.get());
            controller.enqueue(value);
          }
        });
      }
    };
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/util/encode-text.js
function encodeText(value) {
  if (typeof TextEncoder == "undefined") {
    value = unescape(encodeURIComponent(value));
    const result = new Uint8Array(value.length);
    for (let i2 = 0; i2 < result.length; i2++) {
      result[i2] = value.charCodeAt(i2);
    }
    return result;
  } else {
    return new TextEncoder().encode(value);
  }
}
var init_encode_text = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/util/encode-text.js"() {
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/codecs/sjcl.js
var bitArray, codec, hash, cipher, random, mode, misc;
var init_sjcl = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/codecs/sjcl.js"() {
    bitArray = {
      /**
       * Concatenate two bit arrays.
       * @param {bitArray} a1 The first array.
       * @param {bitArray} a2 The second array.
       * @return {bitArray} The concatenation of a1 and a2.
       */
      concat(a1, a2) {
        if (a1.length === 0 || a2.length === 0) {
          return a1.concat(a2);
        }
        const last = a1[a1.length - 1], shift = bitArray.getPartial(last);
        if (shift === 32) {
          return a1.concat(a2);
        } else {
          return bitArray._shiftRight(a2, shift, last | 0, a1.slice(0, a1.length - 1));
        }
      },
      /**
       * Find the length of an array of bits.
       * @param {bitArray} a The array.
       * @return {Number} The length of a, in bits.
       */
      bitLength(a2) {
        const l2 = a2.length;
        if (l2 === 0) {
          return 0;
        }
        const x2 = a2[l2 - 1];
        return (l2 - 1) * 32 + bitArray.getPartial(x2);
      },
      /**
       * Truncate an array.
       * @param {bitArray} a The array.
       * @param {Number} len The length to truncate to, in bits.
       * @return {bitArray} A new array, truncated to len bits.
       */
      clamp(a2, len) {
        if (a2.length * 32 < len) {
          return a2;
        }
        a2 = a2.slice(0, Math.ceil(len / 32));
        const l2 = a2.length;
        len = len & 31;
        if (l2 > 0 && len) {
          a2[l2 - 1] = bitArray.partial(len, a2[l2 - 1] & 2147483648 >> len - 1, 1);
        }
        return a2;
      },
      /**
       * Make a partial word for a bit array.
       * @param {Number} len The number of bits in the word.
       * @param {Number} x The bits.
       * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.
       * @return {Number} The partial word.
       */
      partial(len, x2, _end) {
        if (len === 32) {
          return x2;
        }
        return (_end ? x2 | 0 : x2 << 32 - len) + len * 1099511627776;
      },
      /**
       * Get the number of bits used by a partial word.
       * @param {Number} x The partial word.
       * @return {Number} The number of bits used by the partial word.
       */
      getPartial(x2) {
        return Math.round(x2 / 1099511627776) || 32;
      },
      /** Shift an array right.
       * @param {bitArray} a The array to shift.
       * @param {Number} shift The number of bits to shift.
       * @param {Number} [carry=0] A byte to carry in
       * @param {bitArray} [out=[]] An array to prepend to the output.
       * @private
       */
      _shiftRight(a2, shift, carry, out) {
        if (out === void 0) {
          out = [];
        }
        for (; shift >= 32; shift -= 32) {
          out.push(carry);
          carry = 0;
        }
        if (shift === 0) {
          return out.concat(a2);
        }
        for (let i2 = 0; i2 < a2.length; i2++) {
          out.push(carry | a2[i2] >>> shift);
          carry = a2[i2] << 32 - shift;
        }
        const last2 = a2.length ? a2[a2.length - 1] : 0;
        const shift2 = bitArray.getPartial(last2);
        out.push(bitArray.partial(shift + shift2 & 31, shift + shift2 > 32 ? carry : out.pop(), 1));
        return out;
      }
    };
    codec = {
      bytes: {
        /** Convert from a bitArray to an array of bytes. */
        fromBits(arr) {
          const bl = bitArray.bitLength(arr);
          const byteLength = bl / 8;
          const out = new Uint8Array(byteLength);
          let tmp;
          for (let i2 = 0; i2 < byteLength; i2++) {
            if ((i2 & 3) === 0) {
              tmp = arr[i2 / 4];
            }
            out[i2] = tmp >>> 24;
            tmp <<= 8;
          }
          return out;
        },
        /** Convert from an array of bytes to a bitArray. */
        toBits(bytes) {
          const out = [];
          let i2;
          let tmp = 0;
          for (i2 = 0; i2 < bytes.length; i2++) {
            tmp = tmp << 8 | bytes[i2];
            if ((i2 & 3) === 3) {
              out.push(tmp);
              tmp = 0;
            }
          }
          if (i2 & 3) {
            out.push(bitArray.partial(8 * (i2 & 3), tmp));
          }
          return out;
        }
      }
    };
    hash = {};
    hash.sha1 = class {
      constructor(hash2) {
        const sha1 = this;
        sha1.blockSize = 512;
        sha1._init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        sha1._key = [1518500249, 1859775393, 2400959708, 3395469782];
        if (hash2) {
          sha1._h = hash2._h.slice(0);
          sha1._buffer = hash2._buffer.slice(0);
          sha1._length = hash2._length;
        } else {
          sha1.reset();
        }
      }
      /**
       * Reset the hash state.
       * @return this
       */
      reset() {
        const sha1 = this;
        sha1._h = sha1._init.slice(0);
        sha1._buffer = [];
        sha1._length = 0;
        return sha1;
      }
      /**
       * Input several words to the hash.
       * @param {bitArray|String} data the data to hash.
       * @return this
       */
      update(data2) {
        const sha1 = this;
        if (typeof data2 === "string") {
          data2 = codec.utf8String.toBits(data2);
        }
        const b2 = sha1._buffer = bitArray.concat(sha1._buffer, data2);
        const ol = sha1._length;
        const nl = sha1._length = ol + bitArray.bitLength(data2);
        if (nl > 9007199254740991) {
          throw new Error("Cannot hash more than 2^53 - 1 bits");
        }
        const c2 = new Uint32Array(b2);
        let j2 = 0;
        for (let i2 = sha1.blockSize + ol - (sha1.blockSize + ol & sha1.blockSize - 1); i2 <= nl; i2 += sha1.blockSize) {
          sha1._block(c2.subarray(16 * j2, 16 * (j2 + 1)));
          j2 += 1;
        }
        b2.splice(0, 16 * j2);
        return sha1;
      }
      /**
       * Complete hashing and output the hash value.
       * @return {bitArray} The hash value, an array of 5 big-endian words. TODO
       */
      finalize() {
        const sha1 = this;
        let b2 = sha1._buffer;
        const h2 = sha1._h;
        b2 = bitArray.concat(b2, [bitArray.partial(1, 1)]);
        for (let i2 = b2.length + 2; i2 & 15; i2++) {
          b2.push(0);
        }
        b2.push(Math.floor(sha1._length / 4294967296));
        b2.push(sha1._length | 0);
        while (b2.length) {
          sha1._block(b2.splice(0, 16));
        }
        sha1.reset();
        return h2;
      }
      /**
       * The SHA-1 logical functions f(0), f(1), ..., f(79).
       * @private
       */
      _f(t2, b2, c2, d2) {
        if (t2 <= 19) {
          return b2 & c2 | ~b2 & d2;
        } else if (t2 <= 39) {
          return b2 ^ c2 ^ d2;
        } else if (t2 <= 59) {
          return b2 & c2 | b2 & d2 | c2 & d2;
        } else if (t2 <= 79) {
          return b2 ^ c2 ^ d2;
        }
      }
      /**
       * Circular left-shift operator.
       * @private
       */
      _S(n2, x2) {
        return x2 << n2 | x2 >>> 32 - n2;
      }
      /**
       * Perform one cycle of SHA-1.
       * @param {Uint32Array|bitArray} words one block of words.
       * @private
       */
      _block(words) {
        const sha1 = this;
        const h2 = sha1._h;
        const w2 = Array(80);
        for (let j2 = 0; j2 < 16; j2++) {
          w2[j2] = words[j2];
        }
        let a2 = h2[0];
        let b2 = h2[1];
        let c2 = h2[2];
        let d2 = h2[3];
        let e3 = h2[4];
        for (let t2 = 0; t2 <= 79; t2++) {
          if (t2 >= 16) {
            w2[t2] = sha1._S(1, w2[t2 - 3] ^ w2[t2 - 8] ^ w2[t2 - 14] ^ w2[t2 - 16]);
          }
          const tmp = sha1._S(5, a2) + sha1._f(t2, b2, c2, d2) + e3 + w2[t2] + sha1._key[Math.floor(t2 / 20)] | 0;
          e3 = d2;
          d2 = c2;
          c2 = sha1._S(30, b2);
          b2 = a2;
          a2 = tmp;
        }
        h2[0] = h2[0] + a2 | 0;
        h2[1] = h2[1] + b2 | 0;
        h2[2] = h2[2] + c2 | 0;
        h2[3] = h2[3] + d2 | 0;
        h2[4] = h2[4] + e3 | 0;
      }
    };
    cipher = {};
    cipher.aes = class {
      constructor(key) {
        const aes = this;
        aes._tables = [[[], [], [], [], []], [[], [], [], [], []]];
        if (!aes._tables[0][0][0]) {
          aes._precompute();
        }
        const sbox = aes._tables[0][4];
        const decTable = aes._tables[1];
        const keyLen = key.length;
        let i2, encKey, decKey, rcon = 1;
        if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
          throw new Error("invalid aes key size");
        }
        aes._key = [encKey = key.slice(0), decKey = []];
        for (i2 = keyLen; i2 < 4 * keyLen + 28; i2++) {
          let tmp = encKey[i2 - 1];
          if (i2 % keyLen === 0 || keyLen === 8 && i2 % keyLen === 4) {
            tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
            if (i2 % keyLen === 0) {
              tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
              rcon = rcon << 1 ^ (rcon >> 7) * 283;
            }
          }
          encKey[i2] = encKey[i2 - keyLen] ^ tmp;
        }
        for (let j2 = 0; i2; j2++, i2--) {
          const tmp = encKey[j2 & 3 ? i2 : i2 - 4];
          if (i2 <= 4 || j2 < 4) {
            decKey[j2] = tmp;
          } else {
            decKey[j2] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
          }
        }
      }
      // public
      /* Something like this might appear here eventually
      name: "AES",
      blockSize: 4,
      keySizes: [4,6,8],
      */
      /**
       * Encrypt an array of 4 big-endian words.
       * @param {Array} data The plaintext.
       * @return {Array} The ciphertext.
       */
      encrypt(data2) {
        return this._crypt(data2, 0);
      }
      /**
       * Decrypt an array of 4 big-endian words.
       * @param {Array} data The ciphertext.
       * @return {Array} The plaintext.
       */
      decrypt(data2) {
        return this._crypt(data2, 1);
      }
      /**
       * Expand the S-box tables.
       *
       * @private
       */
      _precompute() {
        const encTable = this._tables[0];
        const decTable = this._tables[1];
        const sbox = encTable[4];
        const sboxInv = decTable[4];
        const d2 = [];
        const th = [];
        let xInv, x2, x4, x8;
        for (let i2 = 0; i2 < 256; i2++) {
          th[(d2[i2] = i2 << 1 ^ (i2 >> 7) * 283) ^ i2] = i2;
        }
        for (let x3 = xInv = 0; !sbox[x3]; x3 ^= x2 || 1, xInv = th[xInv] || 1) {
          let s2 = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
          s2 = s2 >> 8 ^ s2 & 255 ^ 99;
          sbox[x3] = s2;
          sboxInv[s2] = x3;
          x8 = d2[x4 = d2[x2 = d2[x3]]];
          let tDec = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x3 * 16843008;
          let tEnc = d2[s2] * 257 ^ s2 * 16843008;
          for (let i2 = 0; i2 < 4; i2++) {
            encTable[i2][x3] = tEnc = tEnc << 24 ^ tEnc >>> 8;
            decTable[i2][s2] = tDec = tDec << 24 ^ tDec >>> 8;
          }
        }
        for (let i2 = 0; i2 < 5; i2++) {
          encTable[i2] = encTable[i2].slice(0);
          decTable[i2] = decTable[i2].slice(0);
        }
      }
      /**
       * Encryption and decryption core.
       * @param {Array} input Four words to be encrypted or decrypted.
       * @param dir The direction, 0 for encrypt and 1 for decrypt.
       * @return {Array} The four encrypted or decrypted words.
       * @private
       */
      _crypt(input, dir) {
        if (input.length !== 4) {
          throw new Error("invalid aes block size");
        }
        const key = this._key[dir];
        const nInnerRounds = key.length / 4 - 2;
        const out = [0, 0, 0, 0];
        const table3 = this._tables[dir];
        const t0 = table3[0];
        const t1 = table3[1];
        const t2 = table3[2];
        const t3 = table3[3];
        const sbox = table3[4];
        let a2 = input[0] ^ key[0];
        let b2 = input[dir ? 3 : 1] ^ key[1];
        let c2 = input[2] ^ key[2];
        let d2 = input[dir ? 1 : 3] ^ key[3];
        let kIndex = 4;
        let a22, b22, c22;
        for (let i2 = 0; i2 < nInnerRounds; i2++) {
          a22 = t0[a2 >>> 24] ^ t1[b2 >> 16 & 255] ^ t2[c2 >> 8 & 255] ^ t3[d2 & 255] ^ key[kIndex];
          b22 = t0[b2 >>> 24] ^ t1[c2 >> 16 & 255] ^ t2[d2 >> 8 & 255] ^ t3[a2 & 255] ^ key[kIndex + 1];
          c22 = t0[c2 >>> 24] ^ t1[d2 >> 16 & 255] ^ t2[a2 >> 8 & 255] ^ t3[b2 & 255] ^ key[kIndex + 2];
          d2 = t0[d2 >>> 24] ^ t1[a2 >> 16 & 255] ^ t2[b2 >> 8 & 255] ^ t3[c2 & 255] ^ key[kIndex + 3];
          kIndex += 4;
          a2 = a22;
          b2 = b22;
          c2 = c22;
        }
        for (let i2 = 0; i2 < 4; i2++) {
          out[dir ? 3 & -i2 : i2] = sbox[a2 >>> 24] << 24 ^ sbox[b2 >> 16 & 255] << 16 ^ sbox[c2 >> 8 & 255] << 8 ^ sbox[d2 & 255] ^ key[kIndex++];
          a22 = a2;
          a2 = b2;
          b2 = c2;
          c2 = d2;
          d2 = a22;
        }
        return out;
      }
    };
    random = {
      /** 
       * Generate random words with pure js, cryptographically not as strong & safe as native implementation.
       * @param {TypedArray} typedArray The array to fill.
       * @return {TypedArray} The random values.
       */
      getRandomValues(typedArray) {
        const words = new Uint32Array(typedArray.buffer);
        const r2 = (m_w) => {
          let m_z = 987654321;
          const mask = 4294967295;
          return function() {
            m_z = 36969 * (m_z & 65535) + (m_z >> 16) & mask;
            m_w = 18e3 * (m_w & 65535) + (m_w >> 16) & mask;
            const result = ((m_z << 16) + m_w & mask) / 4294967296 + 0.5;
            return result * (Math.random() > 0.5 ? 1 : -1);
          };
        };
        for (let i2 = 0, rcache; i2 < typedArray.length; i2 += 4) {
          const _r2 = r2((rcache || Math.random()) * 4294967296);
          rcache = _r2() * 987654071;
          words[i2 / 4] = _r2() * 4294967296 | 0;
        }
        return typedArray;
      }
    };
    mode = {};
    mode.ctrGladman = class {
      constructor(prf, iv) {
        this._prf = prf;
        this._initIv = iv;
        this._iv = iv;
      }
      reset() {
        this._iv = this._initIv;
      }
      /** Input some data to calculate.
       * @param {bitArray} data the data to process, it must be intergral multiple of 128 bits unless it's the last.
       */
      update(data2) {
        return this.calculate(this._prf, data2, this._iv);
      }
      incWord(word) {
        if ((word >> 24 & 255) === 255) {
          let b1 = word >> 16 & 255;
          let b2 = word >> 8 & 255;
          let b3 = word & 255;
          if (b1 === 255) {
            b1 = 0;
            if (b2 === 255) {
              b2 = 0;
              if (b3 === 255) {
                b3 = 0;
              } else {
                ++b3;
              }
            } else {
              ++b2;
            }
          } else {
            ++b1;
          }
          word = 0;
          word += b1 << 16;
          word += b2 << 8;
          word += b3;
        } else {
          word += 1 << 24;
        }
        return word;
      }
      incCounter(counter) {
        if ((counter[0] = this.incWord(counter[0])) === 0) {
          counter[1] = this.incWord(counter[1]);
        }
      }
      calculate(prf, data2, iv) {
        let l2;
        if (!(l2 = data2.length)) {
          return [];
        }
        const bl = bitArray.bitLength(data2);
        for (let i2 = 0; i2 < l2; i2 += 4) {
          this.incCounter(iv);
          const e3 = prf.encrypt(iv);
          data2[i2] ^= e3[0];
          data2[i2 + 1] ^= e3[1];
          data2[i2 + 2] ^= e3[2];
          data2[i2 + 3] ^= e3[3];
        }
        return bitArray.clamp(data2, bl);
      }
    };
    misc = {
      importKey(password) {
        return new misc.hmacSha1(codec.bytes.toBits(password));
      },
      pbkdf2(prf, salt, count, length) {
        count = count || 1e4;
        if (length < 0 || count < 0) {
          throw new Error("invalid params to pbkdf2");
        }
        const byteLength = (length >> 5) + 1 << 2;
        let u2, ui, i2, j2, k2;
        const arrayBuffer = new ArrayBuffer(byteLength);
        const out = new DataView(arrayBuffer);
        let outLength = 0;
        const b2 = bitArray;
        salt = codec.bytes.toBits(salt);
        for (k2 = 1; outLength < (byteLength || 1); k2++) {
          u2 = ui = prf.encrypt(b2.concat(salt, [k2]));
          for (i2 = 1; i2 < count; i2++) {
            ui = prf.encrypt(ui);
            for (j2 = 0; j2 < ui.length; j2++) {
              u2[j2] ^= ui[j2];
            }
          }
          for (i2 = 0; outLength < (byteLength || 1) && i2 < u2.length; i2++) {
            out.setInt32(outLength, u2[i2]);
            outLength += 4;
          }
        }
        return arrayBuffer.slice(0, length / 8);
      }
    };
    misc.hmacSha1 = class {
      constructor(key) {
        const hmac = this;
        const Hash = hmac._hash = hash.sha1;
        const exKey = [[], []];
        hmac._baseHash = [new Hash(), new Hash()];
        const bs = hmac._baseHash[0].blockSize / 32;
        if (key.length > bs) {
          key = new Hash().update(key).finalize();
        }
        for (let i2 = 0; i2 < bs; i2++) {
          exKey[0][i2] = key[i2] ^ 909522486;
          exKey[1][i2] = key[i2] ^ 1549556828;
        }
        hmac._baseHash[0].update(exKey[0]);
        hmac._baseHash[1].update(exKey[1]);
        hmac._resultHash = new Hash(hmac._baseHash[0]);
      }
      reset() {
        const hmac = this;
        hmac._resultHash = new hmac._hash(hmac._baseHash[0]);
        hmac._updated = false;
      }
      update(data2) {
        const hmac = this;
        hmac._updated = true;
        hmac._resultHash.update(data2);
      }
      digest() {
        const hmac = this;
        const w2 = hmac._resultHash.finalize();
        const result = new hmac._hash(hmac._baseHash[1]).update(w2).finalize();
        hmac.reset();
        return result;
      }
      encrypt(data2) {
        if (!this._updated) {
          this.update(data2);
          return this.digest(data2);
        } else {
          throw new Error("encrypt on already updated hmac called!");
        }
      }
    };
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/common-crypto.js
function getRandomValues(array) {
  if (GET_RANDOM_VALUES_SUPPORTED) {
    return crypto.getRandomValues(array);
  } else {
    return random.getRandomValues(array);
  }
}
var GET_RANDOM_VALUES_SUPPORTED, ERR_INVALID_PASSWORD, ERR_INVALID_SIGNATURE, ERR_ABORT_CHECK_PASSWORD;
var init_common_crypto = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/common-crypto.js"() {
    init_sjcl();
    GET_RANDOM_VALUES_SUPPORTED = typeof crypto != "undefined" && typeof crypto.getRandomValues == "function";
    ERR_INVALID_PASSWORD = "Invalid password";
    ERR_INVALID_SIGNATURE = "Invalid signature";
    ERR_ABORT_CHECK_PASSWORD = "zipjs-abort-check-password";
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/aes-crypto-stream.js
function append(aesCrypto, input, output, paddingStart, paddingEnd, verifySignature) {
  const {
    ctr,
    hmac,
    pending
  } = aesCrypto;
  const inputLength = input.length - paddingEnd;
  if (pending.length) {
    input = concat(pending, input);
    output = expand(output, inputLength - inputLength % BLOCK_LENGTH);
  }
  let offset;
  for (offset = 0; offset <= inputLength - BLOCK_LENGTH; offset += BLOCK_LENGTH) {
    const inputChunk = toBits(codecBytes, subarray(input, offset, offset + BLOCK_LENGTH));
    if (verifySignature) {
      hmac.update(inputChunk);
    }
    const outputChunk = ctr.update(inputChunk);
    if (!verifySignature) {
      hmac.update(outputChunk);
    }
    output.set(fromBits(codecBytes, outputChunk), offset + paddingStart);
  }
  aesCrypto.pending = subarray(input, offset);
  return output;
}
async function createDecryptionKeys(decrypt2, strength, password, preamble) {
  const passwordVerificationKey = await createKeys(decrypt2, strength, password, subarray(preamble, 0, SALT_LENGTH[strength]));
  const passwordVerification = subarray(preamble, SALT_LENGTH[strength]);
  if (passwordVerificationKey[0] != passwordVerification[0] || passwordVerificationKey[1] != passwordVerification[1]) {
    throw new Error(ERR_INVALID_PASSWORD);
  }
}
async function createEncryptionKeys(encrypt2, strength, password) {
  const salt = getRandomValues(new Uint8Array(SALT_LENGTH[strength]));
  const passwordVerification = await createKeys(encrypt2, strength, password, salt);
  return concat(salt, passwordVerification);
}
async function createKeys(aesCrypto, strength, password, salt) {
  aesCrypto.password = null;
  const encodedPassword = encodeText(password);
  const baseKey = await importKey(RAW_FORMAT, encodedPassword, BASE_KEY_ALGORITHM, false, DERIVED_BITS_USAGE);
  const derivedBits = await deriveBits(Object.assign({ salt }, DERIVED_BITS_ALGORITHM), baseKey, 8 * (KEY_LENGTH[strength] * 2 + 2));
  const compositeKey = new Uint8Array(derivedBits);
  const key = toBits(codecBytes, subarray(compositeKey, 0, KEY_LENGTH[strength]));
  const authentication = toBits(codecBytes, subarray(compositeKey, KEY_LENGTH[strength], KEY_LENGTH[strength] * 2));
  const passwordVerification = subarray(compositeKey, KEY_LENGTH[strength] * 2);
  Object.assign(aesCrypto, {
    keys: {
      key,
      authentication,
      passwordVerification
    },
    ctr: new CtrGladman(new Aes(key), Array.from(COUNTER_DEFAULT_VALUE)),
    hmac: new HmacSha1(authentication)
  });
  return passwordVerification;
}
async function importKey(format, password, algorithm, extractable, keyUsages) {
  if (IMPORT_KEY_SUPPORTED) {
    try {
      return await subtle.importKey(format, password, algorithm, extractable, keyUsages);
    } catch (_error) {
      IMPORT_KEY_SUPPORTED = false;
      return misc.importKey(password);
    }
  } else {
    return misc.importKey(password);
  }
}
async function deriveBits(algorithm, baseKey, length) {
  if (DERIVE_BITS_SUPPORTED) {
    try {
      return await subtle.deriveBits(algorithm, baseKey, length);
    } catch (_error) {
      DERIVE_BITS_SUPPORTED = false;
      return misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);
    }
  } else {
    return misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);
  }
}
function concat(leftArray, rightArray) {
  let array = leftArray;
  if (leftArray.length + rightArray.length) {
    array = new Uint8Array(leftArray.length + rightArray.length);
    array.set(leftArray, 0);
    array.set(rightArray, leftArray.length);
  }
  return array;
}
function expand(inputArray, length) {
  if (length && length > inputArray.length) {
    const array = inputArray;
    inputArray = new Uint8Array(length);
    inputArray.set(array, 0);
  }
  return inputArray;
}
function subarray(array, begin, end) {
  return array.subarray(begin, end);
}
function fromBits(codecBytes2, chunk) {
  return codecBytes2.fromBits(chunk);
}
function toBits(codecBytes2, chunk) {
  return codecBytes2.toBits(chunk);
}
var BLOCK_LENGTH, RAW_FORMAT, PBKDF2_ALGORITHM, HASH_ALGORITHM, HASH_FUNCTION, BASE_KEY_ALGORITHM, DERIVED_BITS_ALGORITHM, DERIVED_BITS_USAGE, SALT_LENGTH, KEY_LENGTH, SIGNATURE_LENGTH, COUNTER_DEFAULT_VALUE, UNDEFINED_TYPE2, FUNCTION_TYPE2, CRYPTO_API_SUPPORTED, subtle, SUBTLE_API_SUPPORTED, codecBytes, Aes, CtrGladman, HmacSha1, IMPORT_KEY_SUPPORTED, DERIVE_BITS_SUPPORTED, AESDecryptionStream, AESEncryptionStream;
var init_aes_crypto_stream = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/aes-crypto-stream.js"() {
    init_encode_text();
    init_sjcl();
    init_common_crypto();
    BLOCK_LENGTH = 16;
    RAW_FORMAT = "raw";
    PBKDF2_ALGORITHM = { name: "PBKDF2" };
    HASH_ALGORITHM = { name: "HMAC" };
    HASH_FUNCTION = "SHA-1";
    BASE_KEY_ALGORITHM = Object.assign({ hash: HASH_ALGORITHM }, PBKDF2_ALGORITHM);
    DERIVED_BITS_ALGORITHM = Object.assign({ iterations: 1e3, hash: { name: HASH_FUNCTION } }, PBKDF2_ALGORITHM);
    DERIVED_BITS_USAGE = ["deriveBits"];
    SALT_LENGTH = [8, 12, 16];
    KEY_LENGTH = [16, 24, 32];
    SIGNATURE_LENGTH = 10;
    COUNTER_DEFAULT_VALUE = [0, 0, 0, 0];
    UNDEFINED_TYPE2 = "undefined";
    FUNCTION_TYPE2 = "function";
    CRYPTO_API_SUPPORTED = typeof crypto != UNDEFINED_TYPE2;
    subtle = CRYPTO_API_SUPPORTED && crypto.subtle;
    SUBTLE_API_SUPPORTED = CRYPTO_API_SUPPORTED && typeof subtle != UNDEFINED_TYPE2;
    codecBytes = codec.bytes;
    Aes = cipher.aes;
    CtrGladman = mode.ctrGladman;
    HmacSha1 = misc.hmacSha1;
    IMPORT_KEY_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.importKey == FUNCTION_TYPE2;
    DERIVE_BITS_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.deriveBits == FUNCTION_TYPE2;
    AESDecryptionStream = class extends TransformStream {
      constructor({ password, signed, encryptionStrength, checkPasswordOnly }) {
        super({
          start() {
            Object.assign(this, {
              ready: new Promise((resolve) => this.resolveReady = resolve),
              password,
              signed,
              strength: encryptionStrength - 1,
              pending: new Uint8Array()
            });
          },
          async transform(chunk, controller) {
            const aesCrypto = this;
            const {
              password: password2,
              strength,
              resolveReady,
              ready
            } = aesCrypto;
            if (password2) {
              await createDecryptionKeys(aesCrypto, strength, password2, subarray(chunk, 0, SALT_LENGTH[strength] + 2));
              chunk = subarray(chunk, SALT_LENGTH[strength] + 2);
              if (checkPasswordOnly) {
                controller.error(new Error(ERR_ABORT_CHECK_PASSWORD));
              } else {
                resolveReady();
              }
            } else {
              await ready;
            }
            const output = new Uint8Array(chunk.length - SIGNATURE_LENGTH - (chunk.length - SIGNATURE_LENGTH) % BLOCK_LENGTH);
            controller.enqueue(append(aesCrypto, chunk, output, 0, SIGNATURE_LENGTH, true));
          },
          async flush(controller) {
            const {
              signed: signed2,
              ctr,
              hmac,
              pending,
              ready
            } = this;
            await ready;
            const chunkToDecrypt = subarray(pending, 0, pending.length - SIGNATURE_LENGTH);
            const originalSignature = subarray(pending, pending.length - SIGNATURE_LENGTH);
            let decryptedChunkArray = new Uint8Array();
            if (chunkToDecrypt.length) {
              const encryptedChunk = toBits(codecBytes, chunkToDecrypt);
              hmac.update(encryptedChunk);
              const decryptedChunk = ctr.update(encryptedChunk);
              decryptedChunkArray = fromBits(codecBytes, decryptedChunk);
            }
            if (signed2) {
              const signature = subarray(fromBits(codecBytes, hmac.digest()), 0, SIGNATURE_LENGTH);
              for (let indexSignature = 0; indexSignature < SIGNATURE_LENGTH; indexSignature++) {
                if (signature[indexSignature] != originalSignature[indexSignature]) {
                  throw new Error(ERR_INVALID_SIGNATURE);
                }
              }
            }
            controller.enqueue(decryptedChunkArray);
          }
        });
      }
    };
    AESEncryptionStream = class extends TransformStream {
      constructor({ password, encryptionStrength }) {
        let stream;
        super({
          start() {
            Object.assign(this, {
              ready: new Promise((resolve) => this.resolveReady = resolve),
              password,
              strength: encryptionStrength - 1,
              pending: new Uint8Array()
            });
          },
          async transform(chunk, controller) {
            const aesCrypto = this;
            const {
              password: password2,
              strength,
              resolveReady,
              ready
            } = aesCrypto;
            let preamble = new Uint8Array();
            if (password2) {
              preamble = await createEncryptionKeys(aesCrypto, strength, password2);
              resolveReady();
            } else {
              await ready;
            }
            const output = new Uint8Array(preamble.length + chunk.length - chunk.length % BLOCK_LENGTH);
            output.set(preamble, 0);
            controller.enqueue(append(aesCrypto, chunk, output, preamble.length, 0));
          },
          async flush(controller) {
            const {
              ctr,
              hmac,
              pending,
              ready
            } = this;
            await ready;
            let encryptedChunkArray = new Uint8Array();
            if (pending.length) {
              const encryptedChunk = ctr.update(toBits(codecBytes, pending));
              hmac.update(encryptedChunk);
              encryptedChunkArray = fromBits(codecBytes, encryptedChunk);
            }
            stream.signature = fromBits(codecBytes, hmac.digest()).slice(0, SIGNATURE_LENGTH);
            controller.enqueue(concat(encryptedChunkArray, stream.signature));
          }
        });
        stream = this;
      }
    };
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/zip-crypto-stream.js
function decrypt(target, input) {
  const output = new Uint8Array(input.length);
  for (let index = 0; index < input.length; index++) {
    output[index] = getByte(target) ^ input[index];
    updateKeys(target, output[index]);
  }
  return output;
}
function encrypt(target, input) {
  const output = new Uint8Array(input.length);
  for (let index = 0; index < input.length; index++) {
    output[index] = getByte(target) ^ input[index];
    updateKeys(target, input[index]);
  }
  return output;
}
function createKeys2(target, password) {
  const keys = [305419896, 591751049, 878082192];
  Object.assign(target, {
    keys,
    crcKey0: new Crc32(keys[0]),
    crcKey2: new Crc32(keys[2])
  });
  for (let index = 0; index < password.length; index++) {
    updateKeys(target, password.charCodeAt(index));
  }
}
function updateKeys(target, byte) {
  let [key0, key1, key2] = target.keys;
  target.crcKey0.append([byte]);
  key0 = ~target.crcKey0.get();
  key1 = getInt32(Math.imul(getInt32(key1 + getInt8(key0)), 134775813) + 1);
  target.crcKey2.append([key1 >>> 24]);
  key2 = ~target.crcKey2.get();
  target.keys = [key0, key1, key2];
}
function getByte(target) {
  const temp = target.keys[2] | 2;
  return getInt8(Math.imul(temp, temp ^ 1) >>> 8);
}
function getInt8(number) {
  return number & 255;
}
function getInt32(number) {
  return number & 4294967295;
}
var HEADER_LENGTH, ZipCryptoDecryptionStream, ZipCryptoEncryptionStream;
var init_zip_crypto_stream = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/zip-crypto-stream.js"() {
    init_crc32();
    init_common_crypto();
    HEADER_LENGTH = 12;
    ZipCryptoDecryptionStream = class extends TransformStream {
      constructor({ password, passwordVerification, checkPasswordOnly }) {
        super({
          start() {
            Object.assign(this, {
              password,
              passwordVerification
            });
            createKeys2(this, password);
          },
          transform(chunk, controller) {
            const zipCrypto = this;
            if (zipCrypto.password) {
              const decryptedHeader = decrypt(zipCrypto, chunk.subarray(0, HEADER_LENGTH));
              zipCrypto.password = null;
              if (decryptedHeader[HEADER_LENGTH - 1] != zipCrypto.passwordVerification) {
                throw new Error(ERR_INVALID_PASSWORD);
              }
              chunk = chunk.subarray(HEADER_LENGTH);
            }
            if (checkPasswordOnly) {
              controller.error(new Error(ERR_ABORT_CHECK_PASSWORD));
            } else {
              controller.enqueue(decrypt(zipCrypto, chunk));
            }
          }
        });
      }
    };
    ZipCryptoEncryptionStream = class extends TransformStream {
      constructor({ password, passwordVerification }) {
        super({
          start() {
            Object.assign(this, {
              password,
              passwordVerification
            });
            createKeys2(this, password);
          },
          transform(chunk, controller) {
            const zipCrypto = this;
            let output;
            let offset;
            if (zipCrypto.password) {
              zipCrypto.password = null;
              const header = getRandomValues(new Uint8Array(HEADER_LENGTH));
              header[HEADER_LENGTH - 1] = zipCrypto.passwordVerification;
              output = new Uint8Array(chunk.length + header.length);
              output.set(encrypt(zipCrypto, header), 0);
              offset = HEADER_LENGTH;
            } else {
              output = new Uint8Array(chunk.length);
              offset = 0;
            }
            output.set(encrypt(zipCrypto, chunk), offset);
            controller.enqueue(output);
          }
        });
      }
    };
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/zip-entry-stream.js
function filterEmptyChunks(readable) {
  return pipeThrough(readable, new TransformStream({
    transform(chunk, controller) {
      if (chunk && chunk.length) {
        controller.enqueue(chunk);
      }
    }
  }));
}
function setReadable(stream, readable, flush) {
  readable = pipeThrough(readable, new TransformStream({ flush }));
  Object.defineProperty(stream, "readable", {
    get() {
      return readable;
    }
  });
}
function pipeThroughCommpressionStream(readable, useCompressionStream, options, CodecStreamNative, CodecStream2) {
  try {
    const CompressionStream2 = useCompressionStream && CodecStreamNative ? CodecStreamNative : CodecStream2;
    readable = pipeThrough(readable, new CompressionStream2(COMPRESSION_FORMAT, options));
  } catch (error) {
    if (useCompressionStream) {
      readable = pipeThrough(readable, new CodecStream2(COMPRESSION_FORMAT, options));
    } else {
      throw error;
    }
  }
  return readable;
}
function pipeThrough(readable, transformStream) {
  return readable.pipeThrough(transformStream);
}
var COMPRESSION_FORMAT, DeflateStream, InflateStream;
var init_zip_entry_stream = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/zip-entry-stream.js"() {
    init_crc32_stream();
    init_aes_crypto_stream();
    init_zip_crypto_stream();
    init_common_crypto();
    COMPRESSION_FORMAT = "deflate-raw";
    DeflateStream = class extends TransformStream {
      constructor(options, { chunkSize, CompressionStream: CompressionStream2, CompressionStreamNative }) {
        super({});
        const { compressed, encrypted, useCompressionStream, zipCrypto, signed, level } = options;
        const stream = this;
        let crc32Stream, encryptionStream;
        let readable = filterEmptyChunks(super.readable);
        if ((!encrypted || zipCrypto) && signed) {
          [readable, crc32Stream] = readable.tee();
          crc32Stream = pipeThrough(crc32Stream, new Crc32Stream());
        }
        if (compressed) {
          readable = pipeThroughCommpressionStream(readable, useCompressionStream, { level, chunkSize }, CompressionStreamNative, CompressionStream2);
        }
        if (encrypted) {
          if (zipCrypto) {
            readable = pipeThrough(readable, new ZipCryptoEncryptionStream(options));
          } else {
            encryptionStream = new AESEncryptionStream(options);
            readable = pipeThrough(readable, encryptionStream);
          }
        }
        setReadable(stream, readable, async () => {
          let signature;
          if (encrypted && !zipCrypto) {
            signature = encryptionStream.signature;
          }
          if ((!encrypted || zipCrypto) && signed) {
            signature = await crc32Stream.getReader().read();
            signature = new DataView(signature.value.buffer).getUint32(0);
          }
          stream.signature = signature;
        });
      }
    };
    InflateStream = class extends TransformStream {
      constructor(options, { chunkSize, DecompressionStream: DecompressionStream2, DecompressionStreamNative }) {
        super({});
        const { zipCrypto, encrypted, signed, signature, compressed, useCompressionStream } = options;
        let crc32Stream, decryptionStream;
        let readable = filterEmptyChunks(super.readable);
        if (encrypted) {
          if (zipCrypto) {
            readable = pipeThrough(readable, new ZipCryptoDecryptionStream(options));
          } else {
            decryptionStream = new AESDecryptionStream(options);
            readable = pipeThrough(readable, decryptionStream);
          }
        }
        if (compressed) {
          readable = pipeThroughCommpressionStream(readable, useCompressionStream, { chunkSize }, DecompressionStreamNative, DecompressionStream2);
        }
        if ((!encrypted || zipCrypto) && signed) {
          [readable, crc32Stream] = readable.tee();
          crc32Stream = pipeThrough(crc32Stream, new Crc32Stream());
        }
        setReadable(this, readable, async () => {
          if ((!encrypted || zipCrypto) && signed) {
            const streamSignature = await crc32Stream.getReader().read();
            const dataViewSignature = new DataView(streamSignature.value.buffer);
            if (signature != dataViewSignature.getUint32(0, false)) {
              throw new Error(ERR_INVALID_SIGNATURE);
            }
          }
        });
      }
    };
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/codec-stream.js
var MESSAGE_EVENT_TYPE, MESSAGE_START, MESSAGE_PULL, MESSAGE_DATA, MESSAGE_ACK_DATA, MESSAGE_CLOSE, CODEC_DEFLATE, CODEC_INFLATE, CodecStream;
var init_codec_stream = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/streams/codec-stream.js"() {
    init_zip_entry_stream();
    MESSAGE_EVENT_TYPE = "message";
    MESSAGE_START = "start";
    MESSAGE_PULL = "pull";
    MESSAGE_DATA = "data";
    MESSAGE_ACK_DATA = "ack";
    MESSAGE_CLOSE = "close";
    CODEC_DEFLATE = "deflate";
    CODEC_INFLATE = "inflate";
    CodecStream = class extends TransformStream {
      constructor(options, config2) {
        super({});
        const codec2 = this;
        const { codecType } = options;
        let Stream2;
        if (codecType.startsWith(CODEC_DEFLATE)) {
          Stream2 = DeflateStream;
        } else if (codecType.startsWith(CODEC_INFLATE)) {
          Stream2 = InflateStream;
        }
        let size = 0;
        const stream = new Stream2(options, config2);
        const readable = super.readable;
        const transformStream = new TransformStream({
          transform(chunk, controller) {
            if (chunk && chunk.length) {
              size += chunk.length;
              controller.enqueue(chunk);
            }
          },
          flush() {
            const { signature } = stream;
            Object.assign(codec2, {
              signature,
              size
            });
          }
        });
        Object.defineProperty(codec2, "readable", {
          get() {
            return readable.pipeThrough(stream).pipeThrough(transformStream);
          }
        });
      }
    };
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/codec-worker.js
async function callHandler(handler, ...parameters) {
  try {
    await handler(...parameters);
  } catch (_error) {
  }
}
function createWorkerInterface(workerData, config2) {
  return {
    run: () => runWorker(workerData, config2)
  };
}
function createWebWorkerInterface(workerData, { baseURL: baseURL2, chunkSize }) {
  if (!workerData.interface) {
    Object.assign(workerData, {
      worker: getWebWorker(workerData.scripts[0], baseURL2, workerData),
      interface: {
        run: () => runWebWorker(workerData, { chunkSize })
      }
    });
  }
  return workerData.interface;
}
async function runWorker({ options, readable, writable, onTaskFinished }, config2) {
  const codecStream = new CodecStream(options, config2);
  try {
    await readable.pipeThrough(codecStream).pipeTo(writable, { preventClose: true, preventAbort: true });
    const {
      signature,
      size
    } = codecStream;
    return {
      signature,
      size
    };
  } finally {
    onTaskFinished();
  }
}
async function runWebWorker(workerData, config2) {
  let resolveResult, rejectResult;
  const result = new Promise((resolve, reject) => {
    resolveResult = resolve;
    rejectResult = reject;
  });
  Object.assign(workerData, {
    reader: null,
    writer: null,
    resolveResult,
    rejectResult,
    result
  });
  const { readable, options, scripts } = workerData;
  const { writable, closed } = watchClosedStream(workerData.writable);
  const streamsTransferred = sendMessage({
    type: MESSAGE_START,
    scripts: scripts.slice(1),
    options,
    config: config2,
    readable,
    writable
  }, workerData);
  if (!streamsTransferred) {
    Object.assign(workerData, {
      reader: readable.getReader(),
      writer: writable.getWriter()
    });
  }
  const resultValue = await result;
  try {
    await writable.close();
  } catch (_error) {
  }
  await closed;
  return resultValue;
}
function watchClosedStream(writableSource) {
  const writer = writableSource.getWriter();
  let resolveStreamClosed;
  const closed = new Promise((resolve) => resolveStreamClosed = resolve);
  const writable = new WritableStream({
    async write(chunk) {
      await writer.ready;
      await writer.write(chunk);
    },
    close() {
      writer.releaseLock();
      resolveStreamClosed();
    },
    abort(reason) {
      return writer.abort(reason);
    }
  });
  return { writable, closed };
}
function getWebWorker(url, baseURL2, workerData) {
  const workerOptions = { type: "module" };
  let scriptUrl, worker;
  if (typeof url == FUNCTION_TYPE) {
    url = url();
  }
  try {
    scriptUrl = new URL(url, baseURL2);
  } catch (_error) {
    scriptUrl = url;
  }
  if (classicWorkersSupported) {
    try {
      worker = new Worker(scriptUrl);
    } catch (_error) {
      classicWorkersSupported = false;
      worker = new Worker(scriptUrl, workerOptions);
    }
  } else {
    worker = new Worker(scriptUrl, workerOptions);
  }
  worker.addEventListener(MESSAGE_EVENT_TYPE, (event) => onMessage(event, workerData));
  return worker;
}
function sendMessage(message, { worker, writer, onTaskFinished, transferStreams }) {
  try {
    let { value, readable, writable } = message;
    const transferables = [];
    if (value) {
      const { buffer, length } = value;
      if (length != buffer.byteLength) {
        value = new Uint8Array(value);
      }
      message.value = value.buffer;
      transferables.push(message.value);
    }
    if (transferStreams && transferStreamsSupported) {
      if (readable) {
        transferables.push(readable);
      }
      if (writable) {
        transferables.push(writable);
      }
    } else {
      message.readable = message.writable = null;
    }
    if (transferables.length) {
      try {
        worker.postMessage(message, transferables);
        return true;
      } catch (_error) {
        transferStreamsSupported = false;
        message.readable = message.writable = null;
        worker.postMessage(message);
      }
    } else {
      worker.postMessage(message);
    }
  } catch (error) {
    if (writer) {
      writer.releaseLock();
    }
    onTaskFinished();
    throw error;
  }
}
async function onMessage({ data: data2 }, workerData) {
  const { type, value, messageId, result, error } = data2;
  const { reader, writer, resolveResult, rejectResult, onTaskFinished } = workerData;
  try {
    if (error) {
      const { message, stack, code, name } = error;
      const responseError = new Error(message);
      Object.assign(responseError, { stack, code, name });
      close(responseError);
    } else {
      if (type == MESSAGE_PULL) {
        const { value: value2, done } = await reader.read();
        sendMessage({ type: MESSAGE_DATA, value: value2, done, messageId }, workerData);
      }
      if (type == MESSAGE_DATA) {
        await writer.ready;
        await writer.write(new Uint8Array(value));
        sendMessage({ type: MESSAGE_ACK_DATA, messageId }, workerData);
      }
      if (type == MESSAGE_CLOSE) {
        close(null, result);
      }
    }
  } catch (error2) {
    close(error2);
  }
  function close(error2, result2) {
    if (error2) {
      rejectResult(error2);
    } else {
      resolveResult(result2);
    }
    if (writer) {
      writer.releaseLock();
    }
    onTaskFinished();
  }
}
var WEB_WORKERS_SUPPORTED, CodecWorker, ProgressWatcherStream, classicWorkersSupported, transferStreamsSupported;
var init_codec_worker = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/codec-worker.js"() {
    init_constants();
    init_codec_stream();
    WEB_WORKERS_SUPPORTED = typeof Worker != UNDEFINED_TYPE;
    CodecWorker = class {
      constructor(workerData, { readable, writable }, { options, config: config2, streamOptions, useWebWorkers, transferStreams, scripts }, onTaskFinished) {
        const { signal } = streamOptions;
        Object.assign(workerData, {
          busy: true,
          readable: readable.pipeThrough(new ProgressWatcherStream(readable, streamOptions, config2), { signal }),
          writable,
          options: Object.assign({}, options),
          scripts,
          transferStreams,
          terminate() {
            const { worker, busy } = workerData;
            if (worker && !busy) {
              worker.terminate();
              workerData.interface = null;
            }
          },
          onTaskFinished() {
            workerData.busy = false;
            onTaskFinished(workerData);
          }
        });
        return (useWebWorkers && WEB_WORKERS_SUPPORTED ? createWebWorkerInterface : createWorkerInterface)(workerData, config2);
      }
    };
    ProgressWatcherStream = class extends TransformStream {
      constructor(readableSource, { onstart, onprogress, size, onend }, { chunkSize }) {
        let chunkOffset = 0;
        super({
          start() {
            if (onstart) {
              callHandler(onstart, size);
            }
          },
          async transform(chunk, controller) {
            chunkOffset += chunk.length;
            if (onprogress) {
              await callHandler(onprogress, chunkOffset, size);
            }
            controller.enqueue(chunk);
          },
          flush() {
            readableSource.size = chunkOffset;
            if (onend) {
              callHandler(onend, chunkOffset);
            }
          }
        }, { highWaterMark: 1, size: () => chunkSize });
      }
    };
    classicWorkersSupported = true;
    transferStreamsSupported = true;
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/codec-pool.js
async function runWorker2(stream, workerOptions) {
  const { options, config: config2 } = workerOptions;
  const { transferStreams, useWebWorkers, useCompressionStream, codecType, compressed, signed, encrypted } = options;
  const { workerScripts, maxWorkers: maxWorkers2, terminateWorkerTimeout } = config2;
  workerOptions.transferStreams = transferStreams || transferStreams === UNDEFINED_VALUE;
  const streamCopy = !compressed && !signed && !encrypted && !workerOptions.transferStreams;
  workerOptions.useWebWorkers = !streamCopy && (useWebWorkers || useWebWorkers === UNDEFINED_VALUE && config2.useWebWorkers);
  workerOptions.scripts = workerOptions.useWebWorkers && workerScripts ? workerScripts[codecType] : [];
  options.useCompressionStream = useCompressionStream || useCompressionStream === UNDEFINED_VALUE && config2.useCompressionStream;
  let worker;
  const workerData = pool.find((workerData2) => !workerData2.busy);
  if (workerData) {
    clearTerminateTimeout(workerData);
    worker = new CodecWorker(workerData, stream, workerOptions, onTaskFinished);
  } else if (pool.length < maxWorkers2) {
    const workerData2 = { indexWorker };
    indexWorker++;
    pool.push(workerData2);
    worker = new CodecWorker(workerData2, stream, workerOptions, onTaskFinished);
  } else {
    worker = await new Promise((resolve) => pendingRequests.push({ resolve, stream, workerOptions }));
  }
  return worker.run();
  function onTaskFinished(workerData2) {
    if (pendingRequests.length) {
      const [{ resolve, stream: stream2, workerOptions: workerOptions2 }] = pendingRequests.splice(0, 1);
      resolve(new CodecWorker(workerData2, stream2, workerOptions2, onTaskFinished));
    } else if (workerData2.worker) {
      clearTerminateTimeout(workerData2);
      if (Number.isFinite(terminateWorkerTimeout) && terminateWorkerTimeout >= 0) {
        workerData2.terminateTimeout = setTimeout(() => {
          pool = pool.filter((data2) => data2 != workerData2);
          workerData2.terminate();
        }, terminateWorkerTimeout);
      }
    } else {
      pool = pool.filter((data2) => data2 != workerData2);
    }
  }
}
function clearTerminateTimeout(workerData) {
  const { terminateTimeout } = workerData;
  if (terminateTimeout) {
    clearTimeout(terminateTimeout);
    workerData.terminateTimeout = null;
  }
}
function terminateWorkers() {
  pool.forEach((workerData) => {
    clearTerminateTimeout(workerData);
    workerData.terminate();
  });
}
var pool, pendingRequests, indexWorker;
var init_codec_pool = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/codec-pool.js"() {
    init_constants();
    init_codec_stream();
    init_codec_worker();
    pool = [];
    pendingRequests = [];
    indexWorker = 0;
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/z-worker-inline.js
function e2(e3) {
  const t2 = () => URL.createObjectURL(new Blob(['const{Array:e,Object:t,Number:n,Math:r,Error:s,Uint8Array:i,Uint16Array:o,Uint32Array:c,Int32Array:f,Map:a,DataView:l,Promise:u,TextEncoder:w,crypto:h,postMessage:d,TransformStream:p,ReadableStream:y,WritableStream:m,CompressionStream:b,DecompressionStream:g}=self;class k{constructor(e){return class extends p{constructor(t,n){const r=new e(n);super({transform(e,t){t.enqueue(r.append(e))},flush(e){const t=r.flush();t&&e.enqueue(t)}})}}}}const v=[];for(let e=0;256>e;e++){let t=e;for(let e=0;8>e;e++)1&t?t=t>>>1^3988292384:t>>>=1;v[e]=t}class S{constructor(e){this.t=e||-1}append(e){let t=0|this.t;for(let n=0,r=0|e.length;r>n;n++)t=t>>>8^v[255&(t^e[n])];this.t=t}get(){return~this.t}}class z extends p{constructor(){const e=new S;super({transform(t){e.append(t)},flush(t){const n=new i(4);new l(n.buffer).setUint32(0,e.get()),t.enqueue(n)}})}}const C={concat(e,t){if(0===e.length||0===t.length)return e.concat(t);const n=e[e.length-1],r=C.i(n);return 32===r?e.concat(t):C.o(t,r,0|n,e.slice(0,e.length-1))},l(e){const t=e.length;if(0===t)return 0;const n=e[t-1];return 32*(t-1)+C.i(n)},u(e,t){if(32*e.length<t)return e;const n=(e=e.slice(0,r.ceil(t/32))).length;return t&=31,n>0&&t&&(e[n-1]=C.h(t,e[n-1]&2147483648>>t-1,1)),e},h:(e,t,n)=>32===e?t:(n?0|t:t<<32-e)+1099511627776*e,i:e=>r.round(e/1099511627776)||32,o(e,t,n,r){for(void 0===r&&(r=[]);t>=32;t-=32)r.push(n),n=0;if(0===t)return r.concat(e);for(let s=0;s<e.length;s++)r.push(n|e[s]>>>t),n=e[s]<<32-t;const s=e.length?e[e.length-1]:0,i=C.i(s);return r.push(C.h(t+i&31,t+i>32?n:r.pop(),1)),r}},x={p:{m(e){const t=C.l(e)/8,n=new i(t);let r;for(let s=0;t>s;s++)0==(3&s)&&(r=e[s/4]),n[s]=r>>>24,r<<=8;return n},g(e){const t=[];let n,r=0;for(n=0;n<e.length;n++)r=r<<8|e[n],3==(3&n)&&(t.push(r),r=0);return 3&n&&t.push(C.h(8*(3&n),r)),t}}},_=class{constructor(e){const t=this;t.blockSize=512,t.k=[1732584193,4023233417,2562383102,271733878,3285377520],t.v=[1518500249,1859775393,2400959708,3395469782],e?(t.S=e.S.slice(0),t.C=e.C.slice(0),t._=e._):t.reset()}reset(){const e=this;return e.S=e.k.slice(0),e.C=[],e._=0,e}update(e){const t=this;"string"==typeof e&&(e=x.A.g(e));const n=t.C=C.concat(t.C,e),r=t._,i=t._=r+C.l(e);if(i>9007199254740991)throw new s("Cannot hash more than 2^53 - 1 bits");const o=new c(n);let f=0;for(let e=t.blockSize+r-(t.blockSize+r&t.blockSize-1);i>=e;e+=t.blockSize)t.I(o.subarray(16*f,16*(f+1))),f+=1;return n.splice(0,16*f),t}D(){const e=this;let t=e.C;const n=e.S;t=C.concat(t,[C.h(1,1)]);for(let e=t.length+2;15&e;e++)t.push(0);for(t.push(r.floor(e._/4294967296)),t.push(0|e._);t.length;)e.I(t.splice(0,16));return e.reset(),n}V(e,t,n,r){return e>19?e>39?e>59?e>79?void 0:t^n^r:t&n|t&r|n&r:t^n^r:t&n|~t&r}P(e,t){return t<<e|t>>>32-e}I(t){const n=this,s=n.S,i=e(80);for(let e=0;16>e;e++)i[e]=t[e];let o=s[0],c=s[1],f=s[2],a=s[3],l=s[4];for(let e=0;79>=e;e++){16>e||(i[e]=n.P(1,i[e-3]^i[e-8]^i[e-14]^i[e-16]));const t=n.P(5,o)+n.V(e,c,f,a)+l+i[e]+n.v[r.floor(e/20)]|0;l=a,a=f,f=n.P(30,c),c=o,o=t}s[0]=s[0]+o|0,s[1]=s[1]+c|0,s[2]=s[2]+f|0,s[3]=s[3]+a|0,s[4]=s[4]+l|0}},A={getRandomValues(e){const t=new c(e.buffer),n=e=>{let t=987654321;const n=4294967295;return()=>(t=36969*(65535&t)+(t>>16)&n,(((t<<16)+(e=18e3*(65535&e)+(e>>16)&n)&n)/4294967296+.5)*(r.random()>.5?1:-1))};for(let s,i=0;i<e.length;i+=4){const e=n(4294967296*(s||r.random()));s=987654071*e(),t[i/4]=4294967296*e()|0}return e}},I={importKey:e=>new I.R(x.p.g(e)),B(e,t,n,r){if(n=n||1e4,0>r||0>n)throw new s("invalid params to pbkdf2");const i=1+(r>>5)<<2;let o,c,f,a,u;const w=new ArrayBuffer(i),h=new l(w);let d=0;const p=C;for(t=x.p.g(t),u=1;(i||1)>d;u++){for(o=c=e.encrypt(p.concat(t,[u])),f=1;n>f;f++)for(c=e.encrypt(c),a=0;a<c.length;a++)o[a]^=c[a];for(f=0;(i||1)>d&&f<o.length;f++)h.setInt32(d,o[f]),d+=4}return w.slice(0,r/8)},R:class{constructor(e){const t=this,n=t.M=_,r=[[],[]];t.K=[new n,new n];const s=t.K[0].blockSize/32;e.length>s&&(e=(new n).update(e).D());for(let t=0;s>t;t++)r[0][t]=909522486^e[t],r[1][t]=1549556828^e[t];t.K[0].update(r[0]),t.K[1].update(r[1]),t.U=new n(t.K[0])}reset(){const e=this;e.U=new e.M(e.K[0]),e.N=!1}update(e){this.N=!0,this.U.update(e)}digest(){const e=this,t=e.U.D(),n=new e.M(e.K[1]).update(t).D();return e.reset(),n}encrypt(e){if(this.N)throw new s("encrypt on already updated hmac called!");return this.update(e),this.digest(e)}}},D=void 0!==h&&"function"==typeof h.getRandomValues,V="Invalid password",P="Invalid signature",R="zipjs-abort-check-password";function B(e){return D?h.getRandomValues(e):A.getRandomValues(e)}const E=16,M={name:"PBKDF2"},K=t.assign({hash:{name:"HMAC"}},M),U=t.assign({iterations:1e3,hash:{name:"SHA-1"}},M),N=["deriveBits"],O=[8,12,16],T=[16,24,32],W=10,j=[0,0,0,0],H="undefined",L="function",F=typeof h!=H,q=F&&h.subtle,G=F&&typeof q!=H,J=x.p,Q=class{constructor(e){const t=this;t.O=[[[],[],[],[],[]],[[],[],[],[],[]]],t.O[0][0][0]||t.T();const n=t.O[0][4],r=t.O[1],i=e.length;let o,c,f,a=1;if(4!==i&&6!==i&&8!==i)throw new s("invalid aes key size");for(t.v=[c=e.slice(0),f=[]],o=i;4*i+28>o;o++){let e=c[o-1];(o%i==0||8===i&&o%i==4)&&(e=n[e>>>24]<<24^n[e>>16&255]<<16^n[e>>8&255]<<8^n[255&e],o%i==0&&(e=e<<8^e>>>24^a<<24,a=a<<1^283*(a>>7))),c[o]=c[o-i]^e}for(let e=0;o;e++,o--){const t=c[3&e?o:o-4];f[e]=4>=o||4>e?t:r[0][n[t>>>24]]^r[1][n[t>>16&255]]^r[2][n[t>>8&255]]^r[3][n[255&t]]}}encrypt(e){return this.W(e,0)}decrypt(e){return this.W(e,1)}T(){const e=this.O[0],t=this.O[1],n=e[4],r=t[4],s=[],i=[];let o,c,f,a;for(let e=0;256>e;e++)i[(s[e]=e<<1^283*(e>>7))^e]=e;for(let l=o=0;!n[l];l^=c||1,o=i[o]||1){let i=o^o<<1^o<<2^o<<3^o<<4;i=i>>8^255&i^99,n[l]=i,r[i]=l,a=s[f=s[c=s[l]]];let u=16843009*a^65537*f^257*c^16843008*l,w=257*s[i]^16843008*i;for(let n=0;4>n;n++)e[n][l]=w=w<<24^w>>>8,t[n][i]=u=u<<24^u>>>8}for(let n=0;5>n;n++)e[n]=e[n].slice(0),t[n]=t[n].slice(0)}W(e,t){if(4!==e.length)throw new s("invalid aes block size");const n=this.v[t],r=n.length/4-2,i=[0,0,0,0],o=this.O[t],c=o[0],f=o[1],a=o[2],l=o[3],u=o[4];let w,h,d,p=e[0]^n[0],y=e[t?3:1]^n[1],m=e[2]^n[2],b=e[t?1:3]^n[3],g=4;for(let e=0;r>e;e++)w=c[p>>>24]^f[y>>16&255]^a[m>>8&255]^l[255&b]^n[g],h=c[y>>>24]^f[m>>16&255]^a[b>>8&255]^l[255&p]^n[g+1],d=c[m>>>24]^f[b>>16&255]^a[p>>8&255]^l[255&y]^n[g+2],b=c[b>>>24]^f[p>>16&255]^a[y>>8&255]^l[255&m]^n[g+3],g+=4,p=w,y=h,m=d;for(let e=0;4>e;e++)i[t?3&-e:e]=u[p>>>24]<<24^u[y>>16&255]<<16^u[m>>8&255]<<8^u[255&b]^n[g++],w=p,p=y,y=m,m=b,b=w;return i}},X=class{constructor(e,t){this.j=e,this.H=t,this.L=t}reset(){this.L=this.H}update(e){return this.F(this.j,e,this.L)}q(e){if(255==(e>>24&255)){let t=e>>16&255,n=e>>8&255,r=255&e;255===t?(t=0,255===n?(n=0,255===r?r=0:++r):++n):++t,e=0,e+=t<<16,e+=n<<8,e+=r}else e+=1<<24;return e}G(e){0===(e[0]=this.q(e[0]))&&(e[1]=this.q(e[1]))}F(e,t,n){let r;if(!(r=t.length))return[];const s=C.l(t);for(let s=0;r>s;s+=4){this.G(n);const r=e.encrypt(n);t[s]^=r[0],t[s+1]^=r[1],t[s+2]^=r[2],t[s+3]^=r[3]}return C.u(t,s)}},Y=I.R;let Z=F&&G&&typeof q.importKey==L,$=F&&G&&typeof q.deriveBits==L;class ee extends p{constructor({password:e,signed:n,encryptionStrength:r,checkPasswordOnly:o}){super({start(){t.assign(this,{ready:new u((e=>this.J=e)),password:e,signed:n,X:r-1,pending:new i})},async transform(e,t){const n=this,{password:r,X:c,J:f,ready:a}=n;r?(await(async(e,t,n,r)=>{const i=await re(e,t,n,ie(r,0,O[t])),o=ie(r,O[t]);if(i[0]!=o[0]||i[1]!=o[1])throw new s(V)})(n,c,r,ie(e,0,O[c]+2)),e=ie(e,O[c]+2),o?t.error(new s(R)):f()):await a;const l=new i(e.length-W-(e.length-W)%E);t.enqueue(ne(n,e,l,0,W,!0))},async flush(e){const{signed:t,Y:n,Z:r,pending:o,ready:c}=this;await c;const f=ie(o,0,o.length-W),a=ie(o,o.length-W);let l=new i;if(f.length){const e=ce(J,f);r.update(e);const t=n.update(e);l=oe(J,t)}if(t){const e=ie(oe(J,r.digest()),0,W);for(let t=0;W>t;t++)if(e[t]!=a[t])throw new s(P)}e.enqueue(l)}})}}class te extends p{constructor({password:e,encryptionStrength:n}){let r;super({start(){t.assign(this,{ready:new u((e=>this.J=e)),password:e,X:n-1,pending:new i})},async transform(e,t){const n=this,{password:r,X:s,J:o,ready:c}=n;let f=new i;r?(f=await(async(e,t,n)=>{const r=B(new i(O[t]));return se(r,await re(e,t,n,r))})(n,s,r),o()):await c;const a=new i(f.length+e.length-e.length%E);a.set(f,0),t.enqueue(ne(n,e,a,f.length,0))},async flush(e){const{Y:t,Z:n,pending:s,ready:o}=this;await o;let c=new i;if(s.length){const e=t.update(ce(J,s));n.update(e),c=oe(J,e)}r.signature=oe(J,n.digest()).slice(0,W),e.enqueue(se(c,r.signature))}}),r=this}}function ne(e,t,n,r,s,o){const{Y:c,Z:f,pending:a}=e,l=t.length-s;let u;for(a.length&&(t=se(a,t),n=((e,t)=>{if(t&&t>e.length){const n=e;(e=new i(t)).set(n,0)}return e})(n,l-l%E)),u=0;l-E>=u;u+=E){const e=ce(J,ie(t,u,u+E));o&&f.update(e);const s=c.update(e);o||f.update(s),n.set(oe(J,s),u+r)}return e.pending=ie(t,u),n}async function re(n,r,s,o){n.password=null;const c=(e=>{if(void 0===w){const t=new i((e=unescape(encodeURIComponent(e))).length);for(let n=0;n<t.length;n++)t[n]=e.charCodeAt(n);return t}return(new w).encode(e)})(s),f=await(async(e,t,n,r,s)=>{if(!Z)return I.importKey(t);try{return await q.importKey("raw",t,n,!1,s)}catch(e){return Z=!1,I.importKey(t)}})(0,c,K,0,N),a=await(async(e,t,n)=>{if(!$)return I.B(t,e.salt,U.iterations,n);try{return await q.deriveBits(e,t,n)}catch(r){return $=!1,I.B(t,e.salt,U.iterations,n)}})(t.assign({salt:o},U),f,8*(2*T[r]+2)),l=new i(a),u=ce(J,ie(l,0,T[r])),h=ce(J,ie(l,T[r],2*T[r])),d=ie(l,2*T[r]);return t.assign(n,{keys:{key:u,$:h,passwordVerification:d},Y:new X(new Q(u),e.from(j)),Z:new Y(h)}),d}function se(e,t){let n=e;return e.length+t.length&&(n=new i(e.length+t.length),n.set(e,0),n.set(t,e.length)),n}function ie(e,t,n){return e.subarray(t,n)}function oe(e,t){return e.m(t)}function ce(e,t){return e.g(t)}class fe extends p{constructor({password:e,passwordVerification:n,checkPasswordOnly:r}){super({start(){t.assign(this,{password:e,passwordVerification:n}),we(this,e)},transform(e,t){const n=this;if(n.password){const t=le(n,e.subarray(0,12));if(n.password=null,t[11]!=n.passwordVerification)throw new s(V);e=e.subarray(12)}r?t.error(new s(R)):t.enqueue(le(n,e))}})}}class ae extends p{constructor({password:e,passwordVerification:n}){super({start(){t.assign(this,{password:e,passwordVerification:n}),we(this,e)},transform(e,t){const n=this;let r,s;if(n.password){n.password=null;const t=B(new i(12));t[11]=n.passwordVerification,r=new i(e.length+t.length),r.set(ue(n,t),0),s=12}else r=new i(e.length),s=0;r.set(ue(n,e),s),t.enqueue(r)}})}}function le(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=de(e)^t[r],he(e,n[r]);return n}function ue(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=de(e)^t[r],he(e,t[r]);return n}function we(e,n){const r=[305419896,591751049,878082192];t.assign(e,{keys:r,ee:new S(r[0]),te:new S(r[2])});for(let t=0;t<n.length;t++)he(e,n.charCodeAt(t))}function he(e,t){let[n,s,i]=e.keys;e.ee.append([t]),n=~e.ee.get(),s=ye(r.imul(ye(s+pe(n)),134775813)+1),e.te.append([s>>>24]),i=~e.te.get(),e.keys=[n,s,i]}function de(e){const t=2|e.keys[2];return pe(r.imul(t,1^t)>>>8)}function pe(e){return 255&e}function ye(e){return 4294967295&e}const me="deflate-raw";class be extends p{constructor(e,{chunkSize:t,CompressionStream:n,CompressionStreamNative:r}){super({});const{compressed:s,encrypted:i,useCompressionStream:o,zipCrypto:c,signed:f,level:a}=e,u=this;let w,h,d=ke(super.readable);i&&!c||!f||([d,w]=d.tee(),w=ze(w,new z)),s&&(d=Se(d,o,{level:a,chunkSize:t},r,n)),i&&(c?d=ze(d,new ae(e)):(h=new te(e),d=ze(d,h))),ve(u,d,(async()=>{let e;i&&!c&&(e=h.signature),i&&!c||!f||(e=await w.getReader().read(),e=new l(e.value.buffer).getUint32(0)),u.signature=e}))}}class ge extends p{constructor(e,{chunkSize:t,DecompressionStream:n,DecompressionStreamNative:r}){super({});const{zipCrypto:i,encrypted:o,signed:c,signature:f,compressed:a,useCompressionStream:u}=e;let w,h,d=ke(super.readable);o&&(i?d=ze(d,new fe(e)):(h=new ee(e),d=ze(d,h))),a&&(d=Se(d,u,{chunkSize:t},r,n)),o&&!i||!c||([d,w]=d.tee(),w=ze(w,new z)),ve(this,d,(async()=>{if((!o||i)&&c){const e=await w.getReader().read(),t=new l(e.value.buffer);if(f!=t.getUint32(0,!1))throw new s(P)}}))}}function ke(e){return ze(e,new p({transform(e,t){e&&e.length&&t.enqueue(e)}}))}function ve(e,n,r){n=ze(n,new p({flush:r})),t.defineProperty(e,"readable",{get:()=>n})}function Se(e,t,n,r,s){try{e=ze(e,new(t&&r?r:s)(me,n))}catch(r){if(!t)throw r;e=ze(e,new s(me,n))}return e}function ze(e,t){return e.pipeThrough(t)}const Ce="data";class xe extends p{constructor(e,n){super({});const r=this,{codecType:s}=e;let i;s.startsWith("deflate")?i=be:s.startsWith("inflate")&&(i=ge);let o=0;const c=new i(e,n),f=super.readable,a=new p({transform(e,t){e&&e.length&&(o+=e.length,t.enqueue(e))},flush(){const{signature:e}=c;t.assign(r,{signature:e,size:o})}});t.defineProperty(r,"readable",{get:()=>f.pipeThrough(c).pipeThrough(a)})}}const _e=new a,Ae=new a;let Ie=0;async function De(e){try{const{options:t,scripts:r,config:s}=e;r&&r.length&&importScripts.apply(void 0,r),self.initCodec&&self.initCodec(),s.CompressionStreamNative=self.CompressionStream,s.DecompressionStreamNative=self.DecompressionStream,self.Deflate&&(s.CompressionStream=new k(self.Deflate)),self.Inflate&&(s.DecompressionStream=new k(self.Inflate));const i={highWaterMark:1,size:()=>s.chunkSize},o=e.readable||new y({async pull(e){const t=new u((e=>_e.set(Ie,e)));Ve({type:"pull",messageId:Ie}),Ie=(Ie+1)%n.MAX_SAFE_INTEGER;const{value:r,done:s}=await t;e.enqueue(r),s&&e.close()}},i),c=e.writable||new m({async write(e){let t;const r=new u((e=>t=e));Ae.set(Ie,t),Ve({type:Ce,value:e,messageId:Ie}),Ie=(Ie+1)%n.MAX_SAFE_INTEGER,await r}},i),f=new xe(t,s);await o.pipeThrough(f).pipeTo(c,{preventClose:!0,preventAbort:!0});try{await c.close()}catch(e){}const{signature:a,size:l}=f;Ve({type:"close",result:{signature:a,size:l}})}catch(e){Pe(e)}}function Ve(e){let{value:t}=e;if(t)if(t.length)try{t=new i(t),e.value=t.buffer,d(e,[e.value])}catch(t){d(e)}else d(e);else d(e)}function Pe(e){const{message:t,stack:n,code:r,name:s}=e;d({error:{message:t,stack:n,code:r,name:s}})}addEventListener("message",(({data:e})=>{const{type:t,messageId:n,value:r,done:s}=e;try{if("start"==t&&De(e),t==Ce){const e=_e.get(n);_e.delete(n),e({value:new i(r),done:s})}if("ack"==t){const e=Ae.get(n);Ae.delete(n),e()}}catch(e){Pe(e)}}));const Re=-2;function Be(t){return Ee(t.map((([t,n])=>new e(t).fill(n,0,t))))}function Ee(t){return t.reduce(((t,n)=>t.concat(e.isArray(n)?Ee(n):n)),[])}const Me=[0,1,2,3].concat(...Be([[2,4],[2,5],[4,6],[4,7],[8,8],[8,9],[16,10],[16,11],[32,12],[32,13],[64,14],[64,15],[2,0],[1,16],[1,17],[2,18],[2,19],[4,20],[4,21],[8,22],[8,23],[16,24],[16,25],[32,26],[32,27],[64,28],[64,29]]));function Ke(){const e=this;function t(e,t){let n=0;do{n|=1&e,e>>>=1,n<<=1}while(--t>0);return n>>>1}e.ne=n=>{const s=e.re,i=e.ie.se,o=e.ie.oe;let c,f,a,l=-1;for(n.ce=0,n.fe=573,c=0;o>c;c++)0!==s[2*c]?(n.ae[++n.ce]=l=c,n.le[c]=0):s[2*c+1]=0;for(;2>n.ce;)a=n.ae[++n.ce]=2>l?++l:0,s[2*a]=1,n.le[a]=0,n.ue--,i&&(n.we-=i[2*a+1]);for(e.he=l,c=r.floor(n.ce/2);c>=1;c--)n.de(s,c);a=o;do{c=n.ae[1],n.ae[1]=n.ae[n.ce--],n.de(s,1),f=n.ae[1],n.ae[--n.fe]=c,n.ae[--n.fe]=f,s[2*a]=s[2*c]+s[2*f],n.le[a]=r.max(n.le[c],n.le[f])+1,s[2*c+1]=s[2*f+1]=a,n.ae[1]=a++,n.de(s,1)}while(n.ce>=2);n.ae[--n.fe]=n.ae[1],(t=>{const n=e.re,r=e.ie.se,s=e.ie.pe,i=e.ie.ye,o=e.ie.me;let c,f,a,l,u,w,h=0;for(l=0;15>=l;l++)t.be[l]=0;for(n[2*t.ae[t.fe]+1]=0,c=t.fe+1;573>c;c++)f=t.ae[c],l=n[2*n[2*f+1]+1]+1,l>o&&(l=o,h++),n[2*f+1]=l,f>e.he||(t.be[l]++,u=0,i>f||(u=s[f-i]),w=n[2*f],t.ue+=w*(l+u),r&&(t.we+=w*(r[2*f+1]+u)));if(0!==h){do{for(l=o-1;0===t.be[l];)l--;t.be[l]--,t.be[l+1]+=2,t.be[o]--,h-=2}while(h>0);for(l=o;0!==l;l--)for(f=t.be[l];0!==f;)a=t.ae[--c],a>e.he||(n[2*a+1]!=l&&(t.ue+=(l-n[2*a+1])*n[2*a],n[2*a+1]=l),f--)}})(n),((e,n,r)=>{const s=[];let i,o,c,f=0;for(i=1;15>=i;i++)s[i]=f=f+r[i-1]<<1;for(o=0;n>=o;o++)c=e[2*o+1],0!==c&&(e[2*o]=t(s[c]++,c))})(s,e.he,n.be)}}function Ue(e,t,n,r,s){const i=this;i.se=e,i.pe=t,i.ye=n,i.oe=r,i.me=s}Ke.ge=[0,1,2,3,4,5,6,7].concat(...Be([[2,8],[2,9],[2,10],[2,11],[4,12],[4,13],[4,14],[4,15],[8,16],[8,17],[8,18],[8,19],[16,20],[16,21],[16,22],[16,23],[32,24],[32,25],[32,26],[31,27],[1,28]])),Ke.ke=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],Ke.ve=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],Ke.Se=e=>256>e?Me[e]:Me[256+(e>>>7)],Ke.ze=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],Ke.Ce=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],Ke.xe=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],Ke._e=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];const Ne=Be([[144,8],[112,9],[24,7],[8,8]]);Ue.Ae=Ee([12,140,76,204,44,172,108,236,28,156,92,220,60,188,124,252,2,130,66,194,34,162,98,226,18,146,82,210,50,178,114,242,10,138,74,202,42,170,106,234,26,154,90,218,58,186,122,250,6,134,70,198,38,166,102,230,22,150,86,214,54,182,118,246,14,142,78,206,46,174,110,238,30,158,94,222,62,190,126,254,1,129,65,193,33,161,97,225,17,145,81,209,49,177,113,241,9,137,73,201,41,169,105,233,25,153,89,217,57,185,121,249,5,133,69,197,37,165,101,229,21,149,85,213,53,181,117,245,13,141,77,205,45,173,109,237,29,157,93,221,61,189,125,253,19,275,147,403,83,339,211,467,51,307,179,435,115,371,243,499,11,267,139,395,75,331,203,459,43,299,171,427,107,363,235,491,27,283,155,411,91,347,219,475,59,315,187,443,123,379,251,507,7,263,135,391,71,327,199,455,39,295,167,423,103,359,231,487,23,279,151,407,87,343,215,471,55,311,183,439,119,375,247,503,15,271,143,399,79,335,207,463,47,303,175,431,111,367,239,495,31,287,159,415,95,351,223,479,63,319,191,447,127,383,255,511,0,64,32,96,16,80,48,112,8,72,40,104,24,88,56,120,4,68,36,100,20,84,52,116,3,131,67,195,35,163,99,227].map(((e,t)=>[e,Ne[t]])));const Oe=Be([[30,5]]);function Te(e,t,n,r,s){const i=this;i.Ie=e,i.De=t,i.Ve=n,i.Pe=r,i.Re=s}Ue.Be=Ee([0,16,8,24,4,20,12,28,2,18,10,26,6,22,14,30,1,17,9,25,5,21,13,29,3,19,11,27,7,23].map(((e,t)=>[e,Oe[t]]))),Ue.Ee=new Ue(Ue.Ae,Ke.ze,257,286,15),Ue.Me=new Ue(Ue.Be,Ke.Ce,0,30,15),Ue.Ke=new Ue(null,Ke.xe,0,19,7);const We=[new Te(0,0,0,0,0),new Te(4,4,8,4,1),new Te(4,5,16,8,1),new Te(4,6,32,32,1),new Te(4,4,16,16,2),new Te(8,16,32,32,2),new Te(8,16,128,128,2),new Te(8,32,128,256,2),new Te(32,128,258,1024,2),new Te(32,258,258,4096,2)],je=["need dictionary","stream end","","","stream error","data error","","buffer error","",""],He=113,Le=666,Fe=262;function qe(e,t,n,r){const s=e[2*t],i=e[2*n];return i>s||s==i&&r[t]<=r[n]}function Ge(){const e=this;let t,n,s,c,f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z,C,x,_,A,I,D,V,P,R,B,E,M,K;const U=new Ke,N=new Ke,O=new Ke;let T,W,j,H,L,F;function q(){let t;for(t=0;286>t;t++)E[2*t]=0;for(t=0;30>t;t++)M[2*t]=0;for(t=0;19>t;t++)K[2*t]=0;E[512]=1,e.ue=e.we=0,W=j=0}function G(e,t){let n,r=-1,s=e[1],i=0,o=7,c=4;0===s&&(o=138,c=3),e[2*(t+1)+1]=65535;for(let f=0;t>=f;f++)n=s,s=e[2*(f+1)+1],++i<o&&n==s||(c>i?K[2*n]+=i:0!==n?(n!=r&&K[2*n]++,K[32]++):i>10?K[36]++:K[34]++,i=0,r=n,0===s?(o=138,c=3):n==s?(o=6,c=3):(o=7,c=4))}function J(t){e.Ue[e.pending++]=t}function Q(e){J(255&e),J(e>>>8&255)}function X(e,t){let n;const r=t;F>16-r?(n=e,L|=n<<F&65535,Q(L),L=n>>>16-F,F+=r-16):(L|=e<<F&65535,F+=r)}function Y(e,t){const n=2*e;X(65535&t[n],65535&t[n+1])}function Z(e,t){let n,r,s=-1,i=e[1],o=0,c=7,f=4;for(0===i&&(c=138,f=3),n=0;t>=n;n++)if(r=i,i=e[2*(n+1)+1],++o>=c||r!=i){if(f>o)do{Y(r,K)}while(0!=--o);else 0!==r?(r!=s&&(Y(r,K),o--),Y(16,K),X(o-3,2)):o>10?(Y(18,K),X(o-11,7)):(Y(17,K),X(o-3,3));o=0,s=r,0===i?(c=138,f=3):r==i?(c=6,f=3):(c=7,f=4)}}function $(){16==F?(Q(L),L=0,F=0):8>F||(J(255&L),L>>>=8,F-=8)}function ee(t,n){let s,i,o;if(e.Ne[W]=t,e.Oe[W]=255&n,W++,0===t?E[2*n]++:(j++,t--,E[2*(Ke.ge[n]+256+1)]++,M[2*Ke.Se(t)]++),0==(8191&W)&&V>2){for(s=8*W,i=C-k,o=0;30>o;o++)s+=M[2*o]*(5+Ke.Ce[o]);if(s>>>=3,j<r.floor(W/2)&&s<r.floor(i/2))return!0}return W==T-1}function te(t,n){let r,s,i,o,c=0;if(0!==W)do{r=e.Ne[c],s=e.Oe[c],c++,0===r?Y(s,t):(i=Ke.ge[s],Y(i+256+1,t),o=Ke.ze[i],0!==o&&(s-=Ke.ke[i],X(s,o)),r--,i=Ke.Se(r),Y(i,n),o=Ke.Ce[i],0!==o&&(r-=Ke.ve[i],X(r,o)))}while(W>c);Y(256,t),H=t[513]}function ne(){F>8?Q(L):F>0&&J(255&L),L=0,F=0}function re(t,n,r){X(0+(r?1:0),3),((t,n)=>{ne(),H=8,Q(n),Q(~n),e.Ue.set(u.subarray(t,t+n),e.pending),e.pending+=n})(t,n)}function se(n){((t,n,r)=>{let s,i,o=0;V>0?(U.ne(e),N.ne(e),o=(()=>{let t;for(G(E,U.he),G(M,N.he),O.ne(e),t=18;t>=3&&0===K[2*Ke._e[t]+1];t--);return e.ue+=14+3*(t+1),t})(),s=e.ue+3+7>>>3,i=e.we+3+7>>>3,i>s||(s=i)):s=i=n+5,n+4>s||-1==t?i==s?(X(2+(r?1:0),3),te(Ue.Ae,Ue.Be)):(X(4+(r?1:0),3),((e,t,n)=>{let r;for(X(e-257,5),X(t-1,5),X(n-4,4),r=0;n>r;r++)X(K[2*Ke._e[r]+1],3);Z(E,e-1),Z(M,t-1)})(U.he+1,N.he+1,o+1),te(E,M)):re(t,n,r),q(),r&&ne()})(0>k?-1:k,C-k,n),k=C,t.Te()}function ie(){let e,n,r,s;do{if(s=w-_-C,0===s&&0===C&&0===_)s=f;else if(-1==s)s--;else if(C>=f+f-Fe){u.set(u.subarray(f,f+f),0),x-=f,C-=f,k-=f,e=y,r=e;do{n=65535&d[--r],d[r]=f>n?0:n-f}while(0!=--e);e=f,r=e;do{n=65535&h[--r],h[r]=f>n?0:n-f}while(0!=--e);s+=f}if(0===t.We)return;e=t.je(u,C+_,s),_+=e,3>_||(p=255&u[C],p=(p<<g^255&u[C+1])&b)}while(Fe>_&&0!==t.We)}function oe(e){let t,n,r=I,s=C,i=A;const o=C>f-Fe?C-(f-Fe):0;let c=B;const a=l,w=C+258;let d=u[s+i-1],p=u[s+i];R>A||(r>>=2),c>_&&(c=_);do{if(t=e,u[t+i]==p&&u[t+i-1]==d&&u[t]==u[s]&&u[++t]==u[s+1]){s+=2,t++;do{}while(u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&w>s);if(n=258-(w-s),s=w-258,n>i){if(x=e,i=n,n>=c)break;d=u[s+i-1],p=u[s+i]}}}while((e=65535&h[e&a])>o&&0!=--r);return i>_?_:i}e.le=[],e.be=[],e.ae=[],E=[],M=[],K=[],e.de=(t,n)=>{const r=e.ae,s=r[n];let i=n<<1;for(;i<=e.ce&&(i<e.ce&&qe(t,r[i+1],r[i],e.le)&&i++,!qe(t,s,r[i],e.le));)r[n]=r[i],n=i,i<<=1;r[n]=s},e.He=(t,S,x,W,j,G)=>(W||(W=8),j||(j=8),G||(G=0),t.Le=null,-1==S&&(S=6),1>j||j>9||8!=W||9>x||x>15||0>S||S>9||0>G||G>2?Re:(t.Fe=e,a=x,f=1<<a,l=f-1,m=j+7,y=1<<m,b=y-1,g=r.floor((m+3-1)/3),u=new i(2*f),h=[],d=[],T=1<<j+6,e.Ue=new i(4*T),s=4*T,e.Ne=new o(T),e.Oe=new i(T),V=S,P=G,(t=>(t.qe=t.Ge=0,t.Le=null,e.pending=0,e.Je=0,n=He,c=0,U.re=E,U.ie=Ue.Ee,N.re=M,N.ie=Ue.Me,O.re=K,O.ie=Ue.Ke,L=0,F=0,H=8,q(),(()=>{w=2*f,d[y-1]=0;for(let e=0;y-1>e;e++)d[e]=0;D=We[V].De,R=We[V].Ie,B=We[V].Ve,I=We[V].Pe,C=0,k=0,_=0,v=A=2,z=0,p=0})(),0))(t))),e.Qe=()=>42!=n&&n!=He&&n!=Le?Re:(e.Oe=null,e.Ne=null,e.Ue=null,d=null,h=null,u=null,e.Fe=null,n==He?-3:0),e.Xe=(e,t,n)=>{let r=0;return-1==t&&(t=6),0>t||t>9||0>n||n>2?Re:(We[V].Re!=We[t].Re&&0!==e.qe&&(r=e.Ye(1)),V!=t&&(V=t,D=We[V].De,R=We[V].Ie,B=We[V].Ve,I=We[V].Pe),P=n,r)},e.Ze=(e,t,r)=>{let s,i=r,o=0;if(!t||42!=n)return Re;if(3>i)return 0;for(i>f-Fe&&(i=f-Fe,o=r-i),u.set(t.subarray(o,o+i),0),C=i,k=i,p=255&u[0],p=(p<<g^255&u[1])&b,s=0;i-3>=s;s++)p=(p<<g^255&u[s+2])&b,h[s&l]=d[p],d[p]=s;return 0},e.Ye=(r,i)=>{let o,w,m,I,R;if(i>4||0>i)return Re;if(!r.$e||!r.et&&0!==r.We||n==Le&&4!=i)return r.Le=je[4],Re;if(0===r.tt)return r.Le=je[7],-5;var B;if(t=r,I=c,c=i,42==n&&(w=8+(a-8<<4)<<8,m=(V-1&255)>>1,m>3&&(m=3),w|=m<<6,0!==C&&(w|=32),w+=31-w%31,n=He,J((B=w)>>8&255),J(255&B)),0!==e.pending){if(t.Te(),0===t.tt)return c=-1,0}else if(0===t.We&&I>=i&&4!=i)return t.Le=je[7],-5;if(n==Le&&0!==t.We)return r.Le=je[7],-5;if(0!==t.We||0!==_||0!=i&&n!=Le){switch(R=-1,We[V].Re){case 0:R=(e=>{let n,r=65535;for(r>s-5&&(r=s-5);;){if(1>=_){if(ie(),0===_&&0==e)return 0;if(0===_)break}if(C+=_,_=0,n=k+r,(0===C||C>=n)&&(_=C-n,C=n,se(!1),0===t.tt))return 0;if(C-k>=f-Fe&&(se(!1),0===t.tt))return 0}return se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i);break;case 1:R=(e=>{let n,r=0;for(;;){if(Fe>_){if(ie(),Fe>_&&0==e)return 0;if(0===_)break}if(3>_||(p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C),0===r||(C-r&65535)>f-Fe||2!=P&&(v=oe(r)),3>v)n=ee(0,255&u[C]),_--,C++;else if(n=ee(C-x,v-3),_-=v,v>D||3>_)C+=v,v=0,p=255&u[C],p=(p<<g^255&u[C+1])&b;else{v--;do{C++,p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C}while(0!=--v);C++}if(n&&(se(!1),0===t.tt))return 0}return se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i);break;case 2:R=(e=>{let n,r,s=0;for(;;){if(Fe>_){if(ie(),Fe>_&&0==e)return 0;if(0===_)break}if(3>_||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C),A=v,S=x,v=2,0!==s&&D>A&&f-Fe>=(C-s&65535)&&(2!=P&&(v=oe(s)),5>=v&&(1==P||3==v&&C-x>4096)&&(v=2)),3>A||v>A)if(0!==z){if(n=ee(0,255&u[C-1]),n&&se(!1),C++,_--,0===t.tt)return 0}else z=1,C++,_--;else{r=C+_-3,n=ee(C-1-S,A-3),_-=A-1,A-=2;do{++C>r||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C)}while(0!=--A);if(z=0,v=2,C++,n&&(se(!1),0===t.tt))return 0}}return 0!==z&&(n=ee(0,255&u[C-1]),z=0),se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i)}if(2!=R&&3!=R||(n=Le),0==R||2==R)return 0===t.tt&&(c=-1),0;if(1==R){if(1==i)X(2,3),Y(256,Ue.Ae),$(),9>1+H+10-F&&(X(2,3),Y(256,Ue.Ae),$()),H=7;else if(re(0,0,!1),3==i)for(o=0;y>o;o++)d[o]=0;if(t.Te(),0===t.tt)return c=-1,0}}return 4!=i?0:1}}function Je(){const e=this;e.nt=0,e.rt=0,e.We=0,e.qe=0,e.tt=0,e.Ge=0}function Qe(e){const t=new Je,n=(o=e&&e.chunkSize?e.chunkSize:65536)+5*(r.floor(o/16383)+1);var o;const c=new i(n);let f=e?e.level:-1;void 0===f&&(f=-1),t.He(f),t.$e=c,this.append=(e,r)=>{let o,f,a=0,l=0,u=0;const w=[];if(e.length){t.nt=0,t.et=e,t.We=e.length;do{if(t.rt=0,t.tt=n,o=t.Ye(0),0!=o)throw new s("deflating: "+t.Le);t.rt&&(t.rt==n?w.push(new i(c)):w.push(c.slice(0,t.rt))),u+=t.rt,r&&t.nt>0&&t.nt!=a&&(r(t.nt),a=t.nt)}while(t.We>0||0===t.tt);return w.length>1?(f=new i(u),w.forEach((e=>{f.set(e,l),l+=e.length}))):f=w[0]||new i,f}},this.flush=()=>{let e,r,o=0,f=0;const a=[];do{if(t.rt=0,t.tt=n,e=t.Ye(4),1!=e&&0!=e)throw new s("deflating: "+t.Le);n-t.tt>0&&a.push(c.slice(0,t.rt)),f+=t.rt}while(t.We>0||0===t.tt);return t.Qe(),r=new i(f),a.forEach((e=>{r.set(e,o),o+=e.length})),r}}Je.prototype={He(e,t){const n=this;return n.Fe=new Ge,t||(t=15),n.Fe.He(n,e,t)},Ye(e){const t=this;return t.Fe?t.Fe.Ye(t,e):Re},Qe(){const e=this;if(!e.Fe)return Re;const t=e.Fe.Qe();return e.Fe=null,t},Xe(e,t){const n=this;return n.Fe?n.Fe.Xe(n,e,t):Re},Ze(e,t){const n=this;return n.Fe?n.Fe.Ze(n,e,t):Re},je(e,t,n){const r=this;let s=r.We;return s>n&&(s=n),0===s?0:(r.We-=s,e.set(r.et.subarray(r.nt,r.nt+s),t),r.nt+=s,r.qe+=s,s)},Te(){const e=this;let t=e.Fe.pending;t>e.tt&&(t=e.tt),0!==t&&(e.$e.set(e.Fe.Ue.subarray(e.Fe.Je,e.Fe.Je+t),e.rt),e.rt+=t,e.Fe.Je+=t,e.Ge+=t,e.tt-=t,e.Fe.pending-=t,0===e.Fe.pending&&(e.Fe.Je=0))}};const Xe=-2,Ye=-3,Ze=-5,$e=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],et=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],tt=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],nt=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],rt=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],st=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],it=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function ot(){let e,t,n,r,s,i;function o(e,t,o,c,f,a,l,u,w,h,d){let p,y,m,b,g,k,v,S,z,C,x,_,A,I,D;C=0,g=o;do{n[e[t+C]]++,C++,g--}while(0!==g);if(n[0]==o)return l[0]=-1,u[0]=0,0;for(S=u[0],k=1;15>=k&&0===n[k];k++);for(v=k,k>S&&(S=k),g=15;0!==g&&0===n[g];g--);for(m=g,S>g&&(S=g),u[0]=S,I=1<<k;g>k;k++,I<<=1)if(0>(I-=n[k]))return Ye;if(0>(I-=n[g]))return Ye;for(n[g]+=I,i[1]=k=0,C=1,A=2;0!=--g;)i[A]=k+=n[C],A++,C++;g=0,C=0;do{0!==(k=e[t+C])&&(d[i[k]++]=g),C++}while(++g<o);for(o=i[m],i[0]=g=0,C=0,b=-1,_=-S,s[0]=0,x=0,D=0;m>=v;v++)for(p=n[v];0!=p--;){for(;v>_+S;){if(b++,_+=S,D=m-_,D=D>S?S:D,(y=1<<(k=v-_))>p+1&&(y-=p+1,A=v,D>k))for(;++k<D&&(y<<=1)>n[++A];)y-=n[A];if(D=1<<k,h[0]+D>1440)return Ye;s[b]=x=h[0],h[0]+=D,0!==b?(i[b]=g,r[0]=k,r[1]=S,k=g>>>_-S,r[2]=x-s[b-1]-k,w.set(r,3*(s[b-1]+k))):l[0]=x}for(r[1]=v-_,o>C?d[C]<c?(r[0]=256>d[C]?0:96,r[2]=d[C++]):(r[0]=a[d[C]-c]+16+64,r[2]=f[d[C++]-c]):r[0]=192,y=1<<v-_,k=g>>>_;D>k;k+=y)w.set(r,3*(x+k));for(k=1<<v-1;0!=(g&k);k>>>=1)g^=k;for(g^=k,z=(1<<_)-1;(g&z)!=i[b];)b--,_-=S,z=(1<<_)-1}return 0!==I&&1!=m?Ze:0}function c(o){let c;for(e||(e=[],t=[],n=new f(16),r=[],s=new f(15),i=new f(16)),t.length<o&&(t=[]),c=0;o>c;c++)t[c]=0;for(c=0;16>c;c++)n[c]=0;for(c=0;3>c;c++)r[c]=0;s.set(n.subarray(0,15),0),i.set(n.subarray(0,16),0)}this.st=(n,r,s,i,f)=>{let a;return c(19),e[0]=0,a=o(n,0,19,19,null,null,s,r,i,e,t),a==Ye?f.Le="oversubscribed dynamic bit lengths tree":a!=Ze&&0!==r[0]||(f.Le="incomplete dynamic bit lengths tree",a=Ye),a},this.it=(n,r,s,i,f,a,l,u,w)=>{let h;return c(288),e[0]=0,h=o(s,0,n,257,nt,rt,a,i,u,e,t),0!=h||0===i[0]?(h==Ye?w.Le="oversubscribed literal/length tree":-4!=h&&(w.Le="incomplete literal/length tree",h=Ye),h):(c(288),h=o(s,n,r,0,st,it,l,f,u,e,t),0!=h||0===f[0]&&n>257?(h==Ye?w.Le="oversubscribed distance tree":h==Ze?(w.Le="incomplete distance tree",h=Ye):-4!=h&&(w.Le="empty distance tree with lengths",h=Ye),h):0)}}function ct(){const e=this;let t,n,r,s,i=0,o=0,c=0,f=0,a=0,l=0,u=0,w=0,h=0,d=0;function p(e,t,n,r,s,i,o,c){let f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z;d=c.nt,p=c.We,w=o.ot,h=o.ct,y=o.write,m=y<o.read?o.read-y-1:o.end-y,b=$e[e],g=$e[t];do{for(;20>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;if(f=w&b,a=n,l=r,z=3*(l+f),0!==(u=a[z]))for(;;){if(w>>=a[z+1],h-=a[z+1],0!=(16&u)){for(u&=15,k=a[z+2]+(w&$e[u]),w>>=u,h-=u;15>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;for(f=w&g,a=s,l=i,z=3*(l+f),u=a[z];;){if(w>>=a[z+1],h-=a[z+1],0!=(16&u)){for(u&=15;u>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;if(v=a[z+2]+(w&$e[u]),w>>=u,h-=u,m-=k,v>y){S=y-v;do{S+=o.end}while(0>S);if(u=o.end-S,k>u){if(k-=u,y-S>0&&u>y-S)do{o.lt[y++]=o.lt[S++]}while(0!=--u);else o.lt.set(o.lt.subarray(S,S+u),y),y+=u,S+=u,u=0;S=0}}else S=y-v,y-S>0&&2>y-S?(o.lt[y++]=o.lt[S++],o.lt[y++]=o.lt[S++],k-=2):(o.lt.set(o.lt.subarray(S,S+2),y),y+=2,S+=2,k-=2);if(y-S>0&&k>y-S)do{o.lt[y++]=o.lt[S++]}while(0!=--k);else o.lt.set(o.lt.subarray(S,S+k),y),y+=k,S+=k,k=0;break}if(0!=(64&u))return c.Le="invalid distance code",k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,Ye;f+=a[z+2],f+=w&$e[u],z=3*(l+f),u=a[z]}break}if(0!=(64&u))return 0!=(32&u)?(k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,1):(c.Le="invalid literal/length code",k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,Ye);if(f+=a[z+2],f+=w&$e[u],z=3*(l+f),0===(u=a[z])){w>>=a[z+1],h-=a[z+1],o.lt[y++]=a[z+2],m--;break}}else w>>=a[z+1],h-=a[z+1],o.lt[y++]=a[z+2],m--}while(m>=258&&p>=10);return k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,0}e.init=(e,i,o,c,f,a)=>{t=0,u=e,w=i,r=o,h=c,s=f,d=a,n=null},e.ut=(e,y,m)=>{let b,g,k,v,S,z,C,x=0,_=0,A=0;for(A=y.nt,v=y.We,x=e.ot,_=e.ct,S=e.write,z=S<e.read?e.read-S-1:e.end-S;;)switch(t){case 0:if(z>=258&&v>=10&&(e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,m=p(u,w,r,h,s,d,e,y),A=y.nt,v=y.We,x=e.ot,_=e.ct,S=e.write,z=S<e.read?e.read-S-1:e.end-S,0!=m)){t=1==m?7:9;break}c=u,n=r,o=h,t=1;case 1:for(b=c;b>_;){if(0===v)return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(A++))<<_,_+=8}if(g=3*(o+(x&$e[b])),x>>>=n[g+1],_-=n[g+1],k=n[g],0===k){f=n[g+2],t=6;break}if(0!=(16&k)){a=15&k,i=n[g+2],t=2;break}if(0==(64&k)){c=k,o=g/3+n[g+2];break}if(0!=(32&k)){t=7;break}return t=9,y.Le="invalid literal/length code",m=Ye,e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);case 2:for(b=a;b>_;){if(0===v)return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(A++))<<_,_+=8}i+=x&$e[b],x>>=b,_-=b,c=w,n=s,o=d,t=3;case 3:for(b=c;b>_;){if(0===v)return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(A++))<<_,_+=8}if(g=3*(o+(x&$e[b])),x>>=n[g+1],_-=n[g+1],k=n[g],0!=(16&k)){a=15&k,l=n[g+2],t=4;break}if(0==(64&k)){c=k,o=g/3+n[g+2];break}return t=9,y.Le="invalid distance code",m=Ye,e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);case 4:for(b=a;b>_;){if(0===v)return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(A++))<<_,_+=8}l+=x&$e[b],x>>=b,_-=b,t=5;case 5:for(C=S-l;0>C;)C+=e.end;for(;0!==i;){if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);e.lt[S++]=e.lt[C++],z--,C==e.end&&(C=0),i--}t=0;break;case 6:if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);m=0,e.lt[S++]=f,z--,t=0;break;case 7:if(_>7&&(_-=8,v++,A--),e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,e.read!=e.write)return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);t=8;case 8:return m=1,e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);case 9:return m=Ye,e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);default:return m=Xe,e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m)}},e.ht=()=>{}}ot.dt=(e,t,n,r)=>(e[0]=9,t[0]=5,n[0]=et,r[0]=tt,0);const ft=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function at(e,t){const n=this;let r,s=0,o=0,c=0,a=0;const l=[0],u=[0],w=new ct;let h=0,d=new f(4320);const p=new ot;n.ct=0,n.ot=0,n.lt=new i(t),n.end=t,n.read=0,n.write=0,n.reset=(e,t)=>{t&&(t[0]=0),6==s&&w.ht(e),s=0,n.ct=0,n.ot=0,n.read=n.write=0},n.reset(e,null),n.wt=(e,t)=>{let r,s,i;return s=e.rt,i=n.read,r=(i>n.write?n.end:n.write)-i,r>e.tt&&(r=e.tt),0!==r&&t==Ze&&(t=0),e.tt-=r,e.Ge+=r,e.$e.set(n.lt.subarray(i,i+r),s),s+=r,i+=r,i==n.end&&(i=0,n.write==n.end&&(n.write=0),r=n.write-i,r>e.tt&&(r=e.tt),0!==r&&t==Ze&&(t=0),e.tt-=r,e.Ge+=r,e.$e.set(n.lt.subarray(i,i+r),s),s+=r,i+=r),e.rt=s,n.read=i,t},n.ut=(e,t)=>{let i,f,y,m,b,g,k,v;for(m=e.nt,b=e.We,f=n.ot,y=n.ct,g=n.write,k=g<n.read?n.read-g-1:n.end-g;;){let S,z,C,x,_,A,I,D;switch(s){case 0:for(;3>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}switch(i=7&f,h=1&i,i>>>1){case 0:f>>>=3,y-=3,i=7&y,f>>>=i,y-=i,s=1;break;case 1:S=[],z=[],C=[[]],x=[[]],ot.dt(S,z,C,x),w.init(S[0],z[0],C[0],0,x[0],0),f>>>=3,y-=3,s=6;break;case 2:f>>>=3,y-=3,s=3;break;case 3:return f>>>=3,y-=3,s=9,e.Le="invalid block type",t=Ye,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t)}break;case 1:for(;32>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if((~f>>>16&65535)!=(65535&f))return s=9,e.Le="invalid stored block lengths",t=Ye,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);o=65535&f,f=y=0,s=0!==o?2:0!==h?7:0;break;case 2:if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(0===k&&(g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k&&(n.write=g,t=n.wt(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k)))return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(t=0,i=o,i>b&&(i=b),i>k&&(i=k),n.lt.set(e.je(m,i),g),m+=i,b-=i,g+=i,k-=i,0!=(o-=i))break;s=0!==h?7:0;break;case 3:for(;14>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(c=i=16383&f,(31&i)>29||(i>>5&31)>29)return s=9,e.Le="too many length or distance symbols",t=Ye,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(i=258+(31&i)+(i>>5&31),!r||r.length<i)r=[];else for(v=0;i>v;v++)r[v]=0;f>>>=14,y-=14,a=0,s=4;case 4:for(;4+(c>>>10)>a;){for(;3>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}r[ft[a++]]=7&f,f>>>=3,y-=3}for(;19>a;)r[ft[a++]]=0;if(l[0]=7,i=p.st(r,l,u,d,e),0!=i)return(t=i)==Ye&&(r=null,s=9),n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);a=0,s=5;case 5:for(;i=c,258+(31&i)+(i>>5&31)>a;){let o,w;for(i=l[0];i>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(i=d[3*(u[0]+(f&$e[i]))+1],w=d[3*(u[0]+(f&$e[i]))+2],16>w)f>>>=i,y-=i,r[a++]=w;else{for(v=18==w?7:w-14,o=18==w?11:3;i+v>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(f>>>=i,y-=i,o+=f&$e[v],f>>>=v,y-=v,v=a,i=c,v+o>258+(31&i)+(i>>5&31)||16==w&&1>v)return r=null,s=9,e.Le="invalid bit length repeat",t=Ye,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);w=16==w?r[v-1]:0;do{r[v++]=w}while(0!=--o);a=v}}if(u[0]=-1,_=[],A=[],I=[],D=[],_[0]=9,A[0]=6,i=c,i=p.it(257+(31&i),1+(i>>5&31),r,_,A,I,D,d,e),0!=i)return i==Ye&&(r=null,s=9),t=i,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);w.init(_[0],A[0],d,I[0],d,D[0]),s=6;case 6:if(n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,1!=(t=w.ut(n,e,t)))return n.wt(e,t);if(t=0,w.ht(e),m=e.nt,b=e.We,f=n.ot,y=n.ct,g=n.write,k=g<n.read?n.read-g-1:n.end-g,0===h){s=0;break}s=7;case 7:if(n.write=g,t=n.wt(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,n.read!=n.write)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);s=8;case 8:return t=1,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);case 9:return t=Ye,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);default:return t=Xe,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t)}}},n.ht=e=>{n.reset(e,null),n.lt=null,d=null},n.yt=(e,t,r)=>{n.lt.set(e.subarray(t,t+r),0),n.read=n.write=r},n.bt=()=>1==s?1:0}const lt=13,ut=[0,0,255,255];function wt(){const e=this;function t(e){return e&&e.gt?(e.qe=e.Ge=0,e.Le=null,e.gt.mode=7,e.gt.kt.reset(e,null),0):Xe}e.mode=0,e.method=0,e.vt=[0],e.St=0,e.marker=0,e.zt=0,e.Ct=t=>(e.kt&&e.kt.ht(t),e.kt=null,0),e.xt=(n,r)=>(n.Le=null,e.kt=null,8>r||r>15?(e.Ct(n),Xe):(e.zt=r,n.gt.kt=new at(n,1<<r),t(n),0)),e._t=(e,t)=>{let n,r;if(!e||!e.gt||!e.et)return Xe;const s=e.gt;for(t=4==t?Ze:0,n=Ze;;)switch(s.mode){case 0:if(0===e.We)return n;if(n=t,e.We--,e.qe++,8!=(15&(s.method=e.ft(e.nt++)))){s.mode=lt,e.Le="unknown compression method",s.marker=5;break}if(8+(s.method>>4)>s.zt){s.mode=lt,e.Le="invalid win size",s.marker=5;break}s.mode=1;case 1:if(0===e.We)return n;if(n=t,e.We--,e.qe++,r=255&e.ft(e.nt++),((s.method<<8)+r)%31!=0){s.mode=lt,e.Le="incorrect header check",s.marker=5;break}if(0==(32&r)){s.mode=7;break}s.mode=2;case 2:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St=(255&e.ft(e.nt++))<<24&4278190080,s.mode=3;case 3:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St+=(255&e.ft(e.nt++))<<16&16711680,s.mode=4;case 4:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St+=(255&e.ft(e.nt++))<<8&65280,s.mode=5;case 5:return 0===e.We?n:(n=t,e.We--,e.qe++,s.St+=255&e.ft(e.nt++),s.mode=6,2);case 6:return s.mode=lt,e.Le="need dictionary",s.marker=0,Xe;case 7:if(n=s.kt.ut(e,n),n==Ye){s.mode=lt,s.marker=0;break}if(0==n&&(n=t),1!=n)return n;n=t,s.kt.reset(e,s.vt),s.mode=12;case 12:return e.We=0,1;case lt:return Ye;default:return Xe}},e.At=(e,t,n)=>{let r=0,s=n;if(!e||!e.gt||6!=e.gt.mode)return Xe;const i=e.gt;return s<1<<i.zt||(s=(1<<i.zt)-1,r=n-s),i.kt.yt(t,r,s),i.mode=7,0},e.It=e=>{let n,r,s,i,o;if(!e||!e.gt)return Xe;const c=e.gt;if(c.mode!=lt&&(c.mode=lt,c.marker=0),0===(n=e.We))return Ze;for(r=e.nt,s=c.marker;0!==n&&4>s;)e.ft(r)==ut[s]?s++:s=0!==e.ft(r)?0:4-s,r++,n--;return e.qe+=r-e.nt,e.nt=r,e.We=n,c.marker=s,4!=s?Ye:(i=e.qe,o=e.Ge,t(e),e.qe=i,e.Ge=o,c.mode=7,0)},e.Dt=e=>e&&e.gt&&e.gt.kt?e.gt.kt.bt():Xe}function ht(){}function dt(e){const t=new ht,n=e&&e.chunkSize?r.floor(2*e.chunkSize):131072,o=new i(n);let c=!1;t.xt(),t.$e=o,this.append=(e,r)=>{const f=[];let a,l,u=0,w=0,h=0;if(0!==e.length){t.nt=0,t.et=e,t.We=e.length;do{if(t.rt=0,t.tt=n,0!==t.We||c||(t.nt=0,c=!0),a=t._t(0),c&&a===Ze){if(0!==t.We)throw new s("inflating: bad input")}else if(0!==a&&1!==a)throw new s("inflating: "+t.Le);if((c||1===a)&&t.We===e.length)throw new s("inflating: bad input");t.rt&&(t.rt===n?f.push(new i(o)):f.push(o.slice(0,t.rt))),h+=t.rt,r&&t.nt>0&&t.nt!=u&&(r(t.nt),u=t.nt)}while(t.We>0||0===t.tt);return f.length>1?(l=new i(h),f.forEach((e=>{l.set(e,w),w+=e.length}))):l=f[0]||new i,l}},this.flush=()=>{t.Ct()}}ht.prototype={xt(e){const t=this;return t.gt=new wt,e||(e=15),t.gt.xt(t,e)},_t(e){const t=this;return t.gt?t.gt._t(t,e):Xe},Ct(){const e=this;if(!e.gt)return Xe;const t=e.gt.Ct(e);return e.gt=null,t},It(){const e=this;return e.gt?e.gt.It(e):Xe},At(e,t){const n=this;return n.gt?n.gt.At(n,e,t):Xe},ft(e){return this.et[e]},je(e,t){return this.et.subarray(e,e+t)}},self.initCodec=()=>{self.Deflate=Qe,self.Inflate=dt};\n'], { type: "text/javascript" }));
  e3({ workerScripts: { inflate: [t2], deflate: [t2] } });
}
var init_z_worker_inline = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/z-worker-inline.js"() {
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/util/stream-codec-shim.js
function initShimAsyncCodec(library, options = {}, registerDataHandler) {
  return {
    Deflate: createCodecClass(library.Deflate, options.deflate, registerDataHandler),
    Inflate: createCodecClass(library.Inflate, options.inflate, registerDataHandler)
  };
}
function createCodecClass(constructor, constructorOptions, registerDataHandler) {
  return class {
    constructor(options) {
      const codecAdapter = this;
      const onData = (data2) => {
        if (codecAdapter.pendingData) {
          const previousPendingData = codecAdapter.pendingData;
          codecAdapter.pendingData = new Uint8Array(previousPendingData.length + data2.length);
          const { pendingData } = codecAdapter;
          pendingData.set(previousPendingData, 0);
          pendingData.set(data2, previousPendingData.length);
        } else {
          codecAdapter.pendingData = new Uint8Array(data2);
        }
      };
      if (Object.hasOwn(options, "level") && options.level === void 0) {
        delete options.level;
      }
      codecAdapter.codec = new constructor(Object.assign({}, constructorOptions, options));
      registerDataHandler(codecAdapter.codec, onData);
    }
    append(data2) {
      this.codec.push(data2);
      return getResponse(this);
    }
    flush() {
      this.codec.push(new Uint8Array(), true);
      return getResponse(this);
    }
  };
  function getResponse(codec2) {
    if (codec2.pendingData) {
      const output = codec2.pendingData;
      codec2.pendingData = null;
      return output;
    } else {
      return new Uint8Array();
    }
  }
}
var init_stream_codec_shim = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/util/stream-codec-shim.js"() {
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/io.js
function createHtpReader(httpReader, url, options) {
  const {
    preventHeadRequest,
    useRangeHeader,
    forceRangeRequests
  } = options;
  options = Object.assign({}, options);
  delete options.preventHeadRequest;
  delete options.useRangeHeader;
  delete options.forceRangeRequests;
  delete options.useXHR;
  Object.assign(httpReader, {
    url,
    options,
    preventHeadRequest,
    useRangeHeader,
    forceRangeRequests
  });
}
async function initHttpReader(httpReader, sendRequest, getRequestData2) {
  const {
    url,
    useRangeHeader,
    forceRangeRequests
  } = httpReader;
  if (isHttpFamily(url) && (useRangeHeader || forceRangeRequests)) {
    const { headers } = await sendRequest(HTTP_METHOD_GET, httpReader, getRangeHeaders(httpReader));
    if (!forceRangeRequests && headers.get(HTTP_HEADER_ACCEPT_RANGES) != HTTP_RANGE_UNIT) {
      throw new Error(ERR_HTTP_RANGE);
    } else {
      let contentSize;
      const contentRangeHeader = headers.get(HTTP_HEADER_CONTENT_RANGE);
      if (contentRangeHeader) {
        const splitHeader = contentRangeHeader.trim().split(/\s*\/\s*/);
        if (splitHeader.length) {
          const headerValue = splitHeader[1];
          if (headerValue && headerValue != "*") {
            contentSize = Number(headerValue);
          }
        }
      }
      if (contentSize === UNDEFINED_VALUE) {
        await getContentLength(httpReader, sendRequest, getRequestData2);
      } else {
        httpReader.size = contentSize;
      }
    }
  } else {
    await getContentLength(httpReader, sendRequest, getRequestData2);
  }
}
async function readUint8ArrayHttpReader(httpReader, index, length, sendRequest, getRequestData2) {
  const {
    useRangeHeader,
    forceRangeRequests,
    options
  } = httpReader;
  if (useRangeHeader || forceRangeRequests) {
    const response = await sendRequest(HTTP_METHOD_GET, httpReader, getRangeHeaders(httpReader, index, length));
    if (response.status != 206) {
      throw new Error(ERR_HTTP_RANGE);
    }
    return new Uint8Array(await response.arrayBuffer());
  } else {
    const { data: data2 } = httpReader;
    if (!data2) {
      await getRequestData2(httpReader, options);
    }
    return new Uint8Array(httpReader.data.subarray(index, index + length));
  }
}
function getRangeHeaders(httpReader, index = 0, length = 1) {
  return Object.assign({}, getHeaders(httpReader), { [HTTP_HEADER_RANGE]: HTTP_RANGE_UNIT + "=" + index + "-" + (index + length - 1) });
}
function getHeaders({ options }) {
  const { headers } = options;
  if (headers) {
    if (Symbol.iterator in headers) {
      return Object.fromEntries(headers);
    } else {
      return headers;
    }
  }
}
async function getFetchRequestData(httpReader) {
  await getRequestData(httpReader, sendFetchRequest);
}
async function getXMLHttpRequestData(httpReader) {
  await getRequestData(httpReader, sendXMLHttpRequest);
}
async function getRequestData(httpReader, sendRequest) {
  const response = await sendRequest(HTTP_METHOD_GET, httpReader, getHeaders(httpReader));
  httpReader.data = new Uint8Array(await response.arrayBuffer());
  if (!httpReader.size) {
    httpReader.size = httpReader.data.length;
  }
}
async function getContentLength(httpReader, sendRequest, getRequestData2) {
  if (httpReader.preventHeadRequest) {
    await getRequestData2(httpReader, httpReader.options);
  } else {
    const response = await sendRequest(HTTP_METHOD_HEAD, httpReader, getHeaders(httpReader));
    const contentLength = response.headers.get(HTTP_HEADER_CONTENT_LENGTH);
    if (contentLength) {
      httpReader.size = Number(contentLength);
    } else {
      await getRequestData2(httpReader, httpReader.options);
    }
  }
}
async function sendFetchRequest(method, { options, url }, headers) {
  const response = await fetch(url, Object.assign({}, options, { method, headers }));
  if (response.status < 400) {
    return response;
  } else {
    throw response.status == 416 ? new Error(ERR_HTTP_RANGE) : new Error(ERR_HTTP_STATUS + (response.statusText || response.status));
  }
}
function sendXMLHttpRequest(method, { url }, headers) {
  return new Promise((resolve, reject) => {
    const request = new XMLHttpRequest();
    request.addEventListener("load", () => {
      if (request.status < 400) {
        const headers2 = [];
        request.getAllResponseHeaders().trim().split(/[\r\n]+/).forEach((header) => {
          const splitHeader = header.trim().split(/\s*:\s*/);
          splitHeader[0] = splitHeader[0].trim().replace(/^[a-z]|-[a-z]/g, (value) => value.toUpperCase());
          headers2.push(splitHeader);
        });
        resolve({
          status: request.status,
          arrayBuffer: () => request.response,
          headers: new Map(headers2)
        });
      } else {
        reject(request.status == 416 ? new Error(ERR_HTTP_RANGE) : new Error(ERR_HTTP_STATUS + (request.statusText || request.status)));
      }
    }, false);
    request.addEventListener("error", (event) => reject(event.detail.error), false);
    request.open(method, url);
    if (headers) {
      for (const entry of Object.entries(headers)) {
        request.setRequestHeader(entry[0], entry[1]);
      }
    }
    request.responseType = "arraybuffer";
    request.send();
  });
}
function isHttpFamily(url) {
  const { baseURL: baseURL2 } = getConfiguration();
  const { protocol } = new URL(url, baseURL2);
  return protocol == "http:" || protocol == "https:";
}
async function initStream(stream, initSize) {
  if (stream.init && !stream.initialized) {
    await stream.init(initSize);
  }
}
function initReader(reader) {
  if (Array.isArray(reader)) {
    reader = new SplitDataReader(reader);
  }
  if (reader instanceof ReadableStream) {
    reader = {
      readable: reader
    };
  }
  return reader;
}
function initWriter(writer) {
  if (writer.writable === UNDEFINED_VALUE && typeof writer.next == FUNCTION_TYPE) {
    writer = new SplitDataWriter(writer);
  }
  if (writer instanceof WritableStream) {
    writer = {
      writable: writer
    };
  }
  const { writable } = writer;
  if (writable.size === UNDEFINED_VALUE) {
    writable.size = 0;
  }
  const splitZipFile = writer instanceof SplitDataWriter;
  if (!splitZipFile) {
    Object.assign(writer, {
      diskNumber: 0,
      diskOffset: 0,
      availableSize: Infinity,
      maxSize: Infinity
    });
  }
  return writer;
}
function readUint8Array(reader, offset, size, diskNumber) {
  return reader.readUint8Array(offset, size, diskNumber);
}
var ERR_HTTP_STATUS, ERR_HTTP_RANGE, ERR_ITERATOR_COMPLETED_TOO_SOON, CONTENT_TYPE_TEXT_PLAIN, HTTP_HEADER_CONTENT_LENGTH, HTTP_HEADER_CONTENT_RANGE, HTTP_HEADER_ACCEPT_RANGES, HTTP_HEADER_RANGE, HTTP_HEADER_CONTENT_TYPE, HTTP_METHOD_HEAD, HTTP_METHOD_GET, HTTP_RANGE_UNIT, DEFAULT_CHUNK_SIZE, PROPERTY_NAME_WRITABLE, Stream, Reader, Writer, Data64URIReader, Data64URIWriter, BlobReader, BlobWriter, TextReader, TextWriter, FetchReader, XHRReader, HttpReader, HttpRangeReader, Uint8ArrayReader, Uint8ArrayWriter, SplitDataReader, SplitDataWriter, SplitZipReader, SplitZipWriter;
var init_io = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/io.js"() {
    init_constants();
    init_configuration();
    ERR_HTTP_STATUS = "HTTP error ";
    ERR_HTTP_RANGE = "HTTP Range not supported";
    ERR_ITERATOR_COMPLETED_TOO_SOON = "Writer iterator completed too soon";
    CONTENT_TYPE_TEXT_PLAIN = "text/plain";
    HTTP_HEADER_CONTENT_LENGTH = "Content-Length";
    HTTP_HEADER_CONTENT_RANGE = "Content-Range";
    HTTP_HEADER_ACCEPT_RANGES = "Accept-Ranges";
    HTTP_HEADER_RANGE = "Range";
    HTTP_HEADER_CONTENT_TYPE = "Content-Type";
    HTTP_METHOD_HEAD = "HEAD";
    HTTP_METHOD_GET = "GET";
    HTTP_RANGE_UNIT = "bytes";
    DEFAULT_CHUNK_SIZE = 64 * 1024;
    PROPERTY_NAME_WRITABLE = "writable";
    Stream = class {
      constructor() {
        this.size = 0;
      }
      init() {
        this.initialized = true;
      }
    };
    Reader = class extends Stream {
      get readable() {
        const reader = this;
        const { chunkSize = DEFAULT_CHUNK_SIZE } = reader;
        const readable = new ReadableStream({
          start() {
            this.chunkOffset = 0;
          },
          async pull(controller) {
            const { offset = 0, size, diskNumberStart } = readable;
            const { chunkOffset } = this;
            controller.enqueue(await readUint8Array(reader, offset + chunkOffset, Math.min(chunkSize, size - chunkOffset), diskNumberStart));
            if (chunkOffset + chunkSize > size) {
              controller.close();
            } else {
              this.chunkOffset += chunkSize;
            }
          }
        });
        return readable;
      }
    };
    Writer = class extends Stream {
      constructor() {
        super();
        const writer = this;
        const writable = new WritableStream({
          write(chunk) {
            return writer.writeUint8Array(chunk);
          }
        });
        Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {
          get() {
            return writable;
          }
        });
      }
      writeUint8Array() {
      }
    };
    Data64URIReader = class extends Reader {
      constructor(dataURI) {
        super();
        let dataEnd = dataURI.length;
        while (dataURI.charAt(dataEnd - 1) == "=") {
          dataEnd--;
        }
        const dataStart = dataURI.indexOf(",") + 1;
        Object.assign(this, {
          dataURI,
          dataStart,
          size: Math.floor((dataEnd - dataStart) * 0.75)
        });
      }
      readUint8Array(offset, length) {
        const {
          dataStart,
          dataURI
        } = this;
        const dataArray = new Uint8Array(length);
        const start = Math.floor(offset / 3) * 4;
        const bytes = atob(dataURI.substring(start + dataStart, Math.ceil((offset + length) / 3) * 4 + dataStart));
        const delta = offset - Math.floor(start / 4) * 3;
        for (let indexByte = delta; indexByte < delta + length; indexByte++) {
          dataArray[indexByte - delta] = bytes.charCodeAt(indexByte);
        }
        return dataArray;
      }
    };
    Data64URIWriter = class extends Writer {
      constructor(contentType) {
        super();
        Object.assign(this, {
          data: "data:" + (contentType || "") + ";base64,",
          pending: []
        });
      }
      writeUint8Array(array) {
        const writer = this;
        let indexArray = 0;
        let dataString = writer.pending;
        const delta = writer.pending.length;
        writer.pending = "";
        for (indexArray = 0; indexArray < Math.floor((delta + array.length) / 3) * 3 - delta; indexArray++) {
          dataString += String.fromCharCode(array[indexArray]);
        }
        for (; indexArray < array.length; indexArray++) {
          writer.pending += String.fromCharCode(array[indexArray]);
        }
        if (dataString.length > 2) {
          writer.data += btoa(dataString);
        } else {
          writer.pending = dataString;
        }
      }
      getData() {
        return this.data + btoa(this.pending);
      }
    };
    BlobReader = class extends Reader {
      constructor(blob) {
        super();
        Object.assign(this, {
          blob,
          size: blob.size
        });
      }
      async readUint8Array(offset, length) {
        const reader = this;
        const offsetEnd = offset + length;
        const blob = offset || offsetEnd < reader.size ? reader.blob.slice(offset, offsetEnd) : reader.blob;
        return new Uint8Array(await blob.arrayBuffer());
      }
    };
    BlobWriter = class extends Stream {
      constructor(contentType) {
        super();
        const writer = this;
        const transformStream = new TransformStream();
        const headers = [];
        if (contentType) {
          headers.push([HTTP_HEADER_CONTENT_TYPE, contentType]);
        }
        Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {
          get() {
            return transformStream.writable;
          }
        });
        writer.blob = new Response(transformStream.readable, { headers }).blob();
      }
      getData() {
        return this.blob;
      }
    };
    TextReader = class extends BlobReader {
      constructor(text) {
        super(new Blob([text], { type: CONTENT_TYPE_TEXT_PLAIN }));
      }
    };
    TextWriter = class extends BlobWriter {
      constructor(encoding) {
        super(encoding);
        Object.assign(this, {
          encoding,
          utf8: !encoding || encoding.toLowerCase() == "utf-8"
        });
      }
      async getData() {
        const {
          encoding,
          utf8
        } = this;
        const blob = await super.getData();
        if (blob.text && utf8) {
          return blob.text();
        } else {
          const reader = new FileReader();
          return new Promise((resolve, reject) => {
            Object.assign(reader, {
              onload: ({ target }) => resolve(target.result),
              onerror: () => reject(reader.error)
            });
            reader.readAsText(blob, encoding);
          });
        }
      }
    };
    FetchReader = class extends Reader {
      constructor(url, options) {
        super();
        createHtpReader(this, url, options);
      }
      async init() {
        await initHttpReader(this, sendFetchRequest, getFetchRequestData);
        super.init();
      }
      readUint8Array(index, length) {
        return readUint8ArrayHttpReader(this, index, length, sendFetchRequest, getFetchRequestData);
      }
    };
    XHRReader = class extends Reader {
      constructor(url, options) {
        super();
        createHtpReader(this, url, options);
      }
      async init() {
        await initHttpReader(this, sendXMLHttpRequest, getXMLHttpRequestData);
        super.init();
      }
      readUint8Array(index, length) {
        return readUint8ArrayHttpReader(this, index, length, sendXMLHttpRequest, getXMLHttpRequestData);
      }
    };
    HttpReader = class extends Reader {
      constructor(url, options = {}) {
        super();
        Object.assign(this, {
          url,
          reader: options.useXHR ? new XHRReader(url, options) : new FetchReader(url, options)
        });
      }
      set size(value) {
      }
      get size() {
        return this.reader.size;
      }
      async init() {
        await this.reader.init();
        super.init();
      }
      readUint8Array(index, length) {
        return this.reader.readUint8Array(index, length);
      }
    };
    HttpRangeReader = class extends HttpReader {
      constructor(url, options = {}) {
        options.useRangeHeader = true;
        super(url, options);
      }
    };
    Uint8ArrayReader = class extends Reader {
      constructor(array) {
        super();
        Object.assign(this, {
          array,
          size: array.length
        });
      }
      readUint8Array(index, length) {
        return this.array.slice(index, index + length);
      }
    };
    Uint8ArrayWriter = class extends Writer {
      init(initSize = 0) {
        Object.assign(this, {
          offset: 0,
          array: new Uint8Array(initSize)
        });
        super.init();
      }
      writeUint8Array(array) {
        const writer = this;
        if (writer.offset + array.length > writer.array.length) {
          const previousArray = writer.array;
          writer.array = new Uint8Array(previousArray.length + array.length);
          writer.array.set(previousArray);
        }
        writer.array.set(array, writer.offset);
        writer.offset += array.length;
      }
      getData() {
        return this.array;
      }
    };
    SplitDataReader = class extends Reader {
      constructor(readers) {
        super();
        this.readers = readers;
      }
      async init() {
        const reader = this;
        const { readers } = reader;
        reader.lastDiskNumber = 0;
        await Promise.all(readers.map(async (diskReader) => {
          await diskReader.init();
          reader.size += diskReader.size;
        }));
        super.init();
      }
      async readUint8Array(offset, length, diskNumber = 0) {
        const reader = this;
        const { readers } = this;
        let result;
        let currentDiskNumber = diskNumber;
        if (currentDiskNumber == -1) {
          currentDiskNumber = readers.length - 1;
        }
        let currentReaderOffset = offset;
        while (currentReaderOffset >= readers[currentDiskNumber].size) {
          currentReaderOffset -= readers[currentDiskNumber].size;
          currentDiskNumber++;
        }
        const currentReader = readers[currentDiskNumber];
        const currentReaderSize = currentReader.size;
        if (currentReaderOffset + length <= currentReaderSize) {
          result = await readUint8Array(currentReader, currentReaderOffset, length);
        } else {
          const chunkLength = currentReaderSize - currentReaderOffset;
          result = new Uint8Array(length);
          result.set(await readUint8Array(currentReader, currentReaderOffset, chunkLength));
          result.set(await reader.readUint8Array(offset + chunkLength, length - chunkLength, diskNumber), chunkLength);
        }
        reader.lastDiskNumber = Math.max(currentDiskNumber, reader.lastDiskNumber);
        return result;
      }
    };
    SplitDataWriter = class extends Stream {
      constructor(writerGenerator, maxSize = 4294967295) {
        super();
        const zipWriter = this;
        Object.assign(zipWriter, {
          diskNumber: 0,
          diskOffset: 0,
          size: 0,
          maxSize,
          availableSize: maxSize
        });
        let diskSourceWriter, diskWritable, diskWriter;
        const writable = new WritableStream({
          async write(chunk) {
            const { availableSize } = zipWriter;
            if (!diskWriter) {
              const { value, done } = await writerGenerator.next();
              if (done && !value) {
                throw new Error(ERR_ITERATOR_COMPLETED_TOO_SOON);
              } else {
                diskSourceWriter = value;
                diskSourceWriter.size = 0;
                if (diskSourceWriter.maxSize) {
                  zipWriter.maxSize = diskSourceWriter.maxSize;
                }
                zipWriter.availableSize = zipWriter.maxSize;
                await initStream(diskSourceWriter);
                diskWritable = value.writable;
                diskWriter = diskWritable.getWriter();
              }
              await this.write(chunk);
            } else if (chunk.length >= availableSize) {
              await writeChunk(chunk.slice(0, availableSize));
              await closeDisk();
              zipWriter.diskOffset += diskSourceWriter.size;
              zipWriter.diskNumber++;
              diskWriter = null;
              await this.write(chunk.slice(availableSize));
            } else {
              await writeChunk(chunk);
            }
          },
          async close() {
            await diskWriter.ready;
            await closeDisk();
          }
        });
        Object.defineProperty(zipWriter, PROPERTY_NAME_WRITABLE, {
          get() {
            return writable;
          }
        });
        async function writeChunk(chunk) {
          const chunkLength = chunk.length;
          if (chunkLength) {
            await diskWriter.ready;
            await diskWriter.write(chunk);
            diskSourceWriter.size += chunkLength;
            zipWriter.size += chunkLength;
            zipWriter.availableSize -= chunkLength;
          }
        }
        async function closeDisk() {
          diskWritable.size = diskSourceWriter.size;
          await diskWriter.close();
        }
      }
    };
    SplitZipReader = SplitDataReader;
    SplitZipWriter = SplitDataWriter;
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/util/cp437-decode.js
function decodeCP437(stringValue) {
  if (VALID_CP437) {
    let result = "";
    for (let indexCharacter = 0; indexCharacter < stringValue.length; indexCharacter++) {
      result += CP437[stringValue[indexCharacter]];
    }
    return result;
  } else {
    return new TextDecoder().decode(stringValue);
  }
}
var CP437, VALID_CP437;
var init_cp437_decode = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/util/cp437-decode.js"() {
    CP437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0 ".split("");
    VALID_CP437 = CP437.length == 256;
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/util/decode-text.js
function decodeText(value, encoding) {
  if (encoding && encoding.trim().toLowerCase() == "cp437") {
    return decodeCP437(value);
  } else {
    return new TextDecoder(encoding).decode(value);
  }
}
var init_decode_text = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/util/decode-text.js"() {
    init_cp437_decode();
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/zip-entry.js
var PROPERTY_NAME_FILENAME, PROPERTY_NAME_RAW_FILENAME, PROPERTY_NAME_COMMENT, PROPERTY_NAME_RAW_COMMENT, PROPERTY_NAME_UNCOMPPRESSED_SIZE, PROPERTY_NAME_COMPPRESSED_SIZE, PROPERTY_NAME_OFFSET, PROPERTY_NAME_DISK_NUMBER_START, PROPERTY_NAME_LAST_MODIFICATION_DATE, PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE, PROPERTY_NAME_LAST_ACCESS_DATE, PROPERTY_NAME_RAW_LAST_ACCESS_DATE, PROPERTY_NAME_CREATION_DATE, PROPERTY_NAME_RAW_CREATION_DATE, PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE, PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE, PROPERTY_NAME_MS_DOS_COMPATIBLE, PROPERTY_NAME_ZIP64, PROPERTY_NAMES, Entry;
var init_zip_entry = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/zip-entry.js"() {
    PROPERTY_NAME_FILENAME = "filename";
    PROPERTY_NAME_RAW_FILENAME = "rawFilename";
    PROPERTY_NAME_COMMENT = "comment";
    PROPERTY_NAME_RAW_COMMENT = "rawComment";
    PROPERTY_NAME_UNCOMPPRESSED_SIZE = "uncompressedSize";
    PROPERTY_NAME_COMPPRESSED_SIZE = "compressedSize";
    PROPERTY_NAME_OFFSET = "offset";
    PROPERTY_NAME_DISK_NUMBER_START = "diskNumberStart";
    PROPERTY_NAME_LAST_MODIFICATION_DATE = "lastModDate";
    PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE = "rawLastModDate";
    PROPERTY_NAME_LAST_ACCESS_DATE = "lastAccessDate";
    PROPERTY_NAME_RAW_LAST_ACCESS_DATE = "rawLastAccessDate";
    PROPERTY_NAME_CREATION_DATE = "creationDate";
    PROPERTY_NAME_RAW_CREATION_DATE = "rawCreationDate";
    PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE = "internalFileAttribute";
    PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE = "externalFileAttribute";
    PROPERTY_NAME_MS_DOS_COMPATIBLE = "msDosCompatible";
    PROPERTY_NAME_ZIP64 = "zip64";
    PROPERTY_NAMES = [
      PROPERTY_NAME_FILENAME,
      PROPERTY_NAME_RAW_FILENAME,
      PROPERTY_NAME_COMPPRESSED_SIZE,
      PROPERTY_NAME_UNCOMPPRESSED_SIZE,
      PROPERTY_NAME_LAST_MODIFICATION_DATE,
      PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE,
      PROPERTY_NAME_COMMENT,
      PROPERTY_NAME_RAW_COMMENT,
      PROPERTY_NAME_LAST_ACCESS_DATE,
      PROPERTY_NAME_CREATION_DATE,
      PROPERTY_NAME_OFFSET,
      PROPERTY_NAME_DISK_NUMBER_START,
      PROPERTY_NAME_DISK_NUMBER_START,
      PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE,
      PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE,
      PROPERTY_NAME_MS_DOS_COMPATIBLE,
      PROPERTY_NAME_ZIP64,
      "directory",
      "bitFlag",
      "encrypted",
      "signature",
      "filenameUTF8",
      "commentUTF8",
      "compressionMethod",
      "version",
      "versionMadeBy",
      "extraField",
      "rawExtraField",
      "extraFieldZip64",
      "extraFieldUnicodePath",
      "extraFieldUnicodeComment",
      "extraFieldAES",
      "extraFieldNTFS",
      "extraFieldExtendedTimestamp"
    ];
    Entry = class {
      constructor(data2) {
        PROPERTY_NAMES.forEach((name) => this[name] = data2[name]);
      }
    };
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/zip-reader.js
function readCommonHeader(directory, dataView, offset) {
  const rawBitFlag = directory.rawBitFlag = getUint16(dataView, offset + 2);
  const encrypted = (rawBitFlag & BITFLAG_ENCRYPTED) == BITFLAG_ENCRYPTED;
  const rawLastModDate = getUint32(dataView, offset + 6);
  Object.assign(directory, {
    encrypted,
    version: getUint16(dataView, offset),
    bitFlag: {
      level: (rawBitFlag & BITFLAG_LEVEL) >> 1,
      dataDescriptor: (rawBitFlag & BITFLAG_DATA_DESCRIPTOR) == BITFLAG_DATA_DESCRIPTOR,
      languageEncodingFlag: (rawBitFlag & BITFLAG_LANG_ENCODING_FLAG) == BITFLAG_LANG_ENCODING_FLAG
    },
    rawLastModDate,
    lastModDate: getDate(rawLastModDate),
    filenameLength: getUint16(dataView, offset + 22),
    extraFieldLength: getUint16(dataView, offset + 24)
  });
}
async function readCommonFooter(fileEntry, directory, dataView, offset) {
  const { rawExtraField } = directory;
  const extraField = directory.extraField = /* @__PURE__ */ new Map();
  const rawExtraFieldView = getDataView(new Uint8Array(rawExtraField));
  let offsetExtraField = 0;
  try {
    while (offsetExtraField < rawExtraField.length) {
      const type = getUint16(rawExtraFieldView, offsetExtraField);
      const size = getUint16(rawExtraFieldView, offsetExtraField + 2);
      extraField.set(type, {
        type,
        data: rawExtraField.slice(offsetExtraField + 4, offsetExtraField + 4 + size)
      });
      offsetExtraField += 4 + size;
    }
  } catch (_error) {
  }
  const compressionMethod = getUint16(dataView, offset + 4);
  Object.assign(directory, {
    signature: getUint32(dataView, offset + 10),
    uncompressedSize: getUint32(dataView, offset + 18),
    compressedSize: getUint32(dataView, offset + 14)
  });
  const extraFieldZip64 = extraField.get(EXTRAFIELD_TYPE_ZIP64);
  if (extraFieldZip64) {
    readExtraFieldZip64(extraFieldZip64, directory);
    directory.extraFieldZip64 = extraFieldZip64;
  }
  const extraFieldUnicodePath = extraField.get(EXTRAFIELD_TYPE_UNICODE_PATH);
  if (extraFieldUnicodePath) {
    await readExtraFieldUnicode(extraFieldUnicodePath, PROPERTY_NAME_FILENAME, PROPERTY_NAME_RAW_FILENAME, directory, fileEntry);
    directory.extraFieldUnicodePath = extraFieldUnicodePath;
  }
  const extraFieldUnicodeComment = extraField.get(EXTRAFIELD_TYPE_UNICODE_COMMENT);
  if (extraFieldUnicodeComment) {
    await readExtraFieldUnicode(extraFieldUnicodeComment, PROPERTY_NAME_COMMENT, PROPERTY_NAME_RAW_COMMENT, directory, fileEntry);
    directory.extraFieldUnicodeComment = extraFieldUnicodeComment;
  }
  const extraFieldAES = extraField.get(EXTRAFIELD_TYPE_AES);
  if (extraFieldAES) {
    readExtraFieldAES(extraFieldAES, directory, compressionMethod);
    directory.extraFieldAES = extraFieldAES;
  } else {
    directory.compressionMethod = compressionMethod;
  }
  const extraFieldNTFS = extraField.get(EXTRAFIELD_TYPE_NTFS);
  if (extraFieldNTFS) {
    readExtraFieldNTFS(extraFieldNTFS, directory);
    directory.extraFieldNTFS = extraFieldNTFS;
  }
  const extraFieldExtendedTimestamp = extraField.get(EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);
  if (extraFieldExtendedTimestamp) {
    readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory);
    directory.extraFieldExtendedTimestamp = extraFieldExtendedTimestamp;
  }
}
function readExtraFieldZip64(extraFieldZip64, directory) {
  directory.zip64 = true;
  const extraFieldView = getDataView(extraFieldZip64.data);
  const missingProperties = ZIP64_PROPERTIES.filter(([propertyName, max]) => directory[propertyName] == max);
  for (let indexMissingProperty = 0, offset = 0; indexMissingProperty < missingProperties.length; indexMissingProperty++) {
    const [propertyName, max] = missingProperties[indexMissingProperty];
    if (directory[propertyName] == max) {
      const extraction = ZIP64_EXTRACTION[max];
      directory[propertyName] = extraFieldZip64[propertyName] = extraction.getValue(extraFieldView, offset);
      offset += extraction.bytes;
    } else if (extraFieldZip64[propertyName]) {
      throw new Error(ERR_EXTRAFIELD_ZIP64_NOT_FOUND);
    }
  }
}
async function readExtraFieldUnicode(extraFieldUnicode, propertyName, rawPropertyName, directory, fileEntry) {
  const extraFieldView = getDataView(extraFieldUnicode.data);
  const crc323 = new Crc32();
  crc323.append(fileEntry[rawPropertyName]);
  const dataViewSignature = getDataView(new Uint8Array(4));
  dataViewSignature.setUint32(0, crc323.get(), true);
  Object.assign(extraFieldUnicode, {
    version: getUint8(extraFieldView, 0),
    signature: getUint32(extraFieldView, 1),
    [propertyName]: await decodeText(extraFieldUnicode.data.subarray(5)),
    valid: !fileEntry.bitFlag.languageEncodingFlag && extraFieldUnicode.signature == getUint32(dataViewSignature, 0)
  });
  if (extraFieldUnicode.valid) {
    directory[propertyName] = extraFieldUnicode[propertyName];
    directory[propertyName + "UTF8"] = true;
  }
}
function readExtraFieldAES(extraFieldAES, directory, compressionMethod) {
  const extraFieldView = getDataView(extraFieldAES.data);
  const strength = getUint8(extraFieldView, 4);
  Object.assign(extraFieldAES, {
    vendorVersion: getUint8(extraFieldView, 0),
    vendorId: getUint8(extraFieldView, 2),
    strength,
    originalCompressionMethod: compressionMethod,
    compressionMethod: getUint16(extraFieldView, 5)
  });
  directory.compressionMethod = extraFieldAES.compressionMethod;
}
function readExtraFieldNTFS(extraFieldNTFS, directory) {
  const extraFieldView = getDataView(extraFieldNTFS.data);
  let offsetExtraField = 4;
  let tag1Data;
  try {
    while (offsetExtraField < extraFieldNTFS.data.length && !tag1Data) {
      const tagValue = getUint16(extraFieldView, offsetExtraField);
      const attributeSize = getUint16(extraFieldView, offsetExtraField + 2);
      if (tagValue == EXTRAFIELD_TYPE_NTFS_TAG1) {
        tag1Data = extraFieldNTFS.data.slice(offsetExtraField + 4, offsetExtraField + 4 + attributeSize);
      }
      offsetExtraField += 4 + attributeSize;
    }
  } catch (_error) {
  }
  try {
    if (tag1Data && tag1Data.length == 24) {
      const tag1View = getDataView(tag1Data);
      const rawLastModDate = tag1View.getBigUint64(0, true);
      const rawLastAccessDate = tag1View.getBigUint64(8, true);
      const rawCreationDate = tag1View.getBigUint64(16, true);
      Object.assign(extraFieldNTFS, {
        rawLastModDate,
        rawLastAccessDate,
        rawCreationDate
      });
      const lastModDate = getDateNTFS(rawLastModDate);
      const lastAccessDate = getDateNTFS(rawLastAccessDate);
      const creationDate = getDateNTFS(rawCreationDate);
      const extraFieldData = { lastModDate, lastAccessDate, creationDate };
      Object.assign(extraFieldNTFS, extraFieldData);
      Object.assign(directory, extraFieldData);
    }
  } catch (_error) {
  }
}
function readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory) {
  const extraFieldView = getDataView(extraFieldExtendedTimestamp.data);
  const flags = getUint8(extraFieldView, 0);
  const timeProperties = [];
  const timeRawProperties = [];
  if ((flags & 1) == 1) {
    timeProperties.push(PROPERTY_NAME_LAST_MODIFICATION_DATE);
    timeRawProperties.push(PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE);
  }
  if ((flags & 2) == 2) {
    timeProperties.push(PROPERTY_NAME_LAST_ACCESS_DATE);
    timeRawProperties.push(PROPERTY_NAME_RAW_LAST_ACCESS_DATE);
  }
  if ((flags & 4) == 4) {
    timeProperties.push(PROPERTY_NAME_CREATION_DATE);
    timeRawProperties.push(PROPERTY_NAME_RAW_CREATION_DATE);
  }
  let offset = 1;
  timeProperties.forEach((propertyName, indexProperty) => {
    if (extraFieldExtendedTimestamp.data.length >= offset + 4) {
      const time = getUint32(extraFieldView, offset);
      directory[propertyName] = extraFieldExtendedTimestamp[propertyName] = new Date(time * 1e3);
      const rawPropertyName = timeRawProperties[indexProperty];
      extraFieldExtendedTimestamp[rawPropertyName] = time;
    }
    offset += 4;
  });
}
async function seekSignature(reader, signature, startOffset, minimumBytes, maximumLength) {
  const signatureArray = new Uint8Array(4);
  const signatureView = getDataView(signatureArray);
  setUint32(signatureView, 0, signature);
  const maximumBytes = minimumBytes + maximumLength;
  return await seek(minimumBytes) || await seek(Math.min(maximumBytes, startOffset));
  async function seek(length) {
    const offset = startOffset - length;
    const bytes = await readUint8Array(reader, offset, length);
    for (let indexByte = bytes.length - minimumBytes; indexByte >= 0; indexByte--) {
      if (bytes[indexByte] == signatureArray[0] && bytes[indexByte + 1] == signatureArray[1] && bytes[indexByte + 2] == signatureArray[2] && bytes[indexByte + 3] == signatureArray[3]) {
        return {
          offset: offset + indexByte,
          buffer: bytes.slice(indexByte, indexByte + minimumBytes).buffer
        };
      }
    }
  }
}
function getOptionValue(zipReader, options, name) {
  return options[name] === UNDEFINED_VALUE ? zipReader.options[name] : options[name];
}
function getDate(timeRaw) {
  const date = (timeRaw & 4294901760) >> 16, time = timeRaw & 65535;
  try {
    return new Date(1980 + ((date & 65024) >> 9), ((date & 480) >> 5) - 1, date & 31, (time & 63488) >> 11, (time & 2016) >> 5, (time & 31) * 2, 0);
  } catch (_error) {
  }
}
function getDateNTFS(timeRaw) {
  return new Date(Number(timeRaw / BigInt(1e4) - BigInt(116444736e5)));
}
function getUint8(view, offset) {
  return view.getUint8(offset);
}
function getUint16(view, offset) {
  return view.getUint16(offset, true);
}
function getUint32(view, offset) {
  return view.getUint32(offset, true);
}
function getBigUint64(view, offset) {
  return Number(view.getBigUint64(offset, true));
}
function setUint32(view, offset, value) {
  view.setUint32(offset, value, true);
}
function getDataView(array) {
  return new DataView(array.buffer);
}
var ERR_BAD_FORMAT, ERR_EOCDR_NOT_FOUND, ERR_EOCDR_ZIP64_NOT_FOUND, ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND, ERR_CENTRAL_DIRECTORY_NOT_FOUND, ERR_LOCAL_FILE_HEADER_NOT_FOUND, ERR_EXTRAFIELD_ZIP64_NOT_FOUND, ERR_ENCRYPTED, ERR_UNSUPPORTED_ENCRYPTION, ERR_UNSUPPORTED_COMPRESSION, ERR_SPLIT_ZIP_FILE, CHARSET_UTF8, CHARSET_CP437, ZIP64_PROPERTIES, ZIP64_EXTRACTION, ZipReader, ZipEntry;
var init_zip_reader = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/zip-reader.js"() {
    init_constants();
    init_configuration();
    init_codec_pool();
    init_io();
    init_decode_text();
    init_crc32();
    init_zip_entry();
    ERR_BAD_FORMAT = "File format is not recognized";
    ERR_EOCDR_NOT_FOUND = "End of central directory not found";
    ERR_EOCDR_ZIP64_NOT_FOUND = "End of Zip64 central directory not found";
    ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND = "End of Zip64 central directory locator not found";
    ERR_CENTRAL_DIRECTORY_NOT_FOUND = "Central directory header not found";
    ERR_LOCAL_FILE_HEADER_NOT_FOUND = "Local file header not found";
    ERR_EXTRAFIELD_ZIP64_NOT_FOUND = "Zip64 extra field not found";
    ERR_ENCRYPTED = "File contains encrypted entry";
    ERR_UNSUPPORTED_ENCRYPTION = "Encryption method not supported";
    ERR_UNSUPPORTED_COMPRESSION = "Compression method not supported";
    ERR_SPLIT_ZIP_FILE = "Split zip file";
    CHARSET_UTF8 = "utf-8";
    CHARSET_CP437 = "cp437";
    ZIP64_PROPERTIES = [
      [PROPERTY_NAME_UNCOMPPRESSED_SIZE, MAX_32_BITS],
      [PROPERTY_NAME_COMPPRESSED_SIZE, MAX_32_BITS],
      [PROPERTY_NAME_OFFSET, MAX_32_BITS],
      [PROPERTY_NAME_DISK_NUMBER_START, MAX_16_BITS]
    ];
    ZIP64_EXTRACTION = {
      [MAX_16_BITS]: {
        getValue: getUint32,
        bytes: 4
      },
      [MAX_32_BITS]: {
        getValue: getBigUint64,
        bytes: 8
      }
    };
    ZipReader = class {
      constructor(reader, options = {}) {
        Object.assign(this, {
          reader: initReader(reader),
          options,
          config: getConfiguration()
        });
      }
      async *getEntriesGenerator(options = {}) {
        const zipReader = this;
        let { reader } = zipReader;
        const { config: config2 } = zipReader;
        await initStream(reader);
        if (reader.size === UNDEFINED_VALUE || !reader.readUint8Array) {
          reader = new BlobReader(await new Response(reader.readable).blob());
          await initStream(reader);
        }
        if (reader.size < END_OF_CENTRAL_DIR_LENGTH) {
          throw new Error(ERR_BAD_FORMAT);
        }
        reader.chunkSize = getChunkSize(config2);
        const endOfDirectoryInfo = await seekSignature(reader, END_OF_CENTRAL_DIR_SIGNATURE, reader.size, END_OF_CENTRAL_DIR_LENGTH, MAX_16_BITS * 16);
        if (!endOfDirectoryInfo) {
          const signatureArray = await readUint8Array(reader, 0, 4);
          const signatureView = getDataView(signatureArray);
          if (getUint32(signatureView) == SPLIT_ZIP_FILE_SIGNATURE) {
            throw new Error(ERR_SPLIT_ZIP_FILE);
          } else {
            throw new Error(ERR_EOCDR_NOT_FOUND);
          }
        }
        const endOfDirectoryView = getDataView(endOfDirectoryInfo);
        let directoryDataLength = getUint32(endOfDirectoryView, 12);
        let directoryDataOffset = getUint32(endOfDirectoryView, 16);
        const commentOffset = endOfDirectoryInfo.offset;
        const commentLength = getUint16(endOfDirectoryView, 20);
        const appendedDataOffset = commentOffset + END_OF_CENTRAL_DIR_LENGTH + commentLength;
        let lastDiskNumber = getUint16(endOfDirectoryView, 4);
        const expectedLastDiskNumber = reader.lastDiskNumber || 0;
        let diskNumber = getUint16(endOfDirectoryView, 6);
        let filesLength = getUint16(endOfDirectoryView, 8);
        let prependedDataLength = 0;
        let startOffset = 0;
        if (directoryDataOffset == MAX_32_BITS || directoryDataLength == MAX_32_BITS || filesLength == MAX_16_BITS || diskNumber == MAX_16_BITS) {
          const endOfDirectoryLocatorArray = await readUint8Array(reader, endOfDirectoryInfo.offset - ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH);
          const endOfDirectoryLocatorView = getDataView(endOfDirectoryLocatorArray);
          if (getUint32(endOfDirectoryLocatorView, 0) != ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE) {
            throw new Error(ERR_EOCDR_ZIP64_NOT_FOUND);
          }
          directoryDataOffset = getBigUint64(endOfDirectoryLocatorView, 8);
          let endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH, -1);
          let endOfDirectoryView2 = getDataView(endOfDirectoryArray);
          const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH - ZIP64_END_OF_CENTRAL_DIR_LENGTH;
          if (getUint32(endOfDirectoryView2, 0) != ZIP64_END_OF_CENTRAL_DIR_SIGNATURE && directoryDataOffset != expectedDirectoryDataOffset) {
            const originalDirectoryDataOffset = directoryDataOffset;
            directoryDataOffset = expectedDirectoryDataOffset;
            prependedDataLength = directoryDataOffset - originalDirectoryDataOffset;
            endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH, -1);
            endOfDirectoryView2 = getDataView(endOfDirectoryArray);
          }
          if (getUint32(endOfDirectoryView2, 0) != ZIP64_END_OF_CENTRAL_DIR_SIGNATURE) {
            throw new Error(ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND);
          }
          if (lastDiskNumber == MAX_16_BITS) {
            lastDiskNumber = getUint32(endOfDirectoryView2, 16);
          }
          if (diskNumber == MAX_16_BITS) {
            diskNumber = getUint32(endOfDirectoryView2, 20);
          }
          if (filesLength == MAX_16_BITS) {
            filesLength = getBigUint64(endOfDirectoryView2, 32);
          }
          if (directoryDataLength == MAX_32_BITS) {
            directoryDataLength = getBigUint64(endOfDirectoryView2, 40);
          }
          directoryDataOffset -= directoryDataLength;
        }
        if (expectedLastDiskNumber != lastDiskNumber) {
          throw new Error(ERR_SPLIT_ZIP_FILE);
        }
        if (directoryDataOffset < 0 || directoryDataOffset >= reader.size) {
          throw new Error(ERR_BAD_FORMAT);
        }
        let offset = 0;
        let directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
        let directoryView = getDataView(directoryArray);
        if (directoryDataLength) {
          const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - directoryDataLength;
          if (getUint32(directoryView, offset) != CENTRAL_FILE_HEADER_SIGNATURE && directoryDataOffset != expectedDirectoryDataOffset) {
            const originalDirectoryDataOffset = directoryDataOffset;
            directoryDataOffset = expectedDirectoryDataOffset;
            prependedDataLength = directoryDataOffset - originalDirectoryDataOffset;
            directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
            directoryView = getDataView(directoryArray);
          }
        }
        if (directoryDataOffset < 0 || directoryDataOffset >= reader.size) {
          throw new Error(ERR_BAD_FORMAT);
        }
        const filenameEncoding = getOptionValue(zipReader, options, "filenameEncoding");
        const commentEncoding = getOptionValue(zipReader, options, "commentEncoding");
        for (let indexFile = 0; indexFile < filesLength; indexFile++) {
          const fileEntry = new ZipEntry(reader, config2, zipReader.options);
          if (getUint32(directoryView, offset) != CENTRAL_FILE_HEADER_SIGNATURE) {
            throw new Error(ERR_CENTRAL_DIRECTORY_NOT_FOUND);
          }
          readCommonHeader(fileEntry, directoryView, offset + 6);
          const languageEncodingFlag = Boolean(fileEntry.bitFlag.languageEncodingFlag);
          const filenameOffset = offset + 46;
          const extraFieldOffset = filenameOffset + fileEntry.filenameLength;
          const commentOffset2 = extraFieldOffset + fileEntry.extraFieldLength;
          const versionMadeBy = getUint16(directoryView, offset + 4);
          const msDosCompatible = (versionMadeBy & 0) == 0;
          const rawFilename = directoryArray.subarray(filenameOffset, extraFieldOffset);
          const commentLength2 = getUint16(directoryView, offset + 32);
          const endOffset = commentOffset2 + commentLength2;
          const rawComment = directoryArray.subarray(commentOffset2, endOffset);
          const filenameUTF8 = languageEncodingFlag;
          const commentUTF8 = languageEncodingFlag;
          const directory = msDosCompatible && (getUint8(directoryView, offset + 38) & FILE_ATTR_MSDOS_DIR_MASK) == FILE_ATTR_MSDOS_DIR_MASK;
          const offsetFileEntry = getUint32(directoryView, offset + 42) + prependedDataLength;
          Object.assign(fileEntry, {
            versionMadeBy,
            msDosCompatible,
            compressedSize: 0,
            uncompressedSize: 0,
            commentLength: commentLength2,
            directory,
            offset: offsetFileEntry,
            diskNumberStart: getUint16(directoryView, offset + 34),
            internalFileAttribute: getUint16(directoryView, offset + 36),
            externalFileAttribute: getUint32(directoryView, offset + 38),
            rawFilename,
            filenameUTF8,
            commentUTF8,
            rawExtraField: directoryArray.subarray(extraFieldOffset, commentOffset2)
          });
          const [filename, comment] = await Promise.all([
            decodeText(rawFilename, filenameUTF8 ? CHARSET_UTF8 : filenameEncoding || CHARSET_CP437),
            decodeText(rawComment, commentUTF8 ? CHARSET_UTF8 : commentEncoding || CHARSET_CP437)
          ]);
          Object.assign(fileEntry, {
            rawComment,
            filename,
            comment,
            directory: directory || filename.endsWith(DIRECTORY_SIGNATURE)
          });
          startOffset = Math.max(offsetFileEntry, startOffset);
          await readCommonFooter(fileEntry, fileEntry, directoryView, offset + 6);
          const entry = new Entry(fileEntry);
          entry.getData = (writer, options2) => fileEntry.getData(writer, entry, options2);
          offset = endOffset;
          const { onprogress } = options;
          if (onprogress) {
            try {
              await onprogress(indexFile + 1, filesLength, new Entry(fileEntry));
            } catch (_error) {
            }
          }
          yield entry;
        }
        const extractPrependedData = getOptionValue(zipReader, options, "extractPrependedData");
        const extractAppendedData = getOptionValue(zipReader, options, "extractAppendedData");
        if (extractPrependedData) {
          zipReader.prependedData = startOffset > 0 ? await readUint8Array(reader, 0, startOffset) : new Uint8Array();
        }
        zipReader.comment = commentLength ? await readUint8Array(reader, commentOffset + END_OF_CENTRAL_DIR_LENGTH, commentLength) : new Uint8Array();
        if (extractAppendedData) {
          zipReader.appendedData = appendedDataOffset < reader.size ? await readUint8Array(reader, appendedDataOffset, reader.size - appendedDataOffset) : new Uint8Array();
        }
        return true;
      }
      async getEntries(options = {}) {
        const entries = [];
        for await (const entry of this.getEntriesGenerator(options)) {
          entries.push(entry);
        }
        return entries;
      }
      async close() {
      }
    };
    ZipEntry = class {
      constructor(reader, config2, options) {
        Object.assign(this, {
          reader,
          config: config2,
          options
        });
      }
      async getData(writer, fileEntry, options = {}) {
        const zipEntry = this;
        const {
          reader,
          offset,
          diskNumberStart,
          extraFieldAES,
          compressionMethod,
          config: config2,
          bitFlag,
          signature,
          rawLastModDate,
          uncompressedSize,
          compressedSize
        } = zipEntry;
        const localDirectory = zipEntry.localDirectory = {};
        const dataArray = await readUint8Array(reader, offset, 30, diskNumberStart);
        const dataView = getDataView(dataArray);
        let password = getOptionValue(zipEntry, options, "password");
        password = password && password.length && password;
        if (extraFieldAES) {
          if (extraFieldAES.originalCompressionMethod != COMPRESSION_METHOD_AES) {
            throw new Error(ERR_UNSUPPORTED_COMPRESSION);
          }
        }
        if (compressionMethod != COMPRESSION_METHOD_STORE && compressionMethod != COMPRESSION_METHOD_DEFLATE) {
          throw new Error(ERR_UNSUPPORTED_COMPRESSION);
        }
        if (getUint32(dataView, 0) != LOCAL_FILE_HEADER_SIGNATURE) {
          throw new Error(ERR_LOCAL_FILE_HEADER_NOT_FOUND);
        }
        readCommonHeader(localDirectory, dataView, 4);
        localDirectory.rawExtraField = localDirectory.extraFieldLength ? await readUint8Array(reader, offset + 30 + localDirectory.filenameLength, localDirectory.extraFieldLength, diskNumberStart) : new Uint8Array();
        await readCommonFooter(zipEntry, localDirectory, dataView, 4);
        Object.assign(fileEntry, {
          lastAccessDate: localDirectory.lastAccessDate,
          creationDate: localDirectory.creationDate
        });
        const encrypted = zipEntry.encrypted && localDirectory.encrypted;
        const zipCrypto = encrypted && !extraFieldAES;
        if (encrypted) {
          if (!zipCrypto && extraFieldAES.strength === UNDEFINED_VALUE) {
            throw new Error(ERR_UNSUPPORTED_ENCRYPTION);
          } else if (!password) {
            throw new Error(ERR_ENCRYPTED);
          }
        }
        const dataOffset = offset + 30 + localDirectory.filenameLength + localDirectory.extraFieldLength;
        const readable = reader.readable;
        readable.diskNumberStart = diskNumberStart;
        readable.offset = dataOffset;
        let size = readable.size = compressedSize;
        const signal = getOptionValue(zipEntry, options, "signal");
        const checkPasswordOnly = getOptionValue(zipEntry, options, "checkPasswordOnly");
        if (checkPasswordOnly) {
          writer = new WritableStream();
        }
        writer = initWriter(writer);
        await initStream(writer, uncompressedSize);
        const { writable } = writer;
        const { onstart, onprogress, onend } = options;
        const workerOptions = {
          options: {
            codecType: CODEC_INFLATE,
            password,
            zipCrypto,
            encryptionStrength: extraFieldAES && extraFieldAES.strength,
            signed: getOptionValue(zipEntry, options, "checkSignature"),
            passwordVerification: zipCrypto && (bitFlag.dataDescriptor ? rawLastModDate >>> 8 & 255 : signature >>> 24 & 255),
            signature,
            compressed: compressionMethod != 0,
            encrypted,
            useWebWorkers: getOptionValue(zipEntry, options, "useWebWorkers"),
            useCompressionStream: getOptionValue(zipEntry, options, "useCompressionStream"),
            transferStreams: getOptionValue(zipEntry, options, "transferStreams"),
            checkPasswordOnly
          },
          config: config2,
          streamOptions: { signal, size, onstart, onprogress, onend }
        };
        let outputSize = 0;
        try {
          ({ outputSize } = await runWorker2({ readable, writable }, workerOptions));
        } catch (error) {
          if (!checkPasswordOnly || error.message != ERR_ABORT_CHECK_PASSWORD) {
            throw error;
          }
        } finally {
          const preventClose = getOptionValue(zipEntry, options, "preventClose");
          writable.size += outputSize;
          if (!preventClose && !writable.locked) {
            await writable.close();
          }
        }
        return checkPasswordOnly ? void 0 : writer.getData ? writer.getData() : writable;
      }
    };
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/zip-writer.js
async function addFile(zipWriter, name, reader, options) {
  name = name.trim();
  if (options.directory && !name.endsWith(DIRECTORY_SIGNATURE)) {
    name += DIRECTORY_SIGNATURE;
  } else {
    options.directory = name.endsWith(DIRECTORY_SIGNATURE);
  }
  const rawFilename = encodeText(name);
  if (getLength(rawFilename) > MAX_16_BITS) {
    throw new Error(ERR_INVALID_ENTRY_NAME);
  }
  const comment = options.comment || "";
  const rawComment = encodeText(comment);
  if (getLength(rawComment) > MAX_16_BITS) {
    throw new Error(ERR_INVALID_ENTRY_COMMENT);
  }
  const version = getOptionValue2(zipWriter, options, "version", VERSION_DEFLATE);
  if (version > MAX_16_BITS) {
    throw new Error(ERR_INVALID_VERSION);
  }
  const versionMadeBy = getOptionValue2(zipWriter, options, "versionMadeBy", 20);
  if (versionMadeBy > MAX_16_BITS) {
    throw new Error(ERR_INVALID_VERSION);
  }
  const lastModDate = getOptionValue2(zipWriter, options, PROPERTY_NAME_LAST_MODIFICATION_DATE, /* @__PURE__ */ new Date());
  const lastAccessDate = getOptionValue2(zipWriter, options, PROPERTY_NAME_LAST_ACCESS_DATE);
  const creationDate = getOptionValue2(zipWriter, options, PROPERTY_NAME_CREATION_DATE);
  const msDosCompatible = getOptionValue2(zipWriter, options, PROPERTY_NAME_MS_DOS_COMPATIBLE, true);
  const internalFileAttribute = getOptionValue2(zipWriter, options, PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE, 0);
  const externalFileAttribute = getOptionValue2(zipWriter, options, PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE, 0);
  const password = getOptionValue2(zipWriter, options, "password");
  const encryptionStrength = getOptionValue2(zipWriter, options, "encryptionStrength", 3);
  const zipCrypto = getOptionValue2(zipWriter, options, "zipCrypto");
  const extendedTimestamp = getOptionValue2(zipWriter, options, "extendedTimestamp", true);
  const keepOrder = getOptionValue2(zipWriter, options, "keepOrder", true);
  const level = getOptionValue2(zipWriter, options, "level");
  const useWebWorkers = getOptionValue2(zipWriter, options, "useWebWorkers");
  const bufferedWrite = getOptionValue2(zipWriter, options, "bufferedWrite");
  const dataDescriptorSignature = getOptionValue2(zipWriter, options, "dataDescriptorSignature", false);
  const signal = getOptionValue2(zipWriter, options, "signal");
  const useCompressionStream = getOptionValue2(zipWriter, options, "useCompressionStream");
  let dataDescriptor = getOptionValue2(zipWriter, options, "dataDescriptor", true);
  let zip64 = getOptionValue2(zipWriter, options, PROPERTY_NAME_ZIP64);
  if (password !== UNDEFINED_VALUE && encryptionStrength !== UNDEFINED_VALUE && (encryptionStrength < 1 || encryptionStrength > 3)) {
    throw new Error(ERR_INVALID_ENCRYPTION_STRENGTH);
  }
  let rawExtraField = new Uint8Array();
  const { extraField } = options;
  if (extraField) {
    let extraFieldSize = 0;
    let offset = 0;
    extraField.forEach((data2) => extraFieldSize += 4 + getLength(data2));
    rawExtraField = new Uint8Array(extraFieldSize);
    extraField.forEach((data2, type) => {
      if (type > MAX_16_BITS) {
        throw new Error(ERR_INVALID_EXTRAFIELD_TYPE);
      }
      if (getLength(data2) > MAX_16_BITS) {
        throw new Error(ERR_INVALID_EXTRAFIELD_DATA);
      }
      arraySet(rawExtraField, new Uint16Array([type]), offset);
      arraySet(rawExtraField, new Uint16Array([getLength(data2)]), offset + 2);
      arraySet(rawExtraField, data2, offset + 4);
      offset += 4 + getLength(data2);
    });
  }
  let maximumCompressedSize = 0;
  let maximumEntrySize = 0;
  let uncompressedSize = 0;
  const zip64Enabled = zip64 === true;
  if (reader) {
    reader = initReader(reader);
    await initStream(reader);
    if (reader.size === UNDEFINED_VALUE) {
      dataDescriptor = true;
      if (zip64 || zip64 === UNDEFINED_VALUE) {
        zip64 = true;
        maximumCompressedSize = MAX_32_BITS;
      }
    } else {
      uncompressedSize = reader.size;
      maximumCompressedSize = getMaximumCompressedSize2(uncompressedSize);
    }
  }
  const { diskOffset, diskNumber, maxSize } = zipWriter.writer;
  const zip64UncompressedSize = zip64Enabled || uncompressedSize >= MAX_32_BITS;
  const zip64CompressedSize = zip64Enabled || maximumCompressedSize >= MAX_32_BITS;
  const zip64Offset = zip64Enabled || zipWriter.offset + zipWriter.pendingEntriesSize - diskOffset >= MAX_32_BITS;
  const supportZip64SplitFile = getOptionValue2(zipWriter, options, "supportZip64SplitFile", true);
  const zip64DiskNumberStart = supportZip64SplitFile && zip64Enabled || diskNumber + Math.ceil(zipWriter.pendingEntriesSize / maxSize) >= MAX_16_BITS;
  if (zip64Offset || zip64UncompressedSize || zip64CompressedSize || zip64DiskNumberStart) {
    if (zip64 === false || !keepOrder) {
      throw new Error(ERR_UNSUPPORTED_FORMAT);
    } else {
      zip64 = true;
    }
  }
  zip64 = zip64 || false;
  options = Object.assign({}, options, {
    rawFilename,
    rawComment,
    version,
    versionMadeBy,
    lastModDate,
    lastAccessDate,
    creationDate,
    rawExtraField,
    zip64,
    zip64UncompressedSize,
    zip64CompressedSize,
    zip64Offset,
    zip64DiskNumberStart,
    password,
    level,
    useWebWorkers,
    encryptionStrength,
    extendedTimestamp,
    zipCrypto,
    bufferedWrite,
    keepOrder,
    dataDescriptor,
    dataDescriptorSignature,
    signal,
    msDosCompatible,
    internalFileAttribute,
    externalFileAttribute,
    useCompressionStream
  });
  const headerInfo = getHeaderInfo(options);
  const dataDescriptorInfo = getDataDescriptorInfo(options);
  maximumEntrySize = getLength(headerInfo.localHeaderArray, dataDescriptorInfo.dataDescriptorArray) + maximumCompressedSize;
  zipWriter.pendingEntriesSize += maximumEntrySize;
  let fileEntry;
  try {
    fileEntry = await getFileEntry(zipWriter, name, reader, { headerInfo, dataDescriptorInfo }, options);
  } finally {
    zipWriter.pendingEntriesSize -= maximumEntrySize;
  }
  Object.assign(fileEntry, { name, comment, extraField });
  return new Entry(fileEntry);
}
async function getFileEntry(zipWriter, name, reader, entryInfo, options) {
  const {
    files,
    writer
  } = zipWriter;
  const {
    keepOrder,
    dataDescriptor,
    signal
  } = options;
  const {
    headerInfo
  } = entryInfo;
  const previousFileEntry = Array.from(files.values()).pop();
  let fileEntry = {};
  let bufferedWrite;
  let releaseLockWriter;
  let releaseLockCurrentFileEntry;
  let writingBufferedEntryData;
  let writingEntryData;
  let fileWriter;
  files.set(name, fileEntry);
  try {
    let lockPreviousFileEntry;
    if (keepOrder) {
      lockPreviousFileEntry = previousFileEntry && previousFileEntry.lock;
      requestLockCurrentFileEntry();
    }
    if (options.bufferedWrite || zipWriter.writerLocked || zipWriter.bufferedWrites && keepOrder || !dataDescriptor) {
      fileWriter = new BlobWriter();
      fileWriter.writable.size = 0;
      bufferedWrite = true;
      zipWriter.bufferedWrites++;
      await initStream(writer);
    } else {
      fileWriter = writer;
      await requestLockWriter();
    }
    await initStream(fileWriter);
    const { writable } = writer;
    let { diskOffset } = writer;
    if (zipWriter.addSplitZipSignature) {
      delete zipWriter.addSplitZipSignature;
      const signatureArray = new Uint8Array(4);
      const signatureArrayView = getDataView2(signatureArray);
      setUint322(signatureArrayView, 0, SPLIT_ZIP_FILE_SIGNATURE);
      await writeData(writable, signatureArray);
      zipWriter.offset += 4;
    }
    if (!bufferedWrite) {
      await lockPreviousFileEntry;
      await skipDiskIfNeeded(writable);
    }
    const { diskNumber } = writer;
    writingEntryData = true;
    fileEntry.diskNumberStart = diskNumber;
    fileEntry = await createFileEntry(reader, fileWriter, fileEntry, entryInfo, zipWriter.config, options);
    writingEntryData = false;
    files.set(name, fileEntry);
    fileEntry.filename = name;
    if (bufferedWrite) {
      await fileWriter.writable.close();
      let blob = await fileWriter.getData();
      await lockPreviousFileEntry;
      await requestLockWriter();
      writingBufferedEntryData = true;
      if (!dataDescriptor) {
        blob = await writeExtraHeaderInfo(fileEntry, blob, writable, options);
      }
      await skipDiskIfNeeded(writable);
      fileEntry.diskNumberStart = writer.diskNumber;
      diskOffset = writer.diskOffset;
      await blob.stream().pipeTo(writable, { preventClose: true, preventAbort: true, signal });
      writable.size += blob.size;
      writingBufferedEntryData = false;
    }
    fileEntry.offset = zipWriter.offset - diskOffset;
    if (fileEntry.zip64) {
      setZip64ExtraInfo(fileEntry, options);
    } else if (fileEntry.offset >= MAX_32_BITS) {
      throw new Error(ERR_UNSUPPORTED_FORMAT);
    }
    zipWriter.offset += fileEntry.length;
    return fileEntry;
  } catch (error) {
    if (bufferedWrite && writingBufferedEntryData || !bufferedWrite && writingEntryData) {
      zipWriter.hasCorruptedEntries = true;
      if (error) {
        try {
          error.corruptedEntry = true;
        } catch (_error) {
        }
      }
      if (bufferedWrite) {
        zipWriter.offset += fileWriter.writable.size;
      } else {
        zipWriter.offset = fileWriter.writable.size;
      }
    }
    files.delete(name);
    throw error;
  } finally {
    if (bufferedWrite) {
      zipWriter.bufferedWrites--;
    }
    if (releaseLockCurrentFileEntry) {
      releaseLockCurrentFileEntry();
    }
    if (releaseLockWriter) {
      releaseLockWriter();
    }
  }
  function requestLockCurrentFileEntry() {
    fileEntry.lock = new Promise((resolve) => releaseLockCurrentFileEntry = resolve);
  }
  async function requestLockWriter() {
    zipWriter.writerLocked = true;
    const { lockWriter } = zipWriter;
    zipWriter.lockWriter = new Promise((resolve) => releaseLockWriter = () => {
      zipWriter.writerLocked = false;
      resolve();
    });
    await lockWriter;
  }
  async function skipDiskIfNeeded(writable) {
    if (headerInfo.localHeaderArray.length > writer.availableSize) {
      writer.availableSize = 0;
      await writeData(writable, new Uint8Array());
    }
  }
}
async function createFileEntry(reader, writer, { diskNumberStart, lock }, entryInfo, config2, options) {
  const {
    headerInfo,
    dataDescriptorInfo
  } = entryInfo;
  const {
    localHeaderArray,
    headerArray,
    lastModDate,
    rawLastModDate,
    encrypted,
    compressed,
    version,
    compressionMethod,
    rawExtraFieldExtendedTimestamp,
    rawExtraFieldNTFS,
    rawExtraFieldAES
  } = headerInfo;
  const { dataDescriptorArray } = dataDescriptorInfo;
  const {
    rawFilename,
    lastAccessDate,
    creationDate,
    password,
    level,
    zip64,
    zip64UncompressedSize,
    zip64CompressedSize,
    zip64Offset,
    zip64DiskNumberStart,
    zipCrypto,
    dataDescriptor,
    directory,
    versionMadeBy,
    rawComment,
    rawExtraField,
    useWebWorkers,
    onstart,
    onprogress,
    onend,
    signal,
    encryptionStrength,
    extendedTimestamp,
    msDosCompatible,
    internalFileAttribute,
    externalFileAttribute,
    useCompressionStream
  } = options;
  const fileEntry = {
    lock,
    versionMadeBy,
    zip64,
    directory: Boolean(directory),
    filenameUTF8: true,
    rawFilename,
    commentUTF8: true,
    rawComment,
    rawExtraFieldExtendedTimestamp,
    rawExtraFieldNTFS,
    rawExtraFieldAES,
    rawExtraField,
    extendedTimestamp,
    msDosCompatible,
    internalFileAttribute,
    externalFileAttribute,
    diskNumberStart
  };
  let compressedSize = 0;
  let uncompressedSize = 0;
  let signature;
  const { writable } = writer;
  if (reader) {
    reader.chunkSize = getChunkSize(config2);
    await writeData(writable, localHeaderArray);
    const readable = reader.readable;
    const size = readable.size = reader.size;
    const workerOptions = {
      options: {
        codecType: CODEC_DEFLATE,
        level,
        password,
        encryptionStrength,
        zipCrypto: encrypted && zipCrypto,
        passwordVerification: encrypted && zipCrypto && rawLastModDate >> 8 & 255,
        signed: true,
        compressed,
        encrypted,
        useWebWorkers,
        useCompressionStream,
        transferStreams: false
      },
      config: config2,
      streamOptions: { signal, size, onstart, onprogress, onend }
    };
    const result = await runWorker2({ readable, writable }, workerOptions);
    writable.size += result.size;
    signature = result.signature;
    uncompressedSize = reader.size = readable.size;
    compressedSize = result.size;
  } else {
    await writeData(writable, localHeaderArray);
  }
  let rawExtraFieldZip64;
  if (zip64) {
    let rawExtraFieldZip64Length = 4;
    if (zip64UncompressedSize) {
      rawExtraFieldZip64Length += 8;
    }
    if (zip64CompressedSize) {
      rawExtraFieldZip64Length += 8;
    }
    if (zip64Offset) {
      rawExtraFieldZip64Length += 8;
    }
    if (zip64DiskNumberStart) {
      rawExtraFieldZip64Length += 4;
    }
    rawExtraFieldZip64 = new Uint8Array(rawExtraFieldZip64Length);
  } else {
    rawExtraFieldZip64 = new Uint8Array();
  }
  setEntryInfo({
    signature,
    rawExtraFieldZip64,
    compressedSize,
    uncompressedSize,
    headerInfo,
    dataDescriptorInfo
  }, options);
  if (dataDescriptor) {
    await writeData(writable, dataDescriptorArray);
  }
  Object.assign(fileEntry, {
    uncompressedSize,
    compressedSize,
    lastModDate,
    rawLastModDate,
    creationDate,
    lastAccessDate,
    encrypted,
    length: getLength(localHeaderArray, dataDescriptorArray) + compressedSize,
    compressionMethod,
    version,
    headerArray,
    signature,
    rawExtraFieldZip64,
    zip64UncompressedSize,
    zip64CompressedSize,
    zip64Offset,
    zip64DiskNumberStart
  });
  return fileEntry;
}
function getHeaderInfo(options) {
  const {
    rawFilename,
    lastModDate,
    lastAccessDate,
    creationDate,
    password,
    level,
    zip64,
    zipCrypto,
    dataDescriptor,
    directory,
    rawExtraField,
    encryptionStrength,
    extendedTimestamp
  } = options;
  const compressed = level !== 0 && !directory;
  const encrypted = Boolean(password && getLength(password));
  let version = options.version;
  let rawExtraFieldAES;
  if (encrypted && !zipCrypto) {
    rawExtraFieldAES = new Uint8Array(getLength(EXTRAFIELD_DATA_AES) + 2);
    const extraFieldAESView = getDataView2(rawExtraFieldAES);
    setUint16(extraFieldAESView, 0, EXTRAFIELD_TYPE_AES);
    arraySet(rawExtraFieldAES, EXTRAFIELD_DATA_AES, 2);
    setUint8(extraFieldAESView, 8, encryptionStrength);
  } else {
    rawExtraFieldAES = new Uint8Array();
  }
  let rawExtraFieldNTFS;
  let rawExtraFieldExtendedTimestamp;
  if (extendedTimestamp) {
    rawExtraFieldExtendedTimestamp = new Uint8Array(9 + (lastAccessDate ? 4 : 0) + (creationDate ? 4 : 0));
    const extraFieldExtendedTimestampView = getDataView2(rawExtraFieldExtendedTimestamp);
    setUint16(extraFieldExtendedTimestampView, 0, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);
    setUint16(extraFieldExtendedTimestampView, 2, getLength(rawExtraFieldExtendedTimestamp) - 4);
    const extraFieldExtendedTimestampFlag = 1 + (lastAccessDate ? 2 : 0) + (creationDate ? 4 : 0);
    setUint8(extraFieldExtendedTimestampView, 4, extraFieldExtendedTimestampFlag);
    setUint322(extraFieldExtendedTimestampView, 5, Math.floor(lastModDate.getTime() / 1e3));
    if (lastAccessDate) {
      setUint322(extraFieldExtendedTimestampView, 9, Math.floor(lastAccessDate.getTime() / 1e3));
    }
    if (creationDate) {
      setUint322(extraFieldExtendedTimestampView, 13, Math.floor(creationDate.getTime() / 1e3));
    }
    try {
      rawExtraFieldNTFS = new Uint8Array(36);
      const extraFieldNTFSView = getDataView2(rawExtraFieldNTFS);
      const lastModTimeNTFS = getTimeNTFS(lastModDate);
      setUint16(extraFieldNTFSView, 0, EXTRAFIELD_TYPE_NTFS);
      setUint16(extraFieldNTFSView, 2, 32);
      setUint16(extraFieldNTFSView, 8, EXTRAFIELD_TYPE_NTFS_TAG1);
      setUint16(extraFieldNTFSView, 10, 24);
      setBigUint64(extraFieldNTFSView, 12, lastModTimeNTFS);
      setBigUint64(extraFieldNTFSView, 20, getTimeNTFS(lastAccessDate) || lastModTimeNTFS);
      setBigUint64(extraFieldNTFSView, 28, getTimeNTFS(creationDate) || lastModTimeNTFS);
    } catch (_error) {
      rawExtraFieldNTFS = new Uint8Array();
    }
  } else {
    rawExtraFieldNTFS = rawExtraFieldExtendedTimestamp = new Uint8Array();
  }
  let bitFlag = BITFLAG_LANG_ENCODING_FLAG;
  if (dataDescriptor) {
    bitFlag = bitFlag | BITFLAG_DATA_DESCRIPTOR;
  }
  let compressionMethod = COMPRESSION_METHOD_STORE;
  if (compressed) {
    compressionMethod = COMPRESSION_METHOD_DEFLATE;
  }
  if (zip64) {
    version = version > VERSION_ZIP64 ? version : VERSION_ZIP64;
  }
  if (encrypted) {
    bitFlag = bitFlag | BITFLAG_ENCRYPTED;
    if (!zipCrypto) {
      version = version > VERSION_AES ? version : VERSION_AES;
      compressionMethod = COMPRESSION_METHOD_AES;
      if (compressed) {
        rawExtraFieldAES[9] = COMPRESSION_METHOD_DEFLATE;
      }
    }
  }
  const headerArray = new Uint8Array(26);
  const headerView = getDataView2(headerArray);
  setUint16(headerView, 0, version);
  setUint16(headerView, 2, bitFlag);
  setUint16(headerView, 4, compressionMethod);
  const dateArray = new Uint32Array(1);
  const dateView = getDataView2(dateArray);
  let lastModDateMsDos;
  if (lastModDate < MIN_DATE) {
    lastModDateMsDos = MIN_DATE;
  } else if (lastModDate > MAX_DATE) {
    lastModDateMsDos = MAX_DATE;
  } else {
    lastModDateMsDos = lastModDate;
  }
  setUint16(dateView, 0, (lastModDateMsDos.getHours() << 6 | lastModDateMsDos.getMinutes()) << 5 | lastModDateMsDos.getSeconds() / 2);
  setUint16(dateView, 2, (lastModDateMsDos.getFullYear() - 1980 << 4 | lastModDateMsDos.getMonth() + 1) << 5 | lastModDateMsDos.getDate());
  const rawLastModDate = dateArray[0];
  setUint322(headerView, 6, rawLastModDate);
  setUint16(headerView, 22, getLength(rawFilename));
  const extraFieldLength = getLength(rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS, rawExtraField);
  setUint16(headerView, 24, extraFieldLength);
  const localHeaderArray = new Uint8Array(30 + getLength(rawFilename) + extraFieldLength);
  const localHeaderView = getDataView2(localHeaderArray);
  setUint322(localHeaderView, 0, LOCAL_FILE_HEADER_SIGNATURE);
  arraySet(localHeaderArray, headerArray, 4);
  arraySet(localHeaderArray, rawFilename, 30);
  arraySet(localHeaderArray, rawExtraFieldAES, 30 + getLength(rawFilename));
  arraySet(localHeaderArray, rawExtraFieldExtendedTimestamp, 30 + getLength(rawFilename, rawExtraFieldAES));
  arraySet(localHeaderArray, rawExtraFieldNTFS, 30 + getLength(rawFilename, rawExtraFieldAES, rawExtraFieldExtendedTimestamp));
  arraySet(localHeaderArray, rawExtraField, 30 + getLength(rawFilename, rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS));
  return {
    localHeaderArray,
    headerArray,
    headerView,
    lastModDate,
    rawLastModDate,
    encrypted,
    compressed,
    version,
    compressionMethod,
    rawExtraFieldExtendedTimestamp,
    rawExtraFieldNTFS,
    rawExtraFieldAES
  };
}
function getDataDescriptorInfo(options) {
  const {
    zip64,
    dataDescriptor,
    dataDescriptorSignature
  } = options;
  let dataDescriptorArray = new Uint8Array();
  let dataDescriptorView, dataDescriptorOffset = 0;
  if (dataDescriptor) {
    dataDescriptorArray = new Uint8Array(zip64 ? dataDescriptorSignature ? 24 : 20 : dataDescriptorSignature ? 16 : 12);
    dataDescriptorView = getDataView2(dataDescriptorArray);
    if (dataDescriptorSignature) {
      dataDescriptorOffset = 4;
      setUint322(dataDescriptorView, 0, DATA_DESCRIPTOR_RECORD_SIGNATURE);
    }
  }
  return {
    dataDescriptorArray,
    dataDescriptorView,
    dataDescriptorOffset
  };
}
function setEntryInfo(entryInfo, options) {
  const {
    signature,
    rawExtraFieldZip64,
    compressedSize,
    uncompressedSize,
    headerInfo,
    dataDescriptorInfo
  } = entryInfo;
  const {
    headerView,
    encrypted
  } = headerInfo;
  const {
    dataDescriptorView,
    dataDescriptorOffset
  } = dataDescriptorInfo;
  const {
    zip64,
    zip64UncompressedSize,
    zip64CompressedSize,
    zipCrypto,
    dataDescriptor
  } = options;
  if ((!encrypted || zipCrypto) && signature !== UNDEFINED_VALUE) {
    setUint322(headerView, 10, signature);
    if (dataDescriptor) {
      setUint322(dataDescriptorView, dataDescriptorOffset, signature);
    }
  }
  if (zip64) {
    const rawExtraFieldZip64View = getDataView2(rawExtraFieldZip64);
    setUint16(rawExtraFieldZip64View, 0, EXTRAFIELD_TYPE_ZIP64);
    setUint16(rawExtraFieldZip64View, 2, rawExtraFieldZip64.length - 4);
    let rawExtraFieldZip64Offset = 4;
    if (zip64UncompressedSize) {
      setUint322(headerView, 18, MAX_32_BITS);
      setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(uncompressedSize));
      rawExtraFieldZip64Offset += 8;
    }
    if (zip64CompressedSize) {
      setUint322(headerView, 14, MAX_32_BITS);
      setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(compressedSize));
    }
    if (dataDescriptor) {
      setBigUint64(dataDescriptorView, dataDescriptorOffset + 4, BigInt(compressedSize));
      setBigUint64(dataDescriptorView, dataDescriptorOffset + 12, BigInt(uncompressedSize));
    }
  } else {
    setUint322(headerView, 14, compressedSize);
    setUint322(headerView, 18, uncompressedSize);
    if (dataDescriptor) {
      setUint322(dataDescriptorView, dataDescriptorOffset + 4, compressedSize);
      setUint322(dataDescriptorView, dataDescriptorOffset + 8, uncompressedSize);
    }
  }
}
async function writeExtraHeaderInfo(fileEntry, entryData, writable, { zipCrypto }) {
  const arrayBuffer = await sliceAsArrayBuffer(entryData, 0, 26);
  const arrayBufferView = new DataView(arrayBuffer);
  if (!fileEntry.encrypted || zipCrypto) {
    setUint322(arrayBufferView, 14, fileEntry.signature);
  }
  if (fileEntry.zip64) {
    setUint322(arrayBufferView, 18, MAX_32_BITS);
    setUint322(arrayBufferView, 22, MAX_32_BITS);
  } else {
    setUint322(arrayBufferView, 18, fileEntry.compressedSize);
    setUint322(arrayBufferView, 22, fileEntry.uncompressedSize);
  }
  await writeData(writable, new Uint8Array(arrayBuffer));
  return entryData.slice(arrayBuffer.byteLength);
}
function setZip64ExtraInfo(fileEntry, options) {
  const { rawExtraFieldZip64, offset, diskNumberStart } = fileEntry;
  const { zip64UncompressedSize, zip64CompressedSize, zip64Offset, zip64DiskNumberStart } = options;
  const rawExtraFieldZip64View = getDataView2(rawExtraFieldZip64);
  let rawExtraFieldZip64Offset = 4;
  if (zip64UncompressedSize) {
    rawExtraFieldZip64Offset += 8;
  }
  if (zip64CompressedSize) {
    rawExtraFieldZip64Offset += 8;
  }
  if (zip64Offset) {
    setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(offset));
    rawExtraFieldZip64Offset += 8;
  }
  if (zip64DiskNumberStart) {
    setUint322(rawExtraFieldZip64View, rawExtraFieldZip64Offset, diskNumberStart);
  }
}
async function closeFile(zipWriter, comment, options) {
  const { files, writer } = zipWriter;
  const { diskOffset, writable } = writer;
  let { diskNumber } = writer;
  let offset = 0;
  let directoryDataLength = 0;
  let directoryOffset = zipWriter.offset - diskOffset;
  let filesLength = files.size;
  for (const [, {
    rawFilename,
    rawExtraFieldZip64,
    rawExtraFieldAES,
    rawExtraField,
    rawComment,
    rawExtraFieldExtendedTimestamp,
    rawExtraFieldNTFS
  }] of files) {
    directoryDataLength += 46 + getLength(
      rawFilename,
      rawComment,
      rawExtraFieldZip64,
      rawExtraFieldAES,
      rawExtraFieldExtendedTimestamp,
      rawExtraFieldNTFS,
      rawExtraField
    );
  }
  const directoryArray = new Uint8Array(directoryDataLength);
  const directoryView = getDataView2(directoryArray);
  await initStream(writer);
  let directoryDiskOffset = 0;
  for (const [indexFileEntry, fileEntry] of Array.from(files.values()).entries()) {
    const {
      offset: fileEntryOffset,
      rawFilename,
      rawExtraFieldZip64,
      rawExtraFieldAES,
      rawExtraFieldNTFS,
      rawExtraField,
      rawComment,
      versionMadeBy,
      headerArray,
      directory,
      zip64: zip642,
      zip64UncompressedSize,
      zip64CompressedSize,
      zip64DiskNumberStart,
      zip64Offset,
      msDosCompatible,
      internalFileAttribute,
      externalFileAttribute,
      extendedTimestamp,
      lastModDate,
      diskNumberStart,
      uncompressedSize,
      compressedSize
    } = fileEntry;
    let rawExtraFieldExtendedTimestamp;
    if (extendedTimestamp) {
      rawExtraFieldExtendedTimestamp = new Uint8Array(9);
      const extraFieldExtendedTimestampView = getDataView2(rawExtraFieldExtendedTimestamp);
      setUint16(extraFieldExtendedTimestampView, 0, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);
      setUint16(extraFieldExtendedTimestampView, 2, getLength(rawExtraFieldExtendedTimestamp) - 4);
      setUint8(extraFieldExtendedTimestampView, 4, 1);
      setUint322(extraFieldExtendedTimestampView, 5, Math.floor(lastModDate.getTime() / 1e3));
    } else {
      rawExtraFieldExtendedTimestamp = new Uint8Array();
    }
    const extraFieldLength = getLength(rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS, rawExtraField);
    setUint322(directoryView, offset, CENTRAL_FILE_HEADER_SIGNATURE);
    setUint16(directoryView, offset + 4, versionMadeBy);
    const headerView = getDataView2(headerArray);
    if (!zip64UncompressedSize) {
      setUint322(headerView, 18, uncompressedSize);
    }
    if (!zip64CompressedSize) {
      setUint322(headerView, 14, compressedSize);
    }
    arraySet(directoryArray, headerArray, offset + 6);
    setUint16(directoryView, offset + 30, extraFieldLength);
    setUint16(directoryView, offset + 32, getLength(rawComment));
    setUint16(directoryView, offset + 34, zip642 && zip64DiskNumberStart ? MAX_16_BITS : diskNumberStart);
    setUint16(directoryView, offset + 36, internalFileAttribute);
    if (externalFileAttribute) {
      setUint322(directoryView, offset + 38, externalFileAttribute);
    } else if (directory && msDosCompatible) {
      setUint8(directoryView, offset + 38, FILE_ATTR_MSDOS_DIR_MASK);
    }
    setUint322(directoryView, offset + 42, zip642 && zip64Offset ? MAX_32_BITS : fileEntryOffset);
    arraySet(directoryArray, rawFilename, offset + 46);
    arraySet(directoryArray, rawExtraFieldZip64, offset + 46 + getLength(rawFilename));
    arraySet(directoryArray, rawExtraFieldAES, offset + 46 + getLength(rawFilename, rawExtraFieldZip64));
    arraySet(directoryArray, rawExtraFieldExtendedTimestamp, offset + 46 + getLength(rawFilename, rawExtraFieldZip64, rawExtraFieldAES));
    arraySet(directoryArray, rawExtraFieldNTFS, offset + 46 + getLength(rawFilename, rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldExtendedTimestamp));
    arraySet(directoryArray, rawExtraField, offset + 46 + getLength(rawFilename, rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS));
    arraySet(directoryArray, rawComment, offset + 46 + getLength(rawFilename) + extraFieldLength);
    const directoryEntryLength = 46 + getLength(rawFilename, rawComment) + extraFieldLength;
    if (offset - directoryDiskOffset > writer.availableSize) {
      writer.availableSize = 0;
      await writeData(writable, directoryArray.slice(directoryDiskOffset, offset));
      directoryDiskOffset = offset;
    }
    offset += directoryEntryLength;
    if (options.onprogress) {
      try {
        await options.onprogress(indexFileEntry + 1, files.size, new Entry(fileEntry));
      } catch (_error) {
      }
    }
  }
  await writeData(writable, directoryDiskOffset ? directoryArray.slice(directoryDiskOffset) : directoryArray);
  let lastDiskNumber = writer.diskNumber;
  const { availableSize } = writer;
  if (availableSize < END_OF_CENTRAL_DIR_LENGTH) {
    lastDiskNumber++;
  }
  let zip64 = getOptionValue2(zipWriter, options, "zip64");
  if (directoryOffset >= MAX_32_BITS || directoryDataLength >= MAX_32_BITS || filesLength >= MAX_16_BITS || lastDiskNumber >= MAX_16_BITS) {
    if (zip64 === false) {
      throw new Error(ERR_UNSUPPORTED_FORMAT);
    } else {
      zip64 = true;
    }
  }
  const endOfdirectoryArray = new Uint8Array(zip64 ? ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH : END_OF_CENTRAL_DIR_LENGTH);
  const endOfdirectoryView = getDataView2(endOfdirectoryArray);
  offset = 0;
  if (zip64) {
    setUint322(endOfdirectoryView, 0, ZIP64_END_OF_CENTRAL_DIR_SIGNATURE);
    setBigUint64(endOfdirectoryView, 4, BigInt(44));
    setUint16(endOfdirectoryView, 12, 45);
    setUint16(endOfdirectoryView, 14, 45);
    setUint322(endOfdirectoryView, 16, lastDiskNumber);
    setUint322(endOfdirectoryView, 20, diskNumber);
    setBigUint64(endOfdirectoryView, 24, BigInt(filesLength));
    setBigUint64(endOfdirectoryView, 32, BigInt(filesLength));
    setBigUint64(endOfdirectoryView, 40, BigInt(directoryDataLength));
    setBigUint64(endOfdirectoryView, 48, BigInt(directoryOffset));
    setUint322(endOfdirectoryView, 56, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE);
    setBigUint64(endOfdirectoryView, 64, BigInt(directoryOffset) + BigInt(directoryDataLength));
    setUint322(endOfdirectoryView, 72, lastDiskNumber + 1);
    const supportZip64SplitFile = getOptionValue2(zipWriter, options, "supportZip64SplitFile", true);
    if (supportZip64SplitFile) {
      lastDiskNumber = MAX_16_BITS;
      diskNumber = MAX_16_BITS;
    }
    filesLength = MAX_16_BITS;
    directoryOffset = MAX_32_BITS;
    directoryDataLength = MAX_32_BITS;
    offset += ZIP64_END_OF_CENTRAL_DIR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH;
  }
  setUint322(endOfdirectoryView, offset, END_OF_CENTRAL_DIR_SIGNATURE);
  setUint16(endOfdirectoryView, offset + 4, lastDiskNumber);
  setUint16(endOfdirectoryView, offset + 6, diskNumber);
  setUint16(endOfdirectoryView, offset + 8, filesLength);
  setUint16(endOfdirectoryView, offset + 10, filesLength);
  setUint322(endOfdirectoryView, offset + 12, directoryDataLength);
  setUint322(endOfdirectoryView, offset + 16, directoryOffset);
  const commentLength = getLength(comment);
  if (commentLength) {
    if (commentLength <= MAX_16_BITS) {
      setUint16(endOfdirectoryView, offset + 20, commentLength);
    } else {
      throw new Error(ERR_INVALID_COMMENT);
    }
  }
  await writeData(writable, endOfdirectoryArray);
  if (commentLength) {
    await writeData(writable, comment);
  }
}
function sliceAsArrayBuffer(blob, start, end) {
  if (start || end) {
    return blob.slice(start, end).arrayBuffer();
  } else {
    return blob.arrayBuffer();
  }
}
async function writeData(writable, array) {
  const streamWriter = writable.getWriter();
  await streamWriter.ready;
  writable.size += getLength(array);
  await streamWriter.write(array);
  streamWriter.releaseLock();
}
function getTimeNTFS(date) {
  if (date) {
    return (BigInt(date.getTime()) + BigInt(116444736e5)) * BigInt(1e4);
  }
}
function getOptionValue2(zipWriter, options, name, defaultValue) {
  const result = options[name] === UNDEFINED_VALUE ? zipWriter.options[name] : options[name];
  return result === UNDEFINED_VALUE ? defaultValue : result;
}
function getMaximumCompressedSize2(uncompressedSize) {
  return uncompressedSize + 5 * (Math.floor(uncompressedSize / 16383) + 1);
}
function setUint8(view, offset, value) {
  view.setUint8(offset, value);
}
function setUint16(view, offset, value) {
  view.setUint16(offset, value, true);
}
function setUint322(view, offset, value) {
  view.setUint32(offset, value, true);
}
function setBigUint64(view, offset, value) {
  view.setBigUint64(offset, value, true);
}
function arraySet(array, typedArray, offset) {
  array.set(typedArray, offset);
}
function getDataView2(array) {
  return new DataView(array.buffer);
}
function getLength(...arrayLikes) {
  let result = 0;
  arrayLikes.forEach((arrayLike) => arrayLike && (result += arrayLike.length));
  return result;
}
var ERR_DUPLICATED_NAME, ERR_INVALID_COMMENT, ERR_INVALID_ENTRY_COMMENT, ERR_INVALID_ENTRY_NAME, ERR_INVALID_VERSION, ERR_INVALID_ENCRYPTION_STRENGTH, ERR_INVALID_EXTRAFIELD_TYPE, ERR_INVALID_EXTRAFIELD_DATA, ERR_UNSUPPORTED_FORMAT, EXTRAFIELD_DATA_AES, workers, pendingEntries, ZipWriter;
var init_zip_writer = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/zip-writer.js"() {
    init_constants();
    init_configuration();
    init_codec_pool();
    init_io();
    init_encode_text();
    init_zip_entry();
    ERR_DUPLICATED_NAME = "File already exists";
    ERR_INVALID_COMMENT = "Zip file comment exceeds 64KB";
    ERR_INVALID_ENTRY_COMMENT = "File entry comment exceeds 64KB";
    ERR_INVALID_ENTRY_NAME = "File entry name exceeds 64KB";
    ERR_INVALID_VERSION = "Version exceeds 65535";
    ERR_INVALID_ENCRYPTION_STRENGTH = "The strength must equal 1, 2, or 3";
    ERR_INVALID_EXTRAFIELD_TYPE = "Extra field type exceeds 65535";
    ERR_INVALID_EXTRAFIELD_DATA = "Extra field data exceeds 64KB";
    ERR_UNSUPPORTED_FORMAT = "Zip64 is not supported (make sure 'keepOrder' is set to 'true')";
    EXTRAFIELD_DATA_AES = new Uint8Array([7, 0, 2, 0, 65, 69, 3, 0, 0]);
    workers = 0;
    pendingEntries = [];
    ZipWriter = class {
      constructor(writer, options = {}) {
        writer = initWriter(writer);
        Object.assign(this, {
          writer,
          addSplitZipSignature: writer instanceof SplitDataWriter,
          options,
          config: getConfiguration(),
          files: /* @__PURE__ */ new Map(),
          filenames: /* @__PURE__ */ new Set(),
          offset: writer.writable.size,
          pendingEntriesSize: 0,
          pendingAddFileCalls: /* @__PURE__ */ new Set(),
          bufferedWrites: 0
        });
      }
      async add(name = "", reader, options = {}) {
        const zipWriter = this;
        const {
          pendingAddFileCalls,
          config: config2
        } = zipWriter;
        if (workers < config2.maxWorkers) {
          workers++;
        } else {
          await new Promise((resolve) => pendingEntries.push(resolve));
        }
        let promiseAddFile;
        try {
          name = name.trim();
          if (zipWriter.filenames.has(name)) {
            throw new Error(ERR_DUPLICATED_NAME);
          }
          zipWriter.filenames.add(name);
          promiseAddFile = addFile(zipWriter, name, reader, options);
          pendingAddFileCalls.add(promiseAddFile);
          return await promiseAddFile;
        } catch (error) {
          zipWriter.filenames.delete(name);
          throw error;
        } finally {
          pendingAddFileCalls.delete(promiseAddFile);
          const pendingEntry = pendingEntries.shift();
          if (pendingEntry) {
            pendingEntry();
          } else {
            workers--;
          }
        }
      }
      async close(comment = new Uint8Array(), options = {}) {
        const zipWriter = this;
        const { pendingAddFileCalls, writer } = this;
        const { writable } = writer;
        while (pendingAddFileCalls.size) {
          await Promise.all(Array.from(pendingAddFileCalls));
        }
        await closeFile(this, comment, options);
        const preventClose = getOptionValue2(zipWriter, options, "preventClose");
        if (!preventClose) {
          await writable.close();
        }
        return writer.getData ? writer.getData() : writable;
      }
    };
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/core/zip-fs-core.js
function getTotalSize(entries, propertyName) {
  let size = 0;
  entries.forEach(process2);
  return size;
  function process2(entry) {
    size += entry[propertyName];
    if (entry.children) {
      entry.children.forEach(process2);
    }
  }
}
function getZipBlobReader(options) {
  return class extends Reader {
    constructor(entry, options2 = {}) {
      super();
      this.entry = entry;
      this.options = options2;
    }
    async init() {
      const zipBlobReader = this;
      zipBlobReader.size = zipBlobReader.entry.uncompressedSize;
      const data2 = await zipBlobReader.entry.getData(new BlobWriter(), Object.assign({}, zipBlobReader.options, options));
      zipBlobReader.data = data2;
      zipBlobReader.blobReader = new BlobReader(data2);
      super.init();
    }
    readUint8Array(index, length) {
      return this.blobReader.readUint8Array(index, length);
    }
  };
}
async function initReaders(entry, options) {
  if (entry.children.length) {
    await Promise.all(entry.children.map(async (child) => {
      if (child.directory) {
        await initReaders(child, options);
      } else {
        const reader = child.reader = new child.Reader(child.data, options);
        try {
          await initStream(reader);
        } catch (error) {
          try {
            error.entryId = child.id;
            error.cause = {
              entry: child
            };
          } catch (_error) {
          }
          throw error;
        }
        child.uncompressedSize = reader.size;
      }
    }));
  }
}
function detach(entry) {
  if (entry.parent) {
    const children = entry.parent.children;
    children.forEach((child, index) => {
      if (child.id == entry.id) {
        children.splice(index, 1);
      }
    });
  }
}
async function exportZip(zipWriter, entry, totalSize, options) {
  const selectedEntry = entry;
  const entryOffsets = /* @__PURE__ */ new Map();
  await process2(zipWriter, entry);
  async function process2(zipWriter2, entry2) {
    await exportChild();
    async function exportChild() {
      if (options.bufferedWrite) {
        await Promise.allSettled(entry2.children.map(processChild));
      } else {
        for (const child of entry2.children) {
          await processChild(child);
        }
      }
    }
    async function processChild(child) {
      const name = options.relativePath ? child.getRelativeName(selectedEntry) : child.getFullname();
      let externalFileAttribute;
      let versionMadeBy;
      let comment;
      let lastModDate;
      let childOptions = child.options || {};
      if (child.data instanceof Entry) {
        ({
          externalFileAttribute,
          versionMadeBy,
          comment,
          lastModDate
        } = child.data);
      }
      await zipWriter2.add(name, child.reader, Object.assign({
        directory: child.directory
      }, Object.assign({}, options, {
        externalFileAttribute,
        versionMadeBy,
        comment,
        lastModDate,
        onprogress: async (indexProgress) => {
          if (options.onprogress) {
            entryOffsets.set(name, indexProgress);
            try {
              await options.onprogress(Array.from(entryOffsets.values()).reduce((previousValue, currentValue) => previousValue + currentValue), totalSize);
            } catch (_error) {
            }
          }
        }
      }, childOptions)));
      await process2(zipWriter2, child);
    }
  }
}
async function addFileSystemEntry(zipEntry, fileSystemEntry, options) {
  if (fileSystemEntry.isDirectory) {
    const entry = zipEntry.addDirectory(fileSystemEntry.name, options);
    await addDirectory(entry, fileSystemEntry);
    return entry;
  } else {
    return new Promise((resolve, reject) => fileSystemEntry.file((file) => resolve(zipEntry.addBlob(fileSystemEntry.name, file, options)), reject));
  }
  async function addDirectory(zipEntry2, fileEntry) {
    const children = await getChildren(fileEntry);
    for (const child of children) {
      if (child.isDirectory) {
        await addDirectory(zipEntry2.addDirectory(child.name, options), child);
      } else {
        await new Promise((resolve, reject) => {
          child.file((file) => {
            const childZipEntry = zipEntry2.addBlob(child.name, file, options);
            childZipEntry.uncompressedSize = file.size;
            resolve(childZipEntry);
          }, reject);
        });
      }
    }
  }
  function getChildren(fileEntry) {
    return new Promise((resolve, reject) => {
      let entries = [];
      if (fileEntry.isDirectory) {
        readEntries(fileEntry.createReader());
      }
      if (fileEntry.isFile) {
        resolve(entries);
      }
      function readEntries(directoryReader) {
        directoryReader.readEntries((temporaryEntries) => {
          if (!temporaryEntries.length) {
            resolve(entries);
          } else {
            entries = entries.concat(temporaryEntries);
            readEntries(directoryReader);
          }
        }, reject);
      }
    });
  }
}
function resetFS(fs3) {
  fs3.entries = [];
  fs3.root = new ZipDirectoryEntry(fs3);
}
function addChild(parent, name, params, directory) {
  if (parent.directory) {
    return directory ? new ZipDirectoryEntry(parent.fs, name, params, parent) : new ZipFileEntry(parent.fs, name, params, parent);
  } else {
    throw new Error("Parent entry is not a directory");
  }
}
var ZipEntry2, ZipFileEntry, ZipDirectoryEntry, FS, fs;
var init_zip_fs_core = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/core/zip-fs-core.js"() {
    init_io();
    init_zip_reader();
    init_zip_writer();
    init_zip_entry();
    ZipEntry2 = class {
      constructor(fs3, name, params, parent) {
        const zipEntry = this;
        if (fs3.root && parent && parent.getChildByName(name)) {
          throw new Error("Entry filename already exists");
        }
        if (!params) {
          params = {};
        }
        Object.assign(zipEntry, {
          fs: fs3,
          name,
          data: params.data,
          options: params.options,
          id: fs3.entries.length,
          parent,
          children: [],
          uncompressedSize: 0
        });
        fs3.entries.push(zipEntry);
        if (parent) {
          zipEntry.parent.children.push(zipEntry);
        }
      }
      moveTo(target) {
        const zipEntry = this;
        zipEntry.fs.move(zipEntry, target);
      }
      getFullname() {
        return this.getRelativeName();
      }
      getRelativeName(ancestor = this.fs.root) {
        const zipEntry = this;
        let relativeName = zipEntry.name;
        let entry = zipEntry.parent;
        while (entry && entry != ancestor) {
          relativeName = (entry.name ? entry.name + "/" : "") + relativeName;
          entry = entry.parent;
        }
        return relativeName;
      }
      isDescendantOf(ancestor) {
        let entry = this.parent;
        while (entry && entry.id != ancestor.id) {
          entry = entry.parent;
        }
        return Boolean(entry);
      }
      rename(name) {
        const parent = this.parent;
        if (parent && parent.getChildByName(name)) {
          throw new Error("Entry filename already exists");
        } else {
          this.name = name;
        }
      }
    };
    ZipFileEntry = class _ZipFileEntry extends ZipEntry2 {
      constructor(fs3, name, params, parent) {
        super(fs3, name, params, parent);
        const zipEntry = this;
        zipEntry.Reader = params.Reader;
        zipEntry.Writer = params.Writer;
        if (params.getData) {
          zipEntry.getData = params.getData;
        }
      }
      clone() {
        return new _ZipFileEntry(this.fs, this.name, this);
      }
      async getData(writer, options = {}) {
        const zipEntry = this;
        if (!writer || writer.constructor == zipEntry.Writer && zipEntry.data) {
          return zipEntry.data;
        } else {
          const reader = zipEntry.reader = new zipEntry.Reader(zipEntry.data, options);
          await Promise.all([initStream(reader), initStream(writer, zipEntry.data.uncompressedSize)]);
          const readable = reader.readable;
          readable.size = zipEntry.uncompressedSize = reader.size;
          await readable.pipeTo(writer.writable);
          return writer.getData ? writer.getData() : writer.writable;
        }
      }
      isPasswordProtected() {
        return this.data.encrypted;
      }
      async checkPassword(password, options = {}) {
        const zipEntry = this;
        if (zipEntry.isPasswordProtected()) {
          options.password = password;
          options.checkPasswordOnly = true;
          try {
            await zipEntry.data.getData(null, options);
            return true;
          } catch (error) {
            if (error.message == ERR_INVALID_PASSWORD) {
              return false;
            } else {
              throw error;
            }
          }
        } else {
          return true;
        }
      }
      getText(encoding, options) {
        return this.getData(new TextWriter(encoding), options);
      }
      getBlob(mimeType, options) {
        return this.getData(new BlobWriter(mimeType), options);
      }
      getData64URI(mimeType, options) {
        return this.getData(new Data64URIWriter(mimeType), options);
      }
      getUint8Array(options) {
        return this.getData(new Uint8ArrayWriter(), options);
      }
      getWritable(writable = new WritableStream(), options) {
        return this.getData({ writable }, options);
      }
      replaceBlob(blob) {
        Object.assign(this, {
          data: blob,
          Reader: BlobReader,
          Writer: BlobWriter,
          reader: null
        });
      }
      replaceText(text) {
        Object.assign(this, {
          data: text,
          Reader: TextReader,
          Writer: TextWriter,
          reader: null
        });
      }
      replaceData64URI(dataURI) {
        Object.assign(this, {
          data: dataURI,
          Reader: Data64URIReader,
          Writer: Data64URIWriter,
          reader: null
        });
      }
      replaceUint8Array(array) {
        Object.assign(this, {
          data: array,
          Reader: Uint8ArrayReader,
          Writer: Uint8ArrayWriter,
          reader: null
        });
      }
      replaceReadable(readable) {
        Object.assign(this, {
          data: null,
          Reader: function() {
            return { readable };
          },
          Writer: null,
          reader: null
        });
      }
    };
    ZipDirectoryEntry = class _ZipDirectoryEntry extends ZipEntry2 {
      constructor(fs3, name, params, parent) {
        super(fs3, name, params, parent);
        this.directory = true;
      }
      clone(deepClone) {
        const zipEntry = this;
        const clonedEntry = new _ZipDirectoryEntry(zipEntry.fs, zipEntry.name);
        if (deepClone) {
          clonedEntry.children = zipEntry.children.map((child) => {
            const childClone = child.clone(deepClone);
            childClone.parent = clonedEntry;
            return childClone;
          });
        }
        return clonedEntry;
      }
      addDirectory(name, options) {
        return addChild(this, name, { options }, true);
      }
      addText(name, text, options = {}) {
        return addChild(this, name, {
          data: text,
          Reader: TextReader,
          Writer: TextWriter,
          options
        });
      }
      addBlob(name, blob, options = {}) {
        return addChild(this, name, {
          data: blob,
          Reader: BlobReader,
          Writer: BlobWriter,
          options
        });
      }
      addData64URI(name, dataURI, options = {}) {
        return addChild(this, name, {
          data: dataURI,
          Reader: Data64URIReader,
          Writer: Data64URIWriter,
          options
        });
      }
      addUint8Array(name, array, options = {}) {
        return addChild(this, name, {
          data: array,
          Reader: Uint8ArrayReader,
          Writer: Uint8ArrayWriter,
          options
        });
      }
      addHttpContent(name, url, options = {}) {
        return addChild(this, name, {
          data: url,
          Reader: class extends HttpReader {
            constructor(url2) {
              super(url2, options);
            }
          },
          options
        });
      }
      addReadable(name, readable, options = {}) {
        return addChild(this, name, {
          Reader: function() {
            return { readable };
          },
          options
        });
      }
      addFileSystemEntry(fileSystemEntry, options = {}) {
        return addFileSystemEntry(this, fileSystemEntry, options);
      }
      addData(name, params) {
        return addChild(this, name, params);
      }
      importBlob(blob, options) {
        return this.importZip(new BlobReader(blob), options);
      }
      importData64URI(dataURI, options) {
        return this.importZip(new Data64URIReader(dataURI), options);
      }
      importUint8Array(array, options) {
        return this.importZip(new Uint8ArrayReader(array), options);
      }
      importHttpContent(url, options) {
        return this.importZip(new HttpReader(url, options), options);
      }
      importReadable(readable, options) {
        return this.importZip({ readable }, options);
      }
      exportBlob(options = {}) {
        return this.exportZip(new BlobWriter(options.mimeType || "application/zip"), options);
      }
      exportData64URI(options = {}) {
        return this.exportZip(new Data64URIWriter(options.mimeType || "application/zip"), options);
      }
      exportUint8Array(options = {}) {
        return this.exportZip(new Uint8ArrayWriter(), options);
      }
      async exportWritable(writable = new WritableStream(), options = {}) {
        await this.exportZip({ writable }, options);
        return writable;
      }
      async importZip(reader, options = {}) {
        await initStream(reader);
        const zipReader = new ZipReader(reader, options);
        const importedEntries = [];
        const entries = await zipReader.getEntries();
        for (const entry of entries) {
          let parent = this;
          try {
            const path2 = entry.filename.split("/");
            const name = path2.pop();
            path2.forEach((pathPart, pathIndex) => {
              const previousParent = parent;
              parent = parent.getChildByName(pathPart);
              if (!parent) {
                parent = new _ZipDirectoryEntry(this.fs, pathPart, { data: pathIndex == path2.length - 1 ? entry : null }, previousParent);
                importedEntries.push(parent);
              }
            });
            if (!entry.directory) {
              importedEntries.push(addChild(parent, name, {
                data: entry,
                Reader: getZipBlobReader(Object.assign({}, options))
              }));
            }
          } catch (error) {
            try {
              error.cause = {
                entry
              };
            } catch (_error) {
            }
            throw error;
          }
        }
        return importedEntries;
      }
      async exportZip(writer, options) {
        const zipEntry = this;
        await Promise.all([initReaders(zipEntry, options.readerOptions), initStream(writer)]);
        const zipWriter = new ZipWriter(writer, options);
        await exportZip(zipWriter, zipEntry, getTotalSize([zipEntry], "uncompressedSize"), options);
        await zipWriter.close();
        return writer.getData ? writer.getData() : writer.writable;
      }
      getChildByName(name) {
        const children = this.children;
        for (let childIndex = 0; childIndex < children.length; childIndex++) {
          const child = children[childIndex];
          if (child.name == name) {
            return child;
          }
        }
      }
      isPasswordProtected() {
        const children = this.children;
        for (let childIndex = 0; childIndex < children.length; childIndex++) {
          const child = children[childIndex];
          if (child.isPasswordProtected()) {
            return true;
          }
        }
        return false;
      }
      async checkPassword(password, options = {}) {
        const children = this.children;
        const result = await Promise.all(children.map((child) => child.checkPassword(password, options)));
        return !result.includes(false);
      }
    };
    FS = class {
      constructor() {
        resetFS(this);
      }
      get children() {
        return this.root.children;
      }
      remove(entry) {
        detach(entry);
        this.entries[entry.id] = null;
      }
      move(entry, destination) {
        if (entry == this.root) {
          throw new Error("Root directory cannot be moved");
        } else {
          if (destination.directory) {
            if (!destination.isDescendantOf(entry)) {
              if (entry != destination) {
                if (destination.getChildByName(entry.name)) {
                  throw new Error("Entry filename already exists");
                }
                detach(entry);
                entry.parent = destination;
                destination.children.push(entry);
              }
            } else {
              throw new Error("Entry is a ancestor of target entry");
            }
          } else {
            throw new Error("Target entry is not a directory");
          }
        }
      }
      find(fullname) {
        const path2 = fullname.split("/");
        let node = this.root;
        for (let index = 0; node && index < path2.length; index++) {
          node = node.getChildByName(path2[index]);
        }
        return node;
      }
      getById(id) {
        return this.entries[id];
      }
      getChildByName(name) {
        return this.root.getChildByName(name);
      }
      addDirectory(name, options) {
        return this.root.addDirectory(name, options);
      }
      addText(name, text, options) {
        return this.root.addText(name, text, options);
      }
      addBlob(name, blob, options) {
        return this.root.addBlob(name, blob, options);
      }
      addData64URI(name, dataURI, options) {
        return this.root.addData64URI(name, dataURI, options);
      }
      addHttpContent(name, url, options) {
        return this.root.addHttpContent(name, url, options);
      }
      addReadable(name, readable, options) {
        return this.root.addReadable(name, readable, options);
      }
      addFileSystemEntry(fileSystemEntry, options) {
        return this.root.addFileSystemEntry(fileSystemEntry, options);
      }
      addData(name, params) {
        return this.root.addData(name, params);
      }
      importBlob(blob, options) {
        resetFS(this);
        return this.root.importBlob(blob, options);
      }
      importData64URI(dataURI, options) {
        resetFS(this);
        return this.root.importData64URI(dataURI, options);
      }
      importUint8Array(array, options) {
        resetFS(this);
        return this.root.importUint8Array(array, options);
      }
      importHttpContent(url, options) {
        resetFS(this);
        return this.root.importHttpContent(url, options);
      }
      importReadable(readable, options) {
        resetFS(this);
        return this.root.importReadable(readable, options);
      }
      importZip(reader, options) {
        return this.root.importZip(reader, options);
      }
      exportBlob(options) {
        return this.root.exportBlob(options);
      }
      exportData64URI(options) {
        return this.root.exportData64URI(options);
      }
      exportUint8Array(options) {
        return this.root.exportUint8Array(options);
      }
      exportWritable(writable, options) {
        return this.root.exportWritable(writable, options);
      }
      isPasswordProtected() {
        return this.root.isPasswordProtected();
      }
      async checkPassword(password, options) {
        return this.root.checkPassword(password, options);
      }
    };
    fs = { FS, ZipDirectoryEntry, ZipFileEntry };
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/lib/zip-fs.js
var baseURL;
var init_zip_fs = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/lib/zip-fs.js"() {
    init_configuration();
    init_z_worker_inline();
    init_default_mime_type();
    init_stream_codec_shim();
    init_codec_pool();
    init_io();
    init_zip_reader();
    init_zip_writer();
    init_zip_fs_core();
    try {
      baseURL = import.meta.url;
    } catch (_error) {
    }
    configure({ baseURL });
    e2(configure);
  }
});

// node_modules/scribe.js-ocr/lib/zip.js/index.js
var zip_exports = {};
__export(zip_exports, {
  BlobReader: () => BlobReader,
  BlobWriter: () => BlobWriter,
  Data64URIReader: () => Data64URIReader,
  Data64URIWriter: () => Data64URIWriter,
  ERR_BAD_FORMAT: () => ERR_BAD_FORMAT,
  ERR_CENTRAL_DIRECTORY_NOT_FOUND: () => ERR_CENTRAL_DIRECTORY_NOT_FOUND,
  ERR_DUPLICATED_NAME: () => ERR_DUPLICATED_NAME,
  ERR_ENCRYPTED: () => ERR_ENCRYPTED,
  ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND: () => ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND,
  ERR_EOCDR_NOT_FOUND: () => ERR_EOCDR_NOT_FOUND,
  ERR_EOCDR_ZIP64_NOT_FOUND: () => ERR_EOCDR_ZIP64_NOT_FOUND,
  ERR_EXTRAFIELD_ZIP64_NOT_FOUND: () => ERR_EXTRAFIELD_ZIP64_NOT_FOUND,
  ERR_HTTP_RANGE: () => ERR_HTTP_RANGE,
  ERR_INVALID_COMMENT: () => ERR_INVALID_COMMENT,
  ERR_INVALID_ENCRYPTION_STRENGTH: () => ERR_INVALID_ENCRYPTION_STRENGTH,
  ERR_INVALID_ENTRY_COMMENT: () => ERR_INVALID_ENTRY_COMMENT,
  ERR_INVALID_ENTRY_NAME: () => ERR_INVALID_ENTRY_NAME,
  ERR_INVALID_EXTRAFIELD_DATA: () => ERR_INVALID_EXTRAFIELD_DATA,
  ERR_INVALID_EXTRAFIELD_TYPE: () => ERR_INVALID_EXTRAFIELD_TYPE,
  ERR_INVALID_PASSWORD: () => ERR_INVALID_PASSWORD,
  ERR_INVALID_SIGNATURE: () => ERR_INVALID_SIGNATURE,
  ERR_INVALID_VERSION: () => ERR_INVALID_VERSION,
  ERR_ITERATOR_COMPLETED_TOO_SOON: () => ERR_ITERATOR_COMPLETED_TOO_SOON,
  ERR_LOCAL_FILE_HEADER_NOT_FOUND: () => ERR_LOCAL_FILE_HEADER_NOT_FOUND,
  ERR_SPLIT_ZIP_FILE: () => ERR_SPLIT_ZIP_FILE,
  ERR_UNSUPPORTED_COMPRESSION: () => ERR_UNSUPPORTED_COMPRESSION,
  ERR_UNSUPPORTED_ENCRYPTION: () => ERR_UNSUPPORTED_ENCRYPTION,
  ERR_UNSUPPORTED_FORMAT: () => ERR_UNSUPPORTED_FORMAT,
  HttpRangeReader: () => HttpRangeReader,
  HttpReader: () => HttpReader,
  Reader: () => Reader,
  SplitDataReader: () => SplitDataReader,
  SplitDataWriter: () => SplitDataWriter,
  SplitZipReader: () => SplitZipReader,
  SplitZipWriter: () => SplitZipWriter,
  TextReader: () => TextReader,
  TextWriter: () => TextWriter,
  Uint8ArrayReader: () => Uint8ArrayReader,
  Uint8ArrayWriter: () => Uint8ArrayWriter,
  Writer: () => Writer,
  ZipReader: () => ZipReader,
  ZipWriter: () => ZipWriter,
  configure: () => configure,
  fs: () => fs,
  getMimeType: () => getMimeType2,
  initShimAsyncCodec: () => initShimAsyncCodec,
  terminateWorkers: () => terminateWorkers
});
var init_zip = __esm({
  "node_modules/scribe.js-ocr/lib/zip.js/index.js"() {
    init_deflate();
    init_inflate();
    init_configuration();
    init_mime_type();
    init_codec_pool();
    init_zip_fs();
    configure({ Deflate: ZipDeflate, Inflate: ZipInflate });
  }
});

// node_modules/scribe.js-ocr/js/export/writeDocx.js
var writeDocx_exports = {};
__export(writeDocx_exports, {
  writeDocx: () => writeDocx,
  writeDocxContent: () => writeDocxContent
});
function writeDocxContent({
  ocrCurrent,
  minpage = 0,
  maxpage = -1,
  reflowText = false,
  wordIds = null
}) {
  let textStr = "";
  if (maxpage === -1) maxpage = ocrCurrent.length - 1;
  let newLine = false;
  for (let g2 = minpage; g2 <= maxpage; g2++) {
    if (!ocrCurrent[g2] || ocrCurrent[g2].lines.length === 0) continue;
    const pageObj = ocrCurrent[g2];
    if (reflowText && (!pageObj.textSource || !["textract", "abbyy"].includes(pageObj.textSource))) {
      const angle = pageMetricsAll[g2].angle || 0;
      assignParagraphs(pageObj, angle);
    }
    let parCurrent = pageObj.lines[0].par;
    let fontStylePrev = "";
    let supPrev = false;
    for (let h2 = 0; h2 < pageObj.lines.length; h2++) {
      const lineObj = pageObj.lines[h2];
      if (reflowText) {
        if (g2 > 0 && h2 === 0 || lineObj.par !== parCurrent) newLine = true;
        parCurrent = lineObj.par;
      } else {
        newLine = true;
      }
      for (let i2 = 0; i2 < lineObj.words.length; i2++) {
        const wordObj = lineObj.words[i2];
        if (!wordObj) continue;
        if (wordIds && !wordIds.includes(wordObj.id)) continue;
        let fontStyle = "";
        if (wordObj.style.italic) {
          fontStyle += "<w:i/>";
        } else if (wordObj.style.bold) {
          fontStyle += "<w:b/>";
        }
        if (wordObj.style.smallCaps) {
          fontStyle += "<w:smallCaps/>";
        }
        if (wordObj.style.underline) {
          fontStyle += '<w:u w:val="single"/>';
        }
        if (wordObj.style.sup) {
          fontStyle += '<w:vertAlign w:val="superscript"/>';
        }
        if (newLine || fontStyle !== fontStylePrev || h2 === 0 && g2 === 0 && i2 === 0) {
          const styleStr = fontStyle === "" ? "" : `<w:rPr>${fontStyle}</w:rPr>`;
          if (h2 === 0 && g2 === 0 && i2 === 0) {
            textStr = `${textStr}<w:p><w:r>${styleStr}<w:t xml:space="preserve">`;
          } else if (newLine) {
            textStr = `${textStr}</w:t></w:r></w:p><w:p><w:r>${styleStr}<w:t xml:space="preserve">`;
          } else if (supPrev) {
            textStr = `${textStr}</w:t></w:r><w:r>${styleStr}<w:t xml:space="preserve"> `;
          } else if (wordObj.style.sup && i2 > 0) {
            textStr = `${textStr}</w:t></w:r><w:r>${styleStr}<w:t xml:space="preserve">`;
          } else {
            textStr = `${textStr} </w:t></w:r><w:r>${styleStr}<w:t xml:space="preserve">`;
          }
        } else {
          textStr += " ";
        }
        fontStylePrev = fontStyle;
        supPrev = wordObj.style.sup;
        newLine = false;
        textStr += ocrObjects_default.escapeXml(wordObj.text);
      }
    }
    opt.progressHandler({ n: g2, type: "export", info: {} });
  }
  if (textStr) textStr += "</w:t></w:r></w:p>";
  return textStr;
}
async function writeDocx({ hocrCurrent, minpage = 0, maxpage = -1 }) {
  const { Uint8ArrayWriter: Uint8ArrayWriter2, TextReader: TextReader2, ZipWriter: ZipWriter2 } = await Promise.resolve().then(() => (init_zip(), zip_exports));
  if (maxpage === -1) maxpage = hocrCurrent.length - 1;
  const zipFileWriter = new Uint8ArrayWriter2();
  const zipWriter = new ZipWriter2(zipFileWriter);
  const textReader = new TextReader2(documentStart + writeDocxContent({
    ocrCurrent: hocrCurrent,
    minpage,
    maxpage,
    reflowText: opt.reflow
  }) + documentEnd);
  await zipWriter.add("word/document.xml", textReader);
  for (let i2 = 0; i2 < docxStrings.length; i2++) {
    const textReaderI = new TextReader2(docxStrings[i2].content);
    await zipWriter.add(docxStrings[i2].path, textReaderI);
  }
  await zipWriter.close();
  const zipFileData = await zipFileWriter.getData();
  return zipFileData;
}
var init_writeDocx = __esm({
  "node_modules/scribe.js-ocr/js/export/writeDocx.js"() {
    init_docxFiles();
    init_app();
    init_reflowPars();
    init_dataContainer();
    init_ocrObjects();
  }
});

// node_modules/scribe.js-ocr/js/extractTables.js
function extractTableContent(pageObj, layoutObj) {
  const tableWordObj = {};
  if (!layoutObj?.tables || Object.keys(layoutObj.tables).length === 0) return tableWordObj;
  for (const [key, value] of Object.entries(layoutObj.tables)) {
    tableWordObj[key] = extractSingleTableContent(pageObj, Object.values(value.boxes));
  }
  return tableWordObj;
}
function extractSingleTableContent(pageObj, boxes) {
  const wordArr = [];
  const boxArr = [];
  const wordPriorityArr = [];
  const boxesArr = Object.values(boxes).sort((a2, b2) => a2.coords.left - b2.coords.left);
  const tableBox = {
    left: boxesArr[0].coords.left,
    top: boxesArr[0].coords.top,
    right: boxesArr[boxesArr.length - 1].coords.right,
    bottom: boxesArr[boxesArr.length - 1].coords.bottom
  };
  for (let i2 = 0; i2 < pageObj.lines.length; i2++) {
    const lineObj = ocrObjects_default.cloneLine(pageObj.lines[i2]);
    ocrObjects_default.rotateLine(lineObj, pageObj.angle * -1, pageObj.dims);
    if (lineObj.bbox.left > tableBox.right || lineObj.bbox.right < tableBox.left || lineObj.bbox.top > tableBox.bottom || lineObj.bbox.bottom < tableBox.top) continue;
    const lineBoxALeft = {
      left: lineObj.bbox.left,
      top: lineObj.bbox.top,
      right: lineObj.bbox.left + 1,
      bottom: lineObj.bbox.bottom
    };
    let boxFoundLine = false;
    for (let j2 = 0; j2 < boxesArr.length; j2++) {
      const obj = boxesArr[j2];
      if (obj.inclusionLevel !== "line") continue;
      const overlap = obj.inclusionRule === "left" ? calcBoxOverlap(lineBoxALeft, obj.coords) : calcBoxOverlap(lineObj.bbox, obj.coords);
      if (overlap > 0.5) {
        for (let k2 = 0; k2 < lineObj.words.length; k2++) {
          const wordObj = lineObj.words[k2];
          wordArr.push(wordObj);
          boxArr.push(lineObj.bbox);
          wordPriorityArr.push(j2);
        }
        boxFoundLine = true;
        break;
      }
    }
    if (boxFoundLine) continue;
    for (const wordObj of lineObj.words) {
      let boxFoundWord = false;
      for (let j2 = 0; j2 < boxesArr.length; j2++) {
        const obj = boxesArr[j2];
        if (obj.inclusionLevel !== "word") continue;
        const wordBoxALeft = {
          left: wordObj.bbox.left,
          top: wordObj.bbox.top,
          right: wordObj.bbox.left + 1,
          bottom: wordObj.bbox.bottom
        };
        const overlap = obj.inclusionRule === "left" ? calcBoxOverlap(wordBoxALeft, obj.coords) : calcBoxOverlap(wordObj.bbox, obj.coords);
        if (overlap > 0.5) {
          wordArr.push(wordObj);
          boxArr.push(wordObj.bbox);
          wordPriorityArr.push(j2);
          boxFoundWord = true;
          break;
        }
      }
      if (boxFoundWord) continue;
      for (let j2 = 0; j2 < boxesArr.length; j2++) {
        const obj = boxesArr[j2];
        const overlap = calcBoxOverlap(wordObj.bbox, obj.coords);
        if (overlap > 0.5) {
          wordArr.push(wordObj);
          boxArr.push(wordObj.bbox);
          wordPriorityArr.push(j2);
          break;
        }
      }
    }
  }
  const colArr = [];
  for (let i2 = 0; i2 < boxesArr.length; i2++) {
    colArr.push([]);
    for (let j2 = 0; j2 < wordPriorityArr.length; j2++) {
      if (wordPriorityArr[j2] === i2) {
        colArr[colArr.length - 1].push({ word: wordArr[j2], box: boxArr[j2] });
      }
    }
  }
  colArr.forEach((x2) => x2.sort((a2, b2) => a2.box.bottom - b2.box.bottom));
  const indexArr = Array(colArr.length);
  indexArr.fill(0);
  const lengthArr = colArr.map((x2) => x2.length);
  const rowWordArr = [];
  const rowBottomArr = [];
  while (!indexArr.every((x2, index) => x2 === lengthArr[index])) {
    const compArrBox = indexArr.map((x2, index) => colArr[index][x2]);
    compArrBox.sort((a2, b2) => a2.box.bottom - b2.box.bottom);
    const rowBox = {
      left: 0,
      top: 0,
      right: 5e3,
      bottom: compArrBox[0].box.bottom
    };
    const colWordArr = [];
    for (let i2 = 0; i2 < colArr.length; i2++) {
      colWordArr[i2] = [];
    }
    let rowBottom;
    for (let i2 = 0; i2 < indexArr.length; i2++) {
      for (let j2 = indexArr[i2]; j2 < colArr[i2].length; j2++) {
        const overlap = calcBoxOverlap(colArr[i2][j2].box, rowBox);
        if (overlap > 0.5) {
          colWordArr[i2].push(colArr[i2][j2].word);
          if (!rowBottom || colArr[i2][j2].box.bottom > rowBottom) rowBottom = colArr[i2][j2].box.bottom;
          indexArr[i2]++;
        } else {
          break;
        }
      }
    }
    rowWordArr.push(colWordArr);
    rowBottomArr.push(rowBottom);
  }
  return { rowWordArr, rowBottomArr };
}
var init_extractTables = __esm({
  "node_modules/scribe.js-ocr/js/extractTables.js"() {
    init_ocrObjects();
    init_miscUtils();
  }
});

// node_modules/scribe.js-ocr/js/export/resources/xlsxFiles.js
var xlsxFiles_exports = {};
__export(xlsxFiles_exports, {
  sheetEnd: () => sheetEnd,
  sheetStart: () => sheetStart,
  xlsxStrings: () => xlsxStrings
});
var rels3, contentTypes2, app2, core2, styles2, workbook, rels22, theme2, xlsxStrings, sheetStart, sheetEnd;
var init_xlsxFiles = __esm({
  "node_modules/scribe.js-ocr/js/export/resources/xlsxFiles.js"() {
    rels3 = String.raw`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>`;
    contentTypes2 = String.raw`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/><Default Extension="xml" ContentType="application/xml"/><Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/><Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/><Override PartName="/xl/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/><Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/><Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/><Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/></Types>`;
    app2 = String.raw`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"><Application>Microsoft Excel</Application><DocSecurity>0</DocSecurity><ScaleCrop>false</ScaleCrop><HeadingPairs><vt:vector size="2" baseType="variant"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs><TitlesOfParts><vt:vector size="1" baseType="lpstr"><vt:lpstr>Sheet1</vt:lpstr></vt:vector></TitlesOfParts><Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion></Properties>`;
    core2 = String.raw`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dc:creator>user</dc:creator><cp:lastModifiedBy>user</cp:lastModifiedBy><dcterms:created xsi:type="dcterms:W3CDTF">2023-06-08T01:17:56Z</dcterms:created><dcterms:modified xsi:type="dcterms:W3CDTF">2023-06-08T01:18:08Z</dcterms:modified></cp:coreProperties>`;
    styles2 = String.raw`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2 xr" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision"><fonts count="1" x14ac:knownFonts="1"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/></cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles><dxfs count="0"/><tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>`;
    workbook = String.raw`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x15 xr xr6 xr10 xr2" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr6="http://schemas.microsoft.com/office/spreadsheetml/2016/revision6" xmlns:xr10="http://schemas.microsoft.com/office/spreadsheetml/2016/revision10" xmlns:xr2="http://schemas.microsoft.com/office/spreadsheetml/2015/revision2"><fileVersion appName="xl" lastEdited="7" lowestEdited="7" rupBuild="26327"/><workbookPr defaultThemeVersion="166925"/><mc:AlternateContent xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"><mc:Choice Requires="x15"><x15ac:absPath url="C:\Users\user\Downloads\" xmlns:x15ac="http://schemas.microsoft.com/office/spreadsheetml/2010/11/ac"/></mc:Choice></mc:AlternateContent><xr:revisionPtr revIDLastSave="0" documentId="8_{C0A956D4-1831-463D-8DD4-02F30254014A}" xr6:coauthVersionLast="47" xr6:coauthVersionMax="47" xr10:uidLastSave="{00000000-0000-0000-0000-000000000000}"/><bookViews><workbookView xWindow="-38520" yWindow="-120" windowWidth="38640" windowHeight="21240" xr2:uid="{484F1F49-1323-4A47-B8F3-28188180E309}"/></bookViews><sheets><sheet name="Sheet1" sheetId="1" r:id="rId1"/></sheets><calcPr calcId="191029"/><extLst><ext uri="{140A7094-0E35-4892-8432-C4D2E57EDEB5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:workbookPr chartTrackingRefBase="1"/></ext><ext uri="{B58B0392-4F1F-4190-BB64-5DF3571DCE5F}" xmlns:xcalcf="http://schemas.microsoft.com/office/spreadsheetml/2018/calcfeatures"><xcalcf:calcFeatures><xcalcf:feature name="microsoft.com:RD"/><xcalcf:feature name="microsoft.com:Single"/><xcalcf:feature name="microsoft.com:FV"/><xcalcf:feature name="microsoft.com:CNMTM"/><xcalcf:feature name="microsoft.com:LET_WF"/><xcalcf:feature name="microsoft.com:LAMBDA_WF"/><xcalcf:feature name="microsoft.com:ARRAYTEXT_WF"/></xcalcf:calcFeatures></ext></extLst></workbook>`;
    rels22 = String.raw`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/></Relationships>`;
    theme2 = String.raw`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="4472C4"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="5B9BD5"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface=" Light"/><a:font script="Hang" typeface=" "/><a:font script="Hans" typeface=" Light"/><a:font script="Hant" typeface=""/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface=""/><a:font script="Hang" typeface=" "/><a:font script="Hans" typeface=""/><a:font script="Hant" typeface=""/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>`;
    xlsxStrings = [
      { path: "_rels/.rels", content: rels3 },
      { path: "[Content_Types].xml", content: contentTypes2 },
      { path: "docProps/app.xml", content: app2 },
      { path: "docProps/core.xml", content: core2 },
      { path: "xl/styles.xml", content: styles2 },
      { path: "xl/workbook.xml", content: workbook },
      { path: "xl/_rels/workbook.xml.rels", content: rels22 },
      { path: "xl/theme/theme1.xml", content: theme2 }
    ];
    sheetStart = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac xr xr2 xr3" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr2="http://schemas.microsoft.com/office/spreadsheetml/2015/revision2" xmlns:xr3="http://schemas.microsoft.com/office/spreadsheetml/2016/revision3" xr:uid="{63929E9A-7BB2-4519-9F63-8656CB57DC6F}"><dimension ref="A1:B2"/><sheetViews><sheetView tabSelected="1" workbookViewId="0"><selection activeCell="A2" sqref="A2"/></sheetView></sheetViews><sheetFormatPr defaultRowHeight="15" x14ac:dyDescent="0.25"/><sheetData>`;
    sheetEnd = '</sheetData><pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/></worksheet>';
  }
});

// node_modules/scribe.js-ocr/js/export/writeTabular.js
var writeTabular_exports = {};
__export(writeTabular_exports, {
  createCells: () => createCells,
  writeXlsx: () => writeXlsx
});
function createCells({
  tableWordObj,
  extraCols = [],
  startRow = 0,
  xlsxMode = true,
  htmlMode = false
}) {
  let textStr = "";
  let rowIndex = startRow;
  let rowCount = 0;
  for (const [key, value] of Object.entries(tableWordObj)) {
    const cellsSingle = createCellsSingle({
      ocrTableWords: value.rowWordArr,
      extraCols,
      startRow: rowIndex,
      xlsxMode,
      htmlMode
    });
    textStr += cellsSingle.content;
    rowIndex += cellsSingle.rows;
    rowCount += cellsSingle.rows;
  }
  return { content: textStr, rows: rowCount };
}
function createCellsSingle({
  ocrTableWords,
  extraCols = [],
  startRow = 0,
  xlsxMode = true,
  htmlMode = false,
  previewMode = true
}) {
  const letters = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
  let textStr = htmlMode ? "<table>" : "";
  for (let i2 = 0; i2 < ocrTableWords.length; i2++) {
    if (xlsxMode) {
      textStr += `<row r="${String(startRow + i2 + 1)}">`;
    } else if (htmlMode) {
      textStr += "<tr>";
    }
    for (let j2 = 0; j2 < extraCols.length; j2++) {
      let colTxt = ocrObjects_default.escapeXml(extraCols[j2]);
      if (xlsxMode) {
        textStr += `<c r="${letters[j2]}${String(startRow + i2 + 1)}" t="inlineStr"><is><r><t xml:space="preserve">${colTxt}</t></r></is></c>`;
      } else if (htmlMode) {
        if (previewMode && colTxt.length > 13) {
          colTxt = `${colTxt.slice(0, 20)}...`;
        }
        textStr += `<td>${colTxt}</td>`;
      }
    }
    for (let j2 = 0; j2 < ocrTableWords[i2].length; j2++) {
      const words = ocrTableWords[i2][j2];
      if (!words || words.length === 0) {
        if (htmlMode) {
          textStr += "<td/>";
        }
        continue;
      }
      words.sort((a2, b2) => a2.bbox.left - b2.bbox.left);
      if (xlsxMode) {
        textStr += `<c r="${letters[j2 + extraCols.length]}${String(startRow + i2 + 1)}" t="inlineStr"><is>`;
      } else if (htmlMode) {
        textStr += "<td>";
      }
      for (let k2 = 0; k2 < words.length; k2++) {
        const wordObj = words[k2];
        const fontStylePrev = "";
        if (xlsxMode) {
          let fontStyle;
          if (wordObj.style.italic) {
            fontStyle = "<i/>";
          } else if (wordObj.style.smallCaps) {
            fontStyle = "<smallCaps/>";
          } else {
            fontStyle = "";
          }
          if (fontStyle !== fontStylePrev || k2 === 0) {
            const styleStr = fontStyle === "" ? "" : `<rPr>${fontStyle}</rPr>`;
            if (k2 === 0) {
              textStr = `${textStr}<r>${styleStr}<t xml:space="preserve">`;
            } else {
              textStr = `${textStr} </t></r><r>${styleStr}<t xml:space="preserve">`;
            }
          } else {
            textStr += " ";
          }
        } else {
          textStr += " ";
        }
        if (xlsxMode) {
          textStr += ocrObjects_default.escapeXml(wordObj.text);
        } else {
          textStr += wordObj.text;
        }
      }
      if (xlsxMode) {
        textStr += "</t></r></is></c>";
      } else if (htmlMode) {
        textStr += "</td>";
      }
    }
    if (xlsxMode) {
      textStr += "</row>";
    } else if (htmlMode) {
      textStr += "</tr>";
    }
  }
  if (htmlMode) textStr += "</table>";
  return { content: textStr, rows: ocrTableWords.length };
}
async function writeXlsx({
  ocrPageArr,
  layoutPageArr,
  minpage = 0,
  maxpage = -1
}) {
  const { xlsxStrings: xlsxStrings2, sheetStart: sheetStart2, sheetEnd: sheetEnd2 } = await Promise.resolve().then(() => (init_xlsxFiles(), xlsxFiles_exports));
  const { Uint8ArrayWriter: Uint8ArrayWriter2, TextReader: TextReader2, ZipWriter: ZipWriter2 } = await Promise.resolve().then(() => (init_zip(), zip_exports));
  if (maxpage === -1) maxpage = ocrPageArr.length - 1;
  const zipFileWriter = new Uint8ArrayWriter2();
  const zipWriter = new ZipWriter2(zipFileWriter);
  let sheetContent = sheetStart2;
  let rowCount = 0;
  for (let i2 = minpage; i2 <= maxpage; i2++) {
    const extraCols = [];
    if (opt.xlsxFilenameColumn) {
      if (inputData.pdfMode) {
        extraCols.push(inputData.inputFileNames[0]);
      } else {
        extraCols.push(inputData.inputFileNames[i2]);
      }
    }
    if (opt.xlsxPageNumberColumn) extraCols.push(String(i2 + 1));
    const tableWordObj = extractTableContent(ocrPageArr[i2], layoutPageArr[i2]);
    const cellsObj = createCells({ tableWordObj, extraCols, startRow: rowCount });
    rowCount += cellsObj.rows;
    sheetContent += cellsObj.content;
    opt.progressHandler({ n: i2, type: "export", info: {} });
  }
  sheetContent += sheetEnd2;
  const textReader = new TextReader2(sheetContent);
  await zipWriter.add("xl/worksheets/sheet1.xml", textReader);
  for (let i2 = 0; i2 < xlsxStrings2.length; i2++) {
    const textReaderI = new TextReader2(xlsxStrings2[i2].content);
    await zipWriter.add(xlsxStrings2[i2].path, textReaderI);
  }
  await zipWriter.close();
  const zipFileData = await zipFileWriter.getData();
  return zipFileData;
}
var init_writeTabular = __esm({
  "node_modules/scribe.js-ocr/js/export/writeTabular.js"() {
    init_ocrObjects();
    init_app();
    init_extractTables();
  }
});

// node_modules/scribe.js-ocr/lib/pako.esm.mjs
var pako_esm_exports = {};
__export(pako_esm_exports, {
  Deflate: () => Deflate_12,
  Inflate: () => Inflate_12,
  constants: () => constants_12,
  default: () => pako2,
  deflate: () => deflate_12,
  deflateRaw: () => deflateRaw_12,
  gzip: () => gzip_12,
  inflate: () => inflate_12,
  inflateRaw: () => inflateRaw_12,
  ungzip: () => ungzip_12
});
function zero$12(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
function StaticTreeDesc2(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
function TreeDesc2(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function Config3(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
function DeflateState2() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$22;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE3 * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES3 + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES3 + 1) * 2);
  zero2(this.dyn_ltree);
  zero2(this.dyn_dtree);
  zero2(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS4 + 1);
  this.heap = new Uint16Array(2 * L_CODES3 + 1);
  zero2(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES3 + 1);
  zero2(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function ZStream4() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
function Deflate$12(options) {
  this.options = common2.assign({
    level: Z_DEFAULT_COMPRESSION3,
    method: Z_DEFLATED$12,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY3
  }, options || {});
  let opt2 = this.options;
  if (opt2.raw && opt2.windowBits > 0) {
    opt2.windowBits = -opt2.windowBits;
  } else if (opt2.gzip && opt2.windowBits > 0 && opt2.windowBits < 16) {
    opt2.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream2();
  this.strm.avail_out = 0;
  let status = deflate_1$22.deflateInit2(
    this.strm,
    opt2.level,
    opt2.method,
    opt2.windowBits,
    opt2.memLevel,
    opt2.strategy
  );
  if (status !== Z_OK$22) {
    throw new Error(messages2[status]);
  }
  if (opt2.header) {
    deflate_1$22.deflateSetHeader(this.strm, opt2.header);
  }
  if (opt2.dictionary) {
    let dict;
    if (typeof opt2.dictionary === "string") {
      dict = strings2.string2buf(opt2.dictionary);
    } else if (toString$12.call(opt2.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt2.dictionary);
    } else {
      dict = opt2.dictionary;
    }
    status = deflate_1$22.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$22) {
      throw new Error(messages2[status]);
    }
    this._dict_set = true;
  }
}
function deflate$12(input, options) {
  const deflator = new Deflate$12(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages2[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$12(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$12(input, options);
}
function gzip$12(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$12(input, options);
}
function InflateState2() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function GZheader2() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
function Inflate$12(options) {
  this.options = common2.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt2 = this.options;
  if (opt2.raw && opt2.windowBits >= 0 && opt2.windowBits < 16) {
    opt2.windowBits = -opt2.windowBits;
    if (opt2.windowBits === 0) {
      opt2.windowBits = -15;
    }
  }
  if (opt2.windowBits >= 0 && opt2.windowBits < 16 && !(options && options.windowBits)) {
    opt2.windowBits += 32;
  }
  if (opt2.windowBits > 15 && opt2.windowBits < 48) {
    if ((opt2.windowBits & 15) === 0) {
      opt2.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream2();
  this.strm.avail_out = 0;
  let status = inflate_1$22.inflateInit2(
    this.strm,
    opt2.windowBits
  );
  if (status !== Z_OK4) {
    throw new Error(messages2[status]);
  }
  this.header = new gzheader2();
  inflate_1$22.inflateGetHeader(this.strm, this.header);
  if (opt2.dictionary) {
    if (typeof opt2.dictionary === "string") {
      opt2.dictionary = strings2.string2buf(opt2.dictionary);
    } else if (toString2.call(opt2.dictionary) === "[object ArrayBuffer]") {
      opt2.dictionary = new Uint8Array(opt2.dictionary);
    }
    if (opt2.raw) {
      status = inflate_1$22.inflateSetDictionary(this.strm, opt2.dictionary);
      if (status !== Z_OK4) {
        throw new Error(messages2[status]);
      }
    }
  }
}
function inflate$12(input, options) {
  const inflator = new Inflate$12(options);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages2[inflator.err];
  return inflator.result;
}
function inflateRaw$12(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$12(input, options);
}
var Z_FIXED$12, Z_BINARY2, Z_TEXT2, Z_UNKNOWN$12, STORED_BLOCK3, STATIC_TREES3, DYN_TREES3, MIN_MATCH$12, MAX_MATCH$12, LENGTH_CODES$12, LITERALS$12, L_CODES$12, D_CODES$12, BL_CODES$12, HEAP_SIZE$12, MAX_BITS$12, Buf_size3, MAX_BL_BITS3, END_BLOCK3, REP_3_63, REPZ_3_103, REPZ_11_1383, extra_lbits2, extra_dbits2, extra_blbits2, bl_order2, DIST_CODE_LEN2, static_ltree2, static_dtree2, _dist_code3, _length_code2, base_length2, base_dist2, static_l_desc2, static_d_desc2, static_bl_desc2, d_code2, put_short2, send_bits2, send_code2, bi_reverse2, bi_flush2, gen_bitlen2, gen_codes2, tr_static_init2, init_block2, bi_windup2, copy_block2, smaller3, pqdownheap2, compress_block2, build_tree2, scan_tree2, send_tree2, build_bl_tree2, send_all_trees2, detect_data_type2, static_init_done2, _tr_init$12, _tr_stored_block$12, _tr_align$12, _tr_flush_block$12, _tr_tally$12, _tr_init_12, _tr_stored_block_12, _tr_flush_block_12, _tr_tally_12, _tr_align_12, trees2, adler322, adler32_12, makeTable2, crcTable2, crc322, crc32_12, messages2, constants$22, _tr_init2, _tr_stored_block2, _tr_flush_block2, _tr_tally2, _tr_align2, Z_NO_FLUSH$22, Z_PARTIAL_FLUSH3, Z_FULL_FLUSH$12, Z_FINISH$32, Z_BLOCK$12, Z_OK$32, Z_STREAM_END$32, Z_STREAM_ERROR$22, Z_DATA_ERROR$22, Z_BUF_ERROR$12, Z_DEFAULT_COMPRESSION$12, Z_FILTERED3, Z_HUFFMAN_ONLY3, Z_RLE2, Z_FIXED2, Z_DEFAULT_STRATEGY$12, Z_UNKNOWN2, Z_DEFLATED$22, MAX_MEM_LEVEL3, MAX_WBITS$12, DEF_MEM_LEVEL3, LENGTH_CODES3, LITERALS3, L_CODES3, D_CODES3, BL_CODES3, HEAP_SIZE3, MAX_BITS4, MIN_MATCH3, MAX_MATCH3, MIN_LOOKAHEAD3, PRESET_DICT4, INIT_STATE3, EXTRA_STATE2, NAME_STATE2, COMMENT_STATE2, HCRC_STATE2, BUSY_STATE3, FINISH_STATE3, BS_NEED_MORE2, BS_BLOCK_DONE2, BS_FINISH_STARTED2, BS_FINISH_DONE2, OS_CODE2, err2, rank2, zero2, HASH_ZLIB2, HASH2, flush_pending2, flush_block_only2, put_byte2, putShortMSB2, read_buf2, longest_match2, fill_window2, deflate_stored2, deflate_fast2, deflate_slow2, deflate_rle2, deflate_huff2, configuration_table2, lm_init2, deflateResetKeep2, deflateReset2, deflateSetHeader2, deflateInit22, deflateInit3, deflate$22, deflateEnd2, deflateSetDictionary2, deflateInit_12, deflateInit2_12, deflateReset_12, deflateResetKeep_12, deflateSetHeader_12, deflate_2$12, deflateEnd_12, deflateSetDictionary_12, deflateInfo2, deflate_1$22, _has2, assign2, flattenChunks2, common2, STR_APPLY_UIA_OK2, _utf8len2, string2buf2, buf2binstring2, buf2string2, utf8border2, strings2, zstream2, toString$12, Z_NO_FLUSH$12, Z_SYNC_FLUSH2, Z_FULL_FLUSH3, Z_FINISH$22, Z_OK$22, Z_STREAM_END$22, Z_DEFAULT_COMPRESSION3, Z_DEFAULT_STRATEGY3, Z_DEFLATED$12, Deflate_1$12, deflate_22, deflateRaw_1$12, gzip_1$12, constants$12, deflate_1$12, BAD$12, TYPE$12, inffast2, MAXBITS2, ENOUGH_LENS$12, ENOUGH_DISTS$12, CODES$12, LENS$12, DISTS$12, lbase2, lext2, dbase2, dext2, inflate_table2, inftrees2, CODES3, LENS3, DISTS2, Z_FINISH$12, Z_BLOCK2, Z_TREES2, Z_OK$12, Z_STREAM_END$12, Z_NEED_DICT$12, Z_STREAM_ERROR$12, Z_DATA_ERROR$12, Z_MEM_ERROR$12, Z_BUF_ERROR4, Z_DEFLATED4, HEAD2, FLAGS2, TIME2, OS2, EXLEN2, EXTRA2, NAME2, COMMENT2, HCRC2, DICTID2, DICT5, TYPE3, TYPEDO2, STORED4, COPY_2, COPY3, TABLE3, LENLENS2, CODELENS2, LEN_2, LEN3, LENEXT3, DIST3, DISTEXT3, MATCH2, LIT3, CHECK2, LENGTH2, DONE3, BAD3, MEM2, SYNC2, ENOUGH_LENS2, ENOUGH_DISTS2, MAX_WBITS2, DEF_WBITS2, zswap322, inflateResetKeep2, inflateReset3, inflateReset22, inflateInit22, inflateInit3, virgin2, lenfix2, distfix2, fixedtables2, updatewindow2, inflate$22, inflateEnd2, inflateGetHeader2, inflateSetDictionary2, inflateReset_12, inflateReset2_12, inflateResetKeep_12, inflateInit_12, inflateInit2_12, inflate_2$12, inflateEnd_12, inflateGetHeader_12, inflateSetDictionary_12, inflateInfo2, inflate_1$22, gzheader2, toString2, Z_NO_FLUSH4, Z_FINISH4, Z_OK4, Z_STREAM_END4, Z_NEED_DICT4, Z_STREAM_ERROR4, Z_DATA_ERROR4, Z_MEM_ERROR3, Inflate_1$12, inflate_22, inflateRaw_1$12, ungzip$12, constants2, inflate_1$12, Deflate3, deflate2, deflateRaw2, gzip2, Inflate3, inflate2, inflateRaw2, ungzip2, Deflate_12, deflate_12, deflateRaw_12, gzip_12, Inflate_12, inflate_12, inflateRaw_12, ungzip_12, constants_12, pako2;
var init_pako_esm = __esm({
  "node_modules/scribe.js-ocr/lib/pako.esm.mjs"() {
    Z_FIXED$12 = 4;
    Z_BINARY2 = 0;
    Z_TEXT2 = 1;
    Z_UNKNOWN$12 = 2;
    STORED_BLOCK3 = 0;
    STATIC_TREES3 = 1;
    DYN_TREES3 = 2;
    MIN_MATCH$12 = 3;
    MAX_MATCH$12 = 258;
    LENGTH_CODES$12 = 29;
    LITERALS$12 = 256;
    L_CODES$12 = LITERALS$12 + 1 + LENGTH_CODES$12;
    D_CODES$12 = 30;
    BL_CODES$12 = 19;
    HEAP_SIZE$12 = 2 * L_CODES$12 + 1;
    MAX_BITS$12 = 15;
    Buf_size3 = 16;
    MAX_BL_BITS3 = 7;
    END_BLOCK3 = 256;
    REP_3_63 = 16;
    REPZ_3_103 = 17;
    REPZ_11_1383 = 18;
    extra_lbits2 = /* extra bits for each length code */
    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
    extra_dbits2 = /* extra bits for each distance code */
    new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
    extra_blbits2 = /* extra bits for each bit length code */
    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
    bl_order2 = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    DIST_CODE_LEN2 = 512;
    static_ltree2 = new Array((L_CODES$12 + 2) * 2);
    zero$12(static_ltree2);
    static_dtree2 = new Array(D_CODES$12 * 2);
    zero$12(static_dtree2);
    _dist_code3 = new Array(DIST_CODE_LEN2);
    zero$12(_dist_code3);
    _length_code2 = new Array(MAX_MATCH$12 - MIN_MATCH$12 + 1);
    zero$12(_length_code2);
    base_length2 = new Array(LENGTH_CODES$12);
    zero$12(base_length2);
    base_dist2 = new Array(D_CODES$12);
    zero$12(base_dist2);
    d_code2 = (dist) => {
      return dist < 256 ? _dist_code3[dist] : _dist_code3[256 + (dist >>> 7)];
    };
    put_short2 = (s2, w2) => {
      s2.pending_buf[s2.pending++] = w2 & 255;
      s2.pending_buf[s2.pending++] = w2 >>> 8 & 255;
    };
    send_bits2 = (s2, value, length) => {
      if (s2.bi_valid > Buf_size3 - length) {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        put_short2(s2, s2.bi_buf);
        s2.bi_buf = value >> Buf_size3 - s2.bi_valid;
        s2.bi_valid += length - Buf_size3;
      } else {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        s2.bi_valid += length;
      }
    };
    send_code2 = (s2, c2, tree) => {
      send_bits2(
        s2,
        tree[c2 * 2],
        tree[c2 * 2 + 1]
        /*.Len*/
      );
    };
    bi_reverse2 = (code, len) => {
      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };
    bi_flush2 = (s2) => {
      if (s2.bi_valid === 16) {
        put_short2(s2, s2.bi_buf);
        s2.bi_buf = 0;
        s2.bi_valid = 0;
      } else if (s2.bi_valid >= 8) {
        s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
        s2.bi_buf >>= 8;
        s2.bi_valid -= 8;
      }
    };
    gen_bitlen2 = (s2, desc) => {
      const tree = desc.dyn_tree;
      const max_code = desc.max_code;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const extra = desc.stat_desc.extra_bits;
      const base = desc.stat_desc.extra_base;
      const max_length = desc.stat_desc.max_length;
      let h2;
      let n2, m2;
      let bits;
      let xbits;
      let f2;
      let overflow = 0;
      for (bits = 0; bits <= MAX_BITS$12; bits++) {
        s2.bl_count[bits] = 0;
      }
      tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
      for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE$12; h2++) {
        n2 = s2.heap[h2];
        bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n2 * 2 + 1] = bits;
        if (n2 > max_code) {
          continue;
        }
        s2.bl_count[bits]++;
        xbits = 0;
        if (n2 >= base) {
          xbits = extra[n2 - base];
        }
        f2 = tree[n2 * 2];
        s2.opt_len += f2 * (bits + xbits);
        if (has_stree) {
          s2.static_len += f2 * (stree[n2 * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s2.bl_count[bits] === 0) {
          bits--;
        }
        s2.bl_count[bits]--;
        s2.bl_count[bits + 1] += 2;
        s2.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n2 = s2.bl_count[bits];
        while (n2 !== 0) {
          m2 = s2.heap[--h2];
          if (m2 > max_code) {
            continue;
          }
          if (tree[m2 * 2 + 1] !== bits) {
            s2.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
            tree[m2 * 2 + 1] = bits;
          }
          n2--;
        }
      }
    };
    gen_codes2 = (tree, max_code, bl_count) => {
      const next_code = new Array(MAX_BITS$12 + 1);
      let code = 0;
      let bits;
      let n2;
      for (bits = 1; bits <= MAX_BITS$12; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n2 = 0; n2 <= max_code; n2++) {
        let len = tree[n2 * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n2 * 2] = bi_reverse2(next_code[len]++, len);
      }
    };
    tr_static_init2 = () => {
      let n2;
      let bits;
      let length;
      let code;
      let dist;
      const bl_count = new Array(MAX_BITS$12 + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES$12 - 1; code++) {
        base_length2[code] = length;
        for (n2 = 0; n2 < 1 << extra_lbits2[code]; n2++) {
          _length_code2[length++] = code;
        }
      }
      _length_code2[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist2[code] = dist;
        for (n2 = 0; n2 < 1 << extra_dbits2[code]; n2++) {
          _dist_code3[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES$12; code++) {
        base_dist2[code] = dist << 7;
        for (n2 = 0; n2 < 1 << extra_dbits2[code] - 7; n2++) {
          _dist_code3[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS$12; bits++) {
        bl_count[bits] = 0;
      }
      n2 = 0;
      while (n2 <= 143) {
        static_ltree2[n2 * 2 + 1] = 8;
        n2++;
        bl_count[8]++;
      }
      while (n2 <= 255) {
        static_ltree2[n2 * 2 + 1] = 9;
        n2++;
        bl_count[9]++;
      }
      while (n2 <= 279) {
        static_ltree2[n2 * 2 + 1] = 7;
        n2++;
        bl_count[7]++;
      }
      while (n2 <= 287) {
        static_ltree2[n2 * 2 + 1] = 8;
        n2++;
        bl_count[8]++;
      }
      gen_codes2(static_ltree2, L_CODES$12 + 1, bl_count);
      for (n2 = 0; n2 < D_CODES$12; n2++) {
        static_dtree2[n2 * 2 + 1] = 5;
        static_dtree2[n2 * 2] = bi_reverse2(n2, 5);
      }
      static_l_desc2 = new StaticTreeDesc2(static_ltree2, extra_lbits2, LITERALS$12 + 1, L_CODES$12, MAX_BITS$12);
      static_d_desc2 = new StaticTreeDesc2(static_dtree2, extra_dbits2, 0, D_CODES$12, MAX_BITS$12);
      static_bl_desc2 = new StaticTreeDesc2(new Array(0), extra_blbits2, 0, BL_CODES$12, MAX_BL_BITS3);
    };
    init_block2 = (s2) => {
      let n2;
      for (n2 = 0; n2 < L_CODES$12; n2++) {
        s2.dyn_ltree[n2 * 2] = 0;
      }
      for (n2 = 0; n2 < D_CODES$12; n2++) {
        s2.dyn_dtree[n2 * 2] = 0;
      }
      for (n2 = 0; n2 < BL_CODES$12; n2++) {
        s2.bl_tree[n2 * 2] = 0;
      }
      s2.dyn_ltree[END_BLOCK3 * 2] = 1;
      s2.opt_len = s2.static_len = 0;
      s2.last_lit = s2.matches = 0;
    };
    bi_windup2 = (s2) => {
      if (s2.bi_valid > 8) {
        put_short2(s2, s2.bi_buf);
      } else if (s2.bi_valid > 0) {
        s2.pending_buf[s2.pending++] = s2.bi_buf;
      }
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    };
    copy_block2 = (s2, buf, len, header) => {
      bi_windup2(s2);
      if (header) {
        put_short2(s2, len);
        put_short2(s2, ~len);
      }
      s2.pending_buf.set(s2.window.subarray(buf, buf + len), s2.pending);
      s2.pending += len;
    };
    smaller3 = (tree, n2, m2, depth) => {
      const _n2 = n2 * 2;
      const _m2 = m2 * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m2];
    };
    pqdownheap2 = (s2, tree, k2) => {
      const v2 = s2.heap[k2];
      let j2 = k2 << 1;
      while (j2 <= s2.heap_len) {
        if (j2 < s2.heap_len && smaller3(tree, s2.heap[j2 + 1], s2.heap[j2], s2.depth)) {
          j2++;
        }
        if (smaller3(tree, v2, s2.heap[j2], s2.depth)) {
          break;
        }
        s2.heap[k2] = s2.heap[j2];
        k2 = j2;
        j2 <<= 1;
      }
      s2.heap[k2] = v2;
    };
    compress_block2 = (s2, ltree, dtree) => {
      let dist;
      let lc;
      let lx = 0;
      let code;
      let extra;
      if (s2.last_lit !== 0) {
        do {
          dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
          lc = s2.pending_buf[s2.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code2(s2, lc, ltree);
          } else {
            code = _length_code2[lc];
            send_code2(s2, code + LITERALS$12 + 1, ltree);
            extra = extra_lbits2[code];
            if (extra !== 0) {
              lc -= base_length2[code];
              send_bits2(s2, lc, extra);
            }
            dist--;
            code = d_code2(dist);
            send_code2(s2, code, dtree);
            extra = extra_dbits2[code];
            if (extra !== 0) {
              dist -= base_dist2[code];
              send_bits2(s2, dist, extra);
            }
          }
        } while (lx < s2.last_lit);
      }
      send_code2(s2, END_BLOCK3, ltree);
    };
    build_tree2 = (s2, desc) => {
      const tree = desc.dyn_tree;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems = desc.stat_desc.elems;
      let n2, m2;
      let max_code = -1;
      let node;
      s2.heap_len = 0;
      s2.heap_max = HEAP_SIZE$12;
      for (n2 = 0; n2 < elems; n2++) {
        if (tree[n2 * 2] !== 0) {
          s2.heap[++s2.heap_len] = max_code = n2;
          s2.depth[n2] = 0;
        } else {
          tree[n2 * 2 + 1] = 0;
        }
      }
      while (s2.heap_len < 2) {
        node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s2.depth[node] = 0;
        s2.opt_len--;
        if (has_stree) {
          s2.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n2 = s2.heap_len >> 1; n2 >= 1; n2--) {
        pqdownheap2(s2, tree, n2);
      }
      node = elems;
      do {
        n2 = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[
          1
          /*SMALLEST*/
        ] = s2.heap[s2.heap_len--];
        pqdownheap2(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
        m2 = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[--s2.heap_max] = n2;
        s2.heap[--s2.heap_max] = m2;
        tree[node * 2] = tree[n2 * 2] + tree[m2 * 2];
        s2.depth[node] = (s2.depth[n2] >= s2.depth[m2] ? s2.depth[n2] : s2.depth[m2]) + 1;
        tree[n2 * 2 + 1] = tree[m2 * 2 + 1] = node;
        s2.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap2(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s2.heap_len >= 2);
      s2.heap[--s2.heap_max] = s2.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen2(s2, desc);
      gen_codes2(tree, max_code, s2.bl_count);
    };
    scan_tree2 = (s2, tree, max_code) => {
      let n2;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n2 = 0; n2 <= max_code; n2++) {
        curlen = nextlen;
        nextlen = tree[(n2 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s2.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s2.bl_tree[curlen * 2]++;
          }
          s2.bl_tree[REP_3_63 * 2]++;
        } else if (count <= 10) {
          s2.bl_tree[REPZ_3_103 * 2]++;
        } else {
          s2.bl_tree[REPZ_11_1383 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    send_tree2 = (s2, tree, max_code) => {
      let n2;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n2 = 0; n2 <= max_code; n2++) {
        curlen = nextlen;
        nextlen = tree[(n2 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code2(s2, curlen, s2.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code2(s2, curlen, s2.bl_tree);
            count--;
          }
          send_code2(s2, REP_3_63, s2.bl_tree);
          send_bits2(s2, count - 3, 2);
        } else if (count <= 10) {
          send_code2(s2, REPZ_3_103, s2.bl_tree);
          send_bits2(s2, count - 3, 3);
        } else {
          send_code2(s2, REPZ_11_1383, s2.bl_tree);
          send_bits2(s2, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    build_bl_tree2 = (s2) => {
      let max_blindex;
      scan_tree2(s2, s2.dyn_ltree, s2.l_desc.max_code);
      scan_tree2(s2, s2.dyn_dtree, s2.d_desc.max_code);
      build_tree2(s2, s2.bl_desc);
      for (max_blindex = BL_CODES$12 - 1; max_blindex >= 3; max_blindex--) {
        if (s2.bl_tree[bl_order2[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    };
    send_all_trees2 = (s2, lcodes, dcodes, blcodes) => {
      let rank3;
      send_bits2(s2, lcodes - 257, 5);
      send_bits2(s2, dcodes - 1, 5);
      send_bits2(s2, blcodes - 4, 4);
      for (rank3 = 0; rank3 < blcodes; rank3++) {
        send_bits2(s2, s2.bl_tree[bl_order2[rank3] * 2 + 1], 3);
      }
      send_tree2(s2, s2.dyn_ltree, lcodes - 1);
      send_tree2(s2, s2.dyn_dtree, dcodes - 1);
    };
    detect_data_type2 = (s2) => {
      let black_mask = 4093624447;
      let n2;
      for (n2 = 0; n2 <= 31; n2++, black_mask >>>= 1) {
        if (black_mask & 1 && s2.dyn_ltree[n2 * 2] !== 0) {
          return Z_BINARY2;
        }
      }
      if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT2;
      }
      for (n2 = 32; n2 < LITERALS$12; n2++) {
        if (s2.dyn_ltree[n2 * 2] !== 0) {
          return Z_TEXT2;
        }
      }
      return Z_BINARY2;
    };
    static_init_done2 = false;
    _tr_init$12 = (s2) => {
      if (!static_init_done2) {
        tr_static_init2();
        static_init_done2 = true;
      }
      s2.l_desc = new TreeDesc2(s2.dyn_ltree, static_l_desc2);
      s2.d_desc = new TreeDesc2(s2.dyn_dtree, static_d_desc2);
      s2.bl_desc = new TreeDesc2(s2.bl_tree, static_bl_desc2);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
      init_block2(s2);
    };
    _tr_stored_block$12 = (s2, buf, stored_len, last) => {
      send_bits2(s2, (STORED_BLOCK3 << 1) + (last ? 1 : 0), 3);
      copy_block2(s2, buf, stored_len, true);
    };
    _tr_align$12 = (s2) => {
      send_bits2(s2, STATIC_TREES3 << 1, 3);
      send_code2(s2, END_BLOCK3, static_ltree2);
      bi_flush2(s2);
    };
    _tr_flush_block$12 = (s2, buf, stored_len, last) => {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (s2.level > 0) {
        if (s2.strm.data_type === Z_UNKNOWN$12) {
          s2.strm.data_type = detect_data_type2(s2);
        }
        build_tree2(s2, s2.l_desc);
        build_tree2(s2, s2.d_desc);
        max_blindex = build_bl_tree2(s2);
        opt_lenb = s2.opt_len + 3 + 7 >>> 3;
        static_lenb = s2.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block$12(s2, buf, stored_len, last);
      } else if (s2.strategy === Z_FIXED$12 || static_lenb === opt_lenb) {
        send_bits2(s2, (STATIC_TREES3 << 1) + (last ? 1 : 0), 3);
        compress_block2(s2, static_ltree2, static_dtree2);
      } else {
        send_bits2(s2, (DYN_TREES3 << 1) + (last ? 1 : 0), 3);
        send_all_trees2(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
        compress_block2(s2, s2.dyn_ltree, s2.dyn_dtree);
      }
      init_block2(s2);
      if (last) {
        bi_windup2(s2);
      }
    };
    _tr_tally$12 = (s2, dist, lc) => {
      s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
      s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
      s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
      s2.last_lit++;
      if (dist === 0) {
        s2.dyn_ltree[lc * 2]++;
      } else {
        s2.matches++;
        dist--;
        s2.dyn_ltree[(_length_code2[lc] + LITERALS$12 + 1) * 2]++;
        s2.dyn_dtree[d_code2(dist) * 2]++;
      }
      return s2.last_lit === s2.lit_bufsize - 1;
    };
    _tr_init_12 = _tr_init$12;
    _tr_stored_block_12 = _tr_stored_block$12;
    _tr_flush_block_12 = _tr_flush_block$12;
    _tr_tally_12 = _tr_tally$12;
    _tr_align_12 = _tr_align$12;
    trees2 = {
      _tr_init: _tr_init_12,
      _tr_stored_block: _tr_stored_block_12,
      _tr_flush_block: _tr_flush_block_12,
      _tr_tally: _tr_tally_12,
      _tr_align: _tr_align_12
    };
    adler322 = (adler, buf, len, pos) => {
      let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
      while (len !== 0) {
        n2 = len > 2e3 ? 2e3 : len;
        len -= n2;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n2);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    };
    adler32_12 = adler322;
    makeTable2 = () => {
      let c2, table3 = [];
      for (var n2 = 0; n2 < 256; n2++) {
        c2 = n2;
        for (var k2 = 0; k2 < 8; k2++) {
          c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
        }
        table3[n2] = c2;
      }
      return table3;
    };
    crcTable2 = new Uint32Array(makeTable2());
    crc322 = (crc, buf, len, pos) => {
      const t2 = crcTable2;
      const end = pos + len;
      crc ^= -1;
      for (let i2 = pos; i2 < end; i2++) {
        crc = crc >>> 8 ^ t2[(crc ^ buf[i2]) & 255];
      }
      return crc ^ -1;
    };
    crc32_12 = crc322;
    messages2 = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
    constants$22 = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
    ({ _tr_init: _tr_init2, _tr_stored_block: _tr_stored_block2, _tr_flush_block: _tr_flush_block2, _tr_tally: _tr_tally2, _tr_align: _tr_align2 } = trees2);
    ({
      Z_NO_FLUSH: Z_NO_FLUSH$22,
      Z_PARTIAL_FLUSH: Z_PARTIAL_FLUSH3,
      Z_FULL_FLUSH: Z_FULL_FLUSH$12,
      Z_FINISH: Z_FINISH$32,
      Z_BLOCK: Z_BLOCK$12,
      Z_OK: Z_OK$32,
      Z_STREAM_END: Z_STREAM_END$32,
      Z_STREAM_ERROR: Z_STREAM_ERROR$22,
      Z_DATA_ERROR: Z_DATA_ERROR$22,
      Z_BUF_ERROR: Z_BUF_ERROR$12,
      Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$12,
      Z_FILTERED: Z_FILTERED3,
      Z_HUFFMAN_ONLY: Z_HUFFMAN_ONLY3,
      Z_RLE: Z_RLE2,
      Z_FIXED: Z_FIXED2,
      Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$12,
      Z_UNKNOWN: Z_UNKNOWN2,
      Z_DEFLATED: Z_DEFLATED$22
    } = constants$22);
    MAX_MEM_LEVEL3 = 9;
    MAX_WBITS$12 = 15;
    DEF_MEM_LEVEL3 = 8;
    LENGTH_CODES3 = 29;
    LITERALS3 = 256;
    L_CODES3 = LITERALS3 + 1 + LENGTH_CODES3;
    D_CODES3 = 30;
    BL_CODES3 = 19;
    HEAP_SIZE3 = 2 * L_CODES3 + 1;
    MAX_BITS4 = 15;
    MIN_MATCH3 = 3;
    MAX_MATCH3 = 258;
    MIN_LOOKAHEAD3 = MAX_MATCH3 + MIN_MATCH3 + 1;
    PRESET_DICT4 = 32;
    INIT_STATE3 = 42;
    EXTRA_STATE2 = 69;
    NAME_STATE2 = 73;
    COMMENT_STATE2 = 91;
    HCRC_STATE2 = 103;
    BUSY_STATE3 = 113;
    FINISH_STATE3 = 666;
    BS_NEED_MORE2 = 1;
    BS_BLOCK_DONE2 = 2;
    BS_FINISH_STARTED2 = 3;
    BS_FINISH_DONE2 = 4;
    OS_CODE2 = 3;
    err2 = (strm, errorCode) => {
      strm.msg = messages2[errorCode];
      return errorCode;
    };
    rank2 = (f2) => {
      return (f2 << 1) - (f2 > 4 ? 9 : 0);
    };
    zero2 = (buf) => {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    };
    HASH_ZLIB2 = (s2, prev, data2) => (prev << s2.hash_shift ^ data2) & s2.hash_mask;
    HASH2 = HASH_ZLIB2;
    flush_pending2 = (strm) => {
      const s2 = strm.state;
      let len = s2.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      strm.output.set(s2.pending_buf.subarray(s2.pending_out, s2.pending_out + len), strm.next_out);
      strm.next_out += len;
      s2.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s2.pending -= len;
      if (s2.pending === 0) {
        s2.pending_out = 0;
      }
    };
    flush_block_only2 = (s2, last) => {
      _tr_flush_block2(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
      s2.block_start = s2.strstart;
      flush_pending2(s2.strm);
    };
    put_byte2 = (s2, b2) => {
      s2.pending_buf[s2.pending++] = b2;
    };
    putShortMSB2 = (s2, b2) => {
      s2.pending_buf[s2.pending++] = b2 >>> 8 & 255;
      s2.pending_buf[s2.pending++] = b2 & 255;
    };
    read_buf2 = (strm, buf, start, size) => {
      let len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32_12(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32_12(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    };
    longest_match2 = (s2, cur_match) => {
      let chain_length = s2.max_chain_length;
      let scan = s2.strstart;
      let match;
      let len;
      let best_len = s2.prev_length;
      let nice_match = s2.nice_match;
      const limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD3 ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD3) : 0;
      const _win = s2.window;
      const wmask = s2.w_mask;
      const prev = s2.prev;
      const strend = s2.strstart + MAX_MATCH3;
      let scan_end1 = _win[scan + best_len - 1];
      let scan_end = _win[scan + best_len];
      if (s2.prev_length >= s2.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s2.lookahead) {
        nice_match = s2.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH3 - (strend - scan);
        scan = strend - MAX_MATCH3;
        if (len > best_len) {
          s2.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s2.lookahead) {
        return best_len;
      }
      return s2.lookahead;
    };
    fill_window2 = (s2) => {
      const _w_size = s2.w_size;
      let p2, n2, m2, more, str;
      do {
        more = s2.window_size - s2.lookahead - s2.strstart;
        if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD3)) {
          s2.window.set(s2.window.subarray(_w_size, _w_size + _w_size), 0);
          s2.match_start -= _w_size;
          s2.strstart -= _w_size;
          s2.block_start -= _w_size;
          n2 = s2.hash_size;
          p2 = n2;
          do {
            m2 = s2.head[--p2];
            s2.head[p2] = m2 >= _w_size ? m2 - _w_size : 0;
          } while (--n2);
          n2 = _w_size;
          p2 = n2;
          do {
            m2 = s2.prev[--p2];
            s2.prev[p2] = m2 >= _w_size ? m2 - _w_size : 0;
          } while (--n2);
          more += _w_size;
        }
        if (s2.strm.avail_in === 0) {
          break;
        }
        n2 = read_buf2(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
        s2.lookahead += n2;
        if (s2.lookahead + s2.insert >= MIN_MATCH3) {
          str = s2.strstart - s2.insert;
          s2.ins_h = s2.window[str];
          s2.ins_h = HASH2(s2, s2.ins_h, s2.window[str + 1]);
          while (s2.insert) {
            s2.ins_h = HASH2(s2, s2.ins_h, s2.window[str + MIN_MATCH3 - 1]);
            s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = str;
            str++;
            s2.insert--;
            if (s2.lookahead + s2.insert < MIN_MATCH3) {
              break;
            }
          }
        }
      } while (s2.lookahead < MIN_LOOKAHEAD3 && s2.strm.avail_in !== 0);
    };
    deflate_stored2 = (s2, flush) => {
      let max_block_size = 65535;
      if (max_block_size > s2.pending_buf_size - 5) {
        max_block_size = s2.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s2.lookahead <= 1) {
          fill_window2(s2);
          if (s2.lookahead === 0 && flush === Z_NO_FLUSH$22) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.strstart += s2.lookahead;
        s2.lookahead = 0;
        const max_start = s2.block_start + max_block_size;
        if (s2.strstart === 0 || s2.strstart >= max_start) {
          s2.lookahead = s2.strstart - max_start;
          s2.strstart = max_start;
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
        if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD3) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH$32) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.strstart > s2.block_start) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_NEED_MORE2;
    };
    deflate_fast2 = (s2, flush) => {
      let hash_head;
      let bflush;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD3) {
          fill_window2(s2);
          if (s2.lookahead < MIN_LOOKAHEAD3 && flush === Z_NO_FLUSH$22) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH3) {
          s2.ins_h = HASH2(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH3 - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD3) {
          s2.match_length = longest_match2(s2, hash_head);
        }
        if (s2.match_length >= MIN_MATCH3) {
          bflush = _tr_tally2(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH3);
          s2.lookahead -= s2.match_length;
          if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH3) {
            s2.match_length--;
            do {
              s2.strstart++;
              s2.ins_h = HASH2(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH3 - 1]);
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            } while (--s2.match_length !== 0);
            s2.strstart++;
          } else {
            s2.strstart += s2.match_length;
            s2.match_length = 0;
            s2.ins_h = s2.window[s2.strstart];
            s2.ins_h = HASH2(s2, s2.ins_h, s2.window[s2.strstart + 1]);
          }
        } else {
          bflush = _tr_tally2(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = s2.strstart < MIN_MATCH3 - 1 ? s2.strstart : MIN_MATCH3 - 1;
      if (flush === Z_FINISH$32) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.last_lit) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    };
    deflate_slow2 = (s2, flush) => {
      let hash_head;
      let bflush;
      let max_insert;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD3) {
          fill_window2(s2);
          if (s2.lookahead < MIN_LOOKAHEAD3 && flush === Z_NO_FLUSH$22) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH3) {
          s2.ins_h = HASH2(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH3 - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        s2.prev_length = s2.match_length;
        s2.prev_match = s2.match_start;
        s2.match_length = MIN_MATCH3 - 1;
        if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD3) {
          s2.match_length = longest_match2(s2, hash_head);
          if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED3 || s2.match_length === MIN_MATCH3 && s2.strstart - s2.match_start > 4096)) {
            s2.match_length = MIN_MATCH3 - 1;
          }
        }
        if (s2.prev_length >= MIN_MATCH3 && s2.match_length <= s2.prev_length) {
          max_insert = s2.strstart + s2.lookahead - MIN_MATCH3;
          bflush = _tr_tally2(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH3);
          s2.lookahead -= s2.prev_length - 1;
          s2.prev_length -= 2;
          do {
            if (++s2.strstart <= max_insert) {
              s2.ins_h = HASH2(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH3 - 1]);
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
          } while (--s2.prev_length !== 0);
          s2.match_available = 0;
          s2.match_length = MIN_MATCH3 - 1;
          s2.strstart++;
          if (bflush) {
            flush_block_only2(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE2;
            }
          }
        } else if (s2.match_available) {
          bflush = _tr_tally2(s2, 0, s2.window[s2.strstart - 1]);
          if (bflush) {
            flush_block_only2(s2, false);
          }
          s2.strstart++;
          s2.lookahead--;
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        } else {
          s2.match_available = 1;
          s2.strstart++;
          s2.lookahead--;
        }
      }
      if (s2.match_available) {
        bflush = _tr_tally2(s2, 0, s2.window[s2.strstart - 1]);
        s2.match_available = 0;
      }
      s2.insert = s2.strstart < MIN_MATCH3 - 1 ? s2.strstart : MIN_MATCH3 - 1;
      if (flush === Z_FINISH$32) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.last_lit) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    };
    deflate_rle2 = (s2, flush) => {
      let bflush;
      let prev;
      let scan, strend;
      const _win = s2.window;
      for (; ; ) {
        if (s2.lookahead <= MAX_MATCH3) {
          fill_window2(s2);
          if (s2.lookahead <= MAX_MATCH3 && flush === Z_NO_FLUSH$22) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.match_length = 0;
        if (s2.lookahead >= MIN_MATCH3 && s2.strstart > 0) {
          scan = s2.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s2.strstart + MAX_MATCH3;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s2.match_length = MAX_MATCH3 - (strend - scan);
            if (s2.match_length > s2.lookahead) {
              s2.match_length = s2.lookahead;
            }
          }
        }
        if (s2.match_length >= MIN_MATCH3) {
          bflush = _tr_tally2(s2, 1, s2.match_length - MIN_MATCH3);
          s2.lookahead -= s2.match_length;
          s2.strstart += s2.match_length;
          s2.match_length = 0;
        } else {
          bflush = _tr_tally2(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH$32) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.last_lit) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    };
    deflate_huff2 = (s2, flush) => {
      let bflush;
      for (; ; ) {
        if (s2.lookahead === 0) {
          fill_window2(s2);
          if (s2.lookahead === 0) {
            if (flush === Z_NO_FLUSH$22) {
              return BS_NEED_MORE2;
            }
            break;
          }
        }
        s2.match_length = 0;
        bflush = _tr_tally2(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
        if (bflush) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH$32) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.last_lit) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    };
    configuration_table2 = [
      /*      good lazy nice chain */
      new Config3(0, 0, 0, 0, deflate_stored2),
      /* 0 store only */
      new Config3(4, 4, 8, 4, deflate_fast2),
      /* 1 max speed, no lazy matches */
      new Config3(4, 5, 16, 8, deflate_fast2),
      /* 2 */
      new Config3(4, 6, 32, 32, deflate_fast2),
      /* 3 */
      new Config3(4, 4, 16, 16, deflate_slow2),
      /* 4 lazy matches */
      new Config3(8, 16, 32, 32, deflate_slow2),
      /* 5 */
      new Config3(8, 16, 128, 128, deflate_slow2),
      /* 6 */
      new Config3(8, 32, 128, 256, deflate_slow2),
      /* 7 */
      new Config3(32, 128, 258, 1024, deflate_slow2),
      /* 8 */
      new Config3(32, 258, 258, 4096, deflate_slow2)
      /* 9 max compression */
    ];
    lm_init2 = (s2) => {
      s2.window_size = 2 * s2.w_size;
      zero2(s2.head);
      s2.max_lazy_match = configuration_table2[s2.level].max_lazy;
      s2.good_match = configuration_table2[s2.level].good_length;
      s2.nice_match = configuration_table2[s2.level].nice_length;
      s2.max_chain_length = configuration_table2[s2.level].max_chain;
      s2.strstart = 0;
      s2.block_start = 0;
      s2.lookahead = 0;
      s2.insert = 0;
      s2.match_length = s2.prev_length = MIN_MATCH3 - 1;
      s2.match_available = 0;
      s2.ins_h = 0;
    };
    deflateResetKeep2 = (strm) => {
      if (!strm || !strm.state) {
        return err2(strm, Z_STREAM_ERROR$22);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN2;
      const s2 = strm.state;
      s2.pending = 0;
      s2.pending_out = 0;
      if (s2.wrap < 0) {
        s2.wrap = -s2.wrap;
      }
      s2.status = s2.wrap ? INIT_STATE3 : BUSY_STATE3;
      strm.adler = s2.wrap === 2 ? 0 : 1;
      s2.last_flush = Z_NO_FLUSH$22;
      _tr_init2(s2);
      return Z_OK$32;
    };
    deflateReset2 = (strm) => {
      const ret = deflateResetKeep2(strm);
      if (ret === Z_OK$32) {
        lm_init2(strm.state);
      }
      return ret;
    };
    deflateSetHeader2 = (strm, head) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$22;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR$22;
      }
      strm.state.gzhead = head;
      return Z_OK$32;
    };
    deflateInit22 = (strm, level, method, windowBits, memLevel, strategy) => {
      if (!strm) {
        return Z_STREAM_ERROR$22;
      }
      let wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION$12) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL3 || method !== Z_DEFLATED$22 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED2) {
        return err2(strm, Z_STREAM_ERROR$22);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      const s2 = new DeflateState2();
      strm.state = s2;
      s2.strm = strm;
      s2.wrap = wrap;
      s2.gzhead = null;
      s2.w_bits = windowBits;
      s2.w_size = 1 << s2.w_bits;
      s2.w_mask = s2.w_size - 1;
      s2.hash_bits = memLevel + 7;
      s2.hash_size = 1 << s2.hash_bits;
      s2.hash_mask = s2.hash_size - 1;
      s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH3 - 1) / MIN_MATCH3);
      s2.window = new Uint8Array(s2.w_size * 2);
      s2.head = new Uint16Array(s2.hash_size);
      s2.prev = new Uint16Array(s2.w_size);
      s2.lit_bufsize = 1 << memLevel + 6;
      s2.pending_buf_size = s2.lit_bufsize * 4;
      s2.pending_buf = new Uint8Array(s2.pending_buf_size);
      s2.d_buf = 1 * s2.lit_bufsize;
      s2.l_buf = (1 + 2) * s2.lit_bufsize;
      s2.level = level;
      s2.strategy = strategy;
      s2.method = method;
      return deflateReset2(strm);
    };
    deflateInit3 = (strm, level) => {
      return deflateInit22(strm, level, Z_DEFLATED$22, MAX_WBITS$12, DEF_MEM_LEVEL3, Z_DEFAULT_STRATEGY$12);
    };
    deflate$22 = (strm, flush) => {
      let beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK$12 || flush < 0) {
        return strm ? err2(strm, Z_STREAM_ERROR$22) : Z_STREAM_ERROR$22;
      }
      const s2 = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE3 && flush !== Z_FINISH$32) {
        return err2(strm, strm.avail_out === 0 ? Z_BUF_ERROR$12 : Z_STREAM_ERROR$22);
      }
      s2.strm = strm;
      const old_flush = s2.last_flush;
      s2.last_flush = flush;
      if (s2.status === INIT_STATE3) {
        if (s2.wrap === 2) {
          strm.adler = 0;
          put_byte2(s2, 31);
          put_byte2(s2, 139);
          put_byte2(s2, 8);
          if (!s2.gzhead) {
            put_byte2(s2, 0);
            put_byte2(s2, 0);
            put_byte2(s2, 0);
            put_byte2(s2, 0);
            put_byte2(s2, 0);
            put_byte2(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY3 || s2.level < 2 ? 4 : 0);
            put_byte2(s2, OS_CODE2);
            s2.status = BUSY_STATE3;
          } else {
            put_byte2(
              s2,
              (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
            );
            put_byte2(s2, s2.gzhead.time & 255);
            put_byte2(s2, s2.gzhead.time >> 8 & 255);
            put_byte2(s2, s2.gzhead.time >> 16 & 255);
            put_byte2(s2, s2.gzhead.time >> 24 & 255);
            put_byte2(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY3 || s2.level < 2 ? 4 : 0);
            put_byte2(s2, s2.gzhead.os & 255);
            if (s2.gzhead.extra && s2.gzhead.extra.length) {
              put_byte2(s2, s2.gzhead.extra.length & 255);
              put_byte2(s2, s2.gzhead.extra.length >> 8 & 255);
            }
            if (s2.gzhead.hcrc) {
              strm.adler = crc32_12(strm.adler, s2.pending_buf, s2.pending, 0);
            }
            s2.gzindex = 0;
            s2.status = EXTRA_STATE2;
          }
        } else {
          let header = Z_DEFLATED$22 + (s2.w_bits - 8 << 4) << 8;
          let level_flags = -1;
          if (s2.strategy >= Z_HUFFMAN_ONLY3 || s2.level < 2) {
            level_flags = 0;
          } else if (s2.level < 6) {
            level_flags = 1;
          } else if (s2.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s2.strstart !== 0) {
            header |= PRESET_DICT4;
          }
          header += 31 - header % 31;
          s2.status = BUSY_STATE3;
          putShortMSB2(s2, header);
          if (s2.strstart !== 0) {
            putShortMSB2(s2, strm.adler >>> 16);
            putShortMSB2(s2, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s2.status === EXTRA_STATE2) {
        if (s2.gzhead.extra) {
          beg = s2.pending;
          while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32_12(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending2(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                break;
              }
            }
            put_byte2(s2, s2.gzhead.extra[s2.gzindex] & 255);
            s2.gzindex++;
          }
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_12(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (s2.gzindex === s2.gzhead.extra.length) {
            s2.gzindex = 0;
            s2.status = NAME_STATE2;
          }
        } else {
          s2.status = NAME_STATE2;
        }
      }
      if (s2.status === NAME_STATE2) {
        if (s2.gzhead.name) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32_12(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending2(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.name.length) {
              val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte2(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_12(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.gzindex = 0;
            s2.status = COMMENT_STATE2;
          }
        } else {
          s2.status = COMMENT_STATE2;
        }
      }
      if (s2.status === COMMENT_STATE2) {
        if (s2.gzhead.comment) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32_12(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending2(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.comment.length) {
              val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte2(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_12(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.status = HCRC_STATE2;
          }
        } else {
          s2.status = HCRC_STATE2;
        }
      }
      if (s2.status === HCRC_STATE2) {
        if (s2.gzhead.hcrc) {
          if (s2.pending + 2 > s2.pending_buf_size) {
            flush_pending2(strm);
          }
          if (s2.pending + 2 <= s2.pending_buf_size) {
            put_byte2(s2, strm.adler & 255);
            put_byte2(s2, strm.adler >> 8 & 255);
            strm.adler = 0;
            s2.status = BUSY_STATE3;
          }
        } else {
          s2.status = BUSY_STATE3;
        }
      }
      if (s2.pending !== 0) {
        flush_pending2(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK$32;
        }
      } else if (strm.avail_in === 0 && rank2(flush) <= rank2(old_flush) && flush !== Z_FINISH$32) {
        return err2(strm, Z_BUF_ERROR$12);
      }
      if (s2.status === FINISH_STATE3 && strm.avail_in !== 0) {
        return err2(strm, Z_BUF_ERROR$12);
      }
      if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH$22 && s2.status !== FINISH_STATE3) {
        let bstate = s2.strategy === Z_HUFFMAN_ONLY3 ? deflate_huff2(s2, flush) : s2.strategy === Z_RLE2 ? deflate_rle2(s2, flush) : configuration_table2[s2.level].func(s2, flush);
        if (bstate === BS_FINISH_STARTED2 || bstate === BS_FINISH_DONE2) {
          s2.status = FINISH_STATE3;
        }
        if (bstate === BS_NEED_MORE2 || bstate === BS_FINISH_STARTED2) {
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
          }
          return Z_OK$32;
        }
        if (bstate === BS_BLOCK_DONE2) {
          if (flush === Z_PARTIAL_FLUSH3) {
            _tr_align2(s2);
          } else if (flush !== Z_BLOCK$12) {
            _tr_stored_block2(s2, 0, 0, false);
            if (flush === Z_FULL_FLUSH$12) {
              zero2(s2.head);
              if (s2.lookahead === 0) {
                s2.strstart = 0;
                s2.block_start = 0;
                s2.insert = 0;
              }
            }
          }
          flush_pending2(strm);
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
            return Z_OK$32;
          }
        }
      }
      if (flush !== Z_FINISH$32) {
        return Z_OK$32;
      }
      if (s2.wrap <= 0) {
        return Z_STREAM_END$32;
      }
      if (s2.wrap === 2) {
        put_byte2(s2, strm.adler & 255);
        put_byte2(s2, strm.adler >> 8 & 255);
        put_byte2(s2, strm.adler >> 16 & 255);
        put_byte2(s2, strm.adler >> 24 & 255);
        put_byte2(s2, strm.total_in & 255);
        put_byte2(s2, strm.total_in >> 8 & 255);
        put_byte2(s2, strm.total_in >> 16 & 255);
        put_byte2(s2, strm.total_in >> 24 & 255);
      } else {
        putShortMSB2(s2, strm.adler >>> 16);
        putShortMSB2(s2, strm.adler & 65535);
      }
      flush_pending2(strm);
      if (s2.wrap > 0) {
        s2.wrap = -s2.wrap;
      }
      return s2.pending !== 0 ? Z_OK$32 : Z_STREAM_END$32;
    };
    deflateEnd2 = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$22;
      }
      const status = strm.state.status;
      if (status !== INIT_STATE3 && status !== EXTRA_STATE2 && status !== NAME_STATE2 && status !== COMMENT_STATE2 && status !== HCRC_STATE2 && status !== BUSY_STATE3 && status !== FINISH_STATE3) {
        return err2(strm, Z_STREAM_ERROR$22);
      }
      strm.state = null;
      return status === BUSY_STATE3 ? err2(strm, Z_DATA_ERROR$22) : Z_OK$32;
    };
    deflateSetDictionary2 = (strm, dictionary) => {
      let dictLength = dictionary.length;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$22;
      }
      const s2 = strm.state;
      const wrap = s2.wrap;
      if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE3 || s2.lookahead) {
        return Z_STREAM_ERROR$22;
      }
      if (wrap === 1) {
        strm.adler = adler32_12(strm.adler, dictionary, dictLength, 0);
      }
      s2.wrap = 0;
      if (dictLength >= s2.w_size) {
        if (wrap === 0) {
          zero2(s2.head);
          s2.strstart = 0;
          s2.block_start = 0;
          s2.insert = 0;
        }
        let tmpDict = new Uint8Array(s2.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s2.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s2.w_size;
      }
      const avail = strm.avail_in;
      const next = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window2(s2);
      while (s2.lookahead >= MIN_MATCH3) {
        let str = s2.strstart;
        let n2 = s2.lookahead - (MIN_MATCH3 - 1);
        do {
          s2.ins_h = HASH2(s2, s2.ins_h, s2.window[str + MIN_MATCH3 - 1]);
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
        } while (--n2);
        s2.strstart = str;
        s2.lookahead = MIN_MATCH3 - 1;
        fill_window2(s2);
      }
      s2.strstart += s2.lookahead;
      s2.block_start = s2.strstart;
      s2.insert = s2.lookahead;
      s2.lookahead = 0;
      s2.match_length = s2.prev_length = MIN_MATCH3 - 1;
      s2.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s2.wrap = wrap;
      return Z_OK$32;
    };
    deflateInit_12 = deflateInit3;
    deflateInit2_12 = deflateInit22;
    deflateReset_12 = deflateReset2;
    deflateResetKeep_12 = deflateResetKeep2;
    deflateSetHeader_12 = deflateSetHeader2;
    deflate_2$12 = deflate$22;
    deflateEnd_12 = deflateEnd2;
    deflateSetDictionary_12 = deflateSetDictionary2;
    deflateInfo2 = "pako deflate (from Nodeca project)";
    deflate_1$22 = {
      deflateInit: deflateInit_12,
      deflateInit2: deflateInit2_12,
      deflateReset: deflateReset_12,
      deflateResetKeep: deflateResetKeep_12,
      deflateSetHeader: deflateSetHeader_12,
      deflate: deflate_2$12,
      deflateEnd: deflateEnd_12,
      deflateSetDictionary: deflateSetDictionary_12,
      deflateInfo: deflateInfo2
    };
    _has2 = (obj, key) => {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };
    assign2 = function(obj) {
      const sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        const source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (const p2 in source) {
          if (_has2(source, p2)) {
            obj[p2] = source[p2];
          }
        }
      }
      return obj;
    };
    flattenChunks2 = (chunks) => {
      let len = 0;
      for (let i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
        len += chunks[i2].length;
      }
      const result = new Uint8Array(len);
      for (let i2 = 0, pos = 0, l2 = chunks.length; i2 < l2; i2++) {
        let chunk = chunks[i2];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    };
    common2 = {
      assign: assign2,
      flattenChunks: flattenChunks2
    };
    STR_APPLY_UIA_OK2 = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK2 = false;
    }
    _utf8len2 = new Uint8Array(256);
    for (let q2 = 0; q2 < 256; q2++) {
      _utf8len2[q2] = q2 >= 252 ? 6 : q2 >= 248 ? 5 : q2 >= 240 ? 4 : q2 >= 224 ? 3 : q2 >= 192 ? 2 : 1;
    }
    _utf8len2[254] = _utf8len2[254] = 1;
    string2buf2 = (str) => {
      if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str);
      }
      let buf, c2, c22, m_pos, i2, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c2 = str.charCodeAt(m_pos);
        if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
      }
      buf = new Uint8Array(buf_len);
      for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
        c2 = str.charCodeAt(m_pos);
        if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        if (c2 < 128) {
          buf[i2++] = c2;
        } else if (c2 < 2048) {
          buf[i2++] = 192 | c2 >>> 6;
          buf[i2++] = 128 | c2 & 63;
        } else if (c2 < 65536) {
          buf[i2++] = 224 | c2 >>> 12;
          buf[i2++] = 128 | c2 >>> 6 & 63;
          buf[i2++] = 128 | c2 & 63;
        } else {
          buf[i2++] = 240 | c2 >>> 18;
          buf[i2++] = 128 | c2 >>> 12 & 63;
          buf[i2++] = 128 | c2 >>> 6 & 63;
          buf[i2++] = 128 | c2 & 63;
        }
      }
      return buf;
    };
    buf2binstring2 = (buf, len) => {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK2) {
          return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
      }
      let result = "";
      for (let i2 = 0; i2 < len; i2++) {
        result += String.fromCharCode(buf[i2]);
      }
      return result;
    };
    buf2string2 = (buf, max) => {
      const len = max || buf.length;
      if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max));
      }
      let i2, out;
      const utf16buf = new Array(len * 2);
      for (out = 0, i2 = 0; i2 < len; ) {
        let c2 = buf[i2++];
        if (c2 < 128) {
          utf16buf[out++] = c2;
          continue;
        }
        let c_len = _utf8len2[c2];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i2 += c_len - 1;
          continue;
        }
        c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i2 < len) {
          c2 = c2 << 6 | buf[i2++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c2 < 65536) {
          utf16buf[out++] = c2;
        } else {
          c2 -= 65536;
          utf16buf[out++] = 55296 | c2 >> 10 & 1023;
          utf16buf[out++] = 56320 | c2 & 1023;
        }
      }
      return buf2binstring2(utf16buf, out);
    };
    utf8border2 = (buf, max) => {
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      let pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len2[buf[pos]] > max ? pos : max;
    };
    strings2 = {
      string2buf: string2buf2,
      buf2string: buf2string2,
      utf8border: utf8border2
    };
    zstream2 = ZStream4;
    toString$12 = Object.prototype.toString;
    ({
      Z_NO_FLUSH: Z_NO_FLUSH$12,
      Z_SYNC_FLUSH: Z_SYNC_FLUSH2,
      Z_FULL_FLUSH: Z_FULL_FLUSH3,
      Z_FINISH: Z_FINISH$22,
      Z_OK: Z_OK$22,
      Z_STREAM_END: Z_STREAM_END$22,
      Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION3,
      Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY3,
      Z_DEFLATED: Z_DEFLATED$12
    } = constants$22);
    Deflate$12.prototype.push = function(data2, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      let status, _flush_mode;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
      else _flush_mode = flush_mode === true ? Z_FINISH$22 : Z_NO_FLUSH$12;
      if (typeof data2 === "string") {
        strm.input = strings2.string2buf(data2);
      } else if (toString$12.call(data2) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data2);
      } else {
        strm.input = data2;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH2 || _flush_mode === Z_FULL_FLUSH3) && strm.avail_out <= 6) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        status = deflate_1$22.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END$22) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = deflate_1$22.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK$22;
        }
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        if (strm.avail_in === 0) break;
      }
      return true;
    };
    Deflate$12.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate$12.prototype.onEnd = function(status) {
      if (status === Z_OK$22) {
        this.result = common2.flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    Deflate_1$12 = Deflate$12;
    deflate_22 = deflate$12;
    deflateRaw_1$12 = deflateRaw$12;
    gzip_1$12 = gzip$12;
    constants$12 = constants$22;
    deflate_1$12 = {
      Deflate: Deflate_1$12,
      deflate: deflate_22,
      deflateRaw: deflateRaw_1$12,
      gzip: gzip_1$12,
      constants: constants$12
    };
    BAD$12 = 30;
    TYPE$12 = 12;
    inffast2 = function inflate_fast2(strm, start) {
      let _in;
      let last;
      let _out;
      let beg;
      let end;
      let dmax;
      let wsize;
      let whave;
      let wnext;
      let s_window;
      let hold;
      let bits;
      let lcode;
      let dcode;
      let lmask;
      let dmask;
      let here;
      let op;
      let len;
      let dist;
      let from;
      let from_source;
      let input, output;
      const state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$12;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD$12;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD$12;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE$12;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD$12;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
    MAXBITS2 = 15;
    ENOUGH_LENS$12 = 852;
    ENOUGH_DISTS$12 = 592;
    CODES$12 = 0;
    LENS$12 = 1;
    DISTS$12 = 2;
    lbase2 = new Uint16Array([
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ]);
    lext2 = new Uint8Array([
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ]);
    dbase2 = new Uint16Array([
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ]);
    dext2 = new Uint8Array([
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ]);
    inflate_table2 = (type, lens, lens_index, codes, table3, table_index, work, opts) => {
      const bits = opts.bits;
      let len = 0;
      let sym = 0;
      let min = 0, max = 0;
      let root = 0;
      let curr = 0;
      let drop = 0;
      let left = 0;
      let used = 0;
      let huff = 0;
      let incr;
      let fill;
      let low;
      let mask;
      let next;
      let base = null;
      let base_index = 0;
      let end;
      const count = new Uint16Array(MAXBITS2 + 1);
      const offs = new Uint16Array(MAXBITS2 + 1);
      let extra = null;
      let extra_index = 0;
      let here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS2; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS2; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table3[table_index++] = 1 << 24 | 64 << 16 | 0;
        table3[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS2; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES$12 || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS2; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES$12) {
        base = extra = work;
        end = 19;
      } else if (type === LENS$12) {
        base = lbase2;
        base_index -= 257;
        extra = lext2;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase2;
        extra = dext2;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS$12 && used > ENOUGH_LENS$12 || type === DISTS$12 && used > ENOUGH_DISTS$12) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table3[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS$12 && used > ENOUGH_LENS$12 || type === DISTS$12 && used > ENOUGH_DISTS$12) {
            return 1;
          }
          low = huff & mask;
          table3[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table3[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
    inftrees2 = inflate_table2;
    CODES3 = 0;
    LENS3 = 1;
    DISTS2 = 2;
    ({
      Z_FINISH: Z_FINISH$12,
      Z_BLOCK: Z_BLOCK2,
      Z_TREES: Z_TREES2,
      Z_OK: Z_OK$12,
      Z_STREAM_END: Z_STREAM_END$12,
      Z_NEED_DICT: Z_NEED_DICT$12,
      Z_STREAM_ERROR: Z_STREAM_ERROR$12,
      Z_DATA_ERROR: Z_DATA_ERROR$12,
      Z_MEM_ERROR: Z_MEM_ERROR$12,
      Z_BUF_ERROR: Z_BUF_ERROR4,
      Z_DEFLATED: Z_DEFLATED4
    } = constants$22);
    HEAD2 = 1;
    FLAGS2 = 2;
    TIME2 = 3;
    OS2 = 4;
    EXLEN2 = 5;
    EXTRA2 = 6;
    NAME2 = 7;
    COMMENT2 = 8;
    HCRC2 = 9;
    DICTID2 = 10;
    DICT5 = 11;
    TYPE3 = 12;
    TYPEDO2 = 13;
    STORED4 = 14;
    COPY_2 = 15;
    COPY3 = 16;
    TABLE3 = 17;
    LENLENS2 = 18;
    CODELENS2 = 19;
    LEN_2 = 20;
    LEN3 = 21;
    LENEXT3 = 22;
    DIST3 = 23;
    DISTEXT3 = 24;
    MATCH2 = 25;
    LIT3 = 26;
    CHECK2 = 27;
    LENGTH2 = 28;
    DONE3 = 29;
    BAD3 = 30;
    MEM2 = 31;
    SYNC2 = 32;
    ENOUGH_LENS2 = 852;
    ENOUGH_DISTS2 = 592;
    MAX_WBITS2 = 15;
    DEF_WBITS2 = MAX_WBITS2;
    zswap322 = (q2) => {
      return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
    };
    inflateResetKeep2 = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$12;
      }
      const state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD2;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS2);
      state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS2);
      state.sane = 1;
      state.back = -1;
      return Z_OK$12;
    };
    inflateReset3 = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$12;
      }
      const state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep2(strm);
    };
    inflateReset22 = (strm, windowBits) => {
      let wrap;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$12;
      }
      const state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR$12;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset3(strm);
    };
    inflateInit22 = (strm, windowBits) => {
      if (!strm) {
        return Z_STREAM_ERROR$12;
      }
      const state = new InflateState2();
      strm.state = state;
      state.window = null;
      const ret = inflateReset22(strm, windowBits);
      if (ret !== Z_OK$12) {
        strm.state = null;
      }
      return ret;
    };
    inflateInit3 = (strm) => {
      return inflateInit22(strm, DEF_WBITS2);
    };
    virgin2 = true;
    fixedtables2 = (state) => {
      if (virgin2) {
        lenfix2 = new Int32Array(512);
        distfix2 = new Int32Array(32);
        let sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inftrees2(LENS3, state.lens, 0, 288, lenfix2, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inftrees2(DISTS2, state.lens, 0, 32, distfix2, 0, state.work, { bits: 5 });
        virgin2 = false;
      }
      state.lencode = lenfix2;
      state.lenbits = 9;
      state.distcode = distfix2;
      state.distbits = 5;
    };
    updatewindow2 = (strm, src, end, copy) => {
      let dist;
      const state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
      }
      if (copy >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
        copy -= dist;
        if (copy) {
          state.window.set(src.subarray(end - copy, end), 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    };
    inflate$22 = (strm, flush) => {
      let state;
      let input, output;
      let next;
      let put;
      let have, left;
      let hold;
      let bits;
      let _in, _out;
      let copy;
      let from;
      let from_source;
      let here = 0;
      let here_bits, here_op, here_val;
      let last_bits, last_op, last_val;
      let len;
      let ret;
      const hbuf = new Uint8Array(4);
      let opts;
      let n2;
      const order = (
        /* permutation of code lengths */
        new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR$12;
      }
      state = strm.state;
      if (state.mode === TYPE3) {
        state.mode = TYPEDO2;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK$12;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD2:
              if (state.wrap === 0) {
                state.mode = TYPEDO2;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_12(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS2;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD3;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED4) {
                strm.msg = "unknown compression method";
                state.mode = BAD3;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD3;
                break;
              }
              state.dmax = 1 << state.wbits;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID2 : TYPE3;
              hold = 0;
              bits = 0;
              break;
            case FLAGS2:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED4) {
                strm.msg = "unknown compression method";
                state.mode = BAD3;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD3;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_12(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME2;
            /* falls through */
            case TIME2:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32_12(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS2;
            /* falls through */
            case OS2:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_12(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN2;
            /* falls through */
            case EXLEN2:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32_12(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA2;
            /* falls through */
            case EXTRA2:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Uint8Array(state.head.extra_len);
                    }
                    state.head.extra.set(
                      input.subarray(
                        next,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        next + copy
                      ),
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32_12(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME2;
            /* falls through */
            case NAME2:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32_12(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT2;
            /* falls through */
            case COMMENT2:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32_12(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC2;
            /* falls through */
            case HCRC2:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD3;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE3;
              break;
            case DICTID2:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap322(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT5;
            /* falls through */
            case DICT5:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT$12;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE3;
            /* falls through */
            case TYPE3:
              if (flush === Z_BLOCK2 || flush === Z_TREES2) {
                break inf_leave;
              }
            /* falls through */
            case TYPEDO2:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK2;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED4;
                  break;
                case 1:
                  fixedtables2(state);
                  state.mode = LEN_2;
                  if (flush === Z_TREES2) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE3;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD3;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED4:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD3;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_2;
              if (flush === Z_TREES2) {
                break inf_leave;
              }
            /* falls through */
            case COPY_2:
              state.mode = COPY3;
            /* falls through */
            case COPY3:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                output.set(input.subarray(next, next + copy), put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE3;
              break;
            case TABLE3:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD3;
                break;
              }
              state.have = 0;
              state.mode = LENLENS2;
            /* falls through */
            case LENLENS2:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inftrees2(CODES3, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD3;
                break;
              }
              state.have = 0;
              state.mode = CODELENS2;
            /* falls through */
            case CODELENS2:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n2 = here_bits + 2;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD3;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n2 = here_bits + 3;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n2 = here_bits + 7;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD3;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD3) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD3;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inftrees2(LENS3, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD3;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inftrees2(DISTS2, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD3;
                break;
              }
              state.mode = LEN_2;
              if (flush === Z_TREES2) {
                break inf_leave;
              }
            /* falls through */
            case LEN_2:
              state.mode = LEN3;
            /* falls through */
            case LEN3:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inffast2(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE3) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT3;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE3;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD3;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT3;
            /* falls through */
            case LENEXT3:
              if (state.extra) {
                n2 = state.extra;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST3;
            /* falls through */
            case DIST3:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD3;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT3;
            /* falls through */
            case DISTEXT3:
              if (state.extra) {
                n2 = state.extra;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD3;
                break;
              }
              state.mode = MATCH2;
            /* falls through */
            case MATCH2:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD3;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN3;
              }
              break;
            case LIT3:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN3;
              break;
            case CHECK2:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32_12(state.check, output, _out, put - _out) : adler32_12(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap322(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD3;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH2;
            /* falls through */
            case LENGTH2:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD3;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE3;
            /* falls through */
            case DONE3:
              ret = Z_STREAM_END$12;
              break inf_leave;
            case BAD3:
              ret = Z_DATA_ERROR$12;
              break inf_leave;
            case MEM2:
              return Z_MEM_ERROR$12;
            case SYNC2:
            /* falls through */
            default:
              return Z_STREAM_ERROR$12;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD3 && (state.mode < CHECK2 || flush !== Z_FINISH$12)) {
        if (updatewindow2(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32_12(state.check, output, _out, strm.next_out - _out) : adler32_12(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE3 ? 128 : 0) + (state.mode === LEN_2 || state.mode === COPY_2 ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH$12) && ret === Z_OK$12) {
        ret = Z_BUF_ERROR4;
      }
      return ret;
    };
    inflateEnd2 = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$12;
      }
      let state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK$12;
    };
    inflateGetHeader2 = (strm, head) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$12;
      }
      const state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR$12;
      }
      state.head = head;
      head.done = false;
      return Z_OK$12;
    };
    inflateSetDictionary2 = (strm, dictionary) => {
      const dictLength = dictionary.length;
      let state;
      let dictid;
      let ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$12;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT5) {
        return Z_STREAM_ERROR$12;
      }
      if (state.mode === DICT5) {
        dictid = 1;
        dictid = adler32_12(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR$12;
        }
      }
      ret = updatewindow2(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM2;
        return Z_MEM_ERROR$12;
      }
      state.havedict = 1;
      return Z_OK$12;
    };
    inflateReset_12 = inflateReset3;
    inflateReset2_12 = inflateReset22;
    inflateResetKeep_12 = inflateResetKeep2;
    inflateInit_12 = inflateInit3;
    inflateInit2_12 = inflateInit22;
    inflate_2$12 = inflate$22;
    inflateEnd_12 = inflateEnd2;
    inflateGetHeader_12 = inflateGetHeader2;
    inflateSetDictionary_12 = inflateSetDictionary2;
    inflateInfo2 = "pako inflate (from Nodeca project)";
    inflate_1$22 = {
      inflateReset: inflateReset_12,
      inflateReset2: inflateReset2_12,
      inflateResetKeep: inflateResetKeep_12,
      inflateInit: inflateInit_12,
      inflateInit2: inflateInit2_12,
      inflate: inflate_2$12,
      inflateEnd: inflateEnd_12,
      inflateGetHeader: inflateGetHeader_12,
      inflateSetDictionary: inflateSetDictionary_12,
      inflateInfo: inflateInfo2
    };
    gzheader2 = GZheader2;
    toString2 = Object.prototype.toString;
    ({
      Z_NO_FLUSH: Z_NO_FLUSH4,
      Z_FINISH: Z_FINISH4,
      Z_OK: Z_OK4,
      Z_STREAM_END: Z_STREAM_END4,
      Z_NEED_DICT: Z_NEED_DICT4,
      Z_STREAM_ERROR: Z_STREAM_ERROR4,
      Z_DATA_ERROR: Z_DATA_ERROR4,
      Z_MEM_ERROR: Z_MEM_ERROR3
    } = constants$22);
    Inflate$12.prototype.push = function(data2, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      const dictionary = this.options.dictionary;
      let status, _flush_mode, last_avail_out;
      if (this.ended) return false;
      if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
      else _flush_mode = flush_mode === true ? Z_FINISH4 : Z_NO_FLUSH4;
      if (toString2.call(data2) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data2);
      } else {
        strm.input = data2;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = inflate_1$22.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT4 && dictionary) {
          status = inflate_1$22.inflateSetDictionary(strm, dictionary);
          if (status === Z_OK4) {
            status = inflate_1$22.inflate(strm, _flush_mode);
          } else if (status === Z_DATA_ERROR4) {
            status = Z_NEED_DICT4;
          }
        }
        while (strm.avail_in > 0 && status === Z_STREAM_END4 && strm.state.wrap > 0 && data2[strm.next_in] !== 0) {
          inflate_1$22.inflateReset(strm);
          status = inflate_1$22.inflate(strm, _flush_mode);
        }
        switch (status) {
          case Z_STREAM_ERROR4:
          case Z_DATA_ERROR4:
          case Z_NEED_DICT4:
          case Z_MEM_ERROR3:
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === Z_STREAM_END4) {
            if (this.options.to === "string") {
              let next_out_utf8 = strings2.utf8border(strm.output, strm.next_out);
              let tail = strm.next_out - next_out_utf8;
              let utf8str = strings2.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
              this.onData(utf8str);
            } else {
              this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
            }
          }
        }
        if (status === Z_OK4 && last_avail_out === 0) continue;
        if (status === Z_STREAM_END4) {
          status = inflate_1$22.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return true;
        }
        if (strm.avail_in === 0) break;
      }
      return true;
    };
    Inflate$12.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate$12.prototype.onEnd = function(status) {
      if (status === Z_OK4) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = common2.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    Inflate_1$12 = Inflate$12;
    inflate_22 = inflate$12;
    inflateRaw_1$12 = inflateRaw$12;
    ungzip$12 = inflate$12;
    constants2 = constants$22;
    inflate_1$12 = {
      Inflate: Inflate_1$12,
      inflate: inflate_22,
      inflateRaw: inflateRaw_1$12,
      ungzip: ungzip$12,
      constants: constants2
    };
    ({ Deflate: Deflate3, deflate: deflate2, deflateRaw: deflateRaw2, gzip: gzip2 } = deflate_1$12);
    ({ Inflate: Inflate3, inflate: inflate2, inflateRaw: inflateRaw2, ungzip: ungzip2 } = inflate_1$12);
    Deflate_12 = Deflate3;
    deflate_12 = deflate2;
    deflateRaw_12 = deflateRaw2;
    gzip_12 = gzip2;
    Inflate_12 = Inflate3;
    inflate_12 = inflate2;
    inflateRaw_12 = inflateRaw2;
    ungzip_12 = ungzip2;
    constants_12 = constants$22;
    pako2 = {
      Deflate: Deflate_12,
      deflate: deflate_12,
      deflateRaw: deflateRaw_12,
      gzip: gzip_12,
      Inflate: Inflate_12,
      inflate: inflate_12,
      inflateRaw: inflateRaw_12,
      ungzip: ungzip_12,
      constants: constants_12
    };
  }
});

// node_modules/scribe.js-ocr/scrollview-web/src/constants.js
function getViewColor(color, lightTheme) {
  if (color === "rgba(255, 255, 255, 255)" && lightTheme) {
    return "rgba(0, 0, 0, 255)";
  }
  return color;
}
function invertTextlineColor(colorRGBA) {
  const color = colorsMapping[colorRGBA];
  switch (color) {
    case "BROWN":
      return { region_type: "BRT_HLINE" };
    case "DARK_GREEN":
      return { region_type: "BRT_VLINE" };
    case "RED":
      return { region_type: "BRT_RECTIMAGE" };
    case "ORANGE":
      return { region_type: "BRT_POLYIMAGE" };
    case "CYAN":
      return { region_type: "BRT_UNKNOWN", flow_type: "BTFT_NONTEXT" };
    case "WHITE":
      return { region_type: "BRT_UNKNOWN", flow_type: "Not BTFT_NONTEXT" };
    case "GREEN":
      return { region_type: "BRT_VERT_TEXT", flow_type: "BTFT_STRONG_CHAIN or BTFT_TEXT_ON_IMAGE" };
    case "LIME_GREEN":
      return { region_type: "BRT_VERT_TEXT", flow_type: "BTFT_CHAIN" };
    case "YELLOW":
      return { region_type: "BRT_VERT_TEXT", flow_type: "Other" };
    case "BLUE":
      return { region_type: "BRT_TEXT", flow_type: "BTFT_STRONG_CHAIN" };
    case "LIGHT_BLUE":
      return { region_type: "BRT_TEXT", flow_type: "BTFT_TEXT_ON_IMAGE" };
    // This case is MEDIUM_BLUE in vanilla Tesseract, however was edited to AQUAMARINE to improve readability.
    // MEDIUM_BLUE is very difficult to tell apart from BLUE.
    case "MEDIUM_BLUE":
      return { region_type: "BRT_TEXT", flow_type: "BTFT_CHAIN" };
    case "AQUAMARINE":
      return { region_type: "BRT_TEXT", flow_type: "BTFT_CHAIN" };
    case "WHEAT":
      return { region_type: "BRT_TEXT", flow_type: "BTFT_LEADER" };
    case "PINK":
      return { region_type: "BRT_TEXT", flow_type: "BTFT_NONTEXT" };
    case "MAGENTA":
      return { region_type: "BRT_TEXT", flow_type: "Other" };
    case "GREY":
      return { region_type: "BRT_NOISE" };
    default:
      return { region_type: "Unknown (Report Bug)", flow_type: "Unknown (Report Bug)" };
  }
}
function invertDisplayGoodBlobsColor(colorRGBA) {
  const color = colorsMapping[colorRGBA];
  switch (color) {
    case "BROWN":
      return { region_type: "BRT_HLINE" };
    case "DARK_GREEN":
      return { region_type: "BRT_VLINE" };
    case "RED":
      return { region_type: "BRT_RECTIMAGE" };
    case "ORANGE":
      return { region_type: "BRT_POLYIMAGE" };
    case "WHITE":
      return { region_type: "BRT_UNKNOWN" };
    case "GREEN":
      return { region_type: "BRT_VERT_TEXT", flow_type: "Goodness > 1" };
    case "LIME_GREEN":
      return { region_type: "BRT_VERT_TEXT", flow_type: "Goodness = 1" };
    case "YELLOW":
      return { region_type: "BRT_VERT_TEXT", flow_type: "Goodness = 0" };
    case "BLUE":
      return { region_type: "BRT_TEXT", flow_type: "Goodness > 1" };
    // This case is MEDIUM_BLUE in vanilla Tesseract, however was edited to AQUAMARINE to improve readability.
    // MEDIUM_BLUE is very difficult to tell apart from BLUE.
    case "MEDIUM_BLUE":
      return { region_type: "BRT_TEXT", flow_type: "Goodness = 1" };
    case "AQUAMARINE":
      return { region_type: "BRT_TEXT", flow_type: "Goodness = 1" };
    case "MAGENTA":
      return { region_type: "BRT_TEXT", flow_type: "Goodness = 0" };
    case "GREY":
      return { region_type: "BRT_NOISE" };
    default:
      return { region_type: "Unknown (Report Bug)", flow_type: "Unknown (Report Bug)" };
  }
}
function invertPhotoMaskColor(colorRGBA) {
  const color = colorsMapping[colorRGBA];
  switch (color) {
    case "WHITE":
      return { type: "Medium Blob" };
    case "DARK_GREEN":
      return { type: "Large Blob" };
    case "GOLDENROD":
      return { type: "Small Blob" };
    case "CORAL":
      return { type: "Noise Blob" };
    case "RED":
      return { type: "Deleted Blob" };
    default:
      return { type: "Unknown (Report Bug)" };
  }
}
function invertImageBlobsColor(colorRGBA) {
  const color = colorsMapping[colorRGBA];
  switch (color) {
    case "WHITE":
      return { type: "Medium Blob" };
    case "DARK_GREEN":
      return { type: "Large Blob" };
    case "GOLDENROD":
      return { type: "Small Blob" };
    case "CORAL":
      return { type: "Noise Blob" };
    case "RED":
      return { type: "Deleted Blob" };
    case "BROWN":
      return { type: "Medium Blob Interior" };
    case "YELLOW":
      return { type: "Small or Large Blob Interior" };
    case "BLUE":
      return { type: "Noise Blob Interior" };
    default:
      return { type: "Unknown (Report Bug)" };
  }
}
function invertPlotGradedBlobsColor(colorRGBA) {
  const color = colorsMapping[colorRGBA];
  switch (color) {
    case "WHITE":
      return { type: "Medium blob." };
    case "BROWN":
      return { type: "Medium blob (child)." };
    case "CORAL":
      return { type: "Noise blob." };
    case "BLUE":
      return { type: "Noise blob (child)." };
    case "GOLDENROD":
      return { type: "Small blob." };
    case "YELLOW":
      return { type: "Small blob (child)." };
    case "DARK_GREEN":
      return { type: "Large blob." };
    case "YELLOW":
      return { type: "Large blob (child)." };
    default:
      return { type: "Unknown (Report Bug)" };
  }
}
function invertTextlineProjectionPlotGradedBlobsColor(colorRGBA) {
  const color = colorsMapping[colorRGBA];
  switch (color) {
    case "YELLOW":
      return { type: "Definite vertical text." };
    case "RED":
      return { type: "Outside textline, not definite vertical text." };
    case "BLUE":
      return { type: "Inside textline, not definite vertical text." };
    default:
      return { type: "Unknown (Report Bug)" };
  }
}
function invertPolyBlockColor(colorRGBA) {
  const color = colorsMapping[colorRGBA];
  const type = colorToPolyBlockType[color.toUpperCase()];
  return type ? { type } : { type: "Unknown (Report Bug)" };
}
function invertTabStopColor(colorRGBA) {
  const color = colorsMapping[colorRGBA];
  switch (color) {
    case "LIME_GREEN":
      return { type: "TA_LEFT_ALIGNED" };
    case "DARK_GREEN":
      return { type: "TA_LEFT_RAGGED" };
    case "PINK":
      return { type: "TA_RIGHT_ALIGNED" };
    case "CORAL":
      return { type: "TA_RIGHT_RAGGED" };
    case "WHITE":
      return { type: "TA_CENTER_JUSTIFIED or TA_SEPARATOR" };
    case "GREY":
      return { type: "Extended Min/Max" };
    default:
      return { type: "Unknown (Report Bug)" };
  }
}
function invertDisplayTabsColor(colorRGBA) {
  const color = colorsMapping[colorRGBA];
  switch (color) {
    case "BLUE":
      return { type: "Left tabtype: TT_MAYBE_ALIGNED" };
    case "YELLOW":
      return { type: "Left tabtype: TT_MAYBE_RAGGED" };
    case "GREEN":
      return { type: "Left tabtype: TT_CONFIRMED" };
    // GREY appears in both this function and `invertTabStopColor`, which are both used on the same canvas, and we cannot tell the difference.
    // Using other definition for the legend as those lines are much more common and prominent.
    // case 'GREY':
    //     return { type: 'Left or Right tabtype: TT_DELETED or TT_VLINE' };
    case "MAGENTA":
      return { type: "Right tabtype: TT_MAYBE_ALIGNED" };
    case "ORANGE":
      return { type: "Right tabtype: TT_MAYBE_RAGGED" };
    case "RED":
      return { type: "Right tabtype: TT_CONFIRMED" };
    // Every function that calls `DisplayTabs` also displays tab stops on the same canvas. The inverse is not true.
    default:
      return invertTabStopColor(colorRGBA);
  }
}
var colorsMapping, colorToPolyBlockType, lineColorLookup, boxColorLookup, getBoxColorFunc, getLineColorFunc;
var init_constants2 = __esm({
  "node_modules/scribe.js-ocr/scrollview-web/src/constants.js"() {
    colorsMapping = {
      "rgba(0, 0, 0, 0)": "NONE",
      "rgba(0, 0, 0, 255)": "BLACK",
      "rgba(255, 255, 255, 255)": "WHITE",
      "rgba(255, 0, 0, 255)": "RED",
      "rgba(255, 255, 0, 255)": "YELLOW",
      "rgba(0, 255, 0, 255)": "GREEN",
      "rgba(0, 255, 255, 255)": "CYAN",
      "rgba(0, 0, 255, 255)": "BLUE",
      "rgba(255, 0, 255, 255)": "MAGENTA",
      "rgba(0, 128, 255, 255)": "AQUAMARINE",
      "rgba(0, 0, 64, 255)": "DARK_SLATE_BLUE",
      "rgba(128, 128, 255, 255)": "LIGHT_BLUE",
      "rgba(64, 64, 255, 255)": "MEDIUM_BLUE",
      "rgba(0, 0, 32, 255)": "MIDNIGHT_BLUE",
      "rgba(0, 0, 128, 255)": "NAVY_BLUE",
      "rgba(192, 192, 255, 255)": "SKY_BLUE",
      "rgba(64, 64, 128, 255)": "SLATE_BLUE",
      "rgba(32, 32, 64, 255)": "STEEL_BLUE",
      "rgba(255, 128, 128, 255)": "CORAL",
      "rgba(128, 64, 0, 255)": "BROWN",
      // "rgba(128, 128, 0, 255)": "SANDY_BROWN", // Same RGBA as WHEAT and never used in Tesseract code.
      "rgba(192, 192, 0, 255)": "GOLD",
      "rgba(192, 192, 128, 255)": "GOLDENROD",
      "rgba(0, 64, 0, 255)": "DARK_GREEN",
      "rgba(32, 64, 0, 255)": "DARK_OLIVE_GREEN",
      "rgba(64, 128, 0, 255)": "FOREST_GREEN",
      "rgba(128, 255, 0, 255)": "LIME_GREEN",
      "rgba(192, 255, 192, 255)": "PALE_GREEN",
      "rgba(192, 255, 0, 255)": "YELLOW_GREEN",
      "rgba(192, 192, 192, 255)": "LIGHT_GREY",
      // "rgba(64, 64, 128, 255)": "DARK_SLATE_GREY", // Same RGBA as SLATE_BLUE and never used in Tesseract code.
      "rgba(64, 64, 64, 255)": "DIM_GREY",
      "rgba(128, 128, 128, 255)": "GREY",
      "rgba(64, 192, 0, 255)": "KHAKI",
      "rgba(255, 0, 192, 255)": "MAROON",
      "rgba(255, 128, 0, 255)": "ORANGE",
      "rgba(255, 128, 64, 255)": "ORCHID",
      "rgba(255, 192, 192, 255)": "PINK",
      "rgba(128, 0, 128, 255)": "PLUM",
      "rgba(255, 0, 64, 255)": "INDIAN_RED",
      "rgba(255, 64, 0, 255)": "ORANGE_RED",
      // "rgba(255, 0, 192, 255)": "VIOLET_RED", // Same RGBA as MAROON and never used in Tesseract code.
      "rgba(255, 192, 128, 255)": "SALMON",
      // "rgba(128, 128, 0, 255)": "TAN", // Same RGBA as WHEAT and never used in Tesseract code.
      // "rgba(0, 255, 255, 255)": "TURQUOISE", // Same RGBA as CYAN and never used in Tesseract code.
      "rgba(0, 128, 128, 255)": "DARK_TURQUOISE",
      "rgba(192, 0, 255, 255)": "VIOLET",
      "rgba(128, 128, 0, 255)": "WHEAT"
      // "rgba(128, 255, 0, 255)": "GREEN_YELLOW" // Same RGBA as LIME_GREEN and never used in Tesseract code.
    };
    colorToPolyBlockType = {
      WHITE: "PT_UNKNOWN",
      BLUE: "PT_FLOWING_TEXT",
      CYAN: "PT_HEADING_TEXT",
      MEDIUM_BLUE: "PT_PULLOUT_TEXT",
      AQUAMARINE: "PT_EQUATION",
      SKY_BLUE: "PT_INLINE_EQUATION",
      MAGENTA: "PT_TABLE",
      GREEN: "PT_VERTICAL_TEXT",
      LIGHT_BLUE: "PT_CAPTION_TEXT",
      RED: "PT_FLOWING_IMAGE",
      YELLOW: "PT_HEADING_IMAGE",
      ORANGE: "PT_PULLOUT_IMAGE",
      BROWN: "PT_HORZ_LINE",
      DARK_GREEN: "PT_VERT_LINE",
      GREY: "PT_NOISE"
    };
    lineColorLookup = {
      InitialTabs: invertDisplayTabsColor,
      FinalTabs: invertDisplayTabsColor,
      InitialPartitions: invertTabStopColor,
      Partitions: invertTabStopColor
    };
    boxColorLookup = {
      "Filtered Input Blobs": invertPlotGradedBlobsColor,
      "Photo Mask Blobs": invertPhotoMaskColor,
      "Image blobs": invertImageBlobsColor,
      "Initial textline Blobs": invertTextlineProjectionPlotGradedBlobsColor,
      // LeaderNeighbours plots everything in white, so does not need a color legend.
      InitialStrokewidths: invertDisplayGoodBlobsColor,
      ImprovedStrokewidths: invertDisplayGoodBlobsColor,
      "Initial text chains": invertTextlineColor,
      "GoodTextline blobs": invertTextlineColor,
      "Smoothed blobs": invertTextlineColor,
      "With Images": invertTextlineColor,
      "Rejected blobs": invertImageBlobsColor,
      InitialPartitions: invertPolyBlockColor
    };
    getBoxColorFunc = (name) => {
      const nameNative = name.replace(/_\d+/, "");
      return boxColorLookup[nameNative];
    };
    getLineColorFunc = (name) => {
      const nameNative = name.replace(/_\d+/, "");
      return lineColorLookup[nameNative];
    };
  }
});

// node_modules/scribe.js-ocr/scrollview-web/src/common.js
function drawColorLegend(canvas, name, colorsRect, colorsLine, lightTheme = false) {
  const boxColorFunc = getBoxColorFunc(name);
  const lineColorFunc = getLineColorFunc(name);
  if (!(boxColorFunc && colorsRect) && !(lineColorFunc && colorsLine)) return false;
  const ctx = (
    /** @type {CanvasRenderingContext2D} */
    canvas.getContext("2d")
  );
  let startY = 10;
  const boxHeight = 20;
  const boxWidth = 40;
  const padding = 10;
  const textPadding = 10;
  const lineHeight = boxHeight + padding;
  const elemsCt = (Object.keys(colorsRect).length || 0) * !!boxColorFunc + (Object.keys(colorsLine).length || 0) * !!lineColorFunc;
  canvas.width = 500;
  canvas.height = lineHeight * elemsCt + padding;
  ctx.fillStyle = lightTheme ? "white" : "black";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  if (colorsRect && boxColorFunc) {
    Object.keys(colorsRect).map((color) => {
      const colorObj = boxColorFunc(color);
      const colorLabelArr = [];
      for (const [key, value] of Object.entries(colorObj)) {
        colorLabelArr.push(`${key}: ${value}`);
      }
      ctx.strokeStyle = getViewColor(color, lightTheme);
      ctx.lineWidth = 2;
      ctx.strokeRect(padding, startY, boxWidth, boxHeight);
      ctx.fillStyle = lightTheme ? "black" : "white";
      ctx.textBaseline = "middle";
      let offsetX = 0;
      for (let i2 = 0; i2 < colorLabelArr.length; i2++) {
        ctx.fillText(colorLabelArr[i2], padding + boxWidth + textPadding + offsetX, startY + boxHeight / 2);
        offsetX += 200;
      }
      startY += lineHeight;
    });
  }
  if (colorsLine && lineColorFunc) {
    Object.keys(colorsLine).map((color) => {
      const colorObj = lineColorFunc(color);
      const colorLabelArr = [];
      for (const [key, value] of Object.entries(colorObj)) {
        colorLabelArr.push(`${key}: ${value}`);
      }
      ctx.strokeStyle = getViewColor(color, lightTheme);
      ctx.lineWidth = 2;
      ctx.fillStyle = getViewColor(color, lightTheme);
      ctx.beginPath();
      ctx.roundRect(padding, startY + 7, boxWidth, 3, [40]);
      ctx.stroke();
      ctx.fill();
      ctx.fillStyle = lightTheme ? "black" : "white";
      ctx.textBaseline = "middle";
      let offsetX = 0;
      for (let i2 = 0; i2 < colorLabelArr.length; i2++) {
        ctx.fillText(colorLabelArr[i2], padding + boxWidth + textPadding + offsetX, startY + boxHeight / 2);
        offsetX += 200;
      }
      startY += lineHeight;
    });
  }
  return true;
}
function getRandomInt2(min, max) {
  const minI = Math.ceil(min);
  const maxI = Math.floor(max);
  return Math.floor(Math.random() * (maxI - minI) + minI);
}
function getRandomAlphanum2(num) {
  const outArr = new Array(num);
  for (let i2 = 0; i2 < num; i2++) {
    let intI = getRandomInt2(1, 62);
    if (intI <= 10) {
      intI += 47;
    } else if (intI <= 36) {
      intI = intI - 10 + 64;
    } else {
      intI = intI - 36 + 96;
    }
    outArr[i2] = String.fromCharCode(intI);
  }
  return outArr.join("");
}
var init_common = __esm({
  "node_modules/scribe.js-ocr/scrollview-web/src/common.js"() {
    init_constants2();
  }
});

// node_modules/scribe.js-ocr/scrollview-web/scrollview/ui/SVImageHandler.js
var browserMode, SVImageHandler;
var init_SVImageHandler = __esm({
  "node_modules/scribe.js-ocr/scrollview-web/scrollview/ui/SVImageHandler.js"() {
    browserMode = typeof process === "undefined";
    SVImageHandler = class {
      /**
       * @param {string} imgStr
       */
      static imageStrToBlob(imgStr) {
        const imgData = new Uint8Array(atob(imgStr).split("").map((c2) => c2.charCodeAt(0)));
        const imgBlob = new Blob([imgData], { type: "application/octet-stream" });
        return imgBlob;
      }
      /**
      * @param {string} imgStr
      */
      static imageStrToBuffer(imgStr) {
        const imageBuffer = Buffer.from(imgStr, "base64");
        return imageBuffer;
      }
      /**
       * Handles various image formats, always returns a ImageBitmap.
       *
       * @param {string} img
       * @param {import('canvaskit-wasm').CanvasKit} [CanvasKit] - CanvasKit module. Must be defined if running in Node.js.
       */
      static async readImage(img, CanvasKit) {
        if (img === void 0) throw new Error("Input is undefined");
        if (img === null) throw new Error("Input is null");
        if (browserMode) {
          const imgBlob = this.imageStrToBlob(img);
          const imgBit2 = await createImageBitmap(imgBlob);
          return imgBit2;
        }
        if (CanvasKit === void 0) throw new Error("CanvasKit module must be provided in environments that do not support OffscreenCanvas natively (i.e. Node.js).");
        const imgBuffer = this.imageStrToBuffer(img);
        const imgBit = CanvasKit.MakeImageFromEncoded(imgBuffer);
        return imgBit;
      }
    };
  }
});

// node_modules/scribe.js-ocr/scrollview-web/scrollview/ui/SVWindow.js
var SVWindow;
var init_SVWindow = __esm({
  "node_modules/scribe.js-ocr/scrollview-web/scrollview/ui/SVWindow.js"() {
    init_constants2();
    SVWindow = class {
      /**
       * Construct a new SVWindow and set it visible.
       *
       * @param {string} name Title of the window.
       * @param {number} hash Unique internal representation. This has to be the same as
       *        defined by the client, as they use this to refer to the windows.
       * @param {number} posX X position of where to draw the window (upper left).
       * @param {number} posY Y position of where to draw the window (upper left).
       * @param {number} sizeX The width of the window.
       * @param {number} sizeY The height of the window.
       * @param {number} canvasSizeX The canvas width of the window.
       * @param {number} canvasSizeY The canvas height of the window.
       * @param {*} createCanvas
       * @param {boolean} [lightTheme=false] Assume white background instead of black background.
       */
      constructor(name, hash2, posX, posY, sizeX, sizeY, canvasSizeX, canvasSizeY, createCanvas, lightTheme = false) {
        if (sizeX <= 0) sizeX = canvasSizeX;
        if (sizeY <= 0) sizeY = canvasSizeY;
        if (canvasSizeX <= 0) canvasSizeX = sizeX;
        if (canvasSizeY <= 0) canvasSizeY = sizeY;
        if (sizeX <= 0) {
          sizeX = 1;
          canvasSizeX = sizeX;
        }
        if (sizeY <= 0) {
          sizeY = 1;
          canvasSizeY = sizeY;
        }
        this.name = name;
        this.hash = hash2;
        this.currentPenColor = "black";
        this.currentBrushColor = "rgb(0, 0, 0, 0)";
        this.currentFont = "normal 12px Times";
        this.stroke = 2;
        this.penColorsRect = {};
        this.penColorsLine = {};
        this.polylineXCoords = [];
        this.polylineYCoords = [];
        this.polylineSize = 0;
        this.polylineScanned = 0;
        this.canvasSizeX = canvasSizeX;
        this.canvasSizeY = canvasSizeY;
        this.canvas = createCanvas(this.canvasSizeX, this.canvasSizeY);
        this.ctx = /** @type {CanvasRenderingContext2D} */
        this.canvas.getContext("2d");
        this.lightTheme = lightTheme;
      }
      /**
       * Draw a line from (x1, y1) to (x2, y2) using the current pen color and stroke.
       * @param {number} x1 - The x-coordinate of the start point of the line.
       * @param {number} y1 - The y-coordinate of the start point of the line.
       * @param {number} x2 - The x-coordinate of the end point of the line.
       * @param {number} y2 - The y-coordinate of the end point of the line.
       */
      drawLine(x1, y1, x2, y2) {
        this.ctx.beginPath();
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
        this.ctx.strokeStyle = getViewColor(this.currentPenColor, this.lightTheme);
        this.ctx.lineWidth = this.stroke;
        this.penColorsLine[this.currentPenColor] = true;
        this.ctx.stroke();
      }
      /**
       * Draw a rectangle given the two points (x1, y1) and (x2, y2) using the current
       * stroke, pen color for the border, and the brush to fill the interior.
       * @param {number} x1 - The x-coordinate of the first point.
       * @param {number} y1 - The y-coordinate of the first point.
       * @param {number} x2 - The x-coordinate of the opposite point.
       * @param {number} y2 - The y-coordinate of the opposite point.
       */
      drawRectangle(x1, y1, x2, y2) {
        if (x1 > x2) {
          const t2 = x1;
          x1 = x2;
          x2 = t2;
        }
        if (y1 > y2) {
          const t2 = y1;
          y1 = y2;
          y2 = t2;
        }
        this.ctx.strokeStyle = getViewColor(this.currentPenColor, this.lightTheme);
        this.ctx.fillStyle = getViewColor(this.currentBrushColor, this.lightTheme);
        if (!(x1 === 0 && y1 === 0 && x2 === this.canvasSizeX && y2 === this.canvasSizeY)) this.penColorsRect[this.currentPenColor] = true;
        this.ctx.lineWidth = this.stroke;
        this.ctx.beginPath();
        this.ctx.rect(x1, y1, x2 - x1, y2 - y1);
        this.ctx.fill();
        this.ctx.stroke();
      }
      /** Set the pen color to an RGBA value */
      pen(red, green, blue, alpha = 255) {
        this.currentPenColor = `rgba(${red}, ${green}, ${blue}, ${alpha})`;
      }
      /** Set the brush to an RGBA color */
      brush(red, green, blue, alpha = 255) {
        this.currentBrushColor = `rgba(${red}, ${green}, ${blue}, ${alpha})`;
      }
      /**
       * Allows you to specify the thickness with which to draw lines, recantgles
       * and ellipses.
       * @param {number} width The new thickness.
       */
      setStrokeWidth(width) {
        this.stroke = width;
      }
      // createPolyline(...args) {
      //   const func = (new Error()).stack?.split('\n')[1].trim().split(' ')[1] || 'Function ';
      //   console.log(`${func} not implemented.`);
      // }
      /**
       * Start setting up a new polyline.
       * @param {number} length - Number of coordinate pairs.
       */
      createPolyline(length) {
        this.polylineXCoords = new Array(length);
        this.polylineYCoords = new Array(length);
        this.polylineSize = length;
        this.polylineScanned = 0;
      }
      /**
       * Draw the now complete polyline.
       */
      drawPolyline() {
        const numCoords = this.polylineXCoords.length;
        if (numCoords < 2) {
          return;
        }
        this.ctx.beginPath();
        this.ctx.moveTo(this.polylineXCoords[0], this.polylineYCoords[0]);
        for (let p2 = 1; p2 < numCoords; ++p2) {
          this.ctx.lineTo(this.polylineXCoords[p2], this.polylineYCoords[p2]);
        }
        this.ctx.strokeStyle = getViewColor(this.currentPenColor, this.lightTheme);
        this.ctx.lineWidth = this.stroke;
        this.ctx.stroke();
        this.penColorsRect[this.currentPenColor] = true;
        this.polylineSize = 0;
      }
      /**
       * Draw some text at (x, y) using the current pen color and text attributes.
       * @param {number} x - The x-coordinate for the text.
       * @param {number} y - The y-coordinate for the text.
       * @param {string} text - The text to be drawn.
       */
      drawText(x2, y2, text) {
        this.ctx.fillStyle = this.currentPenColor;
        this.ctx.font = this.currentFont;
        this.ctx.fillText(text, x2, y2);
      }
      /**
       * Define how to display text.
       * @param {string} font - The font family.
       * @param {number} pixelSize - The size of the font in pixels.
       * @param {boolean} bold - Whether the font is bold.
       * @param {boolean} italic - Whether the font is italic.
       * @param {boolean} underlined - Whether the font is underlined (currently not supported).
       */
      textAttributes(font, pixelSize, bold, italic, underlined) {
        let fontStyle = "";
        if (italic) {
          fontStyle += "italic ";
        }
        if (bold) {
          fontStyle += "bold ";
        }
        this.currentFont = `${fontStyle} ${pixelSize}px ${font}`;
      }
      setVisible(...args) {
        const func = new Error().stack?.split("\n")[1].trim().split(" ")[1] || "Function ";
        console.log(`${func} not implemented.`);
      }
      setAlwaysOnTop(...args) {
        const func = new Error().stack?.split("\n")[1].trim().split(" ")[1] || "Function ";
        console.log(`${func} not implemented.`);
      }
      addMessage(...args) {
        const func = new Error().stack?.split("\n")[1].trim().split(" ")[1] || "Function ";
        console.log(`${func} not implemented.`);
      }
      addMessageBox(...args) {
        const func = new Error().stack?.split("\n")[1].trim().split(" ")[1] || "Function ";
        console.log(`${func} not implemented.`);
      }
      clear(...args) {
      }
      drawEllipse(...args) {
        const func = new Error().stack?.split("\n")[1].trim().split(" ")[1] || "Function ";
        console.log(`${func} not implemented.`);
      }
      addMenuBarItem(...args) {
        const func = new Error().stack?.split("\n")[1].trim().split(" ")[1] || "Function ";
        console.log(`${func} not implemented.`);
      }
      addPopupMenuItem(...args) {
        const func = new Error().stack?.split("\n")[1].trim().split(" ")[1] || "Function ";
        console.log(`${func} not implemented.`);
      }
      update(...args) {
      }
      showInputDialog(...args) {
        const func = new Error().stack?.split("\n")[1].trim().split(" ")[1] || "Function ";
        console.log(`${func} not implemented.`);
      }
      showYesNoDialog(...args) {
        const func = new Error().stack?.split("\n")[1].trim().split(" ")[1] || "Function ";
        console.log(`${func} not implemented.`);
      }
      zoomRectangle(...args) {
        const func = new Error().stack?.split("\n")[1].trim().split(" ")[1] || "Function ";
        console.log(`${func} not implemented.`);
      }
      /**
       * Draw the image with the given name at (x,y).
       * @param {ImageBitmap} img
       * @param {number} xPos
       * @param {number} yPos
       */
      drawImageInternal(img, xPos, yPos) {
        this.ctx.drawImage(img, xPos, yPos);
      }
      drawImage(...args) {
        const func = new Error().stack?.split("\n")[1].trim().split(" ")[1] || "Function ";
        console.log(`${func} not implemented.`);
      }
      destroy(...args) {
        const func = new Error().stack?.split("\n")[1].trim().split(" ")[1] || "Function ";
        console.log(`${func} not implemented.`);
      }
    };
  }
});

// node_modules/scribe.js-ocr/scrollview-web/scrollview/ScrollView.js
var ScrollView_exports = {};
__export(ScrollView_exports, {
  ScrollView: () => ScrollView
});
var ScrollView;
var init_ScrollView = __esm({
  "node_modules/scribe.js-ocr/scrollview-web/scrollview/ScrollView.js"() {
    init_common();
    init_SVImageHandler();
    init_SVWindow();
    ScrollView = class {
      /**
       *
       * @param {Object} param
       * @param {boolean} [param.lightTheme=false]
       * @param {import('canvaskit-wasm').CanvasKit} [param.CanvasKit] - CanvasKit module. Must be defined if running in Node.js.
       */
      constructor({
        lightTheme = false,
        CanvasKit
      }) {
        if (typeof OffscreenCanvas === "undefined" && !CanvasKit) {
          throw new Error("CanvasKit module must be provided in environments that do not support OffscreenCanvas natively (i.e. Node.js).");
        }
        this.CanvasKit = /** @type {import('canvaskit-wasm').CanvasKit} */
        CanvasKit;
        this.createCanvas = typeof process === "undefined" ? (width, height) => new OffscreenCanvas(width, height) : (width, height) => this.CanvasKit.MakeCanvas(width, height);
        this.lightTheme = lightTheme;
        this.svId = getRandomAlphanum2(10);
      }
      /** @type {Object.<string, SVWindow>} */
      windows = {};
      // Some window names are re-used.  For example, "With Images" may appear multiple times.
      // When multiple windows are created with the same name, a number is appended to make the file names unique.
      nameCount = {};
      /**
       * @typedef {Object} DebugVis
       * @property {*} canvas - Canvas with visualization.
       * @property {*} canvasLegend - Canvas with legend, if requested.
       */
      /**
       *
       * @param {boolean} [createLegend=false] - Whether to create a legend explaining the meaning of each color.
       * @returns
       */
      async getAll(createLegend = false) {
        const outputObj = {};
        for (const [key, value] of Object.entries(this.windows)) {
          const name = this.windows[key].name;
          if (this.nameCount[name] === void 0) this.nameCount[name] = 0;
          this.nameCount[name]++;
          const nameFull = `${name}_${String(this.nameCount[name])}`;
          let canvasLegend;
          let nonemptyLegend = false;
          if (createLegend) {
            canvasLegend = this.createCanvas(200, 200);
            nonemptyLegend = drawColorLegend(canvasLegend, nameFull, this.windows[key].penColorsRect, this.windows[key].penColorsLine, this.lightTheme);
          }
          outputObj[nameFull] = {
            canvas: this.windows[key].canvas,
            canvasLegend: createLegend && nonemptyLegend ? canvasLegend : null
          };
        }
        return outputObj;
      }
      /**
       * Parse a comma-separated list of arguments into arrays of different types.
       * @param {string} argList - The argument list as a string.
       * @param {number[]} intList - Array to store integers.
       * @param {number[]} floatList - Array to store floats.
       * @param {string[]} stringList - Array to store strings.
       * @param {boolean[]} boolList - Array to store booleans.
       */
      static parseArguments(argList, intList, floatList, stringList, boolList) {
        let str = null;
        const intPattern = /^[0-9-][0-9]*$/;
        const floatPattern = /^[0-9-][0-9]*\\.[0-9]*$/;
        argList.split(",").forEach((argStr) => {
          if (str !== null) {
            str += `,${argStr}`;
          } else if (argStr.length === 0) {
            return;
          } else {
            const quote = argStr.charAt(0);
            if (quote === "'" || quote === '"') {
              str = argStr;
            }
          }
          if (str !== null) {
            const quote = str.charAt(0);
            const len = str.length;
            if (len > 1 && str.charAt(len - 1) === quote) {
              let slash = len - 1;
              while (slash > 0 && str.charAt(slash - 1) === "\\") --slash;
              if ((len - 1 - slash) % 2 === 0) {
                stringList.push(str.substring(1, len - 1).replace(/\\(.)/g, "$1"));
                str = null;
              }
            }
          } else if (floatPattern.test(argStr)) {
            floatList.push(parseFloat(argStr));
          } else if (argStr === "true") {
            boolList.push(true);
          } else if (argStr === "false") {
            boolList.push(false);
          } else if (intPattern.test(argStr)) {
            intList.push(parseInt(argStr, 10));
          }
        });
        if (str !== null) {
          throw new Error("Unterminated string");
        }
      }
      /**
       * Split function that replicates Java `split` method behavior,
       * with all text after `limit` being included in the final element.
       *
       * @param {string} string
       * @param {*} pattern
       * @param {*} limit
       */
      static splitJava(string, pattern, limit) {
        let idStrs = string.split(pattern);
        if (idStrs.length > limit) {
          idStrs = idStrs.slice(0, limit - 1).concat(idStrs.slice(limit - 1).join(" "));
        }
        return idStrs;
      }
      imageWaiting = false;
      imageXPos = 0;
      imageYPos = 0;
      windowID = 0;
      /**
       *
       * @param {string} inputLine
       */
      async IOLoop(inputLine) {
        if (!inputLine) return;
        if (this.windows[this.windowID] && this.windows[this.windowID].polylineSize > this.windows[this.windowID].polylineScanned) {
          let first = true;
          for (const coordStr of inputLine.replace(/[,\s]+$/, "").split(",")) {
            const coord = Number.parseInt(coordStr);
            if (first) {
              this.windows[this.windowID].polylineXCoords[this.windows[this.windowID].polylineScanned] = coord;
            } else {
              this.windows[this.windowID].polylineYCoords[this.windows[this.windowID].polylineScanned++] = coord;
            }
            first = !first;
          }
          console.assert(first);
        } else if (this.imageWaiting) {
          const image = await SVImageHandler.readImage(inputLine, this.CanvasKit);
          this.windows[this.windowID].drawImageInternal(image, this.imageXPos, this.imageYPos);
          this.imageWaiting = false;
        } else {
          await this.processInput(inputLine);
        }
      }
      /**
       * Processes a command line input, interpreting and executing it as needed.
       * @param {string} inputLine - The input command line.
       */
      async processInput(inputLine) {
        if (!inputLine) {
          return;
        }
        if (!this.createCanvas) {
          throw new Error("createCanvas method must be defined prior to running processInput.");
        }
        if (inputLine.charAt(0) === "w") {
          const noWLine = inputLine.substring(1);
          const idStrs = this.constructor.splitJava(noWLine, /[ :]/, 2);
          this.windowID = parseInt(idStrs[0], 10);
          const start = inputLine.indexOf("(");
          const end = inputLine.lastIndexOf(")");
          const intList = [];
          const floatList = [];
          const stringList = [];
          const boolList = [];
          this.constructor.parseArguments(inputLine.substring(start + 1, end), intList, floatList, stringList, boolList);
          const colon = inputLine.indexOf(":");
          if (colon > 1 && colon < start) {
            const func = inputLine.substring(colon + 1, start);
            switch (func) {
              case "drawLine":
                this.windows[this.windowID].drawLine(intList[0], intList[1], intList[2], intList[3]);
                break;
              case "createPolyline":
                this.windows[this.windowID].createPolyline(intList[0]);
                break;
              case "drawPolyline":
                this.windows[this.windowID].drawPolyline();
                break;
              case "drawRectangle":
                this.windows[this.windowID].drawRectangle(intList[0], intList[1], intList[2], intList[3]);
                break;
              case "setVisible":
                this.windows[this.windowID].setVisible(boolList[0]);
                break;
              case "setAlwaysOnTop":
                this.windows[this.windowID].setAlwaysOnTop(boolList[0]);
                break;
              case "addMessage":
                this.windows[this.windowID].addMessage(stringList[0]);
                break;
              case "addMessageBox":
                this.windows[this.windowID].addMessageBox();
                break;
              case "clear":
                this.windows[this.windowID].clear();
                break;
              case "setStrokeWidth":
                this.windows[this.windowID].setStrokeWidth(floatList[0]);
                break;
              case "drawEllipse":
                this.windows[this.windowID].drawEllipse(intList[0], intList[1], intList[2], intList[3]);
                break;
              case "pen":
                if (intList.length === 4) {
                  this.windows[this.windowID].pen(intList[0], intList[1], intList[2], intList[3]);
                } else {
                  this.windows[this.windowID].pen(intList[0], intList[1], intList[2]);
                }
                break;
              case "brush":
                if (intList.length === 4) {
                  this.windows[this.windowID].brush(intList[0], intList[1], intList[2], intList[3]);
                } else {
                  this.windows[this.windowID].brush(intList[0], intList[1], intList[2]);
                }
                break;
              case "textAttributes":
                this.windows[this.windowID].textAttributes(stringList[0], intList[0], boolList[0], boolList[1], boolList[2]);
                break;
              case "drawText":
                this.windows[this.windowID].drawText(intList[0], intList[1], stringList[0]);
                break;
              case "addMenuBarItem":
                if (boolList.length > 0) {
                  this.windows[this.windowID].addMenuBarItem(stringList[0], stringList[1], intList[0], boolList[0]);
                } else if (intList.length > 0) {
                  this.windows[this.windowID].addMenuBarItem(stringList[0], stringList[1], intList[0]);
                } else {
                  this.windows[this.windowID].addMenuBarItem(stringList[0], stringList[1]);
                }
                break;
              case "addPopupMenuItem":
                if (stringList.length === 4) {
                  this.windows[this.windowID].addPopupMenuItem(stringList[0], stringList[1], intList[0], stringList[2], stringList[3]);
                } else {
                  this.windows[this.windowID].addPopupMenuItem(stringList[0], stringList[1]);
                }
                break;
              case "update":
                this.windows[this.windowID].update();
                break;
              case "showInputDialog":
                this.windows[this.windowID].showInputDialog(stringList[0]);
                break;
              case "showYesNoDialog":
                this.windows[this.windowID].showYesNoDialog(stringList[0]);
                break;
              case "zoomRectangle":
                this.windows[this.windowID].zoomRectangle(intList[0], intList[1], intList[2], intList[3]);
                break;
              case "readImage":
                this.imageWaiting = true;
                this.imageXPos = intList[0];
                this.imageYPos = intList[1];
                break;
              case "drawImage":
                this.windows[this.windowID].drawImage();
                break;
              case "destroy":
                this.windows[this.windowID].destroy();
                break;
              default:
                console.log(`Unrecognized function call: ${func}`);
                break;
            }
          } else if (idStrs[1].startsWith("= luajava.newInstance")) {
            this.windows[this.windowID] = new SVWindow(
              stringList[1],
              intList[0],
              intList[1],
              intList[2],
              intList[3],
              intList[4],
              intList[5],
              intList[6],
              this.createCanvas,
              this.lightTheme
            );
          }
        }
      }
      queue = [];
      isProcessing = false;
      async processQueue() {
        if (this.isProcessing) return;
        this.isProcessing = true;
        while (this.queue.length > 0) {
          const { args, resolve } = this.queue.shift();
          try {
            const result = await this.IOLoop(...args);
            resolve(result);
          } catch (error) {
            resolve(Promise.reject(error));
          }
        }
        this.isProcessing = false;
      }
      async IOLoopWrapper(...args) {
        return new Promise((resolve, reject) => {
          this.queue.push({ args, resolve, reject });
          this.processQueue();
        });
      }
      /**
       *
       * @param {string} inputStr
       */
      async processVisStr(inputStr) {
        const inputArr = inputStr.split(/[\r\n]+/).filter((x2) => x2);
        for (let i2 = 0; i2 < inputArr.length; i2++) {
          await this.IOLoopWrapper(inputArr[i2]);
        }
      }
    };
  }
});

// node_modules/scribe.js-ocr/js/import/nodeAdapter.js
var nodeAdapter_exports = {};
__export(nodeAdapter_exports, {
  FileNode: () => FileNode,
  wrapFilesNode: () => wrapFilesNode
});
import fs2 from "node:fs";
import path from "node:path";
var FileNode, wrapFilesNode;
var init_nodeAdapter = __esm({
  "node_modules/scribe.js-ocr/js/import/nodeAdapter.js"() {
    FileNode = class {
      /**
       * Creates an instance of the File class.
       * @param {string} filePath - The path to the file.
       * @param {string} name - The name of the file.
       * @param {Buffer} fileData - The file's data.
       */
      constructor(filePath, name, fileData) {
        this.filePath = filePath;
        this.name = name;
        this.fileData = fileData;
      }
      /**
       * Returns an ArrayBuffer with the file's contents.
       * @returns {Promise<ArrayBuffer>} A promise that resolves with the file's contents as an ArrayBuffer.
       */
      async arrayBuffer() {
        return this.fileData.buffer.slice(this.fileData.byteOffset, this.fileData.byteOffset + this.fileData.byteLength);
      }
    };
    wrapFilesNode = (filePaths) => {
      const filePromises = filePaths.map(async (filePath) => {
        const isUrl = filePath.startsWith("http://") || filePath.startsWith("https://") || filePath.startsWith("moz-extension://") || filePath.startsWith("chrome-extension://") || filePath.startsWith("file://");
        const fileData = isUrl ? Buffer.from(await fetch(filePath).then((res) => res.arrayBuffer())) : fs2.readFileSync(filePath);
        const fileName = isUrl ? filePath.split("/").pop() : path.basename(filePath);
        return new FileNode(filePath, fileName, fileData);
      });
      return Promise.all(filePromises);
    };
  }
});

// node_modules/scribe.js-ocr/js/clear.js
init_app();
init_dataContainer();

// node_modules/scribe.js-ocr/lib/opentype.module.js
var e;
var t;
String.prototype.codePointAt || (e = function() {
  try {
    var e3 = {}, t2 = Object.defineProperty, r2 = t2(e3, e3, e3) && t2;
  } catch (e4) {
  }
  return r2;
}(), t = function(e3) {
  if (null == this) throw TypeError();
  var t2 = String(this), r2 = t2.length, n2 = e3 ? Number(e3) : 0;
  if (n2 != n2 && (n2 = 0), !(n2 < 0 || n2 >= r2)) {
    var a2, o2 = t2.charCodeAt(n2);
    return o2 >= 55296 && o2 <= 56319 && r2 > n2 + 1 && (a2 = t2.charCodeAt(n2 + 1)) >= 56320 && a2 <= 57343 ? 1024 * (o2 - 55296) + a2 - 56320 + 65536 : o2;
  }
}, e ? e(String.prototype, "codePointAt", { value: t, configurable: true, writable: true }) : String.prototype.codePointAt = t);
var r = 0;
var n = -3;
function a() {
  this.table = new Uint16Array(16), this.trans = new Uint16Array(288);
}
function o(e3, t2) {
  this.source = e3, this.sourceIndex = 0, this.tag = 0, this.bitcount = 0, this.dest = t2, this.destLen = 0, this.ltree = new a(), this.dtree = new a();
}
var s = new a();
var i = new a();
var u = new Uint8Array(30);
var l = new Uint16Array(30);
var p = new Uint8Array(30);
var c = new Uint16Array(30);
var h = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var f = new a();
var d = new Uint8Array(320);
function v(e3, t2, r2, n2) {
  var a2, o2;
  for (a2 = 0; a2 < r2; ++a2) e3[a2] = 0;
  for (a2 = 0; a2 < 30 - r2; ++a2) e3[a2 + r2] = a2 / r2 | 0;
  for (o2 = n2, a2 = 0; a2 < 30; ++a2) t2[a2] = o2, o2 += 1 << e3[a2];
}
var g = new Uint16Array(16);
function m(e3, t2, r2, n2) {
  var a2, o2;
  for (a2 = 0; a2 < 16; ++a2) e3.table[a2] = 0;
  for (a2 = 0; a2 < n2; ++a2) e3.table[t2[r2 + a2]]++;
  for (e3.table[0] = 0, o2 = 0, a2 = 0; a2 < 16; ++a2) g[a2] = o2, o2 += e3.table[a2];
  for (a2 = 0; a2 < n2; ++a2) t2[r2 + a2] && (e3.trans[g[t2[r2 + a2]]++] = a2);
}
function y(e3) {
  e3.bitcount-- || (e3.tag = e3.source[e3.sourceIndex++], e3.bitcount = 7);
  var t2 = 1 & e3.tag;
  return e3.tag >>>= 1, t2;
}
function b(e3, t2, r2) {
  if (!t2) return r2;
  for (; e3.bitcount < 24; ) e3.tag |= e3.source[e3.sourceIndex++] << e3.bitcount, e3.bitcount += 8;
  var n2 = e3.tag & 65535 >>> 16 - t2;
  return e3.tag >>>= t2, e3.bitcount -= t2, n2 + r2;
}
function S(e3, t2) {
  for (; e3.bitcount < 24; ) e3.tag |= e3.source[e3.sourceIndex++] << e3.bitcount, e3.bitcount += 8;
  var r2 = 0, n2 = 0, a2 = 0, o2 = e3.tag;
  do {
    n2 = 2 * n2 + (1 & o2), o2 >>>= 1, ++a2, r2 += t2.table[a2], n2 -= t2.table[a2];
  } while (n2 >= 0);
  return e3.tag = o2, e3.bitcount -= a2, t2.trans[r2 + n2];
}
function x(e3, t2, r2) {
  var n2, a2, o2, s2, i2, u2;
  for (n2 = b(e3, 5, 257), a2 = b(e3, 5, 1), o2 = b(e3, 4, 4), s2 = 0; s2 < 19; ++s2) d[s2] = 0;
  for (s2 = 0; s2 < o2; ++s2) {
    var l2 = b(e3, 3, 0);
    d[h[s2]] = l2;
  }
  for (m(f, d, 0, 19), i2 = 0; i2 < n2 + a2; ) {
    var p2 = S(e3, f);
    switch (p2) {
      case 16:
        var c2 = d[i2 - 1];
        for (u2 = b(e3, 2, 3); u2; --u2) d[i2++] = c2;
        break;
      case 17:
        for (u2 = b(e3, 3, 3); u2; --u2) d[i2++] = 0;
        break;
      case 18:
        for (u2 = b(e3, 7, 11); u2; --u2) d[i2++] = 0;
        break;
      default:
        d[i2++] = p2;
    }
  }
  m(t2, d, 0, n2), m(r2, d, n2, a2);
}
function T(e3, t2, n2) {
  for (; ; ) {
    var a2, o2, s2, i2, h2 = S(e3, t2);
    if (256 === h2) return r;
    if (h2 < 256) e3.dest[e3.destLen++] = h2;
    else for (a2 = b(e3, u[h2 -= 257], l[h2]), o2 = S(e3, n2), i2 = s2 = e3.destLen - b(e3, p[o2], c[o2]); i2 < s2 + a2; ++i2) e3.dest[e3.destLen++] = e3.dest[i2];
  }
}
function U(e3) {
  for (var t2, a2; e3.bitcount > 8; ) e3.sourceIndex--, e3.bitcount -= 8;
  if ((t2 = 256 * (t2 = e3.source[e3.sourceIndex + 1]) + e3.source[e3.sourceIndex]) !== (65535 & ~(256 * e3.source[e3.sourceIndex + 3] + e3.source[e3.sourceIndex + 2]))) return n;
  for (e3.sourceIndex += 4, a2 = t2; a2; --a2) e3.dest[e3.destLen++] = e3.source[e3.sourceIndex++];
  return e3.bitcount = 0, r;
}
!function(e3, t2) {
  var r2;
  for (r2 = 0; r2 < 7; ++r2) e3.table[r2] = 0;
  for (e3.table[7] = 24, e3.table[8] = 152, e3.table[9] = 112, r2 = 0; r2 < 24; ++r2) e3.trans[r2] = 256 + r2;
  for (r2 = 0; r2 < 144; ++r2) e3.trans[24 + r2] = r2;
  for (r2 = 0; r2 < 8; ++r2) e3.trans[168 + r2] = 280 + r2;
  for (r2 = 0; r2 < 112; ++r2) e3.trans[176 + r2] = 144 + r2;
  for (r2 = 0; r2 < 5; ++r2) t2.table[r2] = 0;
  for (t2.table[5] = 32, r2 = 0; r2 < 32; ++r2) t2.trans[r2] = r2;
}(s, i), v(u, l, 4, 3), v(p, c, 2, 1), u[28] = 0, l[28] = 258;
var k = function(e3, t2) {
  var a2, u2, l2 = new o(e3, t2);
  do {
    switch (a2 = y(l2), b(l2, 2, 0)) {
      case 0:
        u2 = U(l2);
        break;
      case 1:
        u2 = T(l2, s, i);
        break;
      case 2:
        x(l2, l2.ltree, l2.dtree), u2 = T(l2, l2.ltree, l2.dtree);
        break;
      default:
        u2 = n;
    }
    if (u2 !== r) throw new Error("Data error");
  } while (!a2);
  return l2.destLen < l2.dest.length ? "function" == typeof l2.dest.slice ? l2.dest.slice(0, l2.destLen) : l2.dest.subarray(0, l2.destLen) : l2.dest;
};
function O(e3, t2, r2, n2, a2) {
  return Math.pow(1 - a2, 3) * e3 + 3 * Math.pow(1 - a2, 2) * a2 * t2 + 3 * (1 - a2) * Math.pow(a2, 2) * r2 + Math.pow(a2, 3) * n2;
}
function R() {
  this.x1 = Number.NaN, this.y1 = Number.NaN, this.x2 = Number.NaN, this.y2 = Number.NaN;
}
function E() {
  this.commands = [], this.fill = "black", this.stroke = null, this.strokeWidth = 1;
}
function L(e3) {
  throw new Error(e3);
}
function C(e3, t2) {
  e3 || L(t2);
}
R.prototype.isEmpty = function() {
  return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
}, R.prototype.addPoint = function(e3, t2) {
  "number" == typeof e3 && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = e3, this.x2 = e3), e3 < this.x1 && (this.x1 = e3), e3 > this.x2 && (this.x2 = e3)), "number" == typeof t2 && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = t2, this.y2 = t2), t2 < this.y1 && (this.y1 = t2), t2 > this.y2 && (this.y2 = t2));
}, R.prototype.addX = function(e3) {
  this.addPoint(e3, null);
}, R.prototype.addY = function(e3) {
  this.addPoint(null, e3);
}, R.prototype.addBezier = function(e3, t2, r2, n2, a2, o2, s2, i2) {
  var u2 = [e3, t2], l2 = [r2, n2], p2 = [a2, o2], c2 = [s2, i2];
  this.addPoint(e3, t2), this.addPoint(s2, i2);
  for (var h2 = 0; h2 <= 1; h2++) {
    var f2 = 6 * u2[h2] - 12 * l2[h2] + 6 * p2[h2], d2 = -3 * u2[h2] + 9 * l2[h2] - 9 * p2[h2] + 3 * c2[h2], v2 = 3 * l2[h2] - 3 * u2[h2];
    if (0 !== d2) {
      var g2 = Math.pow(f2, 2) - 4 * v2 * d2;
      if (!(g2 < 0)) {
        var m2 = (-f2 + Math.sqrt(g2)) / (2 * d2);
        0 < m2 && m2 < 1 && (0 === h2 && this.addX(O(u2[h2], l2[h2], p2[h2], c2[h2], m2)), 1 === h2 && this.addY(O(u2[h2], l2[h2], p2[h2], c2[h2], m2)));
        var y2 = (-f2 - Math.sqrt(g2)) / (2 * d2);
        0 < y2 && y2 < 1 && (0 === h2 && this.addX(O(u2[h2], l2[h2], p2[h2], c2[h2], y2)), 1 === h2 && this.addY(O(u2[h2], l2[h2], p2[h2], c2[h2], y2)));
      }
    } else {
      if (0 === f2) continue;
      var b2 = -v2 / f2;
      0 < b2 && b2 < 1 && (0 === h2 && this.addX(O(u2[h2], l2[h2], p2[h2], c2[h2], b2)), 1 === h2 && this.addY(O(u2[h2], l2[h2], p2[h2], c2[h2], b2)));
    }
  }
}, R.prototype.addQuad = function(e3, t2, r2, n2, a2, o2) {
  var s2 = e3 + 2 / 3 * (r2 - e3), i2 = t2 + 2 / 3 * (n2 - t2), u2 = s2 + 1 / 3 * (a2 - e3), l2 = i2 + 1 / 3 * (o2 - t2);
  this.addBezier(e3, t2, s2, i2, u2, l2, a2, o2);
}, E.prototype.moveTo = function(e3, t2) {
  this.commands.push({ type: "M", x: e3, y: t2 });
}, E.prototype.lineTo = function(e3, t2) {
  this.commands.push({ type: "L", x: e3, y: t2 });
}, E.prototype.curveTo = E.prototype.bezierCurveTo = function(e3, t2, r2, n2, a2, o2) {
  this.commands.push({ type: "C", x1: e3, y1: t2, x2: r2, y2: n2, x: a2, y: o2 });
}, E.prototype.quadTo = E.prototype.quadraticCurveTo = function(e3, t2, r2, n2) {
  this.commands.push({ type: "Q", x1: e3, y1: t2, x: r2, y: n2 });
}, E.prototype.close = E.prototype.closePath = function() {
  this.commands.push({ type: "Z" });
}, E.prototype.extend = function(e3) {
  if (e3.commands) e3 = e3.commands;
  else if (e3 instanceof R) {
    var t2 = e3;
    return this.moveTo(t2.x1, t2.y1), this.lineTo(t2.x2, t2.y1), this.lineTo(t2.x2, t2.y2), this.lineTo(t2.x1, t2.y2), void this.close();
  }
  Array.prototype.push.apply(this.commands, e3);
}, E.prototype.getBoundingBox = function() {
  for (var e3 = new R(), t2 = 0, r2 = 0, n2 = 0, a2 = 0, o2 = 0; o2 < this.commands.length; o2++) {
    var s2 = this.commands[o2];
    switch (s2.type) {
      case "M":
        e3.addPoint(s2.x, s2.y), t2 = n2 = s2.x, r2 = a2 = s2.y;
        break;
      case "L":
        e3.addPoint(s2.x, s2.y), n2 = s2.x, a2 = s2.y;
        break;
      case "Q":
        e3.addQuad(n2, a2, s2.x1, s2.y1, s2.x, s2.y), n2 = s2.x, a2 = s2.y;
        break;
      case "C":
        e3.addBezier(n2, a2, s2.x1, s2.y1, s2.x2, s2.y2, s2.x, s2.y), n2 = s2.x, a2 = s2.y;
        break;
      case "Z":
        n2 = t2, a2 = r2;
        break;
      default:
        throw new Error("Unexpected path command " + s2.type);
    }
  }
  return e3.isEmpty() && e3.addPoint(0, 0), e3;
}, E.prototype.draw = function(e3) {
  e3.beginPath();
  for (var t2 = 0; t2 < this.commands.length; t2 += 1) {
    var r2 = this.commands[t2];
    "M" === r2.type ? e3.moveTo(r2.x, r2.y) : "L" === r2.type ? e3.lineTo(r2.x, r2.y) : "C" === r2.type ? e3.bezierCurveTo(r2.x1, r2.y1, r2.x2, r2.y2, r2.x, r2.y) : "Q" === r2.type ? e3.quadraticCurveTo(r2.x1, r2.y1, r2.x, r2.y) : "Z" === r2.type && e3.closePath();
  }
  this.fill && (e3.fillStyle = this.fill, e3.fill()), this.stroke && (e3.strokeStyle = this.stroke, e3.lineWidth = this.strokeWidth, e3.stroke());
}, E.prototype.toPathData = function(e3) {
  function t2(t3) {
    return Math.round(t3) === t3 ? "" + Math.round(t3) : t3.toFixed(e3);
  }
  function r2() {
    for (var e4 = arguments, r3 = "", n3 = 0; n3 < arguments.length; n3 += 1) {
      var a3 = e4[n3];
      a3 >= 0 && n3 > 0 && (r3 += " "), r3 += t2(a3);
    }
    return r3;
  }
  e3 = void 0 !== e3 ? e3 : 2;
  for (var n2 = "", a2 = 0; a2 < this.commands.length; a2 += 1) {
    var o2 = this.commands[a2];
    "M" === o2.type ? n2 += "M" + r2(o2.x, o2.y) : "L" === o2.type ? n2 += "L" + r2(o2.x, o2.y) : "C" === o2.type ? n2 += "C" + r2(o2.x1, o2.y1, o2.x2, o2.y2, o2.x, o2.y) : "Q" === o2.type ? n2 += "Q" + r2(o2.x1, o2.y1, o2.x, o2.y) : "Z" === o2.type && (n2 += "Z");
  }
  return n2;
}, E.prototype.toSVG = function(e3) {
  var t2 = '<path d="';
  return t2 += this.toPathData(e3), t2 += '"', this.fill && "black" !== this.fill && (null === this.fill ? t2 += ' fill="none"' : t2 += ' fill="' + this.fill + '"'), this.stroke && (t2 += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"'), t2 += "/>";
}, E.prototype.toDOMElement = function(e3) {
  var t2 = this.toPathData(e3), r2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
  return r2.setAttribute("d", t2), r2;
};
var w = { fail: L, argument: C, assert: C };
var D = 2147483648;
var I = {};
var G = {};
var M = {};
function B(e3) {
  return function() {
    return e3;
  };
}
G.BYTE = function(e3) {
  return w.argument(e3 >= 0 && e3 <= 255, "Byte value should be between 0 and 255."), [e3];
}, M.BYTE = B(1), G.CHAR = function(e3) {
  return [e3.charCodeAt(0)];
}, M.CHAR = B(1), G.CHARARRAY = function(e3) {
  void 0 === e3 && (e3 = "", console.warn("Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name."));
  for (var t2 = [], r2 = 0; r2 < e3.length; r2 += 1) t2[r2] = e3.charCodeAt(r2);
  return t2;
}, M.CHARARRAY = function(e3) {
  return void 0 === e3 ? 0 : e3.length;
}, G.USHORT = function(e3) {
  return [e3 >> 8 & 255, 255 & e3];
}, M.USHORT = B(2), G.SHORT = function(e3) {
  return e3 >= 32768 && (e3 = -(65536 - e3)), [e3 >> 8 & 255, 255 & e3];
}, M.SHORT = B(2), G.UINT24 = function(e3) {
  return [e3 >> 16 & 255, e3 >> 8 & 255, 255 & e3];
}, M.UINT24 = B(3), G.ULONG = function(e3) {
  return [e3 >> 24 & 255, e3 >> 16 & 255, e3 >> 8 & 255, 255 & e3];
}, M.ULONG = B(4), G.LONG = function(e3) {
  return e3 >= D && (e3 = -(2 * D - e3)), [e3 >> 24 & 255, e3 >> 16 & 255, e3 >> 8 & 255, 255 & e3];
}, M.LONG = B(4), G.FIXED = G.ULONG, M.FIXED = M.ULONG, G.FWORD = G.SHORT, M.FWORD = M.SHORT, G.UFWORD = G.USHORT, M.UFWORD = M.USHORT, G.LONGDATETIME = function(e3) {
  return [0, 0, 0, 0, e3 >> 24 & 255, e3 >> 16 & 255, e3 >> 8 & 255, 255 & e3];
}, M.LONGDATETIME = B(8), G.TAG = function(e3) {
  return w.argument(4 === e3.length, "Tag should be exactly 4 ASCII characters."), [e3.charCodeAt(0), e3.charCodeAt(1), e3.charCodeAt(2), e3.charCodeAt(3)];
}, M.TAG = B(4), G.Card8 = G.BYTE, M.Card8 = M.BYTE, G.Card16 = G.USHORT, M.Card16 = M.USHORT, G.OffSize = G.BYTE, M.OffSize = M.BYTE, G.SID = G.USHORT, M.SID = M.USHORT, G.NUMBER = function(e3) {
  return e3 >= -107 && e3 <= 107 ? [e3 + 139] : e3 >= 108 && e3 <= 1131 ? [247 + ((e3 -= 108) >> 8), 255 & e3] : e3 >= -1131 && e3 <= -108 ? [251 + ((e3 = -e3 - 108) >> 8), 255 & e3] : e3 >= -32768 && e3 <= 32767 ? G.NUMBER16(e3) : G.NUMBER32(e3);
}, M.NUMBER = function(e3) {
  return G.NUMBER(e3).length;
}, G.NUMBER16 = function(e3) {
  return [28, e3 >> 8 & 255, 255 & e3];
}, M.NUMBER16 = B(3), G.NUMBER32 = function(e3) {
  return [29, e3 >> 24 & 255, e3 >> 16 & 255, e3 >> 8 & 255, 255 & e3];
}, M.NUMBER32 = B(5), G.REAL = function(e3) {
  var t2 = e3.toString(), r2 = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(t2);
  if (r2) {
    var n2 = parseFloat("1e" + ((r2[2] ? +r2[2] : 0) + r2[1].length));
    t2 = (Math.round(e3 * n2) / n2).toString();
  }
  for (var a2 = "", o2 = 0, s2 = t2.length; o2 < s2; o2 += 1) {
    var i2 = t2[o2];
    a2 += "e" === i2 ? "-" === t2[++o2] ? "c" : "b" : "." === i2 ? "a" : "-" === i2 ? "e" : i2;
  }
  for (var u2 = [30], l2 = 0, p2 = (a2 += 1 & a2.length ? "f" : "ff").length; l2 < p2; l2 += 2) u2.push(parseInt(a2.substr(l2, 2), 16));
  return u2;
}, M.REAL = function(e3) {
  return G.REAL(e3).length;
}, G.NAME = G.CHARARRAY, M.NAME = M.CHARARRAY, G.STRING = G.CHARARRAY, M.STRING = M.CHARARRAY, I.UTF8 = function(e3, t2, r2) {
  for (var n2 = [], a2 = r2, o2 = 0; o2 < a2; o2++, t2 += 1) n2[o2] = e3.getUint8(t2);
  return String.fromCharCode.apply(null, n2);
}, I.UTF16 = function(e3, t2, r2) {
  for (var n2 = [], a2 = r2 / 2, o2 = 0; o2 < a2; o2++, t2 += 2) n2[o2] = e3.getUint16(t2);
  return String.fromCharCode.apply(null, n2);
}, G.UTF16 = function(e3) {
  for (var t2 = [], r2 = 0; r2 < e3.length; r2 += 1) {
    var n2 = e3.charCodeAt(r2);
    t2[t2.length] = n2 >> 8 & 255, t2[t2.length] = 255 & n2;
  }
  return t2;
}, M.UTF16 = function(e3) {
  return 2 * e3.length;
};
var F = { "x-mac-croatian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u03A9\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uF8FF\xA9\u2044\u20AC\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7", "x-mac-cyrillic": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\u0490\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E", "x-mac-gaelic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u1E02\xB1\u2264\u2265\u1E03\u010A\u010B\u1E0A\u1E0B\u1E1E\u1E1F\u0120\u0121\u1E40\xE6\xF8\u1E41\u1E56\u1E57\u027C\u0192\u017F\u1E60\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\u1E61\u1E9B\xFF\u0178\u1E6A\u20AC\u2039\u203A\u0176\u0177\u1E6B\xB7\u1EF2\u1EF3\u204A\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u2663\xD2\xDA\xDB\xD9\u0131\xDD\xFD\u0174\u0175\u1E84\u1E85\u1E80\u1E81\u1E82\u1E83", "x-mac-greek": "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\u20AC\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\xB7\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\xAD", "x-mac-icelandic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7", "x-mac-inuit": "\u1403\u1404\u1405\u1406\u140A\u140B\u1431\u1432\u1433\u1434\u1438\u1439\u1449\u144E\u144F\u1450\u1451\u1455\u1456\u1466\u146D\u146E\u146F\u1470\u1472\u1473\u1483\u148B\u148C\u148D\u148E\u1490\u1491\xB0\u14A1\u14A5\u14A6\u2022\xB6\u14A7\xAE\xA9\u2122\u14A8\u14AA\u14AB\u14BB\u14C2\u14C3\u14C4\u14C5\u14C7\u14C8\u14D0\u14EF\u14F0\u14F1\u14F2\u14F4\u14F5\u1505\u14D5\u14D6\u14D7\u14D8\u14DA\u14DB\u14EA\u1528\u1529\u152A\u152B\u152D\u2026\xA0\u152E\u153E\u1555\u1556\u1557\u2013\u2014\u201C\u201D\u2018\u2019\u1558\u1559\u155A\u155D\u1546\u1547\u1548\u1549\u154B\u154C\u1550\u157F\u1580\u1581\u1582\u1583\u1584\u1585\u158F\u1590\u1591\u1592\u1593\u1594\u1595\u1671\u1672\u1673\u1674\u1675\u1676\u1596\u15A0\u15A1\u15A2\u15A3\u15A4\u15A5\u15A6\u157C\u0141\u0142", "x-mac-ce": "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026\xA0\u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7", macintosh: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7", "x-mac-romanian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u0218\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\u0103\u0219\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\u021A\u021B\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7", "x-mac-turkish": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\uF8A0\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7" };
I.MACSTRING = function(e3, t2, r2, n2) {
  var a2 = F[n2];
  if (void 0 !== a2) {
    for (var o2 = "", s2 = 0; s2 < r2; s2++) {
      var i2 = e3.getUint8(t2 + s2);
      o2 += i2 <= 127 ? String.fromCharCode(i2) : a2[127 & i2];
    }
    return o2;
  }
};
var P;
var A = "function" == typeof WeakMap && /* @__PURE__ */ new WeakMap();
function N(e3) {
  return e3 >= -128 && e3 <= 127;
}
function H(e3, t2, r2) {
  for (var n2 = 0, a2 = e3.length; t2 < a2 && n2 < 64 && 0 === e3[t2]; ) ++t2, ++n2;
  return r2.push(128 | n2 - 1), t2;
}
function z(e3, t2, r2) {
  for (var n2 = 0, a2 = e3.length, o2 = t2; o2 < a2 && n2 < 64; ) {
    var s2 = e3[o2];
    if (!N(s2)) break;
    if (0 === s2 && o2 + 1 < a2 && 0 === e3[o2 + 1]) break;
    ++o2, ++n2;
  }
  r2.push(n2 - 1);
  for (var i2 = t2; i2 < o2; ++i2) r2.push(e3[i2] + 256 & 255);
  return o2;
}
function W(e3, t2, r2) {
  for (var n2 = 0, a2 = e3.length, o2 = t2; o2 < a2 && n2 < 64; ) {
    var s2 = e3[o2];
    if (0 === s2) break;
    if (N(s2) && o2 + 1 < a2 && N(e3[o2 + 1])) break;
    ++o2, ++n2;
  }
  r2.push(64 | n2 - 1);
  for (var i2 = t2; i2 < o2; ++i2) {
    var u2 = e3[i2];
    r2.push(u2 + 65536 >> 8 & 255, u2 + 256 & 255);
  }
  return o2;
}
G.MACSTRING = function(e3, t2) {
  var r2 = function(e4) {
    if (!P) for (var t3 in P = {}, F) P[t3] = new String(t3);
    var r3 = P[e4];
    if (void 0 !== r3) {
      if (A) {
        var n3 = A.get(r3);
        if (void 0 !== n3) return n3;
      }
      var a3 = F[e4];
      if (void 0 !== a3) {
        for (var o3 = {}, s2 = 0; s2 < a3.length; s2++) o3[a3.charCodeAt(s2)] = s2 + 128;
        return A && A.set(r3, o3), o3;
      }
    }
  }(t2);
  if (void 0 !== r2) {
    for (var n2 = [], a2 = 0; a2 < e3.length; a2++) {
      var o2 = e3.charCodeAt(a2);
      if (o2 >= 128 && void 0 === (o2 = r2[o2])) return;
      n2[a2] = o2;
    }
    return n2;
  }
}, M.MACSTRING = function(e3, t2) {
  var r2 = G.MACSTRING(e3, t2);
  return void 0 !== r2 ? r2.length : 0;
}, G.VARDELTAS = function(e3) {
  for (var t2 = 0, r2 = []; t2 < e3.length; ) {
    var n2 = e3[t2];
    t2 = 0 === n2 ? H(e3, t2, r2) : n2 >= -128 && n2 <= 127 ? z(e3, t2, r2) : W(e3, t2, r2);
  }
  return r2;
}, G.INDEX = function(e3) {
  for (var t2 = 1, r2 = [t2], n2 = [], a2 = 0; a2 < e3.length; a2 += 1) {
    var o2 = G.OBJECT(e3[a2]);
    Array.prototype.push.apply(n2, o2), t2 += o2.length, r2.push(t2);
  }
  if (0 === n2.length) return [0, 0];
  for (var s2 = [], i2 = 1 + Math.floor(Math.log(t2) / Math.log(2)) / 8 | 0, u2 = [void 0, G.BYTE, G.USHORT, G.UINT24, G.ULONG][i2], l2 = 0; l2 < r2.length; l2 += 1) {
    var p2 = u2(r2[l2]);
    Array.prototype.push.apply(s2, p2);
  }
  return Array.prototype.concat(G.Card16(e3.length), G.OffSize(i2), s2, n2);
}, M.INDEX = function(e3) {
  return G.INDEX(e3).length;
}, G.DICT = function(e3) {
  for (var t2 = [], r2 = Object.keys(e3), n2 = r2.length, a2 = 0; a2 < n2; a2 += 1) {
    for (var o2 = parseInt(r2[a2], 0), s2 = e3[o2], i2 = G.OPERAND(s2.value, s2.type), u2 = G.OPERATOR(o2), l2 = 0; l2 < i2.length; l2++) t2.push(i2[l2]);
    for (var p2 = 0; p2 < u2.length; p2++) t2.push(u2[p2]);
  }
  return t2;
}, M.DICT = function(e3) {
  return G.DICT(e3).length;
}, G.OPERATOR = function(e3) {
  return e3 < 1200 ? [e3] : [12, e3 - 1200];
}, G.OPERAND = function(e3, t2) {
  var r2 = [];
  if (Array.isArray(t2)) for (var n2 = 0; n2 < t2.length; n2 += 1) {
    w.argument(e3.length === t2.length, "Not enough arguments given for type" + t2);
    for (var a2 = G.OPERAND(e3[n2], t2[n2]), o2 = 0; o2 < a2.length; o2++) r2.push(a2[o2]);
  }
  else if ("SID" === t2) for (var s2 = G.NUMBER(e3), i2 = 0; i2 < s2.length; i2++) r2.push(s2[i2]);
  else if ("offset" === t2) for (var u2 = G.NUMBER32(e3), l2 = 0; l2 < u2.length; l2++) r2.push(u2[l2]);
  else if ("number" === t2) for (var p2 = G.NUMBER(e3), c2 = 0; c2 < p2.length; c2++) r2.push(p2[c2]);
  else {
    if ("real" !== t2) throw new Error("Unknown operand type " + t2);
    for (var h2 = G.REAL(e3), f2 = 0; f2 < h2.length; f2++) r2.push(h2[f2]);
  }
  return r2;
}, G.OP = G.BYTE, M.OP = M.BYTE;
var q = "function" == typeof WeakMap && /* @__PURE__ */ new WeakMap();
function _(e3, t2, r2) {
  if (t2.length && ("coverageFormat" !== t2[0].name || 1 === t2[0].value)) for (var n2 = 0; n2 < t2.length; n2 += 1) {
    var a2 = t2[n2];
    this[a2.name] = a2.value;
  }
  if (this.tableName = e3, this.fields = t2, r2) for (var o2 = Object.keys(r2), s2 = 0; s2 < o2.length; s2 += 1) {
    var i2 = o2[s2], u2 = r2[i2];
    void 0 !== this[i2] && (this[i2] = u2);
  }
}
function X(e3, t2, r2) {
  void 0 === r2 && (r2 = t2.length);
  var n2 = new Array(t2.length + 1);
  n2[0] = { name: e3 + "Count", type: "USHORT", value: r2 };
  for (var a2 = 0; a2 < t2.length; a2++) n2[a2 + 1] = { name: e3 + a2, type: "USHORT", value: t2[a2] };
  return n2;
}
function V(e3, t2, r2) {
  var n2 = t2.length, a2 = new Array(n2 + 1);
  a2[0] = { name: e3 + "Count", type: "USHORT", value: n2 };
  for (var o2 = 0; o2 < n2; o2++) a2[o2 + 1] = { name: e3 + o2, type: "TABLE", value: r2(t2[o2], o2) };
  return a2;
}
function j(e3, t2, r2) {
  var n2 = t2.length, a2 = [];
  a2[0] = { name: e3 + "Count", type: "USHORT", value: n2 };
  for (var o2 = 0; o2 < n2; o2++) a2 = a2.concat(r2(t2[o2], o2));
  return a2;
}
function Y(e3) {
  1 === e3.format ? _.call(this, "coverageTable", [{ name: "coverageFormat", type: "USHORT", value: 1 }].concat(X("glyph", e3.glyphs))) : 2 === e3.format ? _.call(this, "coverageTable", [{ name: "coverageFormat", type: "USHORT", value: 2 }].concat(j("rangeRecord", e3.ranges, function(e4) {
    return [{ name: "startGlyphID", type: "USHORT", value: e4.start }, { name: "endGlyphID", type: "USHORT", value: e4.end }, { name: "startCoverageIndex", type: "USHORT", value: e4.index }];
  }))) : w.assert(false, "Coverage format must be 1 or 2.");
}
function Z(e3) {
  _.call(this, "scriptListTable", j("scriptRecord", e3, function(e4, t2) {
    var r2 = e4.script, n2 = r2.defaultLangSys;
    return w.assert(!!n2, "Unable to write GSUB: script " + e4.tag + " has no default language system."), [{ name: "scriptTag" + t2, type: "TAG", value: e4.tag }, { name: "script" + t2, type: "TABLE", value: new _("scriptTable", [{ name: "defaultLangSys", type: "TABLE", value: new _("defaultLangSys", [{ name: "lookupOrder", type: "USHORT", value: 0 }, { name: "reqFeatureIndex", type: "USHORT", value: n2.reqFeatureIndex }].concat(X("featureIndex", n2.featureIndexes))) }].concat(j("langSys", r2.langSysRecords, function(e5, t3) {
      var r3 = e5.langSys;
      return [{ name: "langSysTag" + t3, type: "TAG", value: e5.tag }, { name: "langSys" + t3, type: "TABLE", value: new _("langSys", [{ name: "lookupOrder", type: "USHORT", value: 0 }, { name: "reqFeatureIndex", type: "USHORT", value: r3.reqFeatureIndex }].concat(X("featureIndex", r3.featureIndexes))) }];
    }))) }];
  }));
}
function Q(e3) {
  _.call(this, "featureListTable", j("featureRecord", e3, function(e4, t2) {
    var r2 = e4.feature;
    return [{ name: "featureTag" + t2, type: "TAG", value: e4.tag }, { name: "feature" + t2, type: "TABLE", value: new _("featureTable", [{ name: "featureParams", type: "USHORT", value: r2.featureParams }].concat(X("lookupListIndex", r2.lookupListIndexes))) }];
  }));
}
function K(e3, t2) {
  _.call(this, "lookupListTable", V("lookup", e3, function(e4) {
    var r2 = t2[e4.lookupType];
    return w.assert(!!r2, "Unable to write GSUB lookup type " + e4.lookupType + " tables."), new _("lookupTable", [{ name: "lookupType", type: "USHORT", value: e4.lookupType }, { name: "lookupFlag", type: "USHORT", value: e4.lookupFlag }].concat(V("subtable", e4.subtables, r2)));
  }));
}
G.CHARSTRING = function(e3) {
  if (q) {
    var t2 = q.get(e3);
    if (void 0 !== t2) return t2;
  }
  for (var r2 = [], n2 = e3.length, a2 = 0; a2 < n2; a2 += 1) for (var o2 = e3[a2], s2 = G[o2.type](o2.value), i2 = 0; i2 < s2.length; i2++) r2.push(s2[i2]);
  return q && q.set(e3, r2), r2;
}, M.CHARSTRING = function(e3) {
  return G.CHARSTRING(e3).length;
}, G.OBJECT = function(e3) {
  var t2 = G[e3.type];
  return w.argument(void 0 !== t2, "No encoding function for type " + e3.type), t2(e3.value);
}, M.OBJECT = function(e3) {
  var t2 = M[e3.type];
  return w.argument(void 0 !== t2, "No sizeOf function for type " + e3.type), t2(e3.value);
}, G.TABLE = function(e3) {
  for (var t2 = [], r2 = e3.fields.length, n2 = [], a2 = [], o2 = 0; o2 < r2; o2 += 1) {
    var s2 = e3.fields[o2], i2 = G[s2.type];
    w.argument(void 0 !== i2, "No encoding function for field type " + s2.type + " (" + s2.name + ")");
    var u2 = e3[s2.name];
    void 0 === u2 && (u2 = s2.value);
    var l2 = i2(u2);
    if ("TABLE" === s2.type) a2.push(t2.length), t2.push(0, 0), n2.push(l2);
    else for (var p2 = 0; p2 < l2.length; p2++) t2.push(l2[p2]);
  }
  for (var c2 = 0; c2 < n2.length; c2 += 1) {
    var h2 = a2[c2], f2 = t2.length;
    w.argument(f2 < 65536, "Table " + e3.tableName + " too big."), t2[h2] = f2 >> 8, t2[h2 + 1] = 255 & f2;
    for (var d2 = 0; d2 < n2[c2].length; d2++) t2.push(n2[c2][d2]);
  }
  return t2;
}, M.TABLE = function(e3) {
  for (var t2 = 0, r2 = e3.fields.length, n2 = 0; n2 < r2; n2 += 1) {
    var a2 = e3.fields[n2], o2 = M[a2.type];
    w.argument(void 0 !== o2, "No sizeOf function for field type " + a2.type + " (" + a2.name + ")");
    var s2 = e3[a2.name];
    void 0 === s2 && (s2 = a2.value), t2 += o2(s2), "TABLE" === a2.type && (t2 += 2);
  }
  return t2;
}, G.RECORD = G.TABLE, M.RECORD = M.TABLE, G.LITERAL = function(e3) {
  return e3;
}, M.LITERAL = function(e3) {
  return e3.length;
}, _.prototype.encode = function() {
  return G.TABLE(this);
}, _.prototype.sizeOf = function() {
  return M.TABLE(this);
}, Y.prototype = Object.create(_.prototype), Y.prototype.constructor = Y, Z.prototype = Object.create(_.prototype), Z.prototype.constructor = Z, Q.prototype = Object.create(_.prototype), Q.prototype.constructor = Q, K.prototype = Object.create(_.prototype), K.prototype.constructor = K;
var J = { Table: _, Record: _, Coverage: Y, ScriptList: Z, FeatureList: Q, LookupList: K, ushortList: X, tableList: V, recordList: j };
function $(e3, t2) {
  return e3.getUint8(t2);
}
function ee(e3, t2) {
  return e3.getUint16(t2, false);
}
function te(e3, t2) {
  return e3.getUint32(t2, false);
}
function re(e3, t2) {
  return e3.getInt16(t2, false) + e3.getUint16(t2 + 2, false) / 65535;
}
var ne = { byte: 1, uShort: 2, short: 2, uLong: 4, fixed: 4, longDateTime: 8, tag: 4 };
function ae(e3, t2) {
  this.data = e3, this.offset = t2, this.relativeOffset = 0;
}
ae.prototype.parseByte = function() {
  var e3 = this.data.getUint8(this.offset + this.relativeOffset);
  return this.relativeOffset += 1, e3;
}, ae.prototype.parseChar = function() {
  var e3 = this.data.getInt8(this.offset + this.relativeOffset);
  return this.relativeOffset += 1, e3;
}, ae.prototype.parseCard8 = ae.prototype.parseByte, ae.prototype.parseUShort = function() {
  var e3 = this.data.getUint16(this.offset + this.relativeOffset);
  return this.relativeOffset += 2, e3;
}, ae.prototype.parseCard16 = ae.prototype.parseUShort, ae.prototype.parseSID = ae.prototype.parseUShort, ae.prototype.parseOffset16 = ae.prototype.parseUShort, ae.prototype.parseShort = function() {
  var e3 = this.data.getInt16(this.offset + this.relativeOffset);
  return this.relativeOffset += 2, e3;
}, ae.prototype.parseF2Dot14 = function() {
  var e3 = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
  return this.relativeOffset += 2, e3;
}, ae.prototype.parseULong = function() {
  var e3 = te(this.data, this.offset + this.relativeOffset);
  return this.relativeOffset += 4, e3;
}, ae.prototype.parseOffset32 = ae.prototype.parseULong, ae.prototype.parseFixed = function() {
  var e3 = re(this.data, this.offset + this.relativeOffset);
  return this.relativeOffset += 4, e3;
}, ae.prototype.parseString = function(e3) {
  var t2 = this.data, r2 = this.offset + this.relativeOffset, n2 = "";
  this.relativeOffset += e3;
  for (var a2 = 0; a2 < e3; a2++) n2 += String.fromCharCode(t2.getUint8(r2 + a2));
  return n2;
}, ae.prototype.parseTag = function() {
  return this.parseString(4);
}, ae.prototype.parseLongDateTime = function() {
  var e3 = te(this.data, this.offset + this.relativeOffset + 4);
  return e3 -= 2082844800, this.relativeOffset += 8, e3;
}, ae.prototype.parseVersion = function(e3) {
  var t2 = ee(this.data, this.offset + this.relativeOffset), r2 = ee(this.data, this.offset + this.relativeOffset + 2);
  return this.relativeOffset += 4, void 0 === e3 && (e3 = 4096), t2 + r2 / e3 / 10;
}, ae.prototype.skip = function(e3, t2) {
  void 0 === t2 && (t2 = 1), this.relativeOffset += ne[e3] * t2;
}, ae.prototype.parseULongList = function(e3) {
  void 0 === e3 && (e3 = this.parseULong());
  for (var t2 = new Array(e3), r2 = this.data, n2 = this.offset + this.relativeOffset, a2 = 0; a2 < e3; a2++) t2[a2] = r2.getUint32(n2), n2 += 4;
  return this.relativeOffset += 4 * e3, t2;
}, ae.prototype.parseOffset16List = ae.prototype.parseUShortList = function(e3) {
  void 0 === e3 && (e3 = this.parseUShort());
  for (var t2 = new Array(e3), r2 = this.data, n2 = this.offset + this.relativeOffset, a2 = 0; a2 < e3; a2++) t2[a2] = r2.getUint16(n2), n2 += 2;
  return this.relativeOffset += 2 * e3, t2;
}, ae.prototype.parseShortList = function(e3) {
  for (var t2 = new Array(e3), r2 = this.data, n2 = this.offset + this.relativeOffset, a2 = 0; a2 < e3; a2++) t2[a2] = r2.getInt16(n2), n2 += 2;
  return this.relativeOffset += 2 * e3, t2;
}, ae.prototype.parseByteList = function(e3) {
  for (var t2 = new Array(e3), r2 = this.data, n2 = this.offset + this.relativeOffset, a2 = 0; a2 < e3; a2++) t2[a2] = r2.getUint8(n2++);
  return this.relativeOffset += e3, t2;
}, ae.prototype.parseList = function(e3, t2) {
  t2 || (t2 = e3, e3 = this.parseUShort());
  for (var r2 = new Array(e3), n2 = 0; n2 < e3; n2++) r2[n2] = t2.call(this);
  return r2;
}, ae.prototype.parseList32 = function(e3, t2) {
  t2 || (t2 = e3, e3 = this.parseULong());
  for (var r2 = new Array(e3), n2 = 0; n2 < e3; n2++) r2[n2] = t2.call(this);
  return r2;
}, ae.prototype.parseRecordList = function(e3, t2) {
  t2 || (t2 = e3, e3 = this.parseUShort());
  for (var r2 = new Array(e3), n2 = Object.keys(t2), a2 = 0; a2 < e3; a2++) {
    for (var o2 = {}, s2 = 0; s2 < n2.length; s2++) {
      var i2 = n2[s2], u2 = t2[i2];
      o2[i2] = u2.call(this);
    }
    r2[a2] = o2;
  }
  return r2;
}, ae.prototype.parseRecordList32 = function(e3, t2) {
  t2 || (t2 = e3, e3 = this.parseULong());
  for (var r2 = new Array(e3), n2 = Object.keys(t2), a2 = 0; a2 < e3; a2++) {
    for (var o2 = {}, s2 = 0; s2 < n2.length; s2++) {
      var i2 = n2[s2], u2 = t2[i2];
      o2[i2] = u2.call(this);
    }
    r2[a2] = o2;
  }
  return r2;
}, ae.prototype.parseStruct = function(e3) {
  if ("function" == typeof e3) return e3.call(this);
  for (var t2 = Object.keys(e3), r2 = {}, n2 = 0; n2 < t2.length; n2++) {
    var a2 = t2[n2], o2 = e3[a2];
    r2[a2] = o2.call(this);
  }
  return r2;
}, ae.prototype.parseValueRecord = function(e3) {
  if (void 0 === e3 && (e3 = this.parseUShort()), 0 !== e3) {
    var t2 = {};
    return 1 & e3 && (t2.xPlacement = this.parseShort()), 2 & e3 && (t2.yPlacement = this.parseShort()), 4 & e3 && (t2.xAdvance = this.parseShort()), 8 & e3 && (t2.yAdvance = this.parseShort()), 16 & e3 && (t2.xPlaDevice = void 0, this.parseShort()), 32 & e3 && (t2.yPlaDevice = void 0, this.parseShort()), 64 & e3 && (t2.xAdvDevice = void 0, this.parseShort()), 128 & e3 && (t2.yAdvDevice = void 0, this.parseShort()), t2;
  }
}, ae.prototype.parseValueRecordList = function() {
  for (var e3 = this.parseUShort(), t2 = this.parseUShort(), r2 = new Array(t2), n2 = 0; n2 < t2; n2++) r2[n2] = this.parseValueRecord(e3);
  return r2;
}, ae.prototype.parsePointer = function(e3) {
  var t2 = this.parseOffset16();
  if (t2 > 0) return new ae(this.data, this.offset + t2).parseStruct(e3);
}, ae.prototype.parsePointer32 = function(e3) {
  var t2 = this.parseOffset32();
  if (t2 > 0) return new ae(this.data, this.offset + t2).parseStruct(e3);
}, ae.prototype.parseListOfLists = function(e3) {
  for (var t2 = this.parseOffset16List(), r2 = t2.length, n2 = this.relativeOffset, a2 = new Array(r2), o2 = 0; o2 < r2; o2++) {
    var s2 = t2[o2];
    if (0 !== s2) if (this.relativeOffset = s2, e3) {
      for (var i2 = this.parseOffset16List(), u2 = new Array(i2.length), l2 = 0; l2 < i2.length; l2++) this.relativeOffset = s2 + i2[l2], u2[l2] = e3.call(this);
      a2[o2] = u2;
    } else a2[o2] = this.parseUShortList();
    else a2[o2] = void 0;
  }
  return this.relativeOffset = n2, a2;
}, ae.prototype.parseCoverage = function() {
  var e3 = this.offset + this.relativeOffset, t2 = this.parseUShort(), r2 = this.parseUShort();
  if (1 === t2) return { format: 1, glyphs: this.parseUShortList(r2) };
  if (2 === t2) {
    for (var n2 = new Array(r2), a2 = 0; a2 < r2; a2++) n2[a2] = { start: this.parseUShort(), end: this.parseUShort(), index: this.parseUShort() };
    return { format: 2, ranges: n2 };
  }
  throw new Error("0x" + e3.toString(16) + ": Coverage format must be 1 or 2.");
}, ae.prototype.parseClassDef = function() {
  var e3 = this.offset + this.relativeOffset, t2 = this.parseUShort();
  if (1 === t2) return { format: 1, startGlyph: this.parseUShort(), classes: this.parseUShortList() };
  if (2 === t2) return { format: 2, ranges: this.parseRecordList({ start: ae.uShort, end: ae.uShort, classId: ae.uShort }) };
  throw new Error("0x" + e3.toString(16) + ": ClassDef format must be 1 or 2.");
}, ae.list = function(e3, t2) {
  return function() {
    return this.parseList(e3, t2);
  };
}, ae.list32 = function(e3, t2) {
  return function() {
    return this.parseList32(e3, t2);
  };
}, ae.recordList = function(e3, t2) {
  return function() {
    return this.parseRecordList(e3, t2);
  };
}, ae.recordList32 = function(e3, t2) {
  return function() {
    return this.parseRecordList32(e3, t2);
  };
}, ae.pointer = function(e3) {
  return function() {
    return this.parsePointer(e3);
  };
}, ae.pointer32 = function(e3) {
  return function() {
    return this.parsePointer32(e3);
  };
}, ae.tag = ae.prototype.parseTag, ae.byte = ae.prototype.parseByte, ae.uShort = ae.offset16 = ae.prototype.parseUShort, ae.uShortList = ae.prototype.parseUShortList, ae.uLong = ae.offset32 = ae.prototype.parseULong, ae.uLongList = ae.prototype.parseULongList, ae.struct = ae.prototype.parseStruct, ae.coverage = ae.prototype.parseCoverage, ae.classDef = ae.prototype.parseClassDef;
var oe = { reserved: ae.uShort, reqFeatureIndex: ae.uShort, featureIndexes: ae.uShortList };
ae.prototype.parseScriptList = function() {
  return this.parsePointer(ae.recordList({ tag: ae.tag, script: ae.pointer({ defaultLangSys: ae.pointer(oe), langSysRecords: ae.recordList({ tag: ae.tag, langSys: ae.pointer(oe) }) }) })) || [];
}, ae.prototype.parseFeatureList = function() {
  return this.parsePointer(ae.recordList({ tag: ae.tag, feature: ae.pointer({ featureParams: ae.offset16, lookupListIndexes: ae.uShortList }) })) || [];
}, ae.prototype.parseLookupList = function(e3) {
  return this.parsePointer(ae.list(ae.pointer(function() {
    var t2 = this.parseUShort();
    w.argument(1 <= t2 && t2 <= 9, "GPOS/GSUB lookup type " + t2 + " unknown.");
    var r2 = this.parseUShort(), n2 = 16 & r2;
    return { lookupType: t2, lookupFlag: r2, subtables: this.parseList(ae.pointer(e3[t2])), markFilteringSet: n2 ? this.parseUShort() : void 0 };
  }))) || [];
}, ae.prototype.parseFeatureVariationsList = function() {
  return this.parsePointer32(function() {
    var e3 = this.parseUShort(), t2 = this.parseUShort();
    return w.argument(1 === e3 && t2 < 1, "GPOS/GSUB feature variations table unknown."), this.parseRecordList32({ conditionSetOffset: ae.offset32, featureTableSubstitutionOffset: ae.offset32 });
  }) || [];
};
var se = { getByte: $, getCard8: $, getUShort: ee, getCard16: ee, getShort: function(e3, t2) {
  return e3.getInt16(t2, false);
}, getULong: te, getFixed: re, getTag: function(e3, t2) {
  for (var r2 = "", n2 = t2; n2 < t2 + 4; n2 += 1) r2 += String.fromCharCode(e3.getInt8(n2));
  return r2;
}, getOffset: function(e3, t2, r2) {
  for (var n2 = 0, a2 = 0; a2 < r2; a2 += 1) n2 <<= 8, n2 += e3.getUint8(t2 + a2);
  return n2;
}, getBytes: function(e3, t2, r2) {
  for (var n2 = [], a2 = t2; a2 < r2; a2 += 1) n2.push(e3.getUint8(a2));
  return n2;
}, bytesToString: function(e3) {
  for (var t2 = "", r2 = 0; r2 < e3.length; r2 += 1) t2 += String.fromCharCode(e3[r2]);
  return t2;
}, Parser: ae };
var ie = ["copyright", "fontFamily", "fontSubfamily", "uniqueID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "manufacturerURL", "designerURL", "license", "licenseURL", "reserved", "preferredFamily", "preferredSubfamily", "compatibleFullName", "sampleText", "postScriptFindFontName", "wwsFamily", "wwsSubfamily"];
var ue = { 0: "en", 1: "fr", 2: "de", 3: "it", 4: "nl", 5: "sv", 6: "es", 7: "da", 8: "pt", 9: "no", 10: "he", 11: "ja", 12: "ar", 13: "fi", 14: "el", 15: "is", 16: "mt", 17: "tr", 18: "hr", 19: "zh-Hant", 20: "ur", 21: "hi", 22: "th", 23: "ko", 24: "lt", 25: "pl", 26: "hu", 27: "es", 28: "lv", 29: "se", 30: "fo", 31: "fa", 32: "ru", 33: "zh", 34: "nl-BE", 35: "ga", 36: "sq", 37: "ro", 38: "cz", 39: "sk", 40: "si", 41: "yi", 42: "sr", 43: "mk", 44: "bg", 45: "uk", 46: "be", 47: "uz", 48: "kk", 49: "az-Cyrl", 50: "az-Arab", 51: "hy", 52: "ka", 53: "mo", 54: "ky", 55: "tg", 56: "tk", 57: "mn-CN", 58: "mn", 59: "ps", 60: "ks", 61: "ku", 62: "sd", 63: "bo", 64: "ne", 65: "sa", 66: "mr", 67: "bn", 68: "as", 69: "gu", 70: "pa", 71: "or", 72: "ml", 73: "kn", 74: "ta", 75: "te", 76: "si", 77: "my", 78: "km", 79: "lo", 80: "vi", 81: "id", 82: "tl", 83: "ms", 84: "ms-Arab", 85: "am", 86: "ti", 87: "om", 88: "so", 89: "sw", 90: "rw", 91: "rn", 92: "ny", 93: "mg", 94: "eo", 128: "cy", 129: "eu", 130: "ca", 131: "la", 132: "qu", 133: "gn", 134: "ay", 135: "tt", 136: "ug", 137: "dz", 138: "jv", 139: "su", 140: "gl", 141: "af", 142: "br", 143: "iu", 144: "gd", 145: "gv", 146: "ga", 147: "to", 148: "el-polyton", 149: "kl", 150: "az", 151: "nn" };
var le = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 5, 11: 1, 12: 4, 13: 0, 14: 6, 15: 0, 16: 0, 17: 0, 18: 0, 19: 2, 20: 4, 21: 9, 22: 21, 23: 3, 24: 29, 25: 29, 26: 29, 27: 29, 28: 29, 29: 0, 30: 0, 31: 4, 32: 7, 33: 25, 34: 0, 35: 0, 36: 0, 37: 0, 38: 29, 39: 29, 40: 0, 41: 5, 42: 7, 43: 7, 44: 7, 45: 7, 46: 7, 47: 7, 48: 7, 49: 7, 50: 4, 51: 24, 52: 23, 53: 7, 54: 7, 55: 7, 56: 7, 57: 27, 58: 7, 59: 4, 60: 4, 61: 4, 62: 4, 63: 26, 64: 9, 65: 9, 66: 9, 67: 13, 68: 13, 69: 11, 70: 10, 71: 12, 72: 17, 73: 16, 74: 14, 75: 15, 76: 18, 77: 19, 78: 20, 79: 22, 80: 30, 81: 0, 82: 0, 83: 0, 84: 4, 85: 28, 86: 28, 87: 28, 88: 0, 89: 0, 90: 0, 91: 0, 92: 0, 93: 0, 94: 0, 128: 0, 129: 0, 130: 0, 131: 0, 132: 0, 133: 0, 134: 0, 135: 7, 136: 4, 137: 26, 138: 0, 139: 0, 140: 0, 141: 0, 142: 0, 143: 28, 144: 0, 145: 0, 146: 0, 147: 0, 148: 6, 149: 0, 150: 0, 151: 0 };
var pe = { 1078: "af", 1052: "sq", 1156: "gsw", 1118: "am", 5121: "ar-DZ", 15361: "ar-BH", 3073: "ar", 2049: "ar-IQ", 11265: "ar-JO", 13313: "ar-KW", 12289: "ar-LB", 4097: "ar-LY", 6145: "ary", 8193: "ar-OM", 16385: "ar-QA", 1025: "ar-SA", 10241: "ar-SY", 7169: "aeb", 14337: "ar-AE", 9217: "ar-YE", 1067: "hy", 1101: "as", 2092: "az-Cyrl", 1068: "az", 1133: "ba", 1069: "eu", 1059: "be", 2117: "bn", 1093: "bn-IN", 8218: "bs-Cyrl", 5146: "bs", 1150: "br", 1026: "bg", 1027: "ca", 3076: "zh-HK", 5124: "zh-MO", 2052: "zh", 4100: "zh-SG", 1028: "zh-TW", 1155: "co", 1050: "hr", 4122: "hr-BA", 1029: "cs", 1030: "da", 1164: "prs", 1125: "dv", 2067: "nl-BE", 1043: "nl", 3081: "en-AU", 10249: "en-BZ", 4105: "en-CA", 9225: "en-029", 16393: "en-IN", 6153: "en-IE", 8201: "en-JM", 17417: "en-MY", 5129: "en-NZ", 13321: "en-PH", 18441: "en-SG", 7177: "en-ZA", 11273: "en-TT", 2057: "en-GB", 1033: "en", 12297: "en-ZW", 1061: "et", 1080: "fo", 1124: "fil", 1035: "fi", 2060: "fr-BE", 3084: "fr-CA", 1036: "fr", 5132: "fr-LU", 6156: "fr-MC", 4108: "fr-CH", 1122: "fy", 1110: "gl", 1079: "ka", 3079: "de-AT", 1031: "de", 5127: "de-LI", 4103: "de-LU", 2055: "de-CH", 1032: "el", 1135: "kl", 1095: "gu", 1128: "ha", 1037: "he", 1081: "hi", 1038: "hu", 1039: "is", 1136: "ig", 1057: "id", 1117: "iu", 2141: "iu-Latn", 2108: "ga", 1076: "xh", 1077: "zu", 1040: "it", 2064: "it-CH", 1041: "ja", 1099: "kn", 1087: "kk", 1107: "km", 1158: "quc", 1159: "rw", 1089: "sw", 1111: "kok", 1042: "ko", 1088: "ky", 1108: "lo", 1062: "lv", 1063: "lt", 2094: "dsb", 1134: "lb", 1071: "mk", 2110: "ms-BN", 1086: "ms", 1100: "ml", 1082: "mt", 1153: "mi", 1146: "arn", 1102: "mr", 1148: "moh", 1104: "mn", 2128: "mn-CN", 1121: "ne", 1044: "nb", 2068: "nn", 1154: "oc", 1096: "or", 1123: "ps", 1045: "pl", 1046: "pt", 2070: "pt-PT", 1094: "pa", 1131: "qu-BO", 2155: "qu-EC", 3179: "qu", 1048: "ro", 1047: "rm", 1049: "ru", 9275: "smn", 4155: "smj-NO", 5179: "smj", 3131: "se-FI", 1083: "se", 2107: "se-SE", 8251: "sms", 6203: "sma-NO", 7227: "sms", 1103: "sa", 7194: "sr-Cyrl-BA", 3098: "sr", 6170: "sr-Latn-BA", 2074: "sr-Latn", 1132: "nso", 1074: "tn", 1115: "si", 1051: "sk", 1060: "sl", 11274: "es-AR", 16394: "es-BO", 13322: "es-CL", 9226: "es-CO", 5130: "es-CR", 7178: "es-DO", 12298: "es-EC", 17418: "es-SV", 4106: "es-GT", 18442: "es-HN", 2058: "es-MX", 19466: "es-NI", 6154: "es-PA", 15370: "es-PY", 10250: "es-PE", 20490: "es-PR", 3082: "es", 1034: "es", 21514: "es-US", 14346: "es-UY", 8202: "es-VE", 2077: "sv-FI", 1053: "sv", 1114: "syr", 1064: "tg", 2143: "tzm", 1097: "ta", 1092: "tt", 1098: "te", 1054: "th", 1105: "bo", 1055: "tr", 1090: "tk", 1152: "ug", 1058: "uk", 1070: "hsb", 1056: "ur", 2115: "uz-Cyrl", 1091: "uz", 1066: "vi", 1106: "cy", 1160: "wo", 1157: "sah", 1144: "ii", 1130: "yo" };
function ce(e3, t2, r2) {
  switch (e3) {
    case 0:
      if (65535 === t2) return "und";
      if (r2) return r2[t2];
      break;
    case 1:
      return ue[t2];
    case 3:
      return pe[t2];
  }
}
var he = "utf-16";
var fe = { 0: "macintosh", 1: "x-mac-japanese", 2: "x-mac-chinesetrad", 3: "x-mac-korean", 6: "x-mac-greek", 7: "x-mac-cyrillic", 9: "x-mac-devanagai", 10: "x-mac-gurmukhi", 11: "x-mac-gujarati", 12: "x-mac-oriya", 13: "x-mac-bengali", 14: "x-mac-tamil", 15: "x-mac-telugu", 16: "x-mac-kannada", 17: "x-mac-malayalam", 18: "x-mac-sinhalese", 19: "x-mac-burmese", 20: "x-mac-khmer", 21: "x-mac-thai", 22: "x-mac-lao", 23: "x-mac-georgian", 24: "x-mac-armenian", 25: "x-mac-chinesesimp", 26: "x-mac-tibetan", 27: "x-mac-mongolian", 28: "x-mac-ethiopic", 29: "x-mac-ce", 30: "x-mac-vietnamese", 31: "x-mac-extarabic" };
var de = { 15: "x-mac-icelandic", 17: "x-mac-turkish", 18: "x-mac-croatian", 24: "x-mac-ce", 25: "x-mac-ce", 26: "x-mac-ce", 27: "x-mac-ce", 28: "x-mac-ce", 30: "x-mac-icelandic", 37: "x-mac-romanian", 38: "x-mac-ce", 39: "x-mac-ce", 40: "x-mac-ce", 143: "x-mac-inuit", 146: "x-mac-gaelic" };
function ve(e3, t2, r2) {
  switch (e3) {
    case 0:
      return he;
    case 1:
      return de[r2] || fe[t2];
    case 3:
      if (1 === t2 || 10 === t2) return he;
  }
}
function ge(e3) {
  var t2 = {};
  for (var r2 in e3) t2[e3[r2]] = parseInt(r2);
  return t2;
}
function me(e3, t2, r2, n2, a2, o2) {
  return new J.Record("NameRecord", [{ name: "platformID", type: "USHORT", value: e3 }, { name: "encodingID", type: "USHORT", value: t2 }, { name: "languageID", type: "USHORT", value: r2 }, { name: "nameID", type: "USHORT", value: n2 }, { name: "length", type: "USHORT", value: a2 }, { name: "offset", type: "USHORT", value: o2 }]);
}
function ye(e3, t2) {
  var r2 = function(e4, t3) {
    var r3 = e4.length, n3 = t3.length - r3 + 1;
    e: for (var a3 = 0; a3 < n3; a3++) for (; a3 < n3; a3++) {
      for (var o2 = 0; o2 < r3; o2++) if (t3[a3 + o2] !== e4[o2]) continue e;
      return a3;
    }
    return -1;
  }(e3, t2);
  if (r2 < 0) {
    r2 = t2.length;
    for (var n2 = 0, a2 = e3.length; n2 < a2; ++n2) t2.push(e3[n2]);
  }
  return r2;
}
var be = { parse: function(e3, t2, r2) {
  for (var n2 = {}, a2 = new se.Parser(e3, t2), o2 = a2.parseUShort(), s2 = a2.parseUShort(), i2 = a2.offset + a2.parseUShort(), u2 = 0; u2 < s2; u2++) {
    var l2 = a2.parseUShort(), p2 = a2.parseUShort(), c2 = a2.parseUShort(), h2 = a2.parseUShort(), f2 = ie[h2] || h2, d2 = a2.parseUShort(), v2 = a2.parseUShort(), g2 = ce(l2, c2, r2), m2 = ve(l2, p2, c2);
    if (void 0 !== m2 && void 0 !== g2) {
      var y2 = void 0;
      if (y2 = m2 === he ? I.UTF16(e3, i2 + v2, d2) : I.MACSTRING(e3, i2 + v2, d2, m2)) {
        var b2 = n2[f2];
        void 0 === b2 && (b2 = n2[f2] = {}), b2[g2] = y2;
      }
    }
  }
  return 1 === o2 && a2.parseUShort(), n2;
}, make: function(e3, t2) {
  var r2, n2 = [], a2 = {}, o2 = ge(ie);
  for (var s2 in e3) {
    var i2 = o2[s2];
    if (void 0 === i2 && (i2 = s2), r2 = parseInt(i2), isNaN(r2)) throw new Error('Name table entry "' + s2 + '" does not exist, see nameTableNames for complete list.');
    a2[r2] = e3[s2], n2.push(r2);
  }
  for (var u2 = ge(ue), l2 = ge(pe), p2 = [], c2 = [], h2 = 0; h2 < n2.length; h2++) {
    var f2 = a2[r2 = n2[h2]];
    for (var d2 in f2) {
      var v2 = f2[d2], g2 = 1, m2 = u2[d2], y2 = le[m2], b2 = ve(g2, y2, m2), S2 = G.MACSTRING(v2, b2);
      void 0 === S2 && (g2 = 0, (m2 = t2.indexOf(d2)) < 0 && (m2 = t2.length, t2.push(d2)), y2 = 4, S2 = G.UTF16(v2));
      var x2 = ye(S2, c2);
      p2.push(me(g2, y2, m2, r2, S2.length, x2));
      var T2 = l2[d2];
      if (void 0 !== T2) {
        var U2 = G.UTF16(v2), k2 = ye(U2, c2);
        p2.push(me(3, 1, T2, r2, U2.length, k2));
      }
    }
  }
  p2.sort(function(e4, t3) {
    return e4.platformID - t3.platformID || e4.encodingID - t3.encodingID || e4.languageID - t3.languageID || e4.nameID - t3.nameID;
  });
  for (var O2 = new J.Table("name", [{ name: "format", type: "USHORT", value: 0 }, { name: "count", type: "USHORT", value: p2.length }, { name: "stringOffset", type: "USHORT", value: 6 + 12 * p2.length }]), R2 = 0; R2 < p2.length; R2++) O2.fields.push({ name: "record_" + R2, type: "RECORD", value: p2[R2] });
  return O2.fields.push({ name: "strings", type: "LITERAL", value: c2 }), O2;
} };
function Se(e3, t2, r2) {
  e3.segments.push({ end: t2, start: t2, delta: -(t2 - r2), offset: 0, glyphIndex: r2 });
}
var xe = { parse: function(e3, t2) {
  var r2 = {};
  r2.version = se.getUShort(e3, t2), w.argument(0 === r2.version, "cmap table version should be 0."), r2.numTables = se.getUShort(e3, t2 + 2);
  for (var n2 = null, a2 = -1, o2 = -1, s2 = null, i2 = null, u2 = [0, 1, 2, 3, 4, 6], l2 = [0, 1, 10], p2 = r2.numTables - 1; p2 >= 0; p2 -= 1) if (s2 = se.getUShort(e3, t2 + 4 + 8 * p2), i2 = se.getUShort(e3, t2 + 4 + 8 * p2 + 2), 3 === s2 && l2.includes(i2) || 0 === s2 && u2.includes(i2) || 1 === s2 && 0 === i2) {
    if (o2 > 0) continue;
    if (o2 = se.getULong(e3, t2 + 4 + 8 * p2 + 4), n2) break;
  } else if (0 === s2 && 5 === i2) {
    if (a2 = se.getULong(e3, t2 + 4 + 8 * p2 + 4), 14 !== (n2 = new se.Parser(e3, t2 + a2)).parseUShort()) a2 = -1, n2 = null;
    else if (o2 > 0) break;
  }
  if (-1 === o2) throw new Error("No valid cmap sub-tables found.");
  var c2 = new se.Parser(e3, t2 + o2);
  if (r2.format = c2.parseUShort(), 0 === r2.format) !function(e4, t3, r3, n3) {
    e4.length = t3.parseUShort(), e4.language = t3.parseUShort() - 1;
    for (var a3 = t3.parseByteList(e4.length), o3 = Object.assign({}, a3), s3 = ve(r3, n3, e4.language), i3 = F[s3], u3 = 0; u3 < i3.length; u3++) o3[i3.charCodeAt(u3)] = a3[128 + u3];
    e4.glyphIndexMap = o3;
  }(r2, c2, s2, i2);
  else if (12 === r2.format || 13 === r2.format) !function(e4, t3, r3) {
    var n3;
    t3.parseUShort(), e4.length = t3.parseULong(), e4.language = t3.parseULong(), e4.groupCount = n3 = t3.parseULong(), e4.glyphIndexMap = {};
    for (var a3 = 0; a3 < n3; a3 += 1) for (var o3 = t3.parseULong(), s3 = t3.parseULong(), i3 = t3.parseULong(), u3 = o3; u3 <= s3; u3 += 1) e4.glyphIndexMap[u3] = i3, 12 === r3 && i3++;
  }(r2, c2, r2.format);
  else {
    if (4 !== r2.format) throw new Error("Only format 0 (platformId 1, encodingId 0), 4, 12 and 14 cmap tables are supported (found format " + r2.format + ", platformId " + s2 + ", encodingId " + i2 + ").");
    !function(e4, t3, r3, n3, a3) {
      var o3;
      e4.length = t3.parseUShort(), e4.language = t3.parseUShort(), e4.segCount = o3 = t3.parseUShort() >> 1, t3.skip("uShort", 3), e4.glyphIndexMap = {};
      for (var s3 = new se.Parser(r3, n3 + a3 + 14), i3 = new se.Parser(r3, n3 + a3 + 16 + 2 * o3), u3 = new se.Parser(r3, n3 + a3 + 16 + 4 * o3), l3 = new se.Parser(r3, n3 + a3 + 16 + 6 * o3), p3 = n3 + a3 + 16 + 8 * o3, c3 = 0; c3 < o3 - 1; c3 += 1) for (var h2 = void 0, f2 = s3.parseUShort(), d2 = i3.parseUShort(), v2 = u3.parseShort(), g2 = l3.parseUShort(), m2 = d2; m2 <= f2; m2 += 1) 0 !== g2 ? (p3 = l3.offset + l3.relativeOffset - 2, p3 += g2, p3 += 2 * (m2 - d2), 0 !== (h2 = se.getUShort(r3, p3)) && (h2 = h2 + v2 & 65535)) : h2 = m2 + v2 & 65535, e4.glyphIndexMap[m2] = h2;
    }(r2, c2, e3, t2, o2);
  }
  return r2;
}, make: function(e3) {
  var t2, r2 = true;
  for (t2 = e3.length - 1; t2 > 0; t2 -= 1) {
    if (e3.get(t2).unicode > 65535) {
      console.log("Adding CMAP format 12 (needed!)"), r2 = false;
      break;
    }
  }
  var n2 = [{ name: "version", type: "USHORT", value: 0 }, { name: "numTables", type: "USHORT", value: r2 ? 1 : 2 }, { name: "platformID", type: "USHORT", value: 3 }, { name: "encodingID", type: "USHORT", value: 1 }, { name: "offset", type: "ULONG", value: r2 ? 12 : 20 }];
  r2 || n2.push({ name: "cmap12PlatformID", type: "USHORT", value: 3 }, { name: "cmap12EncodingID", type: "USHORT", value: 10 }, { name: "cmap12Offset", type: "ULONG", value: 0 }), n2.push({ name: "format", type: "USHORT", value: 4 }, { name: "cmap4Length", type: "USHORT", value: 0 }, { name: "language", type: "USHORT", value: 0 }, { name: "segCountX2", type: "USHORT", value: 0 }, { name: "searchRange", type: "USHORT", value: 0 }, { name: "entrySelector", type: "USHORT", value: 0 }, { name: "rangeShift", type: "USHORT", value: 0 });
  var a2 = new J.Table("cmap", n2);
  for (a2.segments = [], t2 = 0; t2 < e3.length; t2 += 1) for (var o2 = e3.get(t2), s2 = 0; s2 < o2.unicodes.length; s2 += 1) Se(a2, o2.unicodes[s2], t2);
  a2.segments.sort(function(e4, t3) {
    return e4.start - t3.start;
  }), function(e4) {
    e4.segments.push({ end: 65535, start: 65535, delta: 1, offset: 0 });
  }(a2);
  var i2 = a2.segments.length, u2 = 0, l2 = [], p2 = [], c2 = [], h2 = [], f2 = [], d2 = [];
  for (t2 = 0; t2 < i2; t2 += 1) {
    var v2 = a2.segments[t2];
    v2.end <= 65535 && v2.start <= 65535 ? (l2.push({ name: "end_" + t2, type: "USHORT", value: v2.end }), p2.push({ name: "start_" + t2, type: "USHORT", value: v2.start }), c2.push({ name: "idDelta_" + t2, type: "SHORT", value: v2.delta }), h2.push({ name: "idRangeOffset_" + t2, type: "USHORT", value: v2.offset }), void 0 !== v2.glyphId && f2.push({ name: "glyph_" + t2, type: "USHORT", value: v2.glyphId })) : u2 += 1, r2 || void 0 === v2.glyphIndex || (d2.push({ name: "cmap12Start_" + t2, type: "ULONG", value: v2.start }), d2.push({ name: "cmap12End_" + t2, type: "ULONG", value: v2.end }), d2.push({ name: "cmap12Glyph_" + t2, type: "ULONG", value: v2.glyphIndex }));
  }
  a2.segCountX2 = 2 * (i2 - u2), a2.searchRange = 2 * Math.pow(2, Math.floor(Math.log(i2 - u2) / Math.log(2))), a2.entrySelector = Math.log(a2.searchRange / 2) / Math.log(2), a2.rangeShift = a2.segCountX2 - a2.searchRange;
  for (var g2 = 0; g2 < l2.length; g2++) a2.fields.push(l2[g2]);
  a2.fields.push({ name: "reservedPad", type: "USHORT", value: 0 });
  for (var m2 = 0; m2 < p2.length; m2++) a2.fields.push(p2[m2]);
  for (var y2 = 0; y2 < c2.length; y2++) a2.fields.push(c2[y2]);
  for (var b2 = 0; b2 < h2.length; b2++) a2.fields.push(h2[b2]);
  for (var S2 = 0; S2 < f2.length; S2++) a2.fields.push(f2[S2]);
  if (a2.cmap4Length = 14 + 2 * l2.length + 2 + 2 * p2.length + 2 * c2.length + 2 * h2.length + 2 * f2.length, !r2) {
    var x2 = 16 + 4 * d2.length;
    a2.cmap12Offset = 20 + a2.cmap4Length, a2.fields.push({ name: "cmap12Format", type: "USHORT", value: 12 }, { name: "cmap12Reserved", type: "USHORT", value: 0 }, { name: "cmap12Length", type: "ULONG", value: x2 }, { name: "cmap12Language", type: "ULONG", value: 0 }, { name: "cmap12nGroups", type: "ULONG", value: d2.length / 3 });
    for (var T2 = 0; T2 < d2.length; T2++) a2.fields.push(d2[T2]);
  }
  return a2;
} };
var Te = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "266 ff", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
var Ue = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls"];
var ke = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
var Oe = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
function Re(e3) {
  this.font = e3;
}
function Ee(e3) {
  this.cmap = e3;
}
function Le(e3, t2) {
  this.encoding = e3, this.charset = t2;
}
function Ce(e3) {
  switch (e3.version) {
    case 1:
      this.names = Oe.slice();
      break;
    case 2:
      this.names = new Array(e3.numberOfGlyphs);
      for (var t2 = 0; t2 < e3.numberOfGlyphs; t2++) e3.glyphNameIndex[t2] < Oe.length ? this.names[t2] = Oe[e3.glyphNameIndex[t2]] : this.names[t2] = e3.names[e3.glyphNameIndex[t2] - Oe.length];
      break;
    case 2.5:
      this.names = new Array(e3.numberOfGlyphs);
      for (var r2 = 0; r2 < e3.numberOfGlyphs; r2++) this.names[r2] = Oe[r2 + e3.glyphNameIndex[r2]];
      break;
    default:
      this.names = [];
  }
}
function we(e3, t2) {
  t2.lowMemory ? function(e4) {
    e4._IndexToUnicodeMap = {};
    for (var t3 = e4.tables.cmap.glyphIndexMap, r2 = Object.keys(t3), n2 = 0; n2 < r2.length; n2 += 1) {
      var a2 = r2[n2], o2 = t3[a2];
      void 0 === e4._IndexToUnicodeMap[o2] ? e4._IndexToUnicodeMap[o2] = { unicodes: [parseInt(a2)] } : e4._IndexToUnicodeMap[o2].unicodes.push(parseInt(a2));
    }
  }(e3) : function(e4) {
    for (var t3, r2 = e4.tables.cmap.glyphIndexMap, n2 = Object.keys(r2), a2 = 0; a2 < n2.length; a2 += 1) {
      var o2 = n2[a2], s2 = r2[o2];
      (t3 = e4.glyphs.get(s2)).addUnicode(parseInt(o2));
    }
    for (var i2 = 0; i2 < e4.glyphs.length; i2 += 1) t3 = e4.glyphs.get(i2), e4.cffEncoding ? e4.isCIDFont ? t3.name = "gid" + i2 : t3.name = e4.cffEncoding.charset[i2] : e4.glyphNames.names && (t3.name = e4.glyphNames.glyphIndexToName(i2));
  }(e3);
}
Re.prototype.charToGlyphIndex = function(e3) {
  var t2 = e3.codePointAt(0), r2 = this.font.glyphs;
  if (r2) {
    for (var n2 = 0; n2 < r2.length; n2 += 1) for (var a2 = r2.get(n2), o2 = 0; o2 < a2.unicodes.length; o2 += 1) if (a2.unicodes[o2] === t2) return n2;
  }
  return null;
}, Ee.prototype.charToGlyphIndex = function(e3) {
  return this.cmap.glyphIndexMap[e3.codePointAt(0)] || 0;
}, Le.prototype.charToGlyphIndex = function(e3) {
  var t2 = e3.codePointAt(0), r2 = this.encoding[t2];
  return this.charset.indexOf(r2);
}, Ce.prototype.nameToGlyphIndex = function(e3) {
  return this.names.indexOf(e3);
}, Ce.prototype.glyphIndexToName = function(e3) {
  return this.names[e3];
};
var De = { line: function(e3, t2, r2, n2, a2) {
  e3.beginPath(), e3.moveTo(t2, r2), e3.lineTo(n2, a2), e3.stroke();
} };
function Ie(e3) {
  this.bindConstructorValues(e3);
}
function Ge(e3, t2, r2) {
  Object.defineProperty(e3, t2, { get: function() {
    return e3.path, e3[r2];
  }, set: function(t3) {
    e3[r2] = t3;
  }, enumerable: true, configurable: true });
}
function Me(e3, t2) {
  if (this.font = e3, this.glyphs = {}, Array.isArray(t2)) for (var r2 = 0; r2 < t2.length; r2++) {
    var n2 = t2[r2];
    n2.path.unitsPerEm = e3.unitsPerEm, this.glyphs[r2] = n2;
  }
  this.length = t2 && t2.length || 0;
}
Ie.prototype.bindConstructorValues = function(e3) {
  var t2, r2;
  this.index = e3.index || 0, this.name = e3.name || null, this.unicode = e3.unicode || void 0, this.unicodes = e3.unicodes || void 0 !== e3.unicode ? [e3.unicode] : [], "xMin" in e3 && (this.xMin = e3.xMin), "yMin" in e3 && (this.yMin = e3.yMin), "xMax" in e3 && (this.xMax = e3.xMax), "yMax" in e3 && (this.yMax = e3.yMax), "advanceWidth" in e3 && (this.advanceWidth = e3.advanceWidth), Object.defineProperty(this, "path", (t2 = e3.path, r2 = t2 || new E(), { configurable: true, get: function() {
    return "function" == typeof r2 && (r2 = r2()), r2;
  }, set: function(e4) {
    r2 = e4;
  } }));
}, Ie.prototype.addUnicode = function(e3) {
  0 === this.unicodes.length && (this.unicode = e3), this.unicodes.push(e3);
}, Ie.prototype.getBoundingBox = function() {
  return this.path.getBoundingBox();
}, Ie.prototype.getPath = function(e3, t2, r2, n2, a2) {
  var o2, s2;
  e3 = void 0 !== e3 ? e3 : 0, t2 = void 0 !== t2 ? t2 : 0, r2 = void 0 !== r2 ? r2 : 72, n2 || (n2 = {});
  var i2 = n2.xScale, u2 = n2.yScale;
  if (n2.hinting && a2 && a2.hinting && (s2 = this.path && a2.hinting.exec(this, r2)), s2) o2 = a2.hinting.getCommands(s2), e3 = Math.round(e3), t2 = Math.round(t2), i2 = u2 = 1;
  else {
    o2 = this.path.commands;
    var l2 = 1 / (this.path.unitsPerEm || 1e3) * r2;
    void 0 === i2 && (i2 = l2), void 0 === u2 && (u2 = l2);
  }
  for (var p2 = new E(), c2 = 0; c2 < o2.length; c2 += 1) {
    var h2 = o2[c2];
    "M" === h2.type ? p2.moveTo(e3 + h2.x * i2, t2 + -h2.y * u2) : "L" === h2.type ? p2.lineTo(e3 + h2.x * i2, t2 + -h2.y * u2) : "Q" === h2.type ? p2.quadraticCurveTo(e3 + h2.x1 * i2, t2 + -h2.y1 * u2, e3 + h2.x * i2, t2 + -h2.y * u2) : "C" === h2.type ? p2.curveTo(e3 + h2.x1 * i2, t2 + -h2.y1 * u2, e3 + h2.x2 * i2, t2 + -h2.y2 * u2, e3 + h2.x * i2, t2 + -h2.y * u2) : "Z" === h2.type && p2.closePath();
  }
  return p2;
}, Ie.prototype.getContours = function() {
  if (void 0 === this.points) return [];
  for (var e3 = [], t2 = [], r2 = 0; r2 < this.points.length; r2 += 1) {
    var n2 = this.points[r2];
    t2.push(n2), n2.lastPointOfContour && (e3.push(t2), t2 = []);
  }
  return w.argument(0 === t2.length, "There are still points left in the current contour."), e3;
}, Ie.prototype.getMetrics = function() {
  for (var e3 = this.path.commands, t2 = [], r2 = [], n2 = 0; n2 < e3.length; n2 += 1) {
    var a2 = e3[n2];
    "Z" !== a2.type && (t2.push(a2.x), r2.push(a2.y)), "Q" !== a2.type && "C" !== a2.type || (t2.push(a2.x1), r2.push(a2.y1)), "C" === a2.type && (t2.push(a2.x2), r2.push(a2.y2));
  }
  var o2 = { xMin: Math.min.apply(null, t2), yMin: Math.min.apply(null, r2), xMax: Math.max.apply(null, t2), yMax: Math.max.apply(null, r2), leftSideBearing: this.leftSideBearing };
  return isFinite(o2.xMin) || (o2.xMin = 0), isFinite(o2.xMax) || (o2.xMax = this.advanceWidth), isFinite(o2.yMin) || (o2.yMin = 0), isFinite(o2.yMax) || (o2.yMax = 0), o2.rightSideBearing = this.advanceWidth - o2.leftSideBearing - (o2.xMax - o2.xMin), o2;
}, Ie.prototype.draw = function(e3, t2, r2, n2, a2) {
  this.getPath(t2, r2, n2, a2).draw(e3);
}, Ie.prototype.drawPoints = function(e3, t2, r2, n2) {
  function a2(t3, r3, n3, a3) {
    e3.beginPath();
    for (var o3 = 0; o3 < t3.length; o3 += 1) e3.moveTo(r3 + t3[o3].x * a3, n3 + t3[o3].y * a3), e3.arc(r3 + t3[o3].x * a3, n3 + t3[o3].y * a3, 2, 0, 2 * Math.PI, false);
    e3.closePath(), e3.fill();
  }
  t2 = void 0 !== t2 ? t2 : 0, r2 = void 0 !== r2 ? r2 : 0, n2 = void 0 !== n2 ? n2 : 24;
  for (var o2 = 1 / this.path.unitsPerEm * n2, s2 = [], i2 = [], u2 = this.path, l2 = 0; l2 < u2.commands.length; l2 += 1) {
    var p2 = u2.commands[l2];
    void 0 !== p2.x && s2.push({ x: p2.x, y: -p2.y }), void 0 !== p2.x1 && i2.push({ x: p2.x1, y: -p2.y1 }), void 0 !== p2.x2 && i2.push({ x: p2.x2, y: -p2.y2 });
  }
  e3.fillStyle = "blue", a2(s2, t2, r2, o2), e3.fillStyle = "red", a2(i2, t2, r2, o2);
}, Ie.prototype.drawMetrics = function(e3, t2, r2, n2) {
  var a2;
  t2 = void 0 !== t2 ? t2 : 0, r2 = void 0 !== r2 ? r2 : 0, n2 = void 0 !== n2 ? n2 : 24, a2 = 1 / this.path.unitsPerEm * n2, e3.lineWidth = 1, e3.strokeStyle = "black", De.line(e3, t2, -1e4, t2, 1e4), De.line(e3, -1e4, r2, 1e4, r2);
  var o2 = this.xMin || 0, s2 = this.yMin || 0, i2 = this.xMax || 0, u2 = this.yMax || 0, l2 = this.advanceWidth || 0;
  e3.strokeStyle = "blue", De.line(e3, t2 + o2 * a2, -1e4, t2 + o2 * a2, 1e4), De.line(e3, t2 + i2 * a2, -1e4, t2 + i2 * a2, 1e4), De.line(e3, -1e4, r2 + -s2 * a2, 1e4, r2 + -s2 * a2), De.line(e3, -1e4, r2 + -u2 * a2, 1e4, r2 + -u2 * a2), e3.strokeStyle = "green", De.line(e3, t2 + l2 * a2, -1e4, t2 + l2 * a2, 1e4);
}, Me.prototype.get = function(e3) {
  if (void 0 === this.glyphs[e3] && "number" == typeof e3) {
    this.font._push(e3), "function" == typeof this.glyphs[e3] && (this.glyphs[e3] = this.glyphs[e3]());
    var t2 = this.glyphs[e3], r2 = this.font._IndexToUnicodeMap[e3];
    if (r2) for (var n2 = 0; n2 < r2.unicodes.length; n2++) t2.addUnicode(r2.unicodes[n2]);
    this.font.cffEncoding ? this.font.isCIDFont ? t2.name = "gid" + e3 : t2.name = this.font.cffEncoding.charset[e3] : this.font.glyphNames.names && (t2.name = this.font.glyphNames.glyphIndexToName(e3)), this.glyphs[e3].advanceWidth = this.font._hmtxTableData[e3].advanceWidth, this.glyphs[e3].leftSideBearing = this.font._hmtxTableData[e3].leftSideBearing;
  } else "function" == typeof this.glyphs[e3] && (this.glyphs[e3] = this.glyphs[e3]());
  return this.glyphs[e3];
}, Me.prototype.push = function(e3, t2) {
  this.glyphs[e3] = t2, this.length++;
};
var Be = { GlyphSet: Me, glyphLoader: function(e3, t2) {
  return new Ie({ index: t2, font: e3 });
}, ttfGlyphLoader: function(e3, t2, r2, n2, a2, o2) {
  return function() {
    var s2 = new Ie({ index: t2, font: e3 });
    return s2.path = function() {
      r2(s2, n2, a2);
      var t3 = o2(e3.glyphs, s2);
      return t3.unitsPerEm = e3.unitsPerEm, t3;
    }, Ge(s2, "xMin", "_xMin"), Ge(s2, "xMax", "_xMax"), Ge(s2, "yMin", "_yMin"), Ge(s2, "yMax", "_yMax"), s2;
  };
}, cffGlyphLoader: function(e3, t2, r2, n2) {
  return function() {
    var a2 = new Ie({ index: t2, font: e3 });
    return a2.path = function() {
      var t3 = r2(e3, a2, n2);
      return t3.unitsPerEm = e3.unitsPerEm, t3;
    }, a2;
  };
} };
function Fe(e3, t2) {
  if (e3 === t2) return true;
  if (Array.isArray(e3) && Array.isArray(t2)) {
    if (e3.length !== t2.length) return false;
    for (var r2 = 0; r2 < e3.length; r2 += 1) if (!Fe(e3[r2], t2[r2])) return false;
    return true;
  }
  return false;
}
function Pe(e3) {
  return e3.length < 1240 ? 107 : e3.length < 33900 ? 1131 : 32768;
}
function Ae(e3, t2, r2) {
  var n2, a2, o2 = [], s2 = [], i2 = se.getCard16(e3, t2);
  if (0 !== i2) {
    var u2 = se.getByte(e3, t2 + 2);
    n2 = t2 + (i2 + 1) * u2 + 2;
    for (var l2 = t2 + 3, p2 = 0; p2 < i2 + 1; p2 += 1) o2.push(se.getOffset(e3, l2, u2)), l2 += u2;
    a2 = n2 + o2[i2];
  } else a2 = t2 + 2;
  for (var c2 = 0; c2 < o2.length - 1; c2 += 1) {
    var h2 = se.getBytes(e3, n2 + o2[c2], n2 + o2[c2 + 1]);
    r2 && (h2 = r2(h2)), s2.push(h2);
  }
  return { objects: s2, startOffset: t2, endOffset: a2 };
}
function Ne(e3, t2) {
  if (28 === t2) return e3.parseByte() << 8 | e3.parseByte();
  if (29 === t2) return e3.parseByte() << 24 | e3.parseByte() << 16 | e3.parseByte() << 8 | e3.parseByte();
  if (30 === t2) return function(e4) {
    for (var t3 = "", r2 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"]; ; ) {
      var n2 = e4.parseByte(), a2 = n2 >> 4, o2 = 15 & n2;
      if (15 === a2) break;
      if (t3 += r2[a2], 15 === o2) break;
      t3 += r2[o2];
    }
    return parseFloat(t3);
  }(e3);
  if (t2 >= 32 && t2 <= 246) return t2 - 139;
  if (t2 >= 247 && t2 <= 250) return 256 * (t2 - 247) + e3.parseByte() + 108;
  if (t2 >= 251 && t2 <= 254) return 256 * -(t2 - 251) - e3.parseByte() - 108;
  throw new Error("Invalid b0 " + t2);
}
function He(e3, t2, r2) {
  t2 = void 0 !== t2 ? t2 : 0;
  var n2 = new se.Parser(e3, t2), a2 = [], o2 = [];
  for (r2 = void 0 !== r2 ? r2 : e3.length; n2.relativeOffset < r2; ) {
    var s2 = n2.parseByte();
    s2 <= 21 ? (12 === s2 && (s2 = 1200 + n2.parseByte()), a2.push([s2, o2]), o2 = []) : o2.push(Ne(n2, s2));
  }
  return function(e4) {
    for (var t3 = {}, r3 = 0; r3 < e4.length; r3 += 1) {
      var n3 = e4[r3][0], a3 = e4[r3][1], o3 = void 0;
      if (o3 = 1 === a3.length ? a3[0] : a3, t3.hasOwnProperty(n3) && !isNaN(t3[n3])) throw new Error("Object " + t3 + " already has key " + n3);
      t3[n3] = o3;
    }
    return t3;
  }(a2);
}
function ze(e3, t2) {
  return t2 = t2 <= 390 ? Te[t2] : e3[t2 - 391];
}
function We(e3, t2, r2) {
  for (var n2, a2 = {}, o2 = 0; o2 < t2.length; o2 += 1) {
    var s2 = t2[o2];
    if (Array.isArray(s2.type)) {
      var i2 = [];
      i2.length = s2.type.length;
      for (var u2 = 0; u2 < s2.type.length; u2++) void 0 === (n2 = void 0 !== e3[s2.op] ? e3[s2.op][u2] : void 0) && (n2 = void 0 !== s2.value && void 0 !== s2.value[u2] ? s2.value[u2] : null), "SID" === s2.type[u2] && (n2 = ze(r2, n2)), i2[u2] = n2;
      a2[s2.name] = i2;
    } else void 0 === (n2 = e3[s2.op]) && (n2 = void 0 !== s2.value ? s2.value : null), "SID" === s2.type && (n2 = ze(r2, n2)), a2[s2.name] = n2;
  }
  return a2;
}
var qe = [{ name: "version", op: 0, type: "SID" }, { name: "notice", op: 1, type: "SID" }, { name: "copyright", op: 1200, type: "SID" }, { name: "fullName", op: 2, type: "SID" }, { name: "familyName", op: 3, type: "SID" }, { name: "weight", op: 4, type: "SID" }, { name: "isFixedPitch", op: 1201, type: "number", value: 0 }, { name: "italicAngle", op: 1202, type: "number", value: 0 }, { name: "underlinePosition", op: 1203, type: "number", value: -100 }, { name: "underlineThickness", op: 1204, type: "number", value: 50 }, { name: "paintType", op: 1205, type: "number", value: 0 }, { name: "charstringType", op: 1206, type: "number", value: 2 }, { name: "fontMatrix", op: 1207, type: ["real", "real", "real", "real", "real", "real"], value: [1e-3, 0, 0, 1e-3, 0, 0] }, { name: "uniqueId", op: 13, type: "number" }, { name: "fontBBox", op: 5, type: ["number", "number", "number", "number"], value: [0, 0, 0, 0] }, { name: "strokeWidth", op: 1208, type: "number", value: 0 }, { name: "xuid", op: 14, type: [], value: null }, { name: "charset", op: 15, type: "offset", value: 0 }, { name: "encoding", op: 16, type: "offset", value: 0 }, { name: "charStrings", op: 17, type: "offset", value: 0 }, { name: "private", op: 18, type: ["number", "offset"], value: [0, 0] }, { name: "ros", op: 1230, type: ["SID", "SID", "number"] }, { name: "cidFontVersion", op: 1231, type: "number", value: 0 }, { name: "cidFontRevision", op: 1232, type: "number", value: 0 }, { name: "cidFontType", op: 1233, type: "number", value: 0 }, { name: "cidCount", op: 1234, type: "number", value: 8720 }, { name: "uidBase", op: 1235, type: "number" }, { name: "fdArray", op: 1236, type: "offset" }, { name: "fdSelect", op: 1237, type: "offset" }, { name: "fontName", op: 1238, type: "SID" }];
var _e = [{ name: "subrs", op: 19, type: "offset", value: 0 }, { name: "defaultWidthX", op: 20, type: "number", value: 0 }, { name: "nominalWidthX", op: 21, type: "number", value: 0 }];
function Xe(e3, t2) {
  return We(He(e3, 0, e3.byteLength), qe, t2);
}
function Ve(e3, t2, r2, n2) {
  return We(He(e3, t2, r2), _e, n2);
}
function je(e3, t2, r2, n2) {
  for (var a2 = [], o2 = 0; o2 < r2.length; o2 += 1) {
    var s2 = Xe(new DataView(new Uint8Array(r2[o2]).buffer), n2);
    s2._subrs = [], s2._subrsBias = 0, s2._defaultWidthX = 0, s2._nominalWidthX = 0;
    var i2 = s2.private[0], u2 = s2.private[1];
    if (0 !== i2 && 0 !== u2) {
      var l2 = Ve(e3, u2 + t2, i2, n2);
      if (s2._defaultWidthX = l2.defaultWidthX, s2._nominalWidthX = l2.nominalWidthX, 0 !== l2.subrs) {
        var p2 = Ae(e3, u2 + l2.subrs + t2);
        s2._subrs = p2.objects, s2._subrsBias = Pe(s2._subrs);
      }
      s2._privateDict = l2;
    }
    a2.push(s2);
  }
  return a2;
}
function Ye(e3, t2, r2) {
  var n2, a2, o2, s2, i2, u2, l2, p2, c2 = new E(), h2 = [], f2 = 0, d2 = false, v2 = false, g2 = 0, m2 = 0;
  if (e3.isCIDFont) {
    var y2 = e3.tables.cff.topDict._fdSelect[t2.index], b2 = e3.tables.cff.topDict._fdArray[y2];
    i2 = b2._subrs, u2 = b2._subrsBias, l2 = b2._defaultWidthX, p2 = b2._nominalWidthX;
  } else i2 = e3.tables.cff.topDict._subrs, u2 = e3.tables.cff.topDict._subrsBias, l2 = e3.tables.cff.topDict._defaultWidthX, p2 = e3.tables.cff.topDict._nominalWidthX;
  var S2 = l2;
  function x2(e4, t3) {
    v2 && c2.closePath(), c2.moveTo(e4, t3), v2 = true;
  }
  function T2() {
    h2.length % 2 != 0 && !d2 && (S2 = h2.shift() + p2), f2 += h2.length >> 1, h2.length = 0, d2 = true;
  }
  return function r3(l3) {
    for (var y3, b3, U2, k2, O2, R2, E2, L2, C2, w2, D2, I2, G2 = 0; G2 < l3.length; ) {
      var M2 = l3[G2];
      switch (G2 += 1, M2) {
        case 1:
        case 3:
        case 18:
        case 23:
          T2();
          break;
        case 4:
          h2.length > 1 && !d2 && (S2 = h2.shift() + p2, d2 = true), m2 += h2.pop(), x2(g2, m2);
          break;
        case 5:
          for (; h2.length > 0; ) g2 += h2.shift(), m2 += h2.shift(), c2.lineTo(g2, m2);
          break;
        case 6:
          for (; h2.length > 0 && (g2 += h2.shift(), c2.lineTo(g2, m2), 0 !== h2.length); ) m2 += h2.shift(), c2.lineTo(g2, m2);
          break;
        case 7:
          for (; h2.length > 0 && (m2 += h2.shift(), c2.lineTo(g2, m2), 0 !== h2.length); ) g2 += h2.shift(), c2.lineTo(g2, m2);
          break;
        case 8:
          for (; h2.length > 0; ) n2 = g2 + h2.shift(), a2 = m2 + h2.shift(), o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), g2 = o2 + h2.shift(), m2 = s2 + h2.shift(), c2.curveTo(n2, a2, o2, s2, g2, m2);
          break;
        case 10:
          O2 = h2.pop() + u2, (R2 = i2[O2]) && r3(R2);
          break;
        case 11:
          return;
        case 12:
          switch (M2 = l3[G2], G2 += 1, M2) {
            case 35:
              n2 = g2 + h2.shift(), a2 = m2 + h2.shift(), o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), E2 = o2 + h2.shift(), L2 = s2 + h2.shift(), C2 = E2 + h2.shift(), w2 = L2 + h2.shift(), D2 = C2 + h2.shift(), I2 = w2 + h2.shift(), g2 = D2 + h2.shift(), m2 = I2 + h2.shift(), h2.shift(), c2.curveTo(n2, a2, o2, s2, E2, L2), c2.curveTo(C2, w2, D2, I2, g2, m2);
              break;
            case 34:
              n2 = g2 + h2.shift(), a2 = m2, o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), E2 = o2 + h2.shift(), L2 = s2, C2 = E2 + h2.shift(), w2 = s2, D2 = C2 + h2.shift(), I2 = m2, g2 = D2 + h2.shift(), c2.curveTo(n2, a2, o2, s2, E2, L2), c2.curveTo(C2, w2, D2, I2, g2, m2);
              break;
            case 36:
              n2 = g2 + h2.shift(), a2 = m2 + h2.shift(), o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), E2 = o2 + h2.shift(), L2 = s2, C2 = E2 + h2.shift(), w2 = s2, D2 = C2 + h2.shift(), I2 = w2 + h2.shift(), g2 = D2 + h2.shift(), c2.curveTo(n2, a2, o2, s2, E2, L2), c2.curveTo(C2, w2, D2, I2, g2, m2);
              break;
            case 37:
              n2 = g2 + h2.shift(), a2 = m2 + h2.shift(), o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), E2 = o2 + h2.shift(), L2 = s2 + h2.shift(), C2 = E2 + h2.shift(), w2 = L2 + h2.shift(), D2 = C2 + h2.shift(), I2 = w2 + h2.shift(), Math.abs(D2 - g2) > Math.abs(I2 - m2) ? g2 = D2 + h2.shift() : m2 = I2 + h2.shift(), c2.curveTo(n2, a2, o2, s2, E2, L2), c2.curveTo(C2, w2, D2, I2, g2, m2);
              break;
            default:
              console.log("Glyph " + t2.index + ": unknown operator 1200" + M2), h2.length = 0;
          }
          break;
        case 14:
          h2.length > 0 && !d2 && (S2 = h2.shift() + p2, d2 = true), v2 && (c2.closePath(), v2 = false);
          break;
        case 19:
        case 20:
          T2(), G2 += f2 + 7 >> 3;
          break;
        case 21:
          h2.length > 2 && !d2 && (S2 = h2.shift() + p2, d2 = true), m2 += h2.pop(), x2(g2 += h2.pop(), m2);
          break;
        case 22:
          h2.length > 1 && !d2 && (S2 = h2.shift() + p2, d2 = true), x2(g2 += h2.pop(), m2);
          break;
        case 24:
          for (; h2.length > 2; ) n2 = g2 + h2.shift(), a2 = m2 + h2.shift(), o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), g2 = o2 + h2.shift(), m2 = s2 + h2.shift(), c2.curveTo(n2, a2, o2, s2, g2, m2);
          g2 += h2.shift(), m2 += h2.shift(), c2.lineTo(g2, m2);
          break;
        case 25:
          for (; h2.length > 6; ) g2 += h2.shift(), m2 += h2.shift(), c2.lineTo(g2, m2);
          n2 = g2 + h2.shift(), a2 = m2 + h2.shift(), o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), g2 = o2 + h2.shift(), m2 = s2 + h2.shift(), c2.curveTo(n2, a2, o2, s2, g2, m2);
          break;
        case 26:
          for (h2.length % 2 && (g2 += h2.shift()); h2.length > 0; ) n2 = g2, a2 = m2 + h2.shift(), o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), g2 = o2, m2 = s2 + h2.shift(), c2.curveTo(n2, a2, o2, s2, g2, m2);
          break;
        case 27:
          for (h2.length % 2 && (m2 += h2.shift()); h2.length > 0; ) n2 = g2 + h2.shift(), a2 = m2, o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), g2 = o2 + h2.shift(), m2 = s2, c2.curveTo(n2, a2, o2, s2, g2, m2);
          break;
        case 28:
          y3 = l3[G2], b3 = l3[G2 + 1], h2.push((y3 << 24 | b3 << 16) >> 16), G2 += 2;
          break;
        case 29:
          O2 = h2.pop() + e3.gsubrsBias, (R2 = e3.gsubrs[O2]) && r3(R2);
          break;
        case 30:
          for (; h2.length > 0 && (n2 = g2, a2 = m2 + h2.shift(), o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), g2 = o2 + h2.shift(), m2 = s2 + (1 === h2.length ? h2.shift() : 0), c2.curveTo(n2, a2, o2, s2, g2, m2), 0 !== h2.length); ) n2 = g2 + h2.shift(), a2 = m2, o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), m2 = s2 + h2.shift(), g2 = o2 + (1 === h2.length ? h2.shift() : 0), c2.curveTo(n2, a2, o2, s2, g2, m2);
          break;
        case 31:
          for (; h2.length > 0 && (n2 = g2 + h2.shift(), a2 = m2, o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), m2 = s2 + h2.shift(), g2 = o2 + (1 === h2.length ? h2.shift() : 0), c2.curveTo(n2, a2, o2, s2, g2, m2), 0 !== h2.length); ) n2 = g2, a2 = m2 + h2.shift(), o2 = n2 + h2.shift(), s2 = a2 + h2.shift(), g2 = o2 + h2.shift(), m2 = s2 + (1 === h2.length ? h2.shift() : 0), c2.curveTo(n2, a2, o2, s2, g2, m2);
          break;
        default:
          M2 < 32 ? console.log("Glyph " + t2.index + ": unknown operator " + M2) : M2 < 247 ? h2.push(M2 - 139) : M2 < 251 ? (y3 = l3[G2], G2 += 1, h2.push(256 * (M2 - 247) + y3 + 108)) : M2 < 255 ? (y3 = l3[G2], G2 += 1, h2.push(256 * -(M2 - 251) - y3 - 108)) : (y3 = l3[G2], b3 = l3[G2 + 1], U2 = l3[G2 + 2], k2 = l3[G2 + 3], G2 += 4, h2.push((y3 << 24 | b3 << 16 | U2 << 8 | k2) / 65536));
      }
    }
  }(r2), t2.advanceWidth = S2, c2;
}
function Ze(e3, t2) {
  var r2, n2 = Te.indexOf(e3);
  return n2 >= 0 && (r2 = n2), (n2 = t2.indexOf(e3)) >= 0 ? r2 = n2 + Te.length : (r2 = Te.length + t2.length, t2.push(e3)), r2;
}
function Qe(e3, t2, r2) {
  for (var n2 = {}, a2 = 0; a2 < e3.length; a2 += 1) {
    var o2 = e3[a2], s2 = t2[o2.name];
    void 0 === s2 || Fe(s2, o2.value) || ("SID" === o2.type && (s2 = Ze(s2, r2)), n2[o2.op] = { name: o2.name, type: o2.type, value: s2 });
  }
  return n2;
}
function Ke(e3, t2) {
  var r2 = new J.Record("Top DICT", [{ name: "dict", type: "DICT", value: {} }]);
  return r2.dict = Qe(qe, e3, t2), r2;
}
function Je(e3) {
  var t2 = new J.Record("Top DICT INDEX", [{ name: "topDicts", type: "INDEX", value: [] }]);
  return t2.topDicts = [{ name: "topDict_0", type: "TABLE", value: e3 }], t2;
}
function $e(e3) {
  var t2 = [], r2 = e3.path;
  t2.push({ name: "width", type: "NUMBER", value: e3.advanceWidth });
  for (var n2 = 0, a2 = 0, o2 = 0; o2 < r2.commands.length; o2 += 1) {
    var s2 = void 0, i2 = void 0, u2 = r2.commands[o2];
    if ("Q" === u2.type) {
      var l2 = 1 / 3, p2 = 2 / 3;
      u2 = { type: "C", x: u2.x, y: u2.y, x1: Math.round(l2 * n2 + p2 * u2.x1), y1: Math.round(l2 * a2 + p2 * u2.y1), x2: Math.round(l2 * u2.x + p2 * u2.x1), y2: Math.round(l2 * u2.y + p2 * u2.y1) };
    }
    if ("M" === u2.type) s2 = Math.round(u2.x - n2), i2 = Math.round(u2.y - a2), t2.push({ name: "dx", type: "NUMBER", value: s2 }), t2.push({ name: "dy", type: "NUMBER", value: i2 }), t2.push({ name: "rmoveto", type: "OP", value: 21 }), n2 = Math.round(u2.x), a2 = Math.round(u2.y);
    else if ("L" === u2.type) s2 = Math.round(u2.x - n2), i2 = Math.round(u2.y - a2), t2.push({ name: "dx", type: "NUMBER", value: s2 }), t2.push({ name: "dy", type: "NUMBER", value: i2 }), t2.push({ name: "rlineto", type: "OP", value: 5 }), n2 = Math.round(u2.x), a2 = Math.round(u2.y);
    else if ("C" === u2.type) {
      var c2 = Math.round(u2.x1 - n2), h2 = Math.round(u2.y1 - a2), f2 = Math.round(u2.x2 - u2.x1), d2 = Math.round(u2.y2 - u2.y1);
      s2 = Math.round(u2.x - u2.x2), i2 = Math.round(u2.y - u2.y2), t2.push({ name: "dx1", type: "NUMBER", value: c2 }), t2.push({ name: "dy1", type: "NUMBER", value: h2 }), t2.push({ name: "dx2", type: "NUMBER", value: f2 }), t2.push({ name: "dy2", type: "NUMBER", value: d2 }), t2.push({ name: "dx", type: "NUMBER", value: s2 }), t2.push({ name: "dy", type: "NUMBER", value: i2 }), t2.push({ name: "rrcurveto", type: "OP", value: 8 }), n2 = Math.round(u2.x), a2 = Math.round(u2.y);
    }
  }
  return t2.push({ name: "endchar", type: "OP", value: 14 }), t2;
}
var et = { parse: function(e3, t2, r2, n2) {
  r2.tables.cff = {};
  var a2 = function(e4, t3) {
    var r3 = {};
    return r3.formatMajor = se.getCard8(e4, t3), r3.formatMinor = se.getCard8(e4, t3 + 1), r3.size = se.getCard8(e4, t3 + 2), r3.offsetSize = se.getCard8(e4, t3 + 3), r3.startOffset = t3, r3.endOffset = t3 + 4, r3;
  }(e3, t2), o2 = Ae(e3, a2.endOffset, se.bytesToString), s2 = Ae(e3, o2.endOffset), i2 = Ae(e3, s2.endOffset, se.bytesToString), u2 = Ae(e3, i2.endOffset);
  r2.gsubrs = u2.objects, r2.gsubrsBias = Pe(r2.gsubrs);
  var l2 = je(e3, t2, s2.objects, i2.objects);
  if (1 !== l2.length) throw new Error("CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = " + l2.length);
  var p2 = l2[0];
  if (r2.tables.cff.topDict = p2, p2._privateDict && (r2.defaultWidthX = p2._privateDict.defaultWidthX, r2.nominalWidthX = p2._privateDict.nominalWidthX), void 0 !== p2.ros[0] && void 0 !== p2.ros[1] && (r2.isCIDFont = true), r2.isCIDFont) {
    var c2 = p2.fdArray, h2 = p2.fdSelect;
    if (0 === c2 || 0 === h2) throw new Error("Font is marked as a CID font, but FDArray and/or FDSelect information is missing");
    var f2 = Ae(e3, c2 += t2), d2 = je(e3, t2, f2.objects, i2.objects);
    p2._fdArray = d2, h2 += t2, p2._fdSelect = function(e4, t3, r3, n3) {
      var a3, o3 = [], s3 = new se.Parser(e4, t3), i3 = s3.parseCard8();
      if (0 === i3) for (var u3 = 0; u3 < r3; u3++) {
        if ((a3 = s3.parseCard8()) >= n3) throw new Error("CFF table CID Font FDSelect has bad FD index value " + a3 + " (FD count " + n3 + ")");
        o3.push(a3);
      }
      else {
        if (3 !== i3) throw new Error("CFF Table CID Font FDSelect table has unsupported format " + i3);
        var l3, p3 = s3.parseCard16(), c3 = s3.parseCard16();
        if (0 !== c3) throw new Error("CFF Table CID Font FDSelect format 3 range has bad initial GID " + c3);
        for (var h3 = 0; h3 < p3; h3++) {
          if (a3 = s3.parseCard8(), l3 = s3.parseCard16(), a3 >= n3) throw new Error("CFF table CID Font FDSelect has bad FD index value " + a3 + " (FD count " + n3 + ")");
          if (l3 > r3) throw new Error("CFF Table CID Font FDSelect format 3 range has bad GID " + l3);
          for (; c3 < l3; c3++) o3.push(a3);
          c3 = l3;
        }
        if (l3 !== r3) throw new Error("CFF Table CID Font FDSelect format 3 range has bad final GID " + l3);
      }
      return o3;
    }(e3, h2, r2.numGlyphs, d2.length);
  }
  var v2, g2 = t2 + p2.private[1], m2 = Ve(e3, g2, p2.private[0], i2.objects);
  if (r2.defaultWidthX = m2.defaultWidthX, r2.nominalWidthX = m2.nominalWidthX, 0 !== m2.subrs) {
    var y2 = g2 + m2.subrs, b2 = Ae(e3, y2);
    r2.subrs = b2.objects, r2.subrsBias = Pe(r2.subrs);
  } else r2.subrs = [], r2.subrsBias = 0;
  n2.lowMemory ? (v2 = function(e4, t3) {
    var r3, n3, a3 = [], o3 = se.getCard16(e4, t3);
    if (0 !== o3) {
      var s3 = se.getByte(e4, t3 + 2);
      r3 = t3 + (o3 + 1) * s3 + 2;
      for (var i3 = t3 + 3, u3 = 0; u3 < o3 + 1; u3 += 1) a3.push(se.getOffset(e4, i3, s3)), i3 += s3;
      n3 = r3 + a3[o3];
    } else n3 = t3 + 2;
    return { offsets: a3, startOffset: t3, endOffset: n3 };
  }(e3, t2 + p2.charStrings), r2.nGlyphs = v2.offsets.length) : (v2 = Ae(e3, t2 + p2.charStrings), r2.nGlyphs = v2.objects.length);
  var S2 = function(e4, t3, r3, n3) {
    var a3, o3, s3 = new se.Parser(e4, t3);
    r3 -= 1;
    var i3 = [".notdef"], u3 = s3.parseCard8();
    if (0 === u3) for (var l3 = 0; l3 < r3; l3 += 1) a3 = s3.parseSID(), i3.push(ze(n3, a3));
    else if (1 === u3) for (; i3.length <= r3; ) {
      a3 = s3.parseSID(), o3 = s3.parseCard8();
      for (var p3 = 0; p3 <= o3; p3 += 1) i3.push(ze(n3, a3)), a3 += 1;
    }
    else {
      if (2 !== u3) throw new Error("Unknown charset format " + u3);
      for (; i3.length <= r3; ) {
        a3 = s3.parseSID(), o3 = s3.parseCard16();
        for (var c3 = 0; c3 <= o3; c3 += 1) i3.push(ze(n3, a3)), a3 += 1;
      }
    }
    return i3;
  }(e3, t2 + p2.charset, r2.nGlyphs, i2.objects);
  if (0 === p2.encoding ? r2.cffEncoding = new Le(Ue, S2) : 1 === p2.encoding ? r2.cffEncoding = new Le(ke, S2) : r2.cffEncoding = function(e4, t3, r3) {
    var n3, a3 = {}, o3 = new se.Parser(e4, t3), s3 = o3.parseCard8();
    if (0 === s3) for (var i3 = o3.parseCard8(), u3 = 0; u3 < i3; u3 += 1) a3[n3 = o3.parseCard8()] = u3;
    else {
      if (1 !== s3) throw new Error("Unknown encoding format " + s3);
      var l3 = o3.parseCard8();
      n3 = 1;
      for (var p3 = 0; p3 < l3; p3 += 1) for (var c3 = o3.parseCard8(), h3 = o3.parseCard8(), f3 = c3; f3 <= c3 + h3; f3 += 1) a3[f3] = n3, n3 += 1;
    }
    return new Le(a3, r3);
  }(e3, t2 + p2.encoding, S2), r2.encoding = r2.encoding || r2.cffEncoding, r2.glyphs = new Be.GlyphSet(r2), n2.lowMemory) r2._push = function(n3) {
    var a3 = function(e4, t3, r3, n4, a4) {
      var o3 = se.getCard16(r3, n4), s3 = 0;
      0 !== o3 && (s3 = n4 + (o3 + 1) * se.getByte(r3, n4 + 2) + 2);
      var i3 = se.getBytes(r3, s3 + t3[e4], s3 + t3[e4 + 1]);
      return a4 && (i3 = a4(i3)), i3;
    }(n3, v2.offsets, e3, t2 + p2.charStrings);
    r2.glyphs.push(n3, Be.cffGlyphLoader(r2, n3, Ye, a3));
  };
  else for (var x2 = 0; x2 < r2.nGlyphs; x2 += 1) {
    var T2 = v2.objects[x2];
    r2.glyphs.push(x2, Be.cffGlyphLoader(r2, x2, Ye, T2));
  }
}, make: function(e3, t2) {
  for (var r2, n2 = new J.Table("CFF ", [{ name: "header", type: "RECORD" }, { name: "nameIndex", type: "RECORD" }, { name: "topDictIndex", type: "RECORD" }, { name: "stringIndex", type: "RECORD" }, { name: "globalSubrIndex", type: "RECORD" }, { name: "charsets", type: "RECORD" }, { name: "charStringsIndex", type: "RECORD" }, { name: "privateDict", type: "RECORD" }]), a2 = 1 / t2.unitsPerEm, o2 = { version: t2.version, fullName: t2.fullName, familyName: t2.familyName, weight: t2.weightName, fontBBox: t2.fontBBox || [0, 0, 0, 0], fontMatrix: [a2, 0, 0, a2, 0, 0], charset: 999, encoding: 0, charStrings: 999, private: [0, 999] }, s2 = [], i2 = 1; i2 < e3.length; i2 += 1) r2 = e3.get(i2), s2.push(r2.name);
  var u2 = [];
  n2.header = new J.Record("Header", [{ name: "major", type: "Card8", value: 1 }, { name: "minor", type: "Card8", value: 0 }, { name: "hdrSize", type: "Card8", value: 4 }, { name: "major", type: "Card8", value: 1 }]), n2.nameIndex = function(e4) {
    var t3 = new J.Record("Name INDEX", [{ name: "names", type: "INDEX", value: [] }]);
    t3.names = [];
    for (var r3 = 0; r3 < e4.length; r3 += 1) t3.names.push({ name: "name_" + r3, type: "NAME", value: e4[r3] });
    return t3;
  }([t2.postScriptName]);
  var l2 = Ke(o2, u2);
  n2.topDictIndex = Je(l2), n2.globalSubrIndex = new J.Record("Global Subr INDEX", [{ name: "subrs", type: "INDEX", value: [] }]), n2.charsets = function(e4, t3) {
    for (var r3 = new J.Record("Charsets", [{ name: "format", type: "Card8", value: 0 }]), n3 = 0; n3 < e4.length; n3 += 1) {
      var a3 = Ze(e4[n3], t3);
      r3.fields.push({ name: "glyph_" + n3, type: "SID", value: a3 });
    }
    return r3;
  }(s2, u2), n2.charStringsIndex = function(e4) {
    for (var t3 = new J.Record("CharStrings INDEX", [{ name: "charStrings", type: "INDEX", value: [] }]), r3 = 0; r3 < e4.length; r3 += 1) {
      var n3 = e4.get(r3), a3 = $e(n3);
      t3.charStrings.push({ name: n3.name, type: "CHARSTRING", value: a3 });
    }
    return t3;
  }(e3), n2.privateDict = function(e4, t3) {
    var r3 = new J.Record("Private DICT", [{ name: "dict", type: "DICT", value: {} }]);
    return r3.dict = Qe(_e, e4, t3), r3;
  }({}, u2), n2.stringIndex = function(e4) {
    var t3 = new J.Record("String INDEX", [{ name: "strings", type: "INDEX", value: [] }]);
    t3.strings = [];
    for (var r3 = 0; r3 < e4.length; r3 += 1) t3.strings.push({ name: "string_" + r3, type: "STRING", value: e4[r3] });
    return t3;
  }(u2);
  var p2 = n2.header.sizeOf() + n2.nameIndex.sizeOf() + n2.topDictIndex.sizeOf() + n2.stringIndex.sizeOf() + n2.globalSubrIndex.sizeOf();
  return o2.charset = p2, o2.encoding = 0, o2.charStrings = o2.charset + n2.charsets.sizeOf(), o2.private[1] = o2.charStrings + n2.charStringsIndex.sizeOf(), l2 = Ke(o2, u2), n2.topDictIndex = Je(l2), n2;
} };
var tt = { parse: function(e3, t2) {
  var r2 = {}, n2 = new se.Parser(e3, t2);
  return r2.version = n2.parseVersion(), r2.fontRevision = Math.round(1e3 * n2.parseFixed()) / 1e3, r2.checkSumAdjustment = n2.parseULong(), r2.magicNumber = n2.parseULong(), w.argument(1594834165 === r2.magicNumber, "Font header has wrong magic number."), r2.flags = n2.parseUShort(), r2.unitsPerEm = n2.parseUShort(), r2.created = n2.parseLongDateTime(), r2.modified = n2.parseLongDateTime(), r2.xMin = n2.parseShort(), r2.yMin = n2.parseShort(), r2.xMax = n2.parseShort(), r2.yMax = n2.parseShort(), r2.macStyle = n2.parseUShort(), r2.lowestRecPPEM = n2.parseUShort(), r2.fontDirectionHint = n2.parseShort(), r2.indexToLocFormat = n2.parseShort(), r2.glyphDataFormat = n2.parseShort(), r2;
}, make: function(e3) {
  var t2 = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) + 2082844800, r2 = t2;
  return e3.createdTimestamp && (r2 = e3.createdTimestamp + 2082844800), new J.Table("head", [{ name: "version", type: "FIXED", value: 65536 }, { name: "fontRevision", type: "FIXED", value: 65536 }, { name: "checkSumAdjustment", type: "ULONG", value: 0 }, { name: "magicNumber", type: "ULONG", value: 1594834165 }, { name: "flags", type: "USHORT", value: 0 }, { name: "unitsPerEm", type: "USHORT", value: 1e3 }, { name: "created", type: "LONGDATETIME", value: r2 }, { name: "modified", type: "LONGDATETIME", value: t2 }, { name: "xMin", type: "SHORT", value: 0 }, { name: "yMin", type: "SHORT", value: 0 }, { name: "xMax", type: "SHORT", value: 0 }, { name: "yMax", type: "SHORT", value: 0 }, { name: "macStyle", type: "USHORT", value: 0 }, { name: "lowestRecPPEM", type: "USHORT", value: 0 }, { name: "fontDirectionHint", type: "SHORT", value: 2 }, { name: "indexToLocFormat", type: "SHORT", value: 0 }, { name: "glyphDataFormat", type: "SHORT", value: 0 }], e3);
} };
var rt = { parse: function(e3, t2) {
  var r2 = {}, n2 = new se.Parser(e3, t2);
  return r2.version = n2.parseVersion(), r2.ascender = n2.parseShort(), r2.descender = n2.parseShort(), r2.lineGap = n2.parseShort(), r2.advanceWidthMax = n2.parseUShort(), r2.minLeftSideBearing = n2.parseShort(), r2.minRightSideBearing = n2.parseShort(), r2.xMaxExtent = n2.parseShort(), r2.caretSlopeRise = n2.parseShort(), r2.caretSlopeRun = n2.parseShort(), r2.caretOffset = n2.parseShort(), n2.relativeOffset += 8, r2.metricDataFormat = n2.parseShort(), r2.numberOfHMetrics = n2.parseUShort(), r2;
}, make: function(e3) {
  return new J.Table("hhea", [{ name: "version", type: "FIXED", value: 65536 }, { name: "ascender", type: "FWORD", value: 0 }, { name: "descender", type: "FWORD", value: 0 }, { name: "lineGap", type: "FWORD", value: 0 }, { name: "advanceWidthMax", type: "UFWORD", value: 0 }, { name: "minLeftSideBearing", type: "FWORD", value: 0 }, { name: "minRightSideBearing", type: "FWORD", value: 0 }, { name: "xMaxExtent", type: "FWORD", value: 0 }, { name: "caretSlopeRise", type: "SHORT", value: 1 }, { name: "caretSlopeRun", type: "SHORT", value: 0 }, { name: "caretOffset", type: "SHORT", value: 0 }, { name: "reserved1", type: "SHORT", value: 0 }, { name: "reserved2", type: "SHORT", value: 0 }, { name: "reserved3", type: "SHORT", value: 0 }, { name: "reserved4", type: "SHORT", value: 0 }, { name: "metricDataFormat", type: "SHORT", value: 0 }, { name: "numberOfHMetrics", type: "USHORT", value: 0 }], e3);
} };
var nt = { parse: function(e3, t2, r2, n2, a2, o2, s2) {
  s2.lowMemory ? function(e4, t3, r3, n3, a3) {
    var o3, s3;
    e4._hmtxTableData = {};
    for (var i2 = new se.Parser(t3, r3), u2 = 0; u2 < a3; u2 += 1) u2 < n3 && (o3 = i2.parseUShort(), s3 = i2.parseShort()), e4._hmtxTableData[u2] = { advanceWidth: o3, leftSideBearing: s3 };
  }(e3, t2, r2, n2, a2) : function(e4, t3, r3, n3, a3) {
    for (var o3, s3, i2 = new se.Parser(e4, t3), u2 = 0; u2 < n3; u2 += 1) {
      u2 < r3 && (o3 = i2.parseUShort(), s3 = i2.parseShort());
      var l2 = a3.get(u2);
      l2.advanceWidth = o3, l2.leftSideBearing = s3;
    }
  }(t2, r2, n2, a2, o2);
}, make: function(e3) {
  for (var t2 = new J.Table("hmtx", []), r2 = 0; r2 < e3.length; r2 += 1) {
    var n2 = e3.get(r2), a2 = n2.advanceWidth || 0, o2 = n2.leftSideBearing || 0;
    t2.fields.push({ name: "advanceWidth_" + r2, type: "USHORT", value: a2 }), t2.fields.push({ name: "leftSideBearing_" + r2, type: "SHORT", value: o2 });
  }
  return t2;
} };
var at = { make: function(e3) {
  for (var t2 = new J.Table("ltag", [{ name: "version", type: "ULONG", value: 1 }, { name: "flags", type: "ULONG", value: 0 }, { name: "numTags", type: "ULONG", value: e3.length }]), r2 = "", n2 = 12 + 4 * e3.length, a2 = 0; a2 < e3.length; ++a2) {
    var o2 = r2.indexOf(e3[a2]);
    o2 < 0 && (o2 = r2.length, r2 += e3[a2]), t2.fields.push({ name: "offset " + a2, type: "USHORT", value: n2 + o2 }), t2.fields.push({ name: "length " + a2, type: "USHORT", value: e3[a2].length });
  }
  return t2.fields.push({ name: "stringPool", type: "CHARARRAY", value: r2 }), t2;
}, parse: function(e3, t2) {
  var r2 = new se.Parser(e3, t2), n2 = r2.parseULong();
  w.argument(1 === n2, "Unsupported ltag table version."), r2.skip("uLong", 1);
  for (var a2 = r2.parseULong(), o2 = [], s2 = 0; s2 < a2; s2++) {
    for (var i2 = "", u2 = t2 + r2.parseUShort(), l2 = r2.parseUShort(), p2 = u2; p2 < u2 + l2; ++p2) i2 += String.fromCharCode(e3.getInt8(p2));
    o2.push(i2);
  }
  return o2;
} };
var ot = { parse: function(e3, t2) {
  var r2 = {}, n2 = new se.Parser(e3, t2);
  return r2.version = n2.parseVersion(), r2.numGlyphs = n2.parseUShort(), 1 === r2.version && (r2.maxPoints = n2.parseUShort(), r2.maxContours = n2.parseUShort(), r2.maxCompositePoints = n2.parseUShort(), r2.maxCompositeContours = n2.parseUShort(), r2.maxZones = n2.parseUShort(), r2.maxTwilightPoints = n2.parseUShort(), r2.maxStorage = n2.parseUShort(), r2.maxFunctionDefs = n2.parseUShort(), r2.maxInstructionDefs = n2.parseUShort(), r2.maxStackElements = n2.parseUShort(), r2.maxSizeOfInstructions = n2.parseUShort(), r2.maxComponentElements = n2.parseUShort(), r2.maxComponentDepth = n2.parseUShort()), r2;
}, make: function(e3) {
  return new J.Table("maxp", [{ name: "version", type: "FIXED", value: 20480 }, { name: "numGlyphs", type: "USHORT", value: e3 }]);
} };
var st = [{ begin: 0, end: 127 }, { begin: 128, end: 255 }, { begin: 256, end: 383 }, { begin: 384, end: 591 }, { begin: 592, end: 687 }, { begin: 688, end: 767 }, { begin: 768, end: 879 }, { begin: 880, end: 1023 }, { begin: 11392, end: 11519 }, { begin: 1024, end: 1279 }, { begin: 1328, end: 1423 }, { begin: 1424, end: 1535 }, { begin: 42240, end: 42559 }, { begin: 1536, end: 1791 }, { begin: 1984, end: 2047 }, { begin: 2304, end: 2431 }, { begin: 2432, end: 2559 }, { begin: 2560, end: 2687 }, { begin: 2688, end: 2815 }, { begin: 2816, end: 2943 }, { begin: 2944, end: 3071 }, { begin: 3072, end: 3199 }, { begin: 3200, end: 3327 }, { begin: 3328, end: 3455 }, { begin: 3584, end: 3711 }, { begin: 3712, end: 3839 }, { begin: 4256, end: 4351 }, { begin: 6912, end: 7039 }, { begin: 4352, end: 4607 }, { begin: 7680, end: 7935 }, { begin: 7936, end: 8191 }, { begin: 8192, end: 8303 }, { begin: 8304, end: 8351 }, { begin: 8352, end: 8399 }, { begin: 8400, end: 8447 }, { begin: 8448, end: 8527 }, { begin: 8528, end: 8591 }, { begin: 8592, end: 8703 }, { begin: 8704, end: 8959 }, { begin: 8960, end: 9215 }, { begin: 9216, end: 9279 }, { begin: 9280, end: 9311 }, { begin: 9312, end: 9471 }, { begin: 9472, end: 9599 }, { begin: 9600, end: 9631 }, { begin: 9632, end: 9727 }, { begin: 9728, end: 9983 }, { begin: 9984, end: 10175 }, { begin: 12288, end: 12351 }, { begin: 12352, end: 12447 }, { begin: 12448, end: 12543 }, { begin: 12544, end: 12591 }, { begin: 12592, end: 12687 }, { begin: 43072, end: 43135 }, { begin: 12800, end: 13055 }, { begin: 13056, end: 13311 }, { begin: 44032, end: 55215 }, { begin: 55296, end: 57343 }, { begin: 67840, end: 67871 }, { begin: 19968, end: 40959 }, { begin: 57344, end: 63743 }, { begin: 12736, end: 12783 }, { begin: 64256, end: 64335 }, { begin: 64336, end: 65023 }, { begin: 65056, end: 65071 }, { begin: 65040, end: 65055 }, { begin: 65104, end: 65135 }, { begin: 65136, end: 65279 }, { begin: 65280, end: 65519 }, { begin: 65520, end: 65535 }, { begin: 3840, end: 4095 }, { begin: 1792, end: 1871 }, { begin: 1920, end: 1983 }, { begin: 3456, end: 3583 }, { begin: 4096, end: 4255 }, { begin: 4608, end: 4991 }, { begin: 5024, end: 5119 }, { begin: 5120, end: 5759 }, { begin: 5760, end: 5791 }, { begin: 5792, end: 5887 }, { begin: 6016, end: 6143 }, { begin: 6144, end: 6319 }, { begin: 10240, end: 10495 }, { begin: 40960, end: 42127 }, { begin: 5888, end: 5919 }, { begin: 66304, end: 66351 }, { begin: 66352, end: 66383 }, { begin: 66560, end: 66639 }, { begin: 118784, end: 119039 }, { begin: 119808, end: 120831 }, { begin: 1044480, end: 1048573 }, { begin: 65024, end: 65039 }, { begin: 917504, end: 917631 }, { begin: 6400, end: 6479 }, { begin: 6480, end: 6527 }, { begin: 6528, end: 6623 }, { begin: 6656, end: 6687 }, { begin: 11264, end: 11359 }, { begin: 11568, end: 11647 }, { begin: 19904, end: 19967 }, { begin: 43008, end: 43055 }, { begin: 65536, end: 65663 }, { begin: 65856, end: 65935 }, { begin: 66432, end: 66463 }, { begin: 66464, end: 66527 }, { begin: 66640, end: 66687 }, { begin: 66688, end: 66735 }, { begin: 67584, end: 67647 }, { begin: 68096, end: 68191 }, { begin: 119552, end: 119647 }, { begin: 73728, end: 74751 }, { begin: 119648, end: 119679 }, { begin: 7040, end: 7103 }, { begin: 7168, end: 7247 }, { begin: 7248, end: 7295 }, { begin: 43136, end: 43231 }, { begin: 43264, end: 43311 }, { begin: 43312, end: 43359 }, { begin: 43520, end: 43615 }, { begin: 65936, end: 65999 }, { begin: 66e3, end: 66047 }, { begin: 66208, end: 66271 }, { begin: 127024, end: 127135 }];
var it = { parse: function(e3, t2) {
  var r2 = {}, n2 = new se.Parser(e3, t2);
  r2.version = n2.parseUShort(), r2.xAvgCharWidth = n2.parseShort(), r2.usWeightClass = n2.parseUShort(), r2.usWidthClass = n2.parseUShort(), r2.fsType = n2.parseUShort(), r2.ySubscriptXSize = n2.parseShort(), r2.ySubscriptYSize = n2.parseShort(), r2.ySubscriptXOffset = n2.parseShort(), r2.ySubscriptYOffset = n2.parseShort(), r2.ySuperscriptXSize = n2.parseShort(), r2.ySuperscriptYSize = n2.parseShort(), r2.ySuperscriptXOffset = n2.parseShort(), r2.ySuperscriptYOffset = n2.parseShort(), r2.yStrikeoutSize = n2.parseShort(), r2.yStrikeoutPosition = n2.parseShort(), r2.sFamilyClass = n2.parseShort(), r2.panose = [];
  for (var a2 = 0; a2 < 10; a2++) r2.panose[a2] = n2.parseByte();
  return r2.ulUnicodeRange1 = n2.parseULong(), r2.ulUnicodeRange2 = n2.parseULong(), r2.ulUnicodeRange3 = n2.parseULong(), r2.ulUnicodeRange4 = n2.parseULong(), r2.achVendID = String.fromCharCode(n2.parseByte(), n2.parseByte(), n2.parseByte(), n2.parseByte()), r2.fsSelection = n2.parseUShort(), r2.usFirstCharIndex = n2.parseUShort(), r2.usLastCharIndex = n2.parseUShort(), r2.sTypoAscender = n2.parseShort(), r2.sTypoDescender = n2.parseShort(), r2.sTypoLineGap = n2.parseShort(), r2.usWinAscent = n2.parseUShort(), r2.usWinDescent = n2.parseUShort(), r2.version >= 1 && (r2.ulCodePageRange1 = n2.parseULong(), r2.ulCodePageRange2 = n2.parseULong()), r2.version >= 2 && (r2.sxHeight = n2.parseShort(), r2.sCapHeight = n2.parseShort(), r2.usDefaultChar = n2.parseUShort(), r2.usBreakChar = n2.parseUShort(), r2.usMaxContent = n2.parseUShort()), r2;
}, make: function(e3) {
  return new J.Table("OS/2", [{ name: "version", type: "USHORT", value: 3 }, { name: "xAvgCharWidth", type: "SHORT", value: 0 }, { name: "usWeightClass", type: "USHORT", value: 0 }, { name: "usWidthClass", type: "USHORT", value: 0 }, { name: "fsType", type: "USHORT", value: 0 }, { name: "ySubscriptXSize", type: "SHORT", value: 650 }, { name: "ySubscriptYSize", type: "SHORT", value: 699 }, { name: "ySubscriptXOffset", type: "SHORT", value: 0 }, { name: "ySubscriptYOffset", type: "SHORT", value: 140 }, { name: "ySuperscriptXSize", type: "SHORT", value: 650 }, { name: "ySuperscriptYSize", type: "SHORT", value: 699 }, { name: "ySuperscriptXOffset", type: "SHORT", value: 0 }, { name: "ySuperscriptYOffset", type: "SHORT", value: 479 }, { name: "yStrikeoutSize", type: "SHORT", value: 49 }, { name: "yStrikeoutPosition", type: "SHORT", value: 258 }, { name: "sFamilyClass", type: "SHORT", value: 0 }, { name: "bFamilyType", type: "BYTE", value: 0 }, { name: "bSerifStyle", type: "BYTE", value: 0 }, { name: "bWeight", type: "BYTE", value: 0 }, { name: "bProportion", type: "BYTE", value: 0 }, { name: "bContrast", type: "BYTE", value: 0 }, { name: "bStrokeVariation", type: "BYTE", value: 0 }, { name: "bArmStyle", type: "BYTE", value: 0 }, { name: "bLetterform", type: "BYTE", value: 0 }, { name: "bMidline", type: "BYTE", value: 0 }, { name: "bXHeight", type: "BYTE", value: 0 }, { name: "ulUnicodeRange1", type: "ULONG", value: 0 }, { name: "ulUnicodeRange2", type: "ULONG", value: 0 }, { name: "ulUnicodeRange3", type: "ULONG", value: 0 }, { name: "ulUnicodeRange4", type: "ULONG", value: 0 }, { name: "achVendID", type: "CHARARRAY", value: "XXXX" }, { name: "fsSelection", type: "USHORT", value: 0 }, { name: "usFirstCharIndex", type: "USHORT", value: 0 }, { name: "usLastCharIndex", type: "USHORT", value: 0 }, { name: "sTypoAscender", type: "SHORT", value: 0 }, { name: "sTypoDescender", type: "SHORT", value: 0 }, { name: "sTypoLineGap", type: "SHORT", value: 0 }, { name: "usWinAscent", type: "USHORT", value: 0 }, { name: "usWinDescent", type: "USHORT", value: 0 }, { name: "ulCodePageRange1", type: "ULONG", value: 0 }, { name: "ulCodePageRange2", type: "ULONG", value: 0 }, { name: "sxHeight", type: "SHORT", value: 0 }, { name: "sCapHeight", type: "SHORT", value: 0 }, { name: "usDefaultChar", type: "USHORT", value: 0 }, { name: "usBreakChar", type: "USHORT", value: 0 }, { name: "usMaxContext", type: "USHORT", value: 0 }], e3);
}, unicodeRanges: st, getUnicodeRange: function(e3) {
  for (var t2 = 0; t2 < st.length; t2 += 1) {
    var r2 = st[t2];
    if (e3 >= r2.begin && e3 < r2.end) return t2;
  }
  return -1;
} };
var ut = { parse: function(e3, t2) {
  var r2 = {}, n2 = new se.Parser(e3, t2);
  switch (r2.version = n2.parseVersion(), r2.italicAngle = n2.parseFixed(), r2.underlinePosition = n2.parseShort(), r2.underlineThickness = n2.parseShort(), r2.isFixedPitch = n2.parseULong(), r2.minMemType42 = n2.parseULong(), r2.maxMemType42 = n2.parseULong(), r2.minMemType1 = n2.parseULong(), r2.maxMemType1 = n2.parseULong(), r2.version) {
    case 1:
      r2.names = Oe.slice();
      break;
    case 2:
      r2.numberOfGlyphs = n2.parseUShort(), r2.glyphNameIndex = new Array(r2.numberOfGlyphs);
      for (var a2 = 0; a2 < r2.numberOfGlyphs; a2++) r2.glyphNameIndex[a2] = n2.parseUShort();
      r2.names = [];
      for (var o2 = 0; o2 < r2.numberOfGlyphs; o2++) if (r2.glyphNameIndex[o2] >= Oe.length) {
        var s2 = n2.parseChar();
        r2.names.push(n2.parseString(s2));
      }
      break;
    case 2.5:
      r2.numberOfGlyphs = n2.parseUShort(), r2.offset = new Array(r2.numberOfGlyphs);
      for (var i2 = 0; i2 < r2.numberOfGlyphs; i2++) r2.offset[i2] = n2.parseChar();
  }
  return r2;
}, make: function() {
  return new J.Table("post", [{ name: "version", type: "FIXED", value: 196608 }, { name: "italicAngle", type: "FIXED", value: 0 }, { name: "underlinePosition", type: "FWORD", value: 0 }, { name: "underlineThickness", type: "FWORD", value: 0 }, { name: "isFixedPitch", type: "ULONG", value: 0 }, { name: "minMemType42", type: "ULONG", value: 0 }, { name: "maxMemType42", type: "ULONG", value: 0 }, { name: "minMemType1", type: "ULONG", value: 0 }, { name: "maxMemType1", type: "ULONG", value: 0 }]);
} };
var lt = new Array(9);
lt[1] = function() {
  var e3 = this.offset + this.relativeOffset, t2 = this.parseUShort();
  return 1 === t2 ? { substFormat: 1, coverage: this.parsePointer(ae.coverage), deltaGlyphId: this.parseShort() } : 2 === t2 ? { substFormat: 2, coverage: this.parsePointer(ae.coverage), substitute: this.parseOffset16List() } : void w.assert(false, "0x" + e3.toString(16) + ": lookup type 1 format must be 1 or 2.");
}, lt[2] = function() {
  var e3 = this.parseUShort();
  return w.argument(1 === e3, "GSUB Multiple Substitution Subtable identifier-format must be 1"), { substFormat: e3, coverage: this.parsePointer(ae.coverage), sequences: this.parseListOfLists() };
}, lt[3] = function() {
  var e3 = this.parseUShort();
  return w.argument(1 === e3, "GSUB Alternate Substitution Subtable identifier-format must be 1"), { substFormat: e3, coverage: this.parsePointer(ae.coverage), alternateSets: this.parseListOfLists() };
}, lt[4] = function() {
  var e3 = this.parseUShort();
  return w.argument(1 === e3, "GSUB ligature table identifier-format must be 1"), { substFormat: e3, coverage: this.parsePointer(ae.coverage), ligatureSets: this.parseListOfLists(function() {
    return { ligGlyph: this.parseUShort(), components: this.parseUShortList(this.parseUShort() - 1) };
  }) };
};
var pt = { sequenceIndex: ae.uShort, lookupListIndex: ae.uShort };
lt[5] = function() {
  var e3 = this.offset + this.relativeOffset, t2 = this.parseUShort();
  if (1 === t2) return { substFormat: t2, coverage: this.parsePointer(ae.coverage), ruleSets: this.parseListOfLists(function() {
    var e4 = this.parseUShort(), t3 = this.parseUShort();
    return { input: this.parseUShortList(e4 - 1), lookupRecords: this.parseRecordList(t3, pt) };
  }) };
  if (2 === t2) return { substFormat: t2, coverage: this.parsePointer(ae.coverage), classDef: this.parsePointer(ae.classDef), classSets: this.parseListOfLists(function() {
    var e4 = this.parseUShort(), t3 = this.parseUShort();
    return { classes: this.parseUShortList(e4 - 1), lookupRecords: this.parseRecordList(t3, pt) };
  }) };
  if (3 === t2) {
    var r2 = this.parseUShort(), n2 = this.parseUShort();
    return { substFormat: t2, coverages: this.parseList(r2, ae.pointer(ae.coverage)), lookupRecords: this.parseRecordList(n2, pt) };
  }
  w.assert(false, "0x" + e3.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");
}, lt[6] = function() {
  var e3 = this.offset + this.relativeOffset, t2 = this.parseUShort();
  return 1 === t2 ? { substFormat: 1, coverage: this.parsePointer(ae.coverage), chainRuleSets: this.parseListOfLists(function() {
    return { backtrack: this.parseUShortList(), input: this.parseUShortList(this.parseShort() - 1), lookahead: this.parseUShortList(), lookupRecords: this.parseRecordList(pt) };
  }) } : 2 === t2 ? { substFormat: 2, coverage: this.parsePointer(ae.coverage), backtrackClassDef: this.parsePointer(ae.classDef), inputClassDef: this.parsePointer(ae.classDef), lookaheadClassDef: this.parsePointer(ae.classDef), chainClassSet: this.parseListOfLists(function() {
    return { backtrack: this.parseUShortList(), input: this.parseUShortList(this.parseShort() - 1), lookahead: this.parseUShortList(), lookupRecords: this.parseRecordList(pt) };
  }) } : 3 === t2 ? { substFormat: 3, backtrackCoverage: this.parseList(ae.pointer(ae.coverage)), inputCoverage: this.parseList(ae.pointer(ae.coverage)), lookaheadCoverage: this.parseList(ae.pointer(ae.coverage)), lookupRecords: this.parseRecordList(pt) } : void w.assert(false, "0x" + e3.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");
}, lt[7] = function() {
  var e3 = this.parseUShort();
  w.argument(1 === e3, "GSUB Extension Substitution subtable identifier-format must be 1");
  var t2 = this.parseUShort(), r2 = new ae(this.data, this.offset + this.parseULong());
  return { substFormat: 1, lookupType: t2, extension: lt[t2].call(r2) };
}, lt[8] = function() {
  var e3 = this.parseUShort();
  return w.argument(1 === e3, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1"), { substFormat: e3, coverage: this.parsePointer(ae.coverage), backtrackCoverage: this.parseList(ae.pointer(ae.coverage)), lookaheadCoverage: this.parseList(ae.pointer(ae.coverage)), substitutes: this.parseUShortList() };
};
var ct = new Array(9);
ct[1] = function(e3) {
  return 1 === e3.substFormat ? new J.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 1 }, { name: "coverage", type: "TABLE", value: new J.Coverage(e3.coverage) }, { name: "deltaGlyphID", type: "SHORT", value: e3.deltaGlyphId }]) : new J.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 2 }, { name: "coverage", type: "TABLE", value: new J.Coverage(e3.coverage) }].concat(J.ushortList("substitute", e3.substitute)));
}, ct[2] = function(e3) {
  return w.assert(1 === e3.substFormat, "Lookup type 2 substFormat must be 1."), new J.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 1 }, { name: "coverage", type: "TABLE", value: new J.Coverage(e3.coverage) }].concat(J.tableList("seqSet", e3.sequences, function(e4) {
    return new J.Table("sequenceSetTable", J.ushortList("sequence", e4));
  })));
}, ct[3] = function(e3) {
  return w.assert(1 === e3.substFormat, "Lookup type 3 substFormat must be 1."), new J.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 1 }, { name: "coverage", type: "TABLE", value: new J.Coverage(e3.coverage) }].concat(J.tableList("altSet", e3.alternateSets, function(e4) {
    return new J.Table("alternateSetTable", J.ushortList("alternate", e4));
  })));
}, ct[4] = function(e3) {
  return w.assert(1 === e3.substFormat, "Lookup type 4 substFormat must be 1."), new J.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 1 }, { name: "coverage", type: "TABLE", value: new J.Coverage(e3.coverage) }].concat(J.tableList("ligSet", e3.ligatureSets, function(e4) {
    return new J.Table("ligatureSetTable", J.tableList("ligature", e4, function(e5) {
      return new J.Table("ligatureTable", [{ name: "ligGlyph", type: "USHORT", value: e5.ligGlyph }].concat(J.ushortList("component", e5.components, e5.components.length + 1)));
    }));
  })));
}, ct[6] = function(e3) {
  if (1 === e3.substFormat) {
    var t2 = new J.Table("chainContextTable", [{ name: "substFormat", type: "USHORT", value: e3.substFormat }, { name: "coverage", type: "TABLE", value: new J.Coverage(e3.coverage) }].concat(J.tableList("chainRuleSet", e3.chainRuleSets, function(e4) {
      return new J.Table("chainRuleSetTable", J.tableList("chainRule", e4, function(e5) {
        var t3 = J.ushortList("backtrackGlyph", e5.backtrack, e5.backtrack.length).concat(J.ushortList("inputGlyph", e5.input, e5.input.length + 1)).concat(J.ushortList("lookaheadGlyph", e5.lookahead, e5.lookahead.length)).concat(J.ushortList("substitution", [], e5.lookupRecords.length));
        return e5.lookupRecords.forEach(function(e6, r3) {
          t3 = t3.concat({ name: "sequenceIndex" + r3, type: "USHORT", value: e6.sequenceIndex }).concat({ name: "lookupListIndex" + r3, type: "USHORT", value: e6.lookupListIndex });
        }), new J.Table("chainRuleTable", t3);
      }));
    })));
    return t2;
  }
  if (2 === e3.substFormat) w.assert(false, "lookup type 6 format 2 is not yet supported.");
  else if (3 === e3.substFormat) {
    var r2 = [{ name: "substFormat", type: "USHORT", value: e3.substFormat }];
    return r2.push({ name: "backtrackGlyphCount", type: "USHORT", value: e3.backtrackCoverage.length }), e3.backtrackCoverage.forEach(function(e4, t3) {
      r2.push({ name: "backtrackCoverage" + t3, type: "TABLE", value: new J.Coverage(e4) });
    }), r2.push({ name: "inputGlyphCount", type: "USHORT", value: e3.inputCoverage.length }), e3.inputCoverage.forEach(function(e4, t3) {
      r2.push({ name: "inputCoverage" + t3, type: "TABLE", value: new J.Coverage(e4) });
    }), r2.push({ name: "lookaheadGlyphCount", type: "USHORT", value: e3.lookaheadCoverage.length }), e3.lookaheadCoverage.forEach(function(e4, t3) {
      r2.push({ name: "lookaheadCoverage" + t3, type: "TABLE", value: new J.Coverage(e4) });
    }), r2.push({ name: "substitutionCount", type: "USHORT", value: e3.lookupRecords.length }), e3.lookupRecords.forEach(function(e4, t3) {
      r2 = r2.concat({ name: "sequenceIndex" + t3, type: "USHORT", value: e4.sequenceIndex }).concat({ name: "lookupListIndex" + t3, type: "USHORT", value: e4.lookupListIndex });
    }), new J.Table("chainContextTable", r2);
  }
  w.assert(false, "lookup type 6 format must be 1, 2 or 3.");
};
var ht = { parse: function(e3, t2) {
  var r2 = new ae(e3, t2 = t2 || 0), n2 = r2.parseVersion(1);
  return w.argument(1 === n2 || 1.1 === n2, "Unsupported GSUB table version."), 1 === n2 ? { version: n2, scripts: r2.parseScriptList(), features: r2.parseFeatureList(), lookups: r2.parseLookupList(lt) } : { version: n2, scripts: r2.parseScriptList(), features: r2.parseFeatureList(), lookups: r2.parseLookupList(lt), variations: r2.parseFeatureVariationsList() };
}, make: function(e3) {
  return new J.Table("GSUB", [{ name: "version", type: "ULONG", value: 65536 }, { name: "scripts", type: "TABLE", value: new J.ScriptList(e3.scripts) }, { name: "features", type: "TABLE", value: new J.FeatureList(e3.features) }, { name: "lookups", type: "TABLE", value: new J.LookupList(e3.lookups, ct) }]);
} };
var ft = new Array(10);
ft[1] = function() {
  var e3 = this.offset + this.relativeOffset, t2 = this.parseUShort();
  return 1 === t2 ? { posFormat: 1, coverage: this.parsePointer(ae.coverage), value: this.parseValueRecord() } : 2 === t2 ? { posFormat: 2, coverage: this.parsePointer(ae.coverage), values: this.parseValueRecordList() } : void w.assert(false, "0x" + e3.toString(16) + ": GPOS lookup type 1 format must be 1 or 2.");
}, ft[2] = function() {
  var e3 = this.offset + this.relativeOffset, t2 = this.parseUShort();
  w.assert(1 === t2 || 2 === t2, "0x" + e3.toString(16) + ": GPOS lookup type 2 format must be 1 or 2.");
  var r2 = this.parsePointer(ae.coverage), n2 = this.parseUShort(), a2 = this.parseUShort();
  if (1 === t2) return { posFormat: t2, coverage: r2, valueFormat1: n2, valueFormat2: a2, pairSets: this.parseList(ae.pointer(ae.list(function() {
    return { secondGlyph: this.parseUShort(), value1: this.parseValueRecord(n2), value2: this.parseValueRecord(a2) };
  }))) };
  if (2 === t2) {
    var o2 = this.parsePointer(ae.classDef), s2 = this.parsePointer(ae.classDef), i2 = this.parseUShort(), u2 = this.parseUShort();
    return { posFormat: t2, coverage: r2, valueFormat1: n2, valueFormat2: a2, classDef1: o2, classDef2: s2, class1Count: i2, class2Count: u2, classRecords: this.parseList(i2, ae.list(u2, function() {
      return { value1: this.parseValueRecord(n2), value2: this.parseValueRecord(a2) };
    })) };
  }
}, ft[3] = function() {
  return { error: "GPOS Lookup 3 not supported" };
}, ft[4] = function() {
  return { error: "GPOS Lookup 4 not supported" };
}, ft[5] = function() {
  return { error: "GPOS Lookup 5 not supported" };
}, ft[6] = function() {
  return { error: "GPOS Lookup 6 not supported" };
}, ft[7] = function() {
  return { error: "GPOS Lookup 7 not supported" };
}, ft[8] = function() {
  return { error: "GPOS Lookup 8 not supported" };
}, ft[9] = function() {
  return { error: "GPOS Lookup 9 not supported" };
};
var dt = { parse: function(e3, t2) {
  var r2 = new ae(e3, t2 = t2 || 0), n2 = r2.parseVersion(1);
  return w.argument(1 === n2 || 1.1 === n2, "Unsupported GPOS table version " + n2), 1 === n2 ? { version: n2, scripts: r2.parseScriptList(), features: r2.parseFeatureList(), lookups: r2.parseLookupList(ft) } : { version: n2, scripts: r2.parseScriptList(), features: r2.parseFeatureList(), lookups: r2.parseLookupList(ft), variations: r2.parseFeatureVariationsList() };
}, make: function(e3) {
  var t2 = Object.entries(e3);
  t2.sort(function(e4, t3) {
    var r3 = parseInt(e4[0].match(/\d+/)[0]), n3 = parseInt(e4[0].match(/\d+$/)[0]), a3 = parseInt(t3[0].match(/\d+/)[0]), o3 = parseInt(t3[0].match(/\d+$/)[0]);
    return r3 < a3 ? -1 : r3 > a3 ? 1 : n3 < o3 ? -1 : 1;
  });
  for (var r2 = t2.length, n2 = [], a2 = [], o2 = 0; o2 < r2; o2++) {
    var s2 = parseInt(t2[o2][0].match(/\d+/)[0]), i2 = parseInt(t2[o2][0].match(/\d+$/)[0]);
    s2 !== n2[n2.length - 1] && (n2.push(s2), a2[n2.length - 1] = []), a2[n2.length - 1].push([i2, t2[o2][1]]);
  }
  for (var u2 = new J.Table("GPOS", [{ name: "majorVersion", type: "USHORT", value: 1 }, { name: "minorVersion", type: "USHORT", value: 0 }, { name: "scriptListOffset", type: "USHORT", value: 10 }, { name: "featureListOffset", type: "USHORT", value: 48 }, { name: "lookupListOffset", type: "USHORT", value: 62 }, { name: "scriptCount", type: "USHORT", value: 2 }, { name: "scriptTag", type: "TAG", value: "DFLT" }, { name: "scriptOffset", type: "USHORT", value: 14 }, { name: "scriptTag2", type: "TAG", value: "latn" }, { name: "scriptOffset2", type: "USHORT", value: 26 }, { name: "defaultLangSysOffset", type: "USHORT", value: 4 }, { name: "langSysCount", type: "USHORT", value: 0 }, { name: "lookupOrderOffset", type: "USHORT", value: 0 }, { name: "requiredFeatureIndex", type: "USHORT", value: 65535 }, { name: "featureIndexCount", type: "USHORT", value: 1 }, { name: "featureIndex", type: "USHORT", value: 0 }, { name: "defaultLangSysOffset2", type: "USHORT", value: 4 }, { name: "langSysCount2", type: "USHORT", value: 0 }, { name: "lookupOrderOffset2", type: "USHORT", value: 0 }, { name: "requiredFeatureIndex2", type: "USHORT", value: 65535 }, { name: "featureIndexCount2", type: "USHORT", value: 1 }, { name: "featureIndex2", type: "USHORT", value: 0 }, { name: "featureCount", type: "USHORT", value: 1 }, { name: "featureTag", type: "TAG", value: "kern" }, { name: "featureOffset", type: "USHORT", value: 8 }, { name: "featureParamsOffset", type: "USHORT", value: 0 }, { name: "lookupIndexCount", type: "USHORT", value: 1 }, { name: "lookupListIndices", type: "USHORT", value: 0 }, { name: "lookupCount", type: "USHORT", value: 1 }, { name: "lookupOffset", type: "USHORT", value: 4 }, { name: "lookupType", type: "USHORT", value: 2 }, { name: "lookupFlag", type: "USHORT", value: 0 }, { name: "subTableCount", type: "USHORT", value: 1 }, { name: "lookupOffset2", type: "USHORT", value: 8 }, { name: "posFormat", type: "USHORT", value: 1 }, { name: "coverageOffset", type: "USHORT", value: 10 + 4 * n2.length + 4 * r2 }, { name: "valueFormat1", type: "USHORT", value: 4 }, { name: "valueFormat2", type: "USHORT", value: 0 }, { name: "pairSetCount", type: "USHORT", value: n2.length }]), l2 = 10 + 2 * n2.length, p2 = 0; p2 < n2.length; p2++) u2.fields.push({ name: "pairSetOffsets", type: "USHORT", value: l2 }), l2 = l2 + 2 + 4 * a2[p2].length;
  for (var c2 = 0; c2 < a2.length; c2++) {
    u2.fields.push({ name: "pairValueCount", type: "USHORT", value: a2[c2].length });
    for (var h2 = 0; h2 < a2[c2].length; h2++) u2.fields.push({ name: "secondGlyph", type: "USHORT", value: a2[c2][h2][0] }), u2.fields.push({ name: "valueRecord1", type: "USHORT", value: a2[c2][h2][1] });
  }
  u2.fields.push({ name: "coverageFormat", type: "USHORT", value: 1 }), u2.fields.push({ name: "glyphCount", type: "USHORT", value: n2.length });
  for (var f2 = 0; f2 < n2.length; f2++) u2.fields.push({ name: "UppercasePGlyphID", type: "USHORT", value: n2[f2] });
  return u2;
} };
var vt = { parse: function(e3, t2) {
  var r2 = new se.Parser(e3, t2), n2 = r2.parseULong();
  w.argument(1 === n2, "Unsupported META table version."), r2.parseULong(), r2.parseULong();
  for (var a2 = r2.parseULong(), o2 = {}, s2 = 0; s2 < a2; s2++) {
    var i2 = r2.parseTag(), u2 = r2.parseULong(), l2 = r2.parseULong(), p2 = I.UTF8(e3, t2 + u2, l2);
    o2[i2] = p2;
  }
  return o2;
}, make: function(e3) {
  var t2 = Object.keys(e3).length, r2 = "", n2 = 16 + 12 * t2, a2 = new J.Table("meta", [{ name: "version", type: "ULONG", value: 1 }, { name: "flags", type: "ULONG", value: 0 }, { name: "offset", type: "ULONG", value: n2 }, { name: "numTags", type: "ULONG", value: t2 }]);
  for (var o2 in e3) {
    var s2 = r2.length;
    r2 += e3[o2], a2.fields.push({ name: "tag " + o2, type: "TAG", value: o2 }), a2.fields.push({ name: "offset " + o2, type: "ULONG", value: n2 + s2 }), a2.fields.push({ name: "length " + o2, type: "ULONG", value: e3[o2].length });
  }
  return a2.fields.push({ name: "stringPool", type: "CHARARRAY", value: r2 }), a2;
} };
var gt = { parse: function(e3, t2) {
  var r2 = new ae(e3, t2), n2 = r2.parseUShort();
  w.argument(0 === n2, "Only COLRv0 supported.");
  var a2 = r2.parseUShort(), o2 = r2.parseOffset32(), s2 = r2.parseOffset32(), i2 = r2.parseUShort();
  r2.relativeOffset = o2;
  var u2 = r2.parseRecordList(a2, { glyphID: ae.uShort, firstLayerIndex: ae.uShort, numLayers: ae.uShort });
  return r2.relativeOffset = s2, { version: n2, baseGlyphRecords: u2, layerRecords: r2.parseRecordList(i2, { glyphID: ae.uShort, paletteIndex: ae.uShort }) };
}, make: function(e3) {
  var t2 = e3.version;
  void 0 === t2 && (t2 = 0);
  var r2 = e3.baseGlyphRecords;
  void 0 === r2 && (r2 = []);
  var n2 = e3.layerRecords;
  void 0 === n2 && (n2 = []), w.argument(0 === t2, "Only COLRv0 supported.");
  var a2 = 14, o2 = a2 + 6 * r2.length;
  return new J.Table("COLR", [{ name: "version", type: "USHORT", value: t2 }, { name: "numBaseGlyphRecords", type: "USHORT", value: r2.length }, { name: "baseGlyphRecordsOffset", type: "ULONG", value: a2 }, { name: "layerRecordsOffset", type: "ULONG", value: o2 }, { name: "numLayerRecords", type: "USHORT", value: n2.length }].concat(r2.map(function(e4, t3) {
    return [{ name: "glyphID_" + t3, type: "USHORT", value: e4.glyphID }, { name: "firstLayerIndex_" + t3, type: "USHORT", value: e4.firstLayerIndex }, { name: "numLayers_" + t3, type: "USHORT", value: e4.numLayers }];
  }).flat(), n2.map(function(e4, t3) {
    return [{ name: "LayerGlyphID_" + t3, type: "USHORT", value: e4.glyphID }, { name: "paletteIndex_" + t3, type: "USHORT", value: e4.paletteIndex }];
  }).flat()));
} };
var mt = { parse: function(e3, t2) {
  var r2 = new ae(e3, t2), n2 = r2.parseShort(), a2 = r2.parseShort(), o2 = r2.parseShort(), s2 = r2.parseShort(), i2 = r2.parseOffset32(), u2 = r2.parseUShortList(o2);
  return r2.relativeOffset = i2, { version: n2, numPaletteEntries: a2, colorRecords: r2.parseULongList(s2), colorRecordIndices: u2 };
}, make: function(e3) {
  var t2 = e3.version;
  void 0 === t2 && (t2 = 0);
  var r2 = e3.numPaletteEntries;
  void 0 === r2 && (r2 = 0);
  var n2 = e3.colorRecords;
  void 0 === n2 && (n2 = []);
  var a2 = e3.colorRecordIndices;
  return void 0 === a2 && (a2 = [0]), w.argument(0 === t2, "Only CPALv0 are supported."), w.argument(n2.length, "No colorRecords given."), w.argument(a2.length, "No colorRecordIndices given."), a2.length > 1 && w.argument(r2, "Can't infer numPaletteEntries on multiple colorRecordIndices"), new J.Table("CPAL", [{ name: "version", type: "USHORT", value: t2 }, { name: "numPaletteEntries", type: "USHORT", value: r2 || n2.length }, { name: "numPalettes", type: "USHORT", value: a2.length }, { name: "numColorRecords", type: "USHORT", value: n2.length }, { name: "colorRecordsArrayOffset", type: "ULONG", value: 12 + 2 * a2.length }].concat(a2.map(function(e4, t3) {
    return { name: "colorRecordIndices_" + t3, type: "USHORT", value: e4 };
  }), n2.map(function(e4, t3) {
    return { name: "colorRecords_" + t3, type: "ULONG", value: e4 };
  })));
} };
function yt(e3) {
  return Math.log(e3) / Math.log(2) | 0;
}
function bt(e3) {
  for (; e3.length % 4 != 0; ) e3.push(0);
  for (var t2 = 0, r2 = 0; r2 < e3.length; r2 += 4) t2 += (e3[r2] << 24) + (e3[r2 + 1] << 16) + (e3[r2 + 2] << 8) + e3[r2 + 3];
  return t2 %= Math.pow(2, 32);
}
function St(e3, t2, r2, n2) {
  return new J.Record("Table Record", [{ name: "tag", type: "TAG", value: void 0 !== e3 ? e3 : "" }, { name: "checkSum", type: "ULONG", value: void 0 !== t2 ? t2 : 0 }, { name: "offset", type: "ULONG", value: void 0 !== r2 ? r2 : 0 }, { name: "length", type: "ULONG", value: void 0 !== n2 ? n2 : 0 }]);
}
function xt(e3) {
  var t2 = new J.Table("sfnt", [{ name: "version", type: "TAG", value: "OTTO" }, { name: "numTables", type: "USHORT", value: 0 }, { name: "searchRange", type: "USHORT", value: 0 }, { name: "entrySelector", type: "USHORT", value: 0 }, { name: "rangeShift", type: "USHORT", value: 0 }]);
  t2.tables = e3, t2.numTables = e3.length;
  var r2 = Math.pow(2, yt(t2.numTables));
  t2.searchRange = 16 * r2, t2.entrySelector = yt(r2), t2.rangeShift = 16 * t2.numTables - t2.searchRange;
  for (var n2 = [], a2 = [], o2 = t2.sizeOf() + St().sizeOf() * t2.numTables; o2 % 4 != 0; ) o2 += 1, a2.push({ name: "padding", type: "BYTE", value: 0 });
  for (var s2 = 0; s2 < e3.length; s2 += 1) {
    var i2 = e3[s2];
    w.argument(4 === i2.tableName.length, "Table name" + i2.tableName + " is invalid.");
    var u2 = i2.sizeOf(), l2 = St(i2.tableName, bt(i2.encode()), o2, u2);
    for (n2.push({ name: l2.tag + " Table Record", type: "RECORD", value: l2 }), a2.push({ name: i2.tableName + " table", type: "RECORD", value: i2 }), o2 += u2, w.argument(!isNaN(o2), "Something went wrong calculating the offset."); o2 % 4 != 0; ) o2 += 1, a2.push({ name: "padding", type: "BYTE", value: 0 });
  }
  return n2.sort(function(e4, t3) {
    return e4.value.tag > t3.value.tag ? 1 : -1;
  }), t2.fields = t2.fields.concat(n2), t2.fields = t2.fields.concat(a2), t2;
}
function Tt(e3, t2, r2) {
  for (var n2 = 0; n2 < t2.length; n2 += 1) {
    var a2 = e3.charToGlyphIndex(t2[n2]);
    if (a2 > 0) return e3.glyphs.get(a2).getMetrics();
  }
  return r2;
}
function Ut(e3) {
  for (var t2 = 0, r2 = 0; r2 < e3.length; r2 += 1) t2 += e3[r2];
  return t2 / e3.length;
}
var kt = { make: xt, fontToTable: function(e3) {
  for (var t2, r2 = [], n2 = [], a2 = [], o2 = [], s2 = [], i2 = [], u2 = [], l2 = 0, p2 = 0, c2 = 0, h2 = 0, f2 = 0, d2 = 0; d2 < e3.glyphs.length; d2 += 1) {
    var v2 = e3.glyphs.get(d2), g2 = 0 | v2.unicode;
    if (isNaN(v2.advanceWidth)) throw new Error("Glyph " + v2.name + " (" + d2 + "): advanceWidth is not a number.");
    (t2 > g2 || void 0 === t2) && g2 > 0 && (t2 = g2), l2 < g2 && (l2 = g2);
    var m2 = it.getUnicodeRange(g2);
    if (m2 < 32) p2 |= 1 << m2;
    else if (m2 < 64) c2 |= 1 << m2 - 32;
    else if (m2 < 96) h2 |= 1 << m2 - 64;
    else {
      if (!(m2 < 123)) throw new Error("Unicode ranges bits > 123 are reserved for internal usage");
      f2 |= 1 << m2 - 96;
    }
    if (".notdef" !== v2.name) {
      var y2 = v2.getMetrics();
      r2.push(y2.xMin), n2.push(y2.yMin), a2.push(y2.xMax), o2.push(y2.yMax), i2.push(y2.leftSideBearing), u2.push(y2.rightSideBearing), s2.push(v2.advanceWidth);
    }
  }
  var b2 = { xMin: Math.min.apply(null, r2), yMin: Math.min.apply(null, n2), xMax: Math.max.apply(null, a2), yMax: Math.max.apply(null, o2), advanceWidthMax: Math.max.apply(null, s2), advanceWidthAvg: Ut(s2), minLeftSideBearing: Math.min.apply(null, i2), maxLeftSideBearing: Math.max.apply(null, i2), minRightSideBearing: Math.min.apply(null, u2) };
  b2.ascender = e3.ascender, b2.descender = e3.descender;
  var S2 = tt.make({ flags: 3, unitsPerEm: e3.unitsPerEm, xMin: b2.xMin, yMin: b2.yMin, xMax: b2.xMax, yMax: b2.yMax, lowestRecPPEM: 3, createdTimestamp: e3.createdTimestamp }), x2 = rt.make({ ascender: b2.ascender, descender: b2.descender, advanceWidthMax: b2.advanceWidthMax, minLeftSideBearing: b2.minLeftSideBearing, minRightSideBearing: b2.minRightSideBearing, xMaxExtent: b2.maxLeftSideBearing + (b2.xMax - b2.xMin), numberOfHMetrics: e3.glyphs.length }), T2 = ot.make(e3.glyphs.length), U2 = it.make(Object.assign({ xAvgCharWidth: Math.round(b2.advanceWidthAvg), usFirstCharIndex: t2, usLastCharIndex: l2, ulUnicodeRange1: p2, ulUnicodeRange2: c2, ulUnicodeRange3: h2, ulUnicodeRange4: f2, sTypoAscender: b2.ascender, sTypoDescender: b2.descender, sTypoLineGap: 0, usWinAscent: b2.yMax, usWinDescent: Math.abs(b2.yMin), ulCodePageRange1: 1, sxHeight: Tt(e3, "xyvw", { yMax: Math.round(b2.ascender / 2) }).yMax, sCapHeight: Tt(e3, "HIKLEFJMNTZBDPRAGOQSUVWXY", b2).yMax, usDefaultChar: e3.hasChar(" ") ? 32 : 0, usBreakChar: e3.hasChar(" ") ? 32 : 0 }, e3.tables.os2)), k2 = nt.make(e3.glyphs), O2 = xe.make(e3.glyphs), R2 = e3.getEnglishName("fontFamily"), E2 = e3.getEnglishName("fontSubfamily"), L2 = R2 + " " + E2, C2 = e3.getEnglishName("postScriptName");
  C2 || (C2 = R2.replace(/\s/g, "") + "-" + E2);
  var w2 = {};
  for (var D2 in e3.names) w2[D2] = e3.names[D2];
  w2.uniqueID || (w2.uniqueID = { en: e3.getEnglishName("manufacturer") + ":" + L2 }), w2.postScriptName || (w2.postScriptName = { en: C2 }), w2.preferredFamily || (w2.preferredFamily = e3.names.fontFamily), w2.preferredSubfamily || (w2.preferredSubfamily = e3.names.fontSubfamily);
  var I2 = [], G2 = be.make(w2, I2), M2 = I2.length > 0 ? at.make(I2) : void 0, B2 = ut.make(), F2 = et.make(e3.glyphs, { version: e3.getEnglishName("version"), fullName: L2, familyName: R2, weightName: E2, postScriptName: C2, unitsPerEm: e3.unitsPerEm, fontBBox: [0, b2.yMin, b2.ascender, b2.advanceWidthMax] }), P2 = e3.metas && Object.keys(e3.metas).length > 0 ? vt.make(e3.metas) : void 0, A2 = [S2, x2, T2, U2, G2, O2, B2, F2, k2];
  M2 && A2.push(M2), e3.tables.gsub && A2.push(ht.make(e3.tables.gsub)), e3.kerningPairs && Object.keys(e3.kerningPairs).length > 0 && A2.push(dt.make(e3.kerningPairs)), e3.tables.cpal && A2.push(mt.make(e3.tables.cpal)), e3.tables.colr && A2.push(gt.make(e3.tables.colr)), P2 && A2.push(P2);
  for (var N2 = xt(A2), H2 = bt(N2.encode()), z2 = N2.fields, W2 = false, q2 = 0; q2 < z2.length; q2 += 1) if ("head table" === z2[q2].name) {
    z2[q2].value.checkSumAdjustment = 2981146554 - H2, W2 = true;
    break;
  }
  if (!W2) throw new Error("Could not find head table with checkSum to adjust.");
  return N2;
}, computeCheckSum: bt };
function Ot(e3, t2) {
  for (var r2 = 0, n2 = e3.length - 1; r2 <= n2; ) {
    var a2 = r2 + n2 >>> 1, o2 = e3[a2].tag;
    if (o2 === t2) return a2;
    o2 < t2 ? r2 = a2 + 1 : n2 = a2 - 1;
  }
  return -r2 - 1;
}
function Rt(e3, t2) {
  for (var r2 = 0, n2 = e3.length - 1; r2 <= n2; ) {
    var a2 = r2 + n2 >>> 1, o2 = e3[a2];
    if (o2 === t2) return a2;
    o2 < t2 ? r2 = a2 + 1 : n2 = a2 - 1;
  }
  return -r2 - 1;
}
function Et(e3, t2) {
  for (var r2, n2 = 0, a2 = e3.length - 1; n2 <= a2; ) {
    var o2 = n2 + a2 >>> 1, s2 = (r2 = e3[o2]).start;
    if (s2 === t2) return r2;
    s2 < t2 ? n2 = o2 + 1 : a2 = o2 - 1;
  }
  if (n2 > 0) return t2 > (r2 = e3[n2 - 1]).end ? 0 : r2;
}
function Lt(e3, t2) {
  this.font = e3, this.tableName = t2;
}
function Ct(e3) {
  Lt.call(this, e3, "gpos");
}
function wt(e3) {
  Lt.call(this, e3, "gsub");
}
function Dt(e3, t2) {
  var r2 = e3.length;
  if (r2 !== t2.length) return false;
  for (var n2 = 0; n2 < r2; n2++) if (e3[n2] !== t2[n2]) return false;
  return true;
}
function It(e3, t2, r2) {
  for (var n2 = e3.subtables, a2 = 0; a2 < n2.length; a2++) {
    var o2 = n2[a2];
    if (o2.substFormat === t2) return o2;
  }
  if (r2) return n2.push(r2), r2;
}
function Gt(e3) {
  for (var t2 = new ArrayBuffer(e3.length), r2 = new Uint8Array(t2), n2 = 0; n2 < e3.length; ++n2) r2[n2] = e3[n2];
  return t2;
}
function Mt(e3, t2) {
  if (!e3) throw t2;
}
function Bt(e3, t2, r2, n2, a2) {
  var o2;
  return (t2 & n2) > 0 ? (o2 = e3.parseByte(), t2 & a2 || (o2 = -o2), o2 = r2 + o2) : o2 = (t2 & a2) > 0 ? r2 : r2 + e3.parseShort(), o2;
}
function Ft(e3, t2, r2) {
  var n2, a2, o2 = new se.Parser(t2, r2);
  if (e3.numberOfContours = o2.parseShort(), e3._xMin = o2.parseShort(), e3._yMin = o2.parseShort(), e3._xMax = o2.parseShort(), e3._yMax = o2.parseShort(), e3.numberOfContours > 0) {
    for (var s2 = e3.endPointIndices = [], i2 = 0; i2 < e3.numberOfContours; i2 += 1) s2.push(o2.parseUShort());
    e3.instructionLength = o2.parseUShort(), e3.instructions = [];
    for (var u2 = 0; u2 < e3.instructionLength; u2 += 1) e3.instructions.push(o2.parseByte());
    var l2 = s2[s2.length - 1] + 1;
    n2 = [];
    for (var p2 = 0; p2 < l2; p2 += 1) if (a2 = o2.parseByte(), n2.push(a2), (8 & a2) > 0) for (var c2 = o2.parseByte(), h2 = 0; h2 < c2; h2 += 1) n2.push(a2), p2 += 1;
    if (w.argument(n2.length === l2, "Bad flags."), s2.length > 0) {
      var f2, d2 = [];
      if (l2 > 0) {
        for (var v2 = 0; v2 < l2; v2 += 1) a2 = n2[v2], (f2 = {}).onCurve = !!(1 & a2), f2.lastPointOfContour = s2.indexOf(v2) >= 0, d2.push(f2);
        for (var g2 = 0, m2 = 0; m2 < l2; m2 += 1) a2 = n2[m2], (f2 = d2[m2]).x = Bt(o2, a2, g2, 2, 16), g2 = f2.x;
        for (var y2 = 0, b2 = 0; b2 < l2; b2 += 1) a2 = n2[b2], (f2 = d2[b2]).y = Bt(o2, a2, y2, 4, 32), y2 = f2.y;
      }
      e3.points = d2;
    } else e3.points = [];
  } else if (0 === e3.numberOfContours) e3.points = [];
  else {
    e3.isComposite = true, e3.points = [], e3.components = [];
    for (var S2 = true; S2; ) {
      n2 = o2.parseUShort();
      var x2 = { glyphIndex: o2.parseUShort(), xScale: 1, scale01: 0, scale10: 0, yScale: 1, dx: 0, dy: 0 };
      (1 & n2) > 0 ? (2 & n2) > 0 ? (x2.dx = o2.parseShort(), x2.dy = o2.parseShort()) : x2.matchedPoints = [o2.parseUShort(), o2.parseUShort()] : (2 & n2) > 0 ? (x2.dx = o2.parseChar(), x2.dy = o2.parseChar()) : x2.matchedPoints = [o2.parseByte(), o2.parseByte()], (8 & n2) > 0 ? x2.xScale = x2.yScale = o2.parseF2Dot14() : (64 & n2) > 0 ? (x2.xScale = o2.parseF2Dot14(), x2.yScale = o2.parseF2Dot14()) : (128 & n2) > 0 && (x2.xScale = o2.parseF2Dot14(), x2.scale01 = o2.parseF2Dot14(), x2.scale10 = o2.parseF2Dot14(), x2.yScale = o2.parseF2Dot14()), e3.components.push(x2), S2 = !!(32 & n2);
    }
    if (256 & n2) {
      e3.instructionLength = o2.parseUShort(), e3.instructions = [];
      for (var T2 = 0; T2 < e3.instructionLength; T2 += 1) e3.instructions.push(o2.parseByte());
    }
  }
}
function Pt(e3, t2) {
  for (var r2 = [], n2 = 0; n2 < e3.length; n2 += 1) {
    var a2 = e3[n2], o2 = { x: t2.xScale * a2.x + t2.scale01 * a2.y + t2.dx, y: t2.scale10 * a2.x + t2.yScale * a2.y + t2.dy, onCurve: a2.onCurve, lastPointOfContour: a2.lastPointOfContour };
    r2.push(o2);
  }
  return r2;
}
function At(e3) {
  var t2 = new E();
  if (!e3) return t2;
  for (var r2 = function(e4) {
    for (var t3 = [], r3 = [], n3 = 0; n3 < e4.length; n3 += 1) {
      var a3 = e4[n3];
      r3.push(a3), a3.lastPointOfContour && (t3.push(r3), r3 = []);
    }
    return w.argument(0 === r3.length, "There are still points left in the current contour."), t3;
  }(e3), n2 = 0; n2 < r2.length; ++n2) {
    var a2 = r2[n2], o2 = null, s2 = a2[a2.length - 1], i2 = a2[0];
    if (s2.onCurve) t2.moveTo(s2.x, s2.y);
    else if (i2.onCurve) t2.moveTo(i2.x, i2.y);
    else {
      var u2 = { x: 0.5 * (s2.x + i2.x), y: 0.5 * (s2.y + i2.y) };
      t2.moveTo(u2.x, u2.y);
    }
    for (var l2 = 0; l2 < a2.length; ++l2) if (o2 = s2, s2 = i2, i2 = a2[(l2 + 1) % a2.length], s2.onCurve) t2.lineTo(s2.x, s2.y);
    else {
      var p2 = i2;
      o2.onCurve || (s2.x, o2.x, s2.y, o2.y), i2.onCurve || (p2 = { x: 0.5 * (s2.x + i2.x), y: 0.5 * (s2.y + i2.y) }), t2.quadraticCurveTo(s2.x, s2.y, p2.x, p2.y);
    }
    t2.closePath();
  }
  return t2;
}
function Nt(e3, t2) {
  if (t2.isComposite) for (var r2 = 0; r2 < t2.components.length; r2 += 1) {
    var n2 = t2.components[r2], a2 = e3.get(n2.glyphIndex);
    if (a2.getPath(), a2.points) {
      var o2 = void 0;
      if (void 0 === n2.matchedPoints) o2 = Pt(a2.points, n2);
      else {
        if (n2.matchedPoints[0] > t2.points.length - 1 || n2.matchedPoints[1] > a2.points.length - 1) throw Error("Matched points out of range in " + t2.name);
        var s2 = t2.points[n2.matchedPoints[0]], i2 = a2.points[n2.matchedPoints[1]], u2 = { xScale: n2.xScale, scale01: n2.scale01, scale10: n2.scale10, yScale: n2.yScale, dx: 0, dy: 0 };
        i2 = Pt([i2], u2)[0], u2.dx = s2.x - i2.x, u2.dy = s2.y - i2.y, o2 = Pt(a2.points, u2);
      }
      t2.points = t2.points.concat(o2);
    }
  }
  return At(t2.points);
}
Lt.prototype = { searchTag: Ot, binSearch: Rt, getTable: function(e3) {
  var t2 = this.font.tables[this.tableName];
  return !t2 && e3 && (t2 = this.font.tables[this.tableName] = this.createDefaultTable()), t2;
}, getScriptNames: function() {
  var e3 = this.getTable();
  return e3 ? e3.scripts.map(function(e4) {
    return e4.tag;
  }) : [];
}, getDefaultScriptName: function() {
  var e3 = this.getTable();
  if (e3) {
    for (var t2 = false, r2 = 0; r2 < e3.scripts.length; r2++) {
      var n2 = e3.scripts[r2].tag;
      if ("DFLT" === n2) return n2;
      "latn" === n2 && (t2 = true);
    }
    return t2 ? "latn" : void 0;
  }
}, getScriptTable: function(e3, t2) {
  var r2 = this.getTable(t2);
  if (r2) {
    e3 = e3 || "DFLT";
    var n2 = r2.scripts, a2 = Ot(r2.scripts, e3);
    if (a2 >= 0) return n2[a2].script;
    if (t2) {
      var o2 = { tag: e3, script: { defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }, langSysRecords: [] } };
      return n2.splice(-1 - a2, 0, o2), o2.script;
    }
  }
}, getLangSysTable: function(e3, t2, r2) {
  var n2 = this.getScriptTable(e3, r2);
  if (n2) {
    if (!t2 || "dflt" === t2 || "DFLT" === t2) return n2.defaultLangSys;
    var a2 = Ot(n2.langSysRecords, t2);
    if (a2 >= 0) return n2.langSysRecords[a2].langSys;
    if (r2) {
      var o2 = { tag: t2, langSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] } };
      return n2.langSysRecords.splice(-1 - a2, 0, o2), o2.langSys;
    }
  }
}, getFeatureTable: function(e3, t2, r2, n2) {
  var a2 = this.getLangSysTable(e3, t2, n2);
  if (a2) {
    for (var o2, s2 = a2.featureIndexes, i2 = this.font.tables[this.tableName].features, u2 = 0; u2 < s2.length; u2++) if ((o2 = i2[s2[u2]]).tag === r2) return o2.feature;
    if (n2) {
      var l2 = i2.length;
      return w.assert(0 === l2 || r2 >= i2[l2 - 1].tag, "Features must be added in alphabetical order."), o2 = { tag: r2, feature: { params: 0, lookupListIndexes: [] } }, i2.push(o2), s2.push(l2), o2.feature;
    }
  }
}, getLookupTables: function(e3, t2, r2, n2, a2) {
  var o2 = this.getFeatureTable(e3, t2, r2, a2), s2 = [];
  if (o2) {
    for (var i2, u2 = o2.lookupListIndexes, l2 = this.font.tables[this.tableName].lookups, p2 = 0; p2 < u2.length; p2++) (i2 = l2[u2[p2]]).lookupType === n2 && s2.push(i2);
    if (0 === s2.length && a2) {
      i2 = { lookupType: n2, lookupFlag: 0, subtables: [], markFilteringSet: void 0 };
      var c2 = l2.length;
      return l2.push(i2), u2.push(c2), [i2];
    }
  }
  return s2;
}, getGlyphClass: function(e3, t2) {
  switch (e3.format) {
    case 1:
      return e3.startGlyph <= t2 && t2 < e3.startGlyph + e3.classes.length ? e3.classes[t2 - e3.startGlyph] : 0;
    case 2:
      var r2 = Et(e3.ranges, t2);
      return r2 ? r2.classId : 0;
  }
}, getCoverageIndex: function(e3, t2) {
  switch (e3.format) {
    case 1:
      var r2 = Rt(e3.glyphs, t2);
      return r2 >= 0 ? r2 : -1;
    case 2:
      var n2 = Et(e3.ranges, t2);
      return n2 ? n2.index + t2 - n2.start : -1;
  }
}, expandCoverage: function(e3) {
  if (1 === e3.format) return e3.glyphs;
  for (var t2 = [], r2 = e3.ranges, n2 = 0; n2 < r2.length; n2++) for (var a2 = r2[n2], o2 = a2.start, s2 = a2.end, i2 = o2; i2 <= s2; i2++) t2.push(i2);
  return t2;
} }, Ct.prototype = Lt.prototype, Ct.prototype.init = function() {
  var e3 = this.getDefaultScriptName();
  this.defaultKerningTables = this.getKerningTables(e3);
}, Ct.prototype.getKerningValue = function(e3, t2, r2) {
  for (var n2 = 0; n2 < e3.length; n2++) for (var a2 = e3[n2].subtables, o2 = 0; o2 < a2.length; o2++) {
    var s2 = a2[o2], i2 = this.getCoverageIndex(s2.coverage, t2);
    if (!(i2 < 0)) switch (s2.posFormat) {
      case 1:
        for (var u2 = s2.pairSets[i2], l2 = 0; l2 < u2.length; l2++) {
          var p2 = u2[l2];
          if (p2.secondGlyph === r2) return p2.value1 && p2.value1.xAdvance || 0;
        }
        break;
      case 2:
        var c2 = this.getGlyphClass(s2.classDef1, t2), h2 = this.getGlyphClass(s2.classDef2, r2), f2 = s2.classRecords[c2][h2];
        return f2.value1 && f2.value1.xAdvance || 0;
    }
  }
  return 0;
}, Ct.prototype.getKerningTables = function(e3, t2) {
  if (this.font.tables.gpos) return this.getLookupTables(e3, t2, "kern", 2);
}, wt.prototype = Lt.prototype, wt.prototype.createDefaultTable = function() {
  return { version: 1, scripts: [{ tag: "DFLT", script: { defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }, langSysRecords: [] } }], features: [], lookups: [] };
}, wt.prototype.getSingle = function(e3, t2, r2) {
  for (var n2 = [], a2 = this.getLookupTables(t2, r2, e3, 1), o2 = 0; o2 < a2.length; o2++) for (var s2 = a2[o2].subtables, i2 = 0; i2 < s2.length; i2++) {
    var u2 = s2[i2], l2 = this.expandCoverage(u2.coverage), p2 = void 0;
    if (1 === u2.substFormat) {
      var c2 = u2.deltaGlyphId;
      for (p2 = 0; p2 < l2.length; p2++) {
        var h2 = l2[p2];
        n2.push({ sub: h2, by: h2 + c2 });
      }
    } else {
      var f2 = u2.substitute;
      for (p2 = 0; p2 < l2.length; p2++) n2.push({ sub: l2[p2], by: f2[p2] });
    }
  }
  return n2;
}, wt.prototype.getMultiple = function(e3, t2, r2) {
  for (var n2 = [], a2 = this.getLookupTables(t2, r2, e3, 2), o2 = 0; o2 < a2.length; o2++) for (var s2 = a2[o2].subtables, i2 = 0; i2 < s2.length; i2++) {
    var u2 = s2[i2], l2 = this.expandCoverage(u2.coverage), p2 = void 0;
    for (p2 = 0; p2 < l2.length; p2++) {
      var c2 = l2[p2], h2 = u2.sequences[p2];
      n2.push({ sub: c2, by: h2 });
    }
  }
  return n2;
}, wt.prototype.getAlternates = function(e3, t2, r2) {
  for (var n2 = [], a2 = this.getLookupTables(t2, r2, e3, 3), o2 = 0; o2 < a2.length; o2++) for (var s2 = a2[o2].subtables, i2 = 0; i2 < s2.length; i2++) for (var u2 = s2[i2], l2 = this.expandCoverage(u2.coverage), p2 = u2.alternateSets, c2 = 0; c2 < l2.length; c2++) n2.push({ sub: l2[c2], by: p2[c2] });
  return n2;
}, wt.prototype.getLigatures = function(e3, t2, r2) {
  for (var n2 = [], a2 = this.getLookupTables(t2, r2, e3, 4), o2 = 0; o2 < a2.length; o2++) for (var s2 = a2[o2].subtables, i2 = 0; i2 < s2.length; i2++) for (var u2 = s2[i2], l2 = this.expandCoverage(u2.coverage), p2 = u2.ligatureSets, c2 = 0; c2 < l2.length; c2++) for (var h2 = l2[c2], f2 = p2[c2], d2 = 0; d2 < f2.length; d2++) {
    var v2 = f2[d2];
    n2.push({ sub: [h2].concat(v2.components), by: v2.ligGlyph });
  }
  return n2;
}, wt.prototype.addSingle = function(e3, t2, r2, n2) {
  var a2 = It(this.getLookupTables(r2, n2, e3, 1, true)[0], 2, { substFormat: 2, coverage: { format: 1, glyphs: [] }, substitute: [] });
  w.assert(1 === a2.coverage.format, "Single: unable to modify coverage table format " + a2.coverage.format);
  var o2 = t2.sub, s2 = this.binSearch(a2.coverage.glyphs, o2);
  s2 < 0 && (s2 = -1 - s2, a2.coverage.glyphs.splice(s2, 0, o2), a2.substitute.splice(s2, 0, 0)), a2.substitute[s2] = t2.by;
}, wt.prototype.addMultiple = function(e3, t2, r2, n2) {
  w.assert(t2.by instanceof Array && t2.by.length > 1, 'Multiple: "by" must be an array of two or more ids');
  var a2 = It(this.getLookupTables(r2, n2, e3, 2, true)[0], 1, { substFormat: 1, coverage: { format: 1, glyphs: [] }, sequences: [] });
  w.assert(1 === a2.coverage.format, "Multiple: unable to modify coverage table format " + a2.coverage.format);
  var o2 = t2.sub, s2 = this.binSearch(a2.coverage.glyphs, o2);
  s2 < 0 && (s2 = -1 - s2, a2.coverage.glyphs.splice(s2, 0, o2), a2.sequences.splice(s2, 0, 0)), a2.sequences[s2] = t2.by;
}, wt.prototype.addAlternate = function(e3, t2, r2, n2) {
  var a2 = It(this.getLookupTables(r2, n2, e3, 3, true)[0], 1, { substFormat: 1, coverage: { format: 1, glyphs: [] }, alternateSets: [] });
  w.assert(1 === a2.coverage.format, "Alternate: unable to modify coverage table format " + a2.coverage.format);
  var o2 = t2.sub, s2 = this.binSearch(a2.coverage.glyphs, o2);
  s2 < 0 && (s2 = -1 - s2, a2.coverage.glyphs.splice(s2, 0, o2), a2.alternateSets.splice(s2, 0, 0)), a2.alternateSets[s2] = t2.by;
}, wt.prototype.addLigature = function(e3, t2, r2, n2) {
  var a2 = this.getLookupTables(r2, n2, e3, 4, true)[0], o2 = a2.subtables[0];
  o2 || (o2 = { substFormat: 1, coverage: { format: 1, glyphs: [] }, ligatureSets: [] }, a2.subtables[0] = o2), w.assert(1 === o2.coverage.format, "Ligature: unable to modify coverage table format " + o2.coverage.format);
  var s2 = t2.sub[0], i2 = t2.sub.slice(1), u2 = { ligGlyph: t2.by, components: i2 }, l2 = this.binSearch(o2.coverage.glyphs, s2);
  if (l2 >= 0) {
    for (var p2 = o2.ligatureSets[l2], c2 = 0; c2 < p2.length; c2++) if (Dt(p2[c2].components, i2)) return;
    p2.push(u2);
  } else l2 = -1 - l2, o2.coverage.glyphs.splice(l2, 0, s2), o2.ligatureSets.splice(l2, 0, [u2]);
}, wt.prototype.getFeature = function(e3, t2, r2) {
  if (/ss\d\d/.test(e3)) return this.getSingle(e3, t2, r2);
  switch (e3) {
    case "aalt":
    case "salt":
      return this.getSingle(e3, t2, r2).concat(this.getAlternates(e3, t2, r2));
    case "dlig":
    case "liga":
    case "rlig":
      return this.getLigatures(e3, t2, r2);
    case "ccmp":
      return this.getMultiple(e3, t2, r2).concat(this.getLigatures(e3, t2, r2));
    case "stch":
      return this.getMultiple(e3, t2, r2);
  }
}, wt.prototype.add = function(e3, t2, r2, n2) {
  if (/ss\d\d/.test(e3)) return this.addSingle(e3, t2, r2, n2);
  switch (e3) {
    case "aalt":
    case "salt":
      return "number" == typeof t2.by ? this.addSingle(e3, t2, r2, n2) : this.addAlternate(e3, t2, r2, n2);
    case "dlig":
    case "liga":
    case "rlig":
      return this.addLigature(e3, t2, r2, n2);
    case "ccmp":
      return t2.by instanceof Array ? this.addMultiple(e3, t2, r2, n2) : this.addLigature(e3, t2, r2, n2);
  }
};
var Ht;
var zt;
var Wt;
var qt;
var _t = { getPath: At, parse: function(e3, t2, r2, n2, a2) {
  return a2.lowMemory ? function(e4, t3, r3, n3) {
    var a3 = new Be.GlyphSet(n3);
    return n3._push = function(o2) {
      var s2 = r3[o2];
      s2 !== r3[o2 + 1] ? a3.push(o2, Be.ttfGlyphLoader(n3, o2, Ft, e4, t3 + s2, Nt)) : a3.push(o2, Be.glyphLoader(n3, o2));
    }, a3;
  }(e3, t2, r2, n2) : function(e4, t3, r3, n3) {
    for (var a3 = new Be.GlyphSet(n3), o2 = 0; o2 < r3.length - 1; o2 += 1) {
      var s2 = r3[o2];
      s2 !== r3[o2 + 1] ? a3.push(o2, Be.ttfGlyphLoader(n3, o2, Ft, e4, t3 + s2, Nt)) : a3.push(o2, Be.glyphLoader(n3, o2));
    }
    return a3;
  }(e3, t2, r2, n2);
} };
function Xt(e3) {
  this.font = e3, this.getCommands = function(e4) {
    return _t.getPath(e4).commands;
  }, this._fpgmState = this._prepState = void 0, this._errorState = 0;
}
function Vt(e3) {
  return e3;
}
function jt(e3) {
  return Math.sign(e3) * Math.round(Math.abs(e3));
}
function Yt(e3) {
  return Math.sign(e3) * Math.round(Math.abs(2 * e3)) / 2;
}
function Zt(e3) {
  return Math.sign(e3) * (Math.round(Math.abs(e3) + 0.5) - 0.5);
}
function Qt(e3) {
  return Math.sign(e3) * Math.ceil(Math.abs(e3));
}
function Kt(e3) {
  return Math.sign(e3) * Math.floor(Math.abs(e3));
}
var Jt = function(e3) {
  var t2 = this.srPeriod, r2 = this.srPhase, n2 = 1;
  return e3 < 0 && (e3 = -e3, n2 = -1), e3 += this.srThreshold - r2, e3 = Math.trunc(e3 / t2) * t2, (e3 += r2) < 0 ? r2 * n2 : e3 * n2;
};
var $t = { x: 1, y: 0, axis: "x", distance: function(e3, t2, r2, n2) {
  return (r2 ? e3.xo : e3.x) - (n2 ? t2.xo : t2.x);
}, interpolate: function(e3, t2, r2, n2) {
  var a2, o2, s2, i2, u2, l2, p2;
  if (!n2 || n2 === this) return a2 = e3.xo - t2.xo, o2 = e3.xo - r2.xo, u2 = t2.x - t2.xo, l2 = r2.x - r2.xo, 0 === (p2 = (s2 = Math.abs(a2)) + (i2 = Math.abs(o2))) ? void (e3.x = e3.xo + (u2 + l2) / 2) : void (e3.x = e3.xo + (u2 * i2 + l2 * s2) / p2);
  a2 = n2.distance(e3, t2, true, true), o2 = n2.distance(e3, r2, true, true), u2 = n2.distance(t2, t2, false, true), l2 = n2.distance(r2, r2, false, true), 0 !== (p2 = (s2 = Math.abs(a2)) + (i2 = Math.abs(o2))) ? $t.setRelative(e3, e3, (u2 * i2 + l2 * s2) / p2, n2, true) : $t.setRelative(e3, e3, (u2 + l2) / 2, n2, true);
}, normalSlope: Number.NEGATIVE_INFINITY, setRelative: function(e3, t2, r2, n2, a2) {
  if (n2 && n2 !== this) {
    var o2 = a2 ? t2.xo : t2.x, s2 = a2 ? t2.yo : t2.y, i2 = o2 + r2 * n2.x, u2 = s2 + r2 * n2.y;
    e3.x = i2 + (e3.y - u2) / n2.normalSlope;
  } else e3.x = (a2 ? t2.xo : t2.x) + r2;
}, slope: 0, touch: function(e3) {
  e3.xTouched = true;
}, touched: function(e3) {
  return e3.xTouched;
}, untouch: function(e3) {
  e3.xTouched = false;
} };
var er = { x: 0, y: 1, axis: "y", distance: function(e3, t2, r2, n2) {
  return (r2 ? e3.yo : e3.y) - (n2 ? t2.yo : t2.y);
}, interpolate: function(e3, t2, r2, n2) {
  var a2, o2, s2, i2, u2, l2, p2;
  if (!n2 || n2 === this) return a2 = e3.yo - t2.yo, o2 = e3.yo - r2.yo, u2 = t2.y - t2.yo, l2 = r2.y - r2.yo, 0 === (p2 = (s2 = Math.abs(a2)) + (i2 = Math.abs(o2))) ? void (e3.y = e3.yo + (u2 + l2) / 2) : void (e3.y = e3.yo + (u2 * i2 + l2 * s2) / p2);
  a2 = n2.distance(e3, t2, true, true), o2 = n2.distance(e3, r2, true, true), u2 = n2.distance(t2, t2, false, true), l2 = n2.distance(r2, r2, false, true), 0 !== (p2 = (s2 = Math.abs(a2)) + (i2 = Math.abs(o2))) ? er.setRelative(e3, e3, (u2 * i2 + l2 * s2) / p2, n2, true) : er.setRelative(e3, e3, (u2 + l2) / 2, n2, true);
}, normalSlope: 0, setRelative: function(e3, t2, r2, n2, a2) {
  if (n2 && n2 !== this) {
    var o2 = a2 ? t2.xo : t2.x, s2 = a2 ? t2.yo : t2.y, i2 = o2 + r2 * n2.x, u2 = s2 + r2 * n2.y;
    e3.y = u2 + n2.normalSlope * (e3.x - i2);
  } else e3.y = (a2 ? t2.yo : t2.y) + r2;
}, slope: Number.POSITIVE_INFINITY, touch: function(e3) {
  e3.yTouched = true;
}, touched: function(e3) {
  return e3.yTouched;
}, untouch: function(e3) {
  e3.yTouched = false;
} };
function tr(e3, t2) {
  this.x = e3, this.y = t2, this.axis = void 0, this.slope = t2 / e3, this.normalSlope = -e3 / t2, Object.freeze(this);
}
function rr(e3, t2) {
  var r2 = Math.sqrt(e3 * e3 + t2 * t2);
  return t2 /= r2, 1 === (e3 /= r2) && 0 === t2 ? $t : 0 === e3 && 1 === t2 ? er : new tr(e3, t2);
}
function nr(e3, t2, r2, n2) {
  this.x = this.xo = Math.round(64 * e3) / 64, this.y = this.yo = Math.round(64 * t2) / 64, this.lastPointOfContour = r2, this.onCurve = n2, this.prevPointOnContour = void 0, this.nextPointOnContour = void 0, this.xTouched = false, this.yTouched = false, Object.preventExtensions(this);
}
Object.freeze($t), Object.freeze(er), tr.prototype.distance = function(e3, t2, r2, n2) {
  return this.x * $t.distance(e3, t2, r2, n2) + this.y * er.distance(e3, t2, r2, n2);
}, tr.prototype.interpolate = function(e3, t2, r2, n2) {
  var a2, o2, s2, i2, u2, l2, p2;
  s2 = n2.distance(e3, t2, true, true), i2 = n2.distance(e3, r2, true, true), a2 = n2.distance(t2, t2, false, true), o2 = n2.distance(r2, r2, false, true), 0 !== (p2 = (u2 = Math.abs(s2)) + (l2 = Math.abs(i2))) ? this.setRelative(e3, e3, (a2 * l2 + o2 * u2) / p2, n2, true) : this.setRelative(e3, e3, (a2 + o2) / 2, n2, true);
}, tr.prototype.setRelative = function(e3, t2, r2, n2, a2) {
  n2 = n2 || this;
  var o2 = a2 ? t2.xo : t2.x, s2 = a2 ? t2.yo : t2.y, i2 = o2 + r2 * n2.x, u2 = s2 + r2 * n2.y, l2 = n2.normalSlope, p2 = this.slope, c2 = e3.x, h2 = e3.y;
  e3.x = (p2 * c2 - l2 * i2 + u2 - h2) / (p2 - l2), e3.y = p2 * (e3.x - c2) + h2;
}, tr.prototype.touch = function(e3) {
  e3.xTouched = true, e3.yTouched = true;
}, nr.prototype.nextTouched = function(e3) {
  for (var t2 = this.nextPointOnContour; !e3.touched(t2) && t2 !== this; ) t2 = t2.nextPointOnContour;
  return t2;
}, nr.prototype.prevTouched = function(e3) {
  for (var t2 = this.prevPointOnContour; !e3.touched(t2) && t2 !== this; ) t2 = t2.prevPointOnContour;
  return t2;
};
var ar = Object.freeze(new nr(0, 0));
var or = { cvCutIn: 17 / 16, deltaBase: 9, deltaShift: 0.125, loop: 1, minDis: 1, autoFlip: true };
function sr(e3, t2) {
  switch (this.env = e3, this.stack = [], this.prog = t2, e3) {
    case "glyf":
      this.zp0 = this.zp1 = this.zp2 = 1, this.rp0 = this.rp1 = this.rp2 = 0;
    case "prep":
      this.fv = this.pv = this.dpv = $t, this.round = jt;
  }
}
function ir(e3) {
  for (var t2 = e3.tZone = new Array(e3.gZone.length), r2 = 0; r2 < t2.length; r2++) t2[r2] = new nr(0, 0);
}
function ur(e3, t2) {
  var r2, n2 = e3.prog, a2 = e3.ip, o2 = 1;
  do {
    if (88 === (r2 = n2[++a2])) o2++;
    else if (89 === r2) o2--;
    else if (64 === r2) a2 += n2[a2 + 1] + 1;
    else if (65 === r2) a2 += 2 * n2[a2 + 1] + 1;
    else if (r2 >= 176 && r2 <= 183) a2 += r2 - 176 + 1;
    else if (r2 >= 184 && r2 <= 191) a2 += 2 * (r2 - 184 + 1);
    else if (t2 && 1 === o2 && 27 === r2) break;
  } while (o2 > 0);
  e3.ip = a2;
}
function lr(e3, t2) {
  exports.DEBUG && console.log(t2.step, "SVTCA[" + e3.axis + "]"), t2.fv = t2.pv = t2.dpv = e3;
}
function pr(e3, t2) {
  exports.DEBUG && console.log(t2.step, "SPVTCA[" + e3.axis + "]"), t2.pv = t2.dpv = e3;
}
function cr(e3, t2) {
  exports.DEBUG && console.log(t2.step, "SFVTCA[" + e3.axis + "]"), t2.fv = e3;
}
function hr(e3, t2) {
  var r2, n2, a2 = t2.stack, o2 = a2.pop(), s2 = a2.pop(), i2 = t2.z2[o2], u2 = t2.z1[s2];
  exports.DEBUG && console.log("SPVTL[" + e3 + "]", o2, s2), e3 ? (r2 = i2.y - u2.y, n2 = u2.x - i2.x) : (r2 = u2.x - i2.x, n2 = u2.y - i2.y), t2.pv = t2.dpv = rr(r2, n2);
}
function fr(e3, t2) {
  var r2, n2, a2 = t2.stack, o2 = a2.pop(), s2 = a2.pop(), i2 = t2.z2[o2], u2 = t2.z1[s2];
  exports.DEBUG && console.log("SFVTL[" + e3 + "]", o2, s2), e3 ? (r2 = i2.y - u2.y, n2 = u2.x - i2.x) : (r2 = u2.x - i2.x, n2 = u2.y - i2.y), t2.fv = rr(r2, n2);
}
function dr(e3) {
  exports.DEBUG && console.log(e3.step, "POP[]"), e3.stack.pop();
}
function vr(e3, t2) {
  var r2 = t2.stack.pop(), n2 = t2.z0[r2], a2 = t2.fv, o2 = t2.pv;
  exports.DEBUG && console.log(t2.step, "MDAP[" + e3 + "]", r2);
  var s2 = o2.distance(n2, ar);
  e3 && (s2 = t2.round(s2)), a2.setRelative(n2, ar, s2, o2), a2.touch(n2), t2.rp0 = t2.rp1 = r2;
}
function gr(e3, t2) {
  var r2, n2, a2, o2 = t2.z2, s2 = o2.length - 2;
  exports.DEBUG && console.log(t2.step, "IUP[" + e3.axis + "]");
  for (var i2 = 0; i2 < s2; i2++) r2 = o2[i2], e3.touched(r2) || (n2 = r2.prevTouched(e3)) !== r2 && (n2 === (a2 = r2.nextTouched(e3)) && e3.setRelative(r2, r2, e3.distance(n2, n2, false, true), e3, true), e3.interpolate(r2, n2, a2, e3));
}
function mr(e3, t2) {
  for (var r2 = t2.stack, n2 = e3 ? t2.rp1 : t2.rp2, a2 = (e3 ? t2.z0 : t2.z1)[n2], o2 = t2.fv, s2 = t2.pv, i2 = t2.loop, u2 = t2.z2; i2--; ) {
    var l2 = r2.pop(), p2 = u2[l2], c2 = s2.distance(a2, a2, false, true);
    o2.setRelative(p2, p2, c2, s2), o2.touch(p2), exports.DEBUG && console.log(t2.step, (t2.loop > 1 ? "loop " + (t2.loop - i2) + ": " : "") + "SHP[" + (e3 ? "rp1" : "rp2") + "]", l2);
  }
  t2.loop = 1;
}
function yr(e3, t2) {
  var r2 = t2.stack, n2 = e3 ? t2.rp1 : t2.rp2, a2 = (e3 ? t2.z0 : t2.z1)[n2], o2 = t2.fv, s2 = t2.pv, i2 = r2.pop(), u2 = t2.z2[t2.contours[i2]], l2 = u2;
  exports.DEBUG && console.log(t2.step, "SHC[" + e3 + "]", i2);
  var p2 = s2.distance(a2, a2, false, true);
  do {
    l2 !== a2 && o2.setRelative(l2, l2, p2, s2), l2 = l2.nextPointOnContour;
  } while (l2 !== u2);
}
function br(e3, t2) {
  var r2, n2, a2 = t2.stack, o2 = e3 ? t2.rp1 : t2.rp2, s2 = (e3 ? t2.z0 : t2.z1)[o2], i2 = t2.fv, u2 = t2.pv, l2 = a2.pop();
  switch (exports.DEBUG && console.log(t2.step, "SHZ[" + e3 + "]", l2), l2) {
    case 0:
      r2 = t2.tZone;
      break;
    case 1:
      r2 = t2.gZone;
      break;
    default:
      throw new Error("Invalid zone");
  }
  for (var p2 = u2.distance(s2, s2, false, true), c2 = r2.length - 2, h2 = 0; h2 < c2; h2++) n2 = r2[h2], i2.setRelative(n2, n2, p2, u2);
}
function Sr(e3, t2) {
  var r2 = t2.stack, n2 = r2.pop() / 64, a2 = r2.pop(), o2 = t2.z1[a2], s2 = t2.z0[t2.rp0], i2 = t2.fv, u2 = t2.pv;
  i2.setRelative(o2, s2, n2, u2), i2.touch(o2), exports.DEBUG && console.log(t2.step, "MSIRP[" + e3 + "]", n2, a2), t2.rp1 = t2.rp0, t2.rp2 = a2, e3 && (t2.rp0 = a2);
}
function xr(e3, t2) {
  var r2 = t2.stack, n2 = r2.pop(), a2 = r2.pop(), o2 = t2.z0[a2], s2 = t2.fv, i2 = t2.pv, u2 = t2.cvt[n2];
  exports.DEBUG && console.log(t2.step, "MIAP[" + e3 + "]", n2, "(", u2, ")", a2);
  var l2 = i2.distance(o2, ar);
  e3 && (Math.abs(l2 - u2) < t2.cvCutIn && (l2 = u2), l2 = t2.round(l2)), s2.setRelative(o2, ar, l2, i2), 0 === t2.zp0 && (o2.xo = o2.x, o2.yo = o2.y), s2.touch(o2), t2.rp0 = t2.rp1 = a2;
}
function Tr(e3, t2) {
  var r2 = t2.stack, n2 = r2.pop(), a2 = t2.z2[n2];
  exports.DEBUG && console.log(t2.step, "GC[" + e3 + "]", n2), r2.push(64 * t2.dpv.distance(a2, ar, e3, false));
}
function Ur(e3, t2) {
  var r2 = t2.stack, n2 = r2.pop(), a2 = r2.pop(), o2 = t2.z1[n2], s2 = t2.z0[a2], i2 = t2.dpv.distance(s2, o2, e3, e3);
  exports.DEBUG && console.log(t2.step, "MD[" + e3 + "]", n2, a2, "->", i2), t2.stack.push(Math.round(64 * i2));
}
function kr(e3, t2) {
  var r2 = t2.stack, n2 = r2.pop(), a2 = t2.fv, o2 = t2.pv, s2 = t2.ppem, i2 = t2.deltaBase + 16 * (e3 - 1), u2 = t2.deltaShift, l2 = t2.z0;
  exports.DEBUG && console.log(t2.step, "DELTAP[" + e3 + "]", n2, r2);
  for (var p2 = 0; p2 < n2; p2++) {
    var c2 = r2.pop(), h2 = r2.pop();
    if (i2 + ((240 & h2) >> 4) === s2) {
      var f2 = (15 & h2) - 8;
      f2 >= 0 && f2++, exports.DEBUG && console.log(t2.step, "DELTAPFIX", c2, "by", f2 * u2);
      var d2 = l2[c2];
      a2.setRelative(d2, d2, f2 * u2, o2);
    }
  }
}
function Or(e3, t2) {
  var r2 = t2.stack, n2 = r2.pop();
  exports.DEBUG && console.log(t2.step, "ROUND[]"), r2.push(64 * t2.round(n2 / 64));
}
function Rr(e3, t2) {
  var r2 = t2.stack, n2 = r2.pop(), a2 = t2.ppem, o2 = t2.deltaBase + 16 * (e3 - 1), s2 = t2.deltaShift;
  exports.DEBUG && console.log(t2.step, "DELTAC[" + e3 + "]", n2, r2);
  for (var i2 = 0; i2 < n2; i2++) {
    var u2 = r2.pop(), l2 = r2.pop();
    if (o2 + ((240 & l2) >> 4) === a2) {
      var p2 = (15 & l2) - 8;
      p2 >= 0 && p2++;
      var c2 = p2 * s2;
      exports.DEBUG && console.log(t2.step, "DELTACFIX", u2, "by", c2), t2.cvt[u2] += c2;
    }
  }
}
function Er(e3, t2) {
  var r2, n2, a2 = t2.stack, o2 = a2.pop(), s2 = a2.pop(), i2 = t2.z2[o2], u2 = t2.z1[s2];
  exports.DEBUG && console.log(t2.step, "SDPVTL[" + e3 + "]", o2, s2), e3 ? (r2 = i2.y - u2.y, n2 = u2.x - i2.x) : (r2 = u2.x - i2.x, n2 = u2.y - i2.y), t2.dpv = rr(r2, n2);
}
function Lr(e3, t2) {
  var r2 = t2.stack, n2 = t2.prog, a2 = t2.ip;
  exports.DEBUG && console.log(t2.step, "PUSHB[" + e3 + "]");
  for (var o2 = 0; o2 < e3; o2++) r2.push(n2[++a2]);
  t2.ip = a2;
}
function Cr(e3, t2) {
  var r2 = t2.ip, n2 = t2.prog, a2 = t2.stack;
  exports.DEBUG && console.log(t2.ip, "PUSHW[" + e3 + "]");
  for (var o2 = 0; o2 < e3; o2++) {
    var s2 = n2[++r2] << 8 | n2[++r2];
    32768 & s2 && (s2 = -(1 + (65535 ^ s2))), a2.push(s2);
  }
  t2.ip = r2;
}
function wr(e3, t2, r2, n2, a2, o2) {
  var s2, i2, u2, l2, p2 = o2.stack, c2 = e3 && p2.pop(), h2 = p2.pop(), f2 = o2.rp0, d2 = o2.z0[f2], v2 = o2.z1[h2], g2 = o2.minDis, m2 = o2.fv, y2 = o2.dpv;
  u2 = (i2 = s2 = y2.distance(v2, d2, true, true)) >= 0 ? 1 : -1, i2 = Math.abs(i2), e3 && (l2 = o2.cvt[c2], n2 && Math.abs(i2 - l2) < o2.cvCutIn && (i2 = l2)), r2 && i2 < g2 && (i2 = g2), n2 && (i2 = o2.round(i2)), m2.setRelative(v2, d2, u2 * i2, y2), m2.touch(v2), exports.DEBUG && console.log(o2.step, (e3 ? "MIRP[" : "MDRP[") + (t2 ? "M" : "m") + (r2 ? ">" : "_") + (n2 ? "R" : "_") + (0 === a2 ? "Gr" : 1 === a2 ? "Bl" : 2 === a2 ? "Wh" : "") + "]", e3 ? c2 + "(" + o2.cvt[c2] + "," + l2 + ")" : "", h2, "(d =", s2, "->", u2 * i2, ")"), o2.rp1 = o2.rp0, o2.rp2 = h2, t2 && (o2.rp0 = h2);
}
function Dr(e3) {
  this.char = e3, this.state = {}, this.activeState = null;
}
function Ir(e3, t2, r2) {
  this.contextName = r2, this.startIndex = e3, this.endOffset = t2;
}
function Gr(e3, t2, r2) {
  this.contextName = e3, this.openRange = null, this.ranges = [], this.checkStart = t2, this.checkEnd = r2;
}
function Mr(e3, t2) {
  this.context = e3, this.index = t2, this.length = e3.length, this.current = e3[t2], this.backtrack = e3.slice(0, t2), this.lookahead = e3.slice(t2 + 1);
}
function Br(e3) {
  this.eventId = e3, this.subscribers = [];
}
function Fr(e3) {
  var t2 = this, r2 = ["start", "end", "next", "newToken", "contextStart", "contextEnd", "insertToken", "removeToken", "removeRange", "replaceToken", "replaceRange", "composeRUD", "updateContextsRanges"];
  r2.forEach(function(e4) {
    Object.defineProperty(t2.events, e4, { value: new Br(e4) });
  }), e3 && r2.forEach(function(r3) {
    var n2 = e3[r3];
    "function" == typeof n2 && t2.events[r3].subscribe(n2);
  });
  ["insertToken", "removeToken", "removeRange", "replaceToken", "replaceRange", "composeRUD"].forEach(function(e4) {
    t2.events[e4].subscribe(t2.updateContextsRanges);
  });
}
function Pr(e3) {
  this.tokens = [], this.registeredContexts = {}, this.contextCheckers = [], this.events = {}, this.registeredModifiers = [], Fr.call(this, e3);
}
function Ar(e3) {
  return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(e3);
}
function Nr(e3) {
  return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(e3);
}
function Hr(e3) {
  return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(e3);
}
function zr(e3) {
  return /[A-z]/.test(e3);
}
function Wr(e3) {
  this.font = e3, this.features = {};
}
function qr(e3) {
  this.id = e3.id, this.tag = e3.tag, this.substitution = e3.substitution;
}
function _r(e3, t2) {
  if (!e3) return -1;
  switch (t2.format) {
    case 1:
      return t2.glyphs.indexOf(e3);
    case 2:
      for (var r2 = t2.ranges, n2 = 0; n2 < r2.length; n2++) {
        var a2 = r2[n2];
        if (e3 >= a2.start && e3 <= a2.end) {
          var o2 = e3 - a2.start;
          return a2.index + o2;
        }
      }
      break;
    default:
      return -1;
  }
  return -1;
}
function Xr(e3, t2) {
  return -1 === _r(e3, t2.coverage) ? null : e3 + t2.deltaGlyphId;
}
function Vr(e3, t2) {
  var r2 = _r(e3, t2.coverage);
  return -1 === r2 ? null : t2.substitute[r2];
}
function jr(e3, t2) {
  for (var r2 = [], n2 = 0; n2 < e3.length; n2++) {
    var a2 = e3[n2], o2 = t2.current, s2 = _r(o2 = Array.isArray(o2) ? o2[0] : o2, a2);
    -1 !== s2 && r2.push(s2);
  }
  return r2.length !== e3.length ? -1 : r2;
}
function Yr(e3, t2) {
  var r2 = t2.inputCoverage.length + t2.lookaheadCoverage.length + t2.backtrackCoverage.length;
  if (e3.context.length < r2) return [];
  var n2 = jr(t2.inputCoverage, e3);
  if (-1 === n2) return [];
  var a2 = t2.inputCoverage.length - 1;
  if (e3.lookahead.length < t2.lookaheadCoverage.length) return [];
  for (var o2 = e3.lookahead.slice(a2); o2.length && Hr(o2[0].char); ) o2.shift();
  var s2 = new Mr(o2, 0), i2 = jr(t2.lookaheadCoverage, s2), u2 = [].concat(e3.backtrack);
  for (u2.reverse(); u2.length && Hr(u2[0].char); ) u2.shift();
  if (u2.length < t2.backtrackCoverage.length) return [];
  var l2 = new Mr(u2, 0), p2 = jr(t2.backtrackCoverage, l2), c2 = [];
  if (n2.length === t2.inputCoverage.length && i2.length === t2.lookaheadCoverage.length && p2.length === t2.backtrackCoverage.length) for (var h2 = 0; h2 < t2.lookupRecords.length; h2++) for (var f2 = t2.lookupRecords[h2].lookupListIndex, d2 = this.getLookupByIndex(f2), v2 = 0; v2 < d2.subtables.length; v2++) {
    var g2 = d2.subtables[v2], m2 = this.getLookupMethod(d2, g2);
    if ("12" === this.getSubstitutionType(d2, g2)) for (var y2 = 0; y2 < n2.length; y2++) {
      var b2 = m2(e3.get(y2));
      b2 && c2.push(b2);
    }
  }
  return c2;
}
function Zr(e3, t2) {
  var r2, n2 = _r(e3.current, t2.coverage);
  if (-1 === n2) return null;
  for (var a2 = t2.ligatureSets[n2], o2 = 0; o2 < a2.length; o2++) {
    r2 = a2[o2];
    for (var s2 = 0; s2 < r2.components.length; s2++) {
      if (e3.lookahead[s2] !== r2.components[s2]) break;
      if (s2 === r2.components.length - 1) return r2;
    }
  }
  return null;
}
function Qr(e3, t2) {
  var r2 = _r(e3, t2.coverage);
  return -1 === r2 ? null : t2.sequences[r2];
}
Xt.prototype.exec = function(e3, t2) {
  if ("number" != typeof t2) throw new Error("Point size is not a number!");
  if (!(this._errorState > 2)) {
    var r2 = this.font, n2 = this._prepState;
    if (!n2 || n2.ppem !== t2) {
      var a2 = this._fpgmState;
      if (!a2) {
        sr.prototype = or, (a2 = this._fpgmState = new sr("fpgm", r2.tables.fpgm)).funcs = [], a2.font = r2, exports.DEBUG && (console.log("---EXEC FPGM---"), a2.step = -1);
        try {
          zt(a2);
        } catch (e4) {
          return console.log("Hinting error in FPGM:" + e4), void (this._errorState = 3);
        }
      }
      sr.prototype = a2, (n2 = this._prepState = new sr("prep", r2.tables.prep)).ppem = t2;
      var o2 = r2.tables.cvt;
      if (o2) for (var s2 = n2.cvt = new Array(o2.length), i2 = t2 / r2.unitsPerEm, u2 = 0; u2 < o2.length; u2++) s2[u2] = o2[u2] * i2;
      else n2.cvt = [];
      exports.DEBUG && (console.log("---EXEC PREP---"), n2.step = -1);
      try {
        zt(n2);
      } catch (e4) {
        this._errorState < 2 && console.log("Hinting error in PREP:" + e4), this._errorState = 2;
      }
    }
    if (!(this._errorState > 1)) try {
      return Wt(e3, n2);
    } catch (e4) {
      return this._errorState < 1 && (console.log("Hinting error:" + e4), console.log("Note: further hinting errors are silenced")), void (this._errorState = 1);
    }
  }
}, Wt = function(e3, t2) {
  var r2, n2, a2, o2 = t2.ppem / t2.font.unitsPerEm, s2 = o2, i2 = e3.components;
  if (sr.prototype = t2, i2) {
    var u2 = t2.font;
    n2 = [], r2 = [];
    for (var l2 = 0; l2 < i2.length; l2++) {
      var p2 = i2[l2], c2 = u2.glyphs.get(p2.glyphIndex);
      a2 = new sr("glyf", c2.instructions), exports.DEBUG && (console.log("---EXEC COMP " + l2 + "---"), a2.step = -1), qt(c2, a2, o2, s2);
      for (var h2 = Math.round(p2.dx * o2), f2 = Math.round(p2.dy * s2), d2 = a2.gZone, v2 = a2.contours, g2 = 0; g2 < d2.length; g2++) {
        var m2 = d2[g2];
        m2.xTouched = m2.yTouched = false, m2.xo = m2.x = m2.x + h2, m2.yo = m2.y = m2.y + f2;
      }
      var y2 = n2.length;
      n2.push.apply(n2, d2);
      for (var b2 = 0; b2 < v2.length; b2++) r2.push(v2[b2] + y2);
    }
    e3.instructions && !a2.inhibitGridFit && ((a2 = new sr("glyf", e3.instructions)).gZone = a2.z0 = a2.z1 = a2.z2 = n2, a2.contours = r2, n2.push(new nr(0, 0), new nr(Math.round(e3.advanceWidth * o2), 0)), exports.DEBUG && (console.log("---EXEC COMPOSITE---"), a2.step = -1), zt(a2), n2.length -= 2);
  } else a2 = new sr("glyf", e3.instructions), exports.DEBUG && (console.log("---EXEC GLYPH---"), a2.step = -1), qt(e3, a2, o2, s2), n2 = a2.gZone;
  return n2;
}, qt = function(e3, t2, r2, n2) {
  for (var a2, o2, s2, i2 = e3.points || [], u2 = i2.length, l2 = t2.gZone = t2.z0 = t2.z1 = t2.z2 = [], p2 = t2.contours = [], c2 = 0; c2 < u2; c2++) a2 = i2[c2], l2[c2] = new nr(a2.x * r2, a2.y * n2, a2.lastPointOfContour, a2.onCurve);
  for (var h2 = 0; h2 < u2; h2++) a2 = l2[h2], o2 || (o2 = a2, p2.push(h2)), a2.lastPointOfContour ? (a2.nextPointOnContour = o2, o2.prevPointOnContour = a2, o2 = void 0) : (s2 = l2[h2 + 1], a2.nextPointOnContour = s2, s2.prevPointOnContour = a2);
  if (!t2.inhibitGridFit) {
    if (exports.DEBUG) {
      console.log("PROCESSING GLYPH", t2.stack);
      for (var f2 = 0; f2 < u2; f2++) console.log(f2, l2[f2].x, l2[f2].y);
    }
    if (l2.push(new nr(0, 0), new nr(Math.round(e3.advanceWidth * r2), 0)), zt(t2), l2.length -= 2, exports.DEBUG) {
      console.log("FINISHED GLYPH", t2.stack);
      for (var d2 = 0; d2 < u2; d2++) console.log(d2, l2[d2].x, l2[d2].y);
    }
  }
}, zt = function(e3) {
  var t2 = e3.prog;
  if (t2) {
    var r2, n2 = t2.length;
    for (e3.ip = 0; e3.ip < n2; e3.ip++) {
      if (exports.DEBUG && e3.step++, !(r2 = Ht[t2[e3.ip]])) throw new Error("unknown instruction: 0x" + Number(t2[e3.ip]).toString(16));
      r2(e3);
    }
  }
}, Ht = [lr.bind(void 0, er), lr.bind(void 0, $t), pr.bind(void 0, er), pr.bind(void 0, $t), cr.bind(void 0, er), cr.bind(void 0, $t), hr.bind(void 0, 0), hr.bind(void 0, 1), fr.bind(void 0, 0), fr.bind(void 0, 1), function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "SPVFS[]", r2, n2), e3.pv = e3.dpv = rr(n2, r2);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "SPVFS[]", r2, n2), e3.fv = rr(n2, r2);
}, function(e3) {
  var t2 = e3.stack, r2 = e3.pv;
  exports.DEBUG && console.log(e3.step, "GPV[]"), t2.push(16384 * r2.x), t2.push(16384 * r2.y);
}, function(e3) {
  var t2 = e3.stack, r2 = e3.fv;
  exports.DEBUG && console.log(e3.step, "GFV[]"), t2.push(16384 * r2.x), t2.push(16384 * r2.y);
}, function(e3) {
  e3.fv = e3.pv, exports.DEBUG && console.log(e3.step, "SFVTPV[]");
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop(), a2 = t2.pop(), o2 = t2.pop(), s2 = t2.pop(), i2 = e3.z0, u2 = e3.z1, l2 = i2[r2], p2 = i2[n2], c2 = u2[a2], h2 = u2[o2], f2 = e3.z2[s2];
  exports.DEBUG && console.log("ISECT[], ", r2, n2, a2, o2, s2);
  var d2 = l2.x, v2 = l2.y, g2 = p2.x, m2 = p2.y, y2 = c2.x, b2 = c2.y, S2 = h2.x, x2 = h2.y, T2 = (d2 - g2) * (b2 - x2) - (v2 - m2) * (y2 - S2), U2 = d2 * m2 - v2 * g2, k2 = y2 * x2 - b2 * S2;
  f2.x = (U2 * (y2 - S2) - k2 * (d2 - g2)) / T2, f2.y = (U2 * (b2 - x2) - k2 * (v2 - m2)) / T2;
}, function(e3) {
  e3.rp0 = e3.stack.pop(), exports.DEBUG && console.log(e3.step, "SRP0[]", e3.rp0);
}, function(e3) {
  e3.rp1 = e3.stack.pop(), exports.DEBUG && console.log(e3.step, "SRP1[]", e3.rp1);
}, function(e3) {
  e3.rp2 = e3.stack.pop(), exports.DEBUG && console.log(e3.step, "SRP2[]", e3.rp2);
}, function(e3) {
  var t2 = e3.stack.pop();
  switch (exports.DEBUG && console.log(e3.step, "SZP0[]", t2), e3.zp0 = t2, t2) {
    case 0:
      e3.tZone || ir(e3), e3.z0 = e3.tZone;
      break;
    case 1:
      e3.z0 = e3.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}, function(e3) {
  var t2 = e3.stack.pop();
  switch (exports.DEBUG && console.log(e3.step, "SZP1[]", t2), e3.zp1 = t2, t2) {
    case 0:
      e3.tZone || ir(e3), e3.z1 = e3.tZone;
      break;
    case 1:
      e3.z1 = e3.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}, function(e3) {
  var t2 = e3.stack.pop();
  switch (exports.DEBUG && console.log(e3.step, "SZP2[]", t2), e3.zp2 = t2, t2) {
    case 0:
      e3.tZone || ir(e3), e3.z2 = e3.tZone;
      break;
    case 1:
      e3.z2 = e3.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}, function(e3) {
  var t2 = e3.stack.pop();
  switch (exports.DEBUG && console.log(e3.step, "SZPS[]", t2), e3.zp0 = e3.zp1 = e3.zp2 = t2, t2) {
    case 0:
      e3.tZone || ir(e3), e3.z0 = e3.z1 = e3.z2 = e3.tZone;
      break;
    case 1:
      e3.z0 = e3.z1 = e3.z2 = e3.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}, function(e3) {
  e3.loop = e3.stack.pop(), exports.DEBUG && console.log(e3.step, "SLOOP[]", e3.loop);
}, function(e3) {
  exports.DEBUG && console.log(e3.step, "RTG[]"), e3.round = jt;
}, function(e3) {
  exports.DEBUG && console.log(e3.step, "RTHG[]"), e3.round = Zt;
}, function(e3) {
  var t2 = e3.stack.pop();
  exports.DEBUG && console.log(e3.step, "SMD[]", t2), e3.minDis = t2 / 64;
}, function(e3) {
  exports.DEBUG && console.log(e3.step, "ELSE[]"), ur(e3, false);
}, function(e3) {
  var t2 = e3.stack.pop();
  exports.DEBUG && console.log(e3.step, "JMPR[]", t2), e3.ip += t2 - 1;
}, function(e3) {
  var t2 = e3.stack.pop();
  exports.DEBUG && console.log(e3.step, "SCVTCI[]", t2), e3.cvCutIn = t2 / 64;
}, void 0, void 0, function(e3) {
  var t2 = e3.stack;
  exports.DEBUG && console.log(e3.step, "DUP[]"), t2.push(t2[t2.length - 1]);
}, dr, function(e3) {
  exports.DEBUG && console.log(e3.step, "CLEAR[]"), e3.stack.length = 0;
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "SWAP[]"), t2.push(r2), t2.push(n2);
}, function(e3) {
  var t2 = e3.stack;
  exports.DEBUG && console.log(e3.step, "DEPTH[]"), t2.push(t2.length);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "CINDEX[]", r2), t2.push(t2[t2.length - r2]);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "MINDEX[]", r2), t2.push(t2.splice(t2.length - r2, 1)[0]);
}, void 0, void 0, void 0, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "LOOPCALL[]", r2, n2);
  var a2 = e3.ip, o2 = e3.prog;
  e3.prog = e3.funcs[r2];
  for (var s2 = 0; s2 < n2; s2++) zt(e3), exports.DEBUG && console.log(++e3.step, s2 + 1 < n2 ? "next loopcall" : "done loopcall", s2);
  e3.ip = a2, e3.prog = o2;
}, function(e3) {
  var t2 = e3.stack.pop();
  exports.DEBUG && console.log(e3.step, "CALL[]", t2);
  var r2 = e3.ip, n2 = e3.prog;
  e3.prog = e3.funcs[t2], zt(e3), e3.ip = r2, e3.prog = n2, exports.DEBUG && console.log(++e3.step, "returning from", t2);
}, function(e3) {
  if ("fpgm" !== e3.env) throw new Error("FDEF not allowed here");
  var t2 = e3.stack, r2 = e3.prog, n2 = e3.ip, a2 = t2.pop(), o2 = n2;
  for (exports.DEBUG && console.log(e3.step, "FDEF[]", a2); 45 !== r2[++n2]; ) ;
  e3.ip = n2, e3.funcs[a2] = r2.slice(o2 + 1, n2);
}, void 0, vr.bind(void 0, 0), vr.bind(void 0, 1), gr.bind(void 0, er), gr.bind(void 0, $t), mr.bind(void 0, 0), mr.bind(void 0, 1), yr.bind(void 0, 0), yr.bind(void 0, 1), br.bind(void 0, 0), br.bind(void 0, 1), function(e3) {
  for (var t2 = e3.stack, r2 = e3.loop, n2 = e3.fv, a2 = t2.pop() / 64, o2 = e3.z2; r2--; ) {
    var s2 = t2.pop(), i2 = o2[s2];
    exports.DEBUG && console.log(e3.step, (e3.loop > 1 ? "loop " + (e3.loop - r2) + ": " : "") + "SHPIX[]", s2, a2), n2.setRelative(i2, i2, a2), n2.touch(i2);
  }
  e3.loop = 1;
}, function(e3) {
  for (var t2 = e3.stack, r2 = e3.rp1, n2 = e3.rp2, a2 = e3.loop, o2 = e3.z0[r2], s2 = e3.z1[n2], i2 = e3.fv, u2 = e3.dpv, l2 = e3.z2; a2--; ) {
    var p2 = t2.pop(), c2 = l2[p2];
    exports.DEBUG && console.log(e3.step, (e3.loop > 1 ? "loop " + (e3.loop - a2) + ": " : "") + "IP[]", p2, r2, "<->", n2), i2.interpolate(c2, o2, s2, u2), i2.touch(c2);
  }
  e3.loop = 1;
}, Sr.bind(void 0, 0), Sr.bind(void 0, 1), function(e3) {
  for (var t2 = e3.stack, r2 = e3.rp0, n2 = e3.z0[r2], a2 = e3.loop, o2 = e3.fv, s2 = e3.pv, i2 = e3.z1; a2--; ) {
    var u2 = t2.pop(), l2 = i2[u2];
    exports.DEBUG && console.log(e3.step, (e3.loop > 1 ? "loop " + (e3.loop - a2) + ": " : "") + "ALIGNRP[]", u2), o2.setRelative(l2, n2, 0, s2), o2.touch(l2);
  }
  e3.loop = 1;
}, function(e3) {
  exports.DEBUG && console.log(e3.step, "RTDG[]"), e3.round = Yt;
}, xr.bind(void 0, 0), xr.bind(void 0, 1), function(e3) {
  var t2 = e3.prog, r2 = e3.ip, n2 = e3.stack, a2 = t2[++r2];
  exports.DEBUG && console.log(e3.step, "NPUSHB[]", a2);
  for (var o2 = 0; o2 < a2; o2++) n2.push(t2[++r2]);
  e3.ip = r2;
}, function(e3) {
  var t2 = e3.ip, r2 = e3.prog, n2 = e3.stack, a2 = r2[++t2];
  exports.DEBUG && console.log(e3.step, "NPUSHW[]", a2);
  for (var o2 = 0; o2 < a2; o2++) {
    var s2 = r2[++t2] << 8 | r2[++t2];
    32768 & s2 && (s2 = -(1 + (65535 ^ s2))), n2.push(s2);
  }
  e3.ip = t2;
}, function(e3) {
  var t2 = e3.stack, r2 = e3.store;
  r2 || (r2 = e3.store = []);
  var n2 = t2.pop(), a2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "WS", n2, a2), r2[a2] = n2;
}, function(e3) {
  var t2 = e3.stack, r2 = e3.store, n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "RS", n2);
  var a2 = r2 && r2[n2] || 0;
  t2.push(a2);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "WCVTP", r2, n2), e3.cvt[n2] = r2 / 64;
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "RCVT", r2), t2.push(64 * e3.cvt[r2]);
}, Tr.bind(void 0, 0), Tr.bind(void 0, 1), void 0, Ur.bind(void 0, 0), Ur.bind(void 0, 1), function(e3) {
  exports.DEBUG && console.log(e3.step, "MPPEM[]"), e3.stack.push(e3.ppem);
}, void 0, function(e3) {
  exports.DEBUG && console.log(e3.step, "FLIPON[]"), e3.autoFlip = true;
}, void 0, void 0, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "LT[]", r2, n2), t2.push(n2 < r2 ? 1 : 0);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "LTEQ[]", r2, n2), t2.push(n2 <= r2 ? 1 : 0);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "GT[]", r2, n2), t2.push(n2 > r2 ? 1 : 0);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "GTEQ[]", r2, n2), t2.push(n2 >= r2 ? 1 : 0);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "EQ[]", r2, n2), t2.push(r2 === n2 ? 1 : 0);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "NEQ[]", r2, n2), t2.push(r2 !== n2 ? 1 : 0);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "ODD[]", r2), t2.push(Math.trunc(r2) % 2 ? 1 : 0);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "EVEN[]", r2), t2.push(Math.trunc(r2) % 2 ? 0 : 1);
}, function(e3) {
  var t2 = e3.stack.pop();
  exports.DEBUG && console.log(e3.step, "IF[]", t2), t2 || (ur(e3, true), exports.DEBUG && console.log(e3.step, "EIF[]"));
}, function(e3) {
  exports.DEBUG && console.log(e3.step, "EIF[]");
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "AND[]", r2, n2), t2.push(r2 && n2 ? 1 : 0);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "OR[]", r2, n2), t2.push(r2 || n2 ? 1 : 0);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "NOT[]", r2), t2.push(r2 ? 0 : 1);
}, kr.bind(void 0, 1), function(e3) {
  var t2 = e3.stack.pop();
  exports.DEBUG && console.log(e3.step, "SDB[]", t2), e3.deltaBase = t2;
}, function(e3) {
  var t2 = e3.stack.pop();
  exports.DEBUG && console.log(e3.step, "SDS[]", t2), e3.deltaShift = Math.pow(0.5, t2);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "ADD[]", r2, n2), t2.push(n2 + r2);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "SUB[]", r2, n2), t2.push(n2 - r2);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "DIV[]", r2, n2), t2.push(64 * n2 / r2);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "MUL[]", r2, n2), t2.push(n2 * r2 / 64);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "ABS[]", r2), t2.push(Math.abs(r2));
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "NEG[]", r2), t2.push(-r2);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "FLOOR[]", r2), t2.push(64 * Math.floor(r2 / 64));
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "CEILING[]", r2), t2.push(64 * Math.ceil(r2 / 64));
}, Or.bind(void 0, 0), Or.bind(void 0, 1), Or.bind(void 0, 2), Or.bind(void 0, 3), void 0, void 0, void 0, void 0, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "WCVTF[]", r2, n2), e3.cvt[n2] = r2 * e3.ppem / e3.font.unitsPerEm;
}, kr.bind(void 0, 2), kr.bind(void 0, 3), Rr.bind(void 0, 1), Rr.bind(void 0, 2), Rr.bind(void 0, 3), function(e3) {
  var t2, r2 = e3.stack.pop();
  switch (exports.DEBUG && console.log(e3.step, "SROUND[]", r2), e3.round = Jt, 192 & r2) {
    case 0:
      t2 = 0.5;
      break;
    case 64:
      t2 = 1;
      break;
    case 128:
      t2 = 2;
      break;
    default:
      throw new Error("invalid SROUND value");
  }
  switch (e3.srPeriod = t2, 48 & r2) {
    case 0:
      e3.srPhase = 0;
      break;
    case 16:
      e3.srPhase = 0.25 * t2;
      break;
    case 32:
      e3.srPhase = 0.5 * t2;
      break;
    case 48:
      e3.srPhase = 0.75 * t2;
      break;
    default:
      throw new Error("invalid SROUND value");
  }
  r2 &= 15, e3.srThreshold = 0 === r2 ? 0 : (r2 / 8 - 0.5) * t2;
}, function(e3) {
  var t2, r2 = e3.stack.pop();
  switch (exports.DEBUG && console.log(e3.step, "S45ROUND[]", r2), e3.round = Jt, 192 & r2) {
    case 0:
      t2 = Math.sqrt(2) / 2;
      break;
    case 64:
      t2 = Math.sqrt(2);
      break;
    case 128:
      t2 = 2 * Math.sqrt(2);
      break;
    default:
      throw new Error("invalid S45ROUND value");
  }
  switch (e3.srPeriod = t2, 48 & r2) {
    case 0:
      e3.srPhase = 0;
      break;
    case 16:
      e3.srPhase = 0.25 * t2;
      break;
    case 32:
      e3.srPhase = 0.5 * t2;
      break;
    case 48:
      e3.srPhase = 0.75 * t2;
      break;
    default:
      throw new Error("invalid S45ROUND value");
  }
  r2 &= 15, e3.srThreshold = 0 === r2 ? 0 : (r2 / 8 - 0.5) * t2;
}, void 0, void 0, function(e3) {
  exports.DEBUG && console.log(e3.step, "ROFF[]"), e3.round = Vt;
}, void 0, function(e3) {
  exports.DEBUG && console.log(e3.step, "RUTG[]"), e3.round = Qt;
}, function(e3) {
  exports.DEBUG && console.log(e3.step, "RDTG[]"), e3.round = Kt;
}, dr, dr, void 0, void 0, void 0, void 0, void 0, function(e3) {
  var t2 = e3.stack.pop();
  exports.DEBUG && console.log(e3.step, "SCANCTRL[]", t2);
}, Er.bind(void 0, 0), Er.bind(void 0, 1), function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = 0;
  exports.DEBUG && console.log(e3.step, "GETINFO[]", r2), 1 & r2 && (n2 = 35), 32 & r2 && (n2 |= 4096), t2.push(n2);
}, void 0, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop(), a2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "ROLL[]"), t2.push(n2), t2.push(r2), t2.push(a2);
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "MAX[]", r2, n2), t2.push(Math.max(n2, r2));
}, function(e3) {
  var t2 = e3.stack, r2 = t2.pop(), n2 = t2.pop();
  exports.DEBUG && console.log(e3.step, "MIN[]", r2, n2), t2.push(Math.min(n2, r2));
}, function(e3) {
  var t2 = e3.stack.pop();
  exports.DEBUG && console.log(e3.step, "SCANTYPE[]", t2);
}, function(e3) {
  var t2 = e3.stack.pop(), r2 = e3.stack.pop();
  switch (exports.DEBUG && console.log(e3.step, "INSTCTRL[]", t2, r2), t2) {
    case 1:
      return void (e3.inhibitGridFit = !!r2);
    case 2:
      return void (e3.ignoreCvt = !!r2);
    default:
      throw new Error("invalid INSTCTRL[] selector");
  }
}, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, Lr.bind(void 0, 1), Lr.bind(void 0, 2), Lr.bind(void 0, 3), Lr.bind(void 0, 4), Lr.bind(void 0, 5), Lr.bind(void 0, 6), Lr.bind(void 0, 7), Lr.bind(void 0, 8), Cr.bind(void 0, 1), Cr.bind(void 0, 2), Cr.bind(void 0, 3), Cr.bind(void 0, 4), Cr.bind(void 0, 5), Cr.bind(void 0, 6), Cr.bind(void 0, 7), Cr.bind(void 0, 8), wr.bind(void 0, 0, 0, 0, 0, 0), wr.bind(void 0, 0, 0, 0, 0, 1), wr.bind(void 0, 0, 0, 0, 0, 2), wr.bind(void 0, 0, 0, 0, 0, 3), wr.bind(void 0, 0, 0, 0, 1, 0), wr.bind(void 0, 0, 0, 0, 1, 1), wr.bind(void 0, 0, 0, 0, 1, 2), wr.bind(void 0, 0, 0, 0, 1, 3), wr.bind(void 0, 0, 0, 1, 0, 0), wr.bind(void 0, 0, 0, 1, 0, 1), wr.bind(void 0, 0, 0, 1, 0, 2), wr.bind(void 0, 0, 0, 1, 0, 3), wr.bind(void 0, 0, 0, 1, 1, 0), wr.bind(void 0, 0, 0, 1, 1, 1), wr.bind(void 0, 0, 0, 1, 1, 2), wr.bind(void 0, 0, 0, 1, 1, 3), wr.bind(void 0, 0, 1, 0, 0, 0), wr.bind(void 0, 0, 1, 0, 0, 1), wr.bind(void 0, 0, 1, 0, 0, 2), wr.bind(void 0, 0, 1, 0, 0, 3), wr.bind(void 0, 0, 1, 0, 1, 0), wr.bind(void 0, 0, 1, 0, 1, 1), wr.bind(void 0, 0, 1, 0, 1, 2), wr.bind(void 0, 0, 1, 0, 1, 3), wr.bind(void 0, 0, 1, 1, 0, 0), wr.bind(void 0, 0, 1, 1, 0, 1), wr.bind(void 0, 0, 1, 1, 0, 2), wr.bind(void 0, 0, 1, 1, 0, 3), wr.bind(void 0, 0, 1, 1, 1, 0), wr.bind(void 0, 0, 1, 1, 1, 1), wr.bind(void 0, 0, 1, 1, 1, 2), wr.bind(void 0, 0, 1, 1, 1, 3), wr.bind(void 0, 1, 0, 0, 0, 0), wr.bind(void 0, 1, 0, 0, 0, 1), wr.bind(void 0, 1, 0, 0, 0, 2), wr.bind(void 0, 1, 0, 0, 0, 3), wr.bind(void 0, 1, 0, 0, 1, 0), wr.bind(void 0, 1, 0, 0, 1, 1), wr.bind(void 0, 1, 0, 0, 1, 2), wr.bind(void 0, 1, 0, 0, 1, 3), wr.bind(void 0, 1, 0, 1, 0, 0), wr.bind(void 0, 1, 0, 1, 0, 1), wr.bind(void 0, 1, 0, 1, 0, 2), wr.bind(void 0, 1, 0, 1, 0, 3), wr.bind(void 0, 1, 0, 1, 1, 0), wr.bind(void 0, 1, 0, 1, 1, 1), wr.bind(void 0, 1, 0, 1, 1, 2), wr.bind(void 0, 1, 0, 1, 1, 3), wr.bind(void 0, 1, 1, 0, 0, 0), wr.bind(void 0, 1, 1, 0, 0, 1), wr.bind(void 0, 1, 1, 0, 0, 2), wr.bind(void 0, 1, 1, 0, 0, 3), wr.bind(void 0, 1, 1, 0, 1, 0), wr.bind(void 0, 1, 1, 0, 1, 1), wr.bind(void 0, 1, 1, 0, 1, 2), wr.bind(void 0, 1, 1, 0, 1, 3), wr.bind(void 0, 1, 1, 1, 0, 0), wr.bind(void 0, 1, 1, 1, 0, 1), wr.bind(void 0, 1, 1, 1, 0, 2), wr.bind(void 0, 1, 1, 1, 0, 3), wr.bind(void 0, 1, 1, 1, 1, 0), wr.bind(void 0, 1, 1, 1, 1, 1), wr.bind(void 0, 1, 1, 1, 1, 2), wr.bind(void 0, 1, 1, 1, 1, 3)], Dr.prototype.setState = function(e3, t2) {
  return this.state[e3] = t2, this.activeState = { key: e3, value: this.state[e3] }, this.activeState;
}, Dr.prototype.getState = function(e3) {
  return this.state[e3] || null;
}, Pr.prototype.inboundIndex = function(e3) {
  return e3 >= 0 && e3 < this.tokens.length;
}, Pr.prototype.composeRUD = function(e3) {
  var t2 = this, r2 = e3.map(function(e4) {
    return t2[e4[0]].apply(t2, e4.slice(1).concat(true));
  }), n2 = function(e4) {
    return "object" == typeof e4 && e4.hasOwnProperty("FAIL");
  };
  if (r2.every(n2)) return { FAIL: "composeRUD: one or more operations hasn't completed successfully", report: r2.filter(n2) };
  this.dispatch("composeRUD", [r2.filter(function(e4) {
    return !n2(e4);
  })]);
}, Pr.prototype.replaceRange = function(e3, t2, r2, n2) {
  t2 = null !== t2 ? t2 : this.tokens.length;
  var a2 = r2.every(function(e4) {
    return e4 instanceof Dr;
  });
  if (!isNaN(e3) && this.inboundIndex(e3) && a2) {
    var o2 = this.tokens.splice.apply(this.tokens, [e3, t2].concat(r2));
    return n2 || this.dispatch("replaceToken", [e3, t2, r2]), [o2, r2];
  }
  return { FAIL: "replaceRange: invalid tokens or startIndex." };
}, Pr.prototype.replaceToken = function(e3, t2, r2) {
  if (!isNaN(e3) && this.inboundIndex(e3) && t2 instanceof Dr) {
    var n2 = this.tokens.splice(e3, 1, t2);
    return r2 || this.dispatch("replaceToken", [e3, t2]), [n2[0], t2];
  }
  return { FAIL: "replaceToken: invalid token or index." };
}, Pr.prototype.removeRange = function(e3, t2, r2) {
  t2 = isNaN(t2) ? this.tokens.length : t2;
  var n2 = this.tokens.splice(e3, t2);
  return r2 || this.dispatch("removeRange", [n2, e3, t2]), n2;
}, Pr.prototype.removeToken = function(e3, t2) {
  if (!isNaN(e3) && this.inboundIndex(e3)) {
    var r2 = this.tokens.splice(e3, 1);
    return t2 || this.dispatch("removeToken", [r2, e3]), r2;
  }
  return { FAIL: "removeToken: invalid token index." };
}, Pr.prototype.insertToken = function(e3, t2, r2) {
  return e3.every(function(e4) {
    return e4 instanceof Dr;
  }) ? (this.tokens.splice.apply(this.tokens, [t2, 0].concat(e3)), r2 || this.dispatch("insertToken", [e3, t2]), e3) : { FAIL: "insertToken: invalid token(s)." };
}, Pr.prototype.registerModifier = function(e3, t2, r2) {
  this.events.newToken.subscribe(function(n2, a2) {
    var o2 = [n2, a2], s2 = [n2, a2];
    if (null === t2 || true === t2.apply(this, o2)) {
      var i2 = r2.apply(this, s2);
      n2.setState(e3, i2);
    }
  }), this.registeredModifiers.push(e3);
}, Br.prototype.subscribe = function(e3) {
  return "function" == typeof e3 ? this.subscribers.push(e3) - 1 : { FAIL: "invalid '" + this.eventId + "' event handler" };
}, Br.prototype.unsubscribe = function(e3) {
  this.subscribers.splice(e3, 1);
}, Mr.prototype.setCurrentIndex = function(e3) {
  this.index = e3, this.current = this.context[e3], this.backtrack = this.context.slice(0, e3), this.lookahead = this.context.slice(e3 + 1);
}, Mr.prototype.get = function(e3) {
  switch (true) {
    case 0 === e3:
      return this.current;
    case (e3 < 0 && Math.abs(e3) <= this.backtrack.length):
      return this.backtrack.slice(e3)[0];
    case (e3 > 0 && e3 <= this.lookahead.length):
      return this.lookahead[e3 - 1];
    default:
      return null;
  }
}, Pr.prototype.rangeToText = function(e3) {
  if (e3 instanceof Ir) return this.getRangeTokens(e3).map(function(e4) {
    return e4.char;
  }).join("");
}, Pr.prototype.getText = function() {
  return this.tokens.map(function(e3) {
    return e3.char;
  }).join("");
}, Pr.prototype.getContext = function(e3) {
  var t2 = this.registeredContexts[e3];
  return t2 || null;
}, Pr.prototype.on = function(e3, t2) {
  var r2 = this.events[e3];
  return r2 ? r2.subscribe(t2) : null;
}, Pr.prototype.dispatch = function(e3, t2) {
  var r2 = this, n2 = this.events[e3];
  n2 instanceof Br && n2.subscribers.forEach(function(e4) {
    e4.apply(r2, t2 || []);
  });
}, Pr.prototype.registerContextChecker = function(e3, t2, r2) {
  if (this.getContext(e3)) return { FAIL: "context name '" + e3 + "' is already registered." };
  if ("function" != typeof t2) return { FAIL: "missing context start check." };
  if ("function" != typeof r2) return { FAIL: "missing context end check." };
  var n2 = new Gr(e3, t2, r2);
  return this.registeredContexts[e3] = n2, this.contextCheckers.push(n2), n2;
}, Pr.prototype.getRangeTokens = function(e3) {
  var t2 = e3.startIndex + e3.endOffset;
  return [].concat(this.tokens.slice(e3.startIndex, t2));
}, Pr.prototype.getContextRanges = function(e3) {
  var t2 = this.getContext(e3);
  return t2 ? t2.ranges : { FAIL: "context checker '" + e3 + "' is not registered." };
}, Pr.prototype.resetContextsRanges = function() {
  var e3 = this.registeredContexts;
  for (var t2 in e3) {
    if (e3.hasOwnProperty(t2)) e3[t2].ranges = [];
  }
}, Pr.prototype.updateContextsRanges = function() {
  this.resetContextsRanges();
  for (var e3 = this.tokens.map(function(e4) {
    return e4.char;
  }), t2 = 0; t2 < e3.length; t2++) {
    var r2 = new Mr(e3, t2);
    this.runContextCheck(r2);
  }
  this.dispatch("updateContextsRanges", [this.registeredContexts]);
}, Pr.prototype.setEndOffset = function(e3, t2) {
  var r2 = new Ir(this.getContext(t2).openRange.startIndex, e3, t2), n2 = this.getContext(t2).ranges;
  return r2.rangeId = t2 + "." + n2.length, n2.push(r2), this.getContext(t2).openRange = null, r2;
}, Pr.prototype.runContextCheck = function(e3) {
  var t2 = this, r2 = e3.index;
  this.contextCheckers.forEach(function(n2) {
    var a2 = n2.contextName, o2 = t2.getContext(a2).openRange;
    if (!o2 && n2.checkStart(e3) && (o2 = new Ir(r2, null, a2), t2.getContext(a2).openRange = o2, t2.dispatch("contextStart", [a2, r2])), o2 && n2.checkEnd(e3)) {
      var s2 = r2 - o2.startIndex + 1, i2 = t2.setEndOffset(s2, a2);
      t2.dispatch("contextEnd", [a2, i2]);
    }
  });
}, Pr.prototype.tokenize = function(e3) {
  this.tokens = [], this.resetContextsRanges();
  var t2 = Array.from(e3);
  this.dispatch("start");
  for (var r2 = 0; r2 < t2.length; r2++) {
    var n2 = t2[r2], a2 = new Mr(t2, r2);
    this.dispatch("next", [a2]), this.runContextCheck(a2);
    var o2 = new Dr(n2);
    this.tokens.push(o2), this.dispatch("newToken", [o2, a2]);
  }
  return this.dispatch("end", [this.tokens]), this.tokens;
}, Wr.prototype.getDefaultScriptFeaturesIndexes = function() {
  for (var e3 = this.font.tables.gsub.scripts, t2 = 0; t2 < e3.length; t2++) {
    var r2 = e3[t2];
    if ("DFLT" === r2.tag) return r2.script.defaultLangSys.featureIndexes;
  }
  return [];
}, Wr.prototype.getScriptFeaturesIndexes = function(e3) {
  if (!this.font.tables.gsub) return [];
  if (!e3) return this.getDefaultScriptFeaturesIndexes();
  for (var t2 = this.font.tables.gsub.scripts, r2 = 0; r2 < t2.length; r2++) {
    var n2 = t2[r2];
    if (n2.tag === e3 && n2.script.defaultLangSys) return n2.script.defaultLangSys.featureIndexes;
    var a2 = n2.langSysRecords;
    if (a2) for (var o2 = 0; o2 < a2.length; o2++) {
      var s2 = a2[o2];
      if (s2.tag === e3) return s2.langSys.featureIndexes;
    }
  }
  return this.getDefaultScriptFeaturesIndexes();
}, Wr.prototype.mapTagsToFeatures = function(e3, t2) {
  for (var r2 = {}, n2 = 0; n2 < e3.length; n2++) {
    var a2 = e3[n2].tag, o2 = e3[n2].feature;
    r2[a2] = o2;
  }
  this.features[t2].tags = r2;
}, Wr.prototype.getScriptFeatures = function(e3) {
  var t2 = this.features[e3];
  if (this.features.hasOwnProperty(e3)) return t2;
  var r2 = this.getScriptFeaturesIndexes(e3);
  if (!r2) return null;
  var n2 = this.font.tables.gsub;
  return t2 = r2.map(function(e4) {
    return n2.features[e4];
  }), this.features[e3] = t2, this.mapTagsToFeatures(t2, e3), t2;
}, Wr.prototype.getSubstitutionType = function(e3, t2) {
  return e3.lookupType.toString() + t2.substFormat.toString();
}, Wr.prototype.getLookupMethod = function(e3, t2) {
  var r2 = this;
  switch (this.getSubstitutionType(e3, t2)) {
    case "11":
      return function(e4) {
        return Xr.apply(r2, [e4, t2]);
      };
    case "12":
      return function(e4) {
        return Vr.apply(r2, [e4, t2]);
      };
    case "63":
      return function(e4) {
        return Yr.apply(r2, [e4, t2]);
      };
    case "41":
      return function(e4) {
        return Zr.apply(r2, [e4, t2]);
      };
    case "21":
      return function(e4) {
        return Qr.apply(r2, [e4, t2]);
      };
    default:
      throw new Error("lookupType: " + e3.lookupType + " - substFormat: " + t2.substFormat + " is not yet supported");
  }
}, Wr.prototype.lookupFeature = function(e3) {
  var t2 = e3.contextParams, r2 = t2.index, n2 = this.getFeature({ tag: e3.tag, script: e3.script });
  if (!n2) return new Error("font '" + this.font.names.fullName.en + "' doesn't support feature '" + e3.tag + "' for script '" + e3.script + "'.");
  for (var a2 = this.getFeatureLookups(n2), o2 = [].concat(t2.context), s2 = 0; s2 < a2.length; s2++) for (var i2 = a2[s2], u2 = this.getLookupSubtables(i2), l2 = 0; l2 < u2.length; l2++) {
    var p2 = u2[l2], c2 = this.getSubstitutionType(i2, p2), h2 = this.getLookupMethod(i2, p2), f2 = void 0;
    switch (c2) {
      case "11":
        (f2 = h2(t2.current)) && o2.splice(r2, 1, new qr({ id: 11, tag: e3.tag, substitution: f2 }));
        break;
      case "12":
        (f2 = h2(t2.current)) && o2.splice(r2, 1, new qr({ id: 12, tag: e3.tag, substitution: f2 }));
        break;
      case "63":
        f2 = h2(t2), Array.isArray(f2) && f2.length && o2.splice(r2, 1, new qr({ id: 63, tag: e3.tag, substitution: f2 }));
        break;
      case "41":
        (f2 = h2(t2)) && o2.splice(r2, 1, new qr({ id: 41, tag: e3.tag, substitution: f2 }));
        break;
      case "21":
        (f2 = h2(t2.current)) && o2.splice(r2, 1, new qr({ id: 21, tag: e3.tag, substitution: f2 }));
    }
    t2 = new Mr(o2, r2), Array.isArray(f2) && !f2.length || (f2 = null);
  }
  return o2.length ? o2 : null;
}, Wr.prototype.supports = function(e3) {
  if (!e3.script) return false;
  this.getScriptFeatures(e3.script);
  var t2 = this.features.hasOwnProperty(e3.script);
  if (!e3.tag) return t2;
  var r2 = this.features[e3.script].some(function(t3) {
    return t3.tag === e3.tag;
  });
  return t2 && r2;
}, Wr.prototype.getLookupSubtables = function(e3) {
  return e3.subtables || null;
}, Wr.prototype.getLookupByIndex = function(e3) {
  return this.font.tables.gsub.lookups[e3] || null;
}, Wr.prototype.getFeatureLookups = function(e3) {
  return e3.lookupListIndexes.map(this.getLookupByIndex.bind(this));
}, Wr.prototype.getFeature = function(e3) {
  if (!this.font) return { FAIL: "No font was found" };
  this.features.hasOwnProperty(e3.script) || this.getScriptFeatures(e3.script);
  var t2 = this.features[e3.script];
  return t2 ? t2.tags[e3.tag] ? this.features[e3.script].tags[e3.tag] : null : { FAIL: "No feature for script " + e3.script };
};
var Kr = { startCheck: function(e3) {
  var t2 = e3.current, r2 = e3.get(-1);
  return null === r2 && Ar(t2) || !Ar(r2) && Ar(t2);
}, endCheck: function(e3) {
  var t2 = e3.get(1);
  return null === t2 || !Ar(t2);
} };
var Jr = { startCheck: function(e3) {
  var t2 = e3.current, r2 = e3.get(-1);
  return (Ar(t2) || Hr(t2)) && !Ar(r2);
}, endCheck: function(e3) {
  var t2 = e3.get(1);
  switch (true) {
    case null === t2:
      return true;
    case (!Ar(t2) && !Hr(t2)):
      var r2 = /\s/.test(t2);
      if (!r2) return true;
      if (r2) {
        var n2;
        if (n2 = e3.lookahead.some(function(e4) {
          return Ar(e4) || Hr(e4);
        }), !n2) return true;
      }
      break;
    default:
      return false;
  }
} };
var $r = { 11: function(e3, t2, r2) {
  t2[r2].setState(e3.tag, e3.substitution);
}, 12: function(e3, t2, r2) {
  t2[r2].setState(e3.tag, e3.substitution);
}, 63: function(e3, t2, r2) {
  e3.substitution.forEach(function(n2, a2) {
    t2[r2 + a2].setState(e3.tag, n2);
  });
}, 41: function(e3, t2, r2) {
  var n2 = t2[r2];
  n2.setState(e3.tag, e3.substitution.ligGlyph);
  for (var a2 = e3.substitution.components.length, o2 = 0; o2 < a2; o2++) (n2 = t2[r2 + o2 + 1]).setState("deleted", true);
} };
function en(e3, t2, r2) {
  e3 instanceof qr && $r[e3.id] && $r[e3.id](e3, t2, r2);
}
function tn(e3) {
  var t2 = this, r2 = "arab", n2 = this.featuresTags[r2], a2 = this.tokenizer.getRangeTokens(e3);
  if (1 !== a2.length) {
    var o2 = new Mr(a2.map(function(e4) {
      return e4.getState("glyphIndex");
    }), 0), s2 = new Mr(a2.map(function(e4) {
      return e4.char;
    }), 0);
    a2.forEach(function(e4, i2) {
      if (!Hr(e4.char)) {
        o2.setCurrentIndex(i2), s2.setCurrentIndex(i2);
        var u2, l2 = 0;
        switch (function(e5) {
          for (var t3 = [].concat(e5.backtrack), r3 = t3.length - 1; r3 >= 0; r3--) {
            var n3 = t3[r3], a3 = Nr(n3), o3 = Hr(n3);
            if (!a3 && !o3) return true;
            if (a3) return false;
          }
          return false;
        }(s2) && (l2 |= 1), function(e5) {
          if (Nr(e5.current)) return false;
          for (var t3 = 0; t3 < e5.lookahead.length; t3++) if (!Hr(e5.lookahead[t3])) return true;
          return false;
        }(s2) && (l2 |= 2), l2) {
          case 1:
            u2 = "fina";
            break;
          case 2:
            u2 = "init";
            break;
          case 3:
            u2 = "medi";
        }
        if (-1 !== n2.indexOf(u2)) {
          var p2 = t2.query.lookupFeature({ tag: u2, script: r2, contextParams: o2 });
          if (p2 instanceof Error) return console.info(p2.message);
          p2.forEach(function(e5, t3) {
            e5 instanceof qr && (en(e5, a2, t3), o2.context[t3] = e5.substitution);
          });
        }
      }
    });
  }
}
function rn(e3, t2) {
  return new Mr(e3.map(function(e4) {
    return e4.activeState.value;
  }), t2 || 0);
}
function nn(e3) {
  var t2 = this, r2 = this.tokenizer.getRangeTokens(e3), n2 = rn(r2);
  n2.context.forEach(function(e4, a2) {
    n2.setCurrentIndex(a2);
    var o2 = t2.query.lookupFeature({ tag: "rlig", script: "arab", contextParams: n2 });
    o2.length && (o2.forEach(function(e5) {
      return en(e5, r2, a2);
    }), n2 = rn(r2));
  });
}
var an = { startCheck: function(e3) {
  var t2 = e3.current, r2 = e3.get(-1);
  return null === r2 && zr(t2) || !zr(r2) && zr(t2);
}, endCheck: function(e3) {
  var t2 = e3.get(1);
  return null === t2 || !zr(t2);
} };
function on(e3, t2) {
  return new Mr(e3.map(function(e4) {
    return e4.activeState.value;
  }), t2 || 0);
}
function sn(e3) {
  var t2 = this, r2 = this.tokenizer.getRangeTokens(e3), n2 = on(r2);
  n2.context.forEach(function(e4, a2) {
    n2.setCurrentIndex(a2);
    var o2 = t2.query.lookupFeature({ tag: "liga", script: "latn", contextParams: n2 });
    o2.length && (o2.forEach(function(e5) {
      return en(e5, r2, a2);
    }), n2 = on(r2));
  });
}
function un(e3) {
  this.baseDir = e3 || "ltr", this.tokenizer = new Pr(), this.featuresTags = {};
}
function ln(e3) {
  var t2 = this.contextChecks[e3 + "Check"];
  return this.tokenizer.registerContextChecker(e3, t2.startCheck, t2.endCheck);
}
function pn() {
  return ln.call(this, "latinWord"), ln.call(this, "arabicWord"), ln.call(this, "arabicSentence"), this.tokenizer.tokenize(this.text);
}
function cn() {
  var e3 = this;
  this.tokenizer.getContextRanges("arabicSentence").forEach(function(t2) {
    var r2 = e3.tokenizer.getRangeTokens(t2);
    e3.tokenizer.replaceRange(t2.startIndex, t2.endOffset, r2.reverse());
  });
}
function hn() {
  if (-1 === this.tokenizer.registeredModifiers.indexOf("glyphIndex")) throw new Error("glyphIndex modifier is required to apply arabic presentation features.");
}
function fn() {
  var e3 = this;
  this.featuresTags.hasOwnProperty("arab") && (hn.call(this), this.tokenizer.getContextRanges("arabicWord").forEach(function(t2) {
    tn.call(e3, t2);
  }));
}
function dn() {
  var e3 = this, t2 = "arab";
  this.featuresTags.hasOwnProperty(t2) && (-1 !== this.featuresTags[t2].indexOf("rlig") && (hn.call(this), this.tokenizer.getContextRanges("arabicWord").forEach(function(t3) {
    nn.call(e3, t3);
  })));
}
function vn() {
  var e3 = this, t2 = "latn";
  this.featuresTags.hasOwnProperty(t2) && (-1 !== this.featuresTags[t2].indexOf("liga") && (hn.call(this), this.tokenizer.getContextRanges("latinWord").forEach(function(t3) {
    sn.call(e3, t3);
  })));
}
function gn(e3) {
  (e3 = e3 || {}).tables = e3.tables || {}, e3.empty || (Mt(e3.familyName, "When creating a new Font object, familyName is required."), Mt(e3.styleName, "When creating a new Font object, styleName is required."), Mt(e3.unitsPerEm, "When creating a new Font object, unitsPerEm is required."), Mt(e3.ascender, "When creating a new Font object, ascender is required."), Mt(e3.descender <= 0, "When creating a new Font object, negative descender value is required."), this.names = { fontFamily: { en: e3.familyName || " " }, fontSubfamily: { en: e3.styleName || " " }, fullName: { en: e3.fullName || e3.familyName + " " + e3.styleName }, postScriptName: { en: e3.postScriptName || (e3.familyName + e3.styleName).replace(/\s/g, "") }, designer: { en: e3.designer || " " }, designerURL: { en: e3.designerURL || " " }, manufacturer: { en: e3.manufacturer || " " }, manufacturerURL: { en: e3.manufacturerURL || " " }, license: { en: e3.license || " " }, licenseURL: { en: e3.licenseURL || " " }, version: { en: e3.version || "Version 0.1" }, description: { en: e3.description || " " }, copyright: { en: e3.copyright || " " }, trademark: { en: e3.trademark || " " } }, this.unitsPerEm = e3.unitsPerEm || 1e3, this.ascender = e3.ascender, this.descender = e3.descender, this.createdTimestamp = e3.createdTimestamp, this.tables = Object.assign(e3.tables, { os2: Object.assign({ usWeightClass: e3.weightClass || this.usWeightClasses.MEDIUM, usWidthClass: e3.widthClass || this.usWidthClasses.MEDIUM, fsSelection: e3.fsSelection || this.fsSelectionValues.REGULAR }, e3.tables.os2) })), this.supported = true, this.glyphs = new Be.GlyphSet(this, e3.glyphs || []), this.encoding = new Re(this), this.position = new Ct(this), this.substitution = new wt(this), this.tables = this.tables || {}, this._push = null, this._hmtxTableData = {}, Object.defineProperty(this, "hinting", { get: function() {
    return this._hinting ? this._hinting : "truetype" === this.outlinesFormat ? this._hinting = new Xt(this) : void 0;
  } });
}
function mn(e3, t2) {
  var r2 = JSON.stringify(e3), n2 = 256;
  for (var a2 in t2) {
    var o2 = parseInt(a2);
    if (o2 && !(o2 < 256)) {
      if (JSON.stringify(t2[a2]) === r2) return o2;
      n2 <= o2 && (n2 = o2 + 1);
    }
  }
  return t2[n2] = e3, n2;
}
function yn(e3, t2, r2) {
  var n2 = mn(t2.name, r2);
  return [{ name: "tag_" + e3, type: "TAG", value: t2.tag }, { name: "minValue_" + e3, type: "FIXED", value: t2.minValue << 16 }, { name: "defaultValue_" + e3, type: "FIXED", value: t2.defaultValue << 16 }, { name: "maxValue_" + e3, type: "FIXED", value: t2.maxValue << 16 }, { name: "flags_" + e3, type: "USHORT", value: 0 }, { name: "nameID_" + e3, type: "USHORT", value: n2 }];
}
function bn(e3, t2, r2) {
  var n2 = {}, a2 = new se.Parser(e3, t2);
  return n2.tag = a2.parseTag(), n2.minValue = a2.parseFixed(), n2.defaultValue = a2.parseFixed(), n2.maxValue = a2.parseFixed(), a2.skip("uShort", 1), n2.name = r2[a2.parseUShort()] || {}, n2;
}
function Sn(e3, t2, r2, n2) {
  for (var a2 = [{ name: "nameID_" + e3, type: "USHORT", value: mn(t2.name, n2) }, { name: "flags_" + e3, type: "USHORT", value: 0 }], o2 = 0; o2 < r2.length; ++o2) {
    var s2 = r2[o2].tag;
    a2.push({ name: "axis_" + e3 + " " + s2, type: "FIXED", value: t2.coordinates[s2] << 16 });
  }
  return a2;
}
function xn(e3, t2, r2, n2) {
  var a2 = {}, o2 = new se.Parser(e3, t2);
  a2.name = n2[o2.parseUShort()] || {}, o2.skip("uShort", 1), a2.coordinates = {};
  for (var s2 = 0; s2 < r2.length; ++s2) a2.coordinates[r2[s2].tag] = o2.parseFixed();
  return a2;
}
un.prototype.setText = function(e3) {
  this.text = e3;
}, un.prototype.contextChecks = { latinWordCheck: an, arabicWordCheck: Kr, arabicSentenceCheck: Jr }, un.prototype.registerFeatures = function(e3, t2) {
  var r2 = this, n2 = t2.filter(function(t3) {
    return r2.query.supports({ script: e3, tag: t3 });
  });
  this.featuresTags.hasOwnProperty(e3) ? this.featuresTags[e3] = this.featuresTags[e3].concat(n2) : this.featuresTags[e3] = n2;
}, un.prototype.applyFeatures = function(e3, t2) {
  if (!e3) throw new Error("No valid font was provided to apply features");
  this.query || (this.query = new Wr(e3));
  for (var r2 = 0; r2 < t2.length; r2++) {
    var n2 = t2[r2];
    this.query.supports({ script: n2.script }) && this.registerFeatures(n2.script, n2.tags);
  }
}, un.prototype.registerModifier = function(e3, t2, r2) {
  this.tokenizer.registerModifier(e3, t2, r2);
}, un.prototype.checkContextReady = function(e3) {
  return !!this.tokenizer.getContext(e3);
}, un.prototype.applyFeaturesToContexts = function() {
  this.checkContextReady("arabicWord") && (fn.call(this), dn.call(this)), this.checkContextReady("latinWord") && vn.call(this), this.checkContextReady("arabicSentence") && cn.call(this);
}, un.prototype.processText = function(e3) {
  this.text && this.text === e3 || (this.setText(e3), pn.call(this), this.applyFeaturesToContexts());
}, un.prototype.getBidiText = function(e3) {
  return this.processText(e3), this.tokenizer.getText();
}, un.prototype.getTextGlyphs = function(e3) {
  this.processText(e3);
  for (var t2 = [], r2 = 0; r2 < this.tokenizer.tokens.length; r2++) {
    var n2 = this.tokenizer.tokens[r2];
    if (!n2.state.deleted) {
      var a2 = n2.activeState.value;
      t2.push(Array.isArray(a2) ? a2[0] : a2);
    }
  }
  return t2;
}, gn.prototype.hasChar = function(e3) {
  return null !== this.encoding.charToGlyphIndex(e3);
}, gn.prototype.charToGlyphIndex = function(e3) {
  return this.encoding.charToGlyphIndex(e3);
}, gn.prototype.charToGlyph = function(e3) {
  var t2 = this.charToGlyphIndex(e3), r2 = this.glyphs.get(t2);
  return r2 || (r2 = this.glyphs.get(0)), r2;
}, gn.prototype.updateFeatures = function(e3) {
  return this.defaultRenderOptions.features.map(function(t2) {
    return "latn" === t2.script ? { script: "latn", tags: t2.tags.filter(function(t3) {
      return e3[t3];
    }) } : t2;
  });
}, gn.prototype.stringToGlyphs = function(e3, t2) {
  var r2 = this, n2 = new un();
  n2.registerModifier("glyphIndex", null, function(e4) {
    return r2.charToGlyphIndex(e4.char);
  });
  var a2 = t2 ? this.updateFeatures(t2.features) : this.defaultRenderOptions.features;
  n2.applyFeatures(this, a2);
  for (var o2 = n2.getTextGlyphs(e3), s2 = o2.length, i2 = new Array(s2), u2 = this.glyphs.get(0), l2 = 0; l2 < s2; l2 += 1) i2[l2] = this.glyphs.get(o2[l2]) || u2;
  return i2;
}, gn.prototype.nameToGlyphIndex = function(e3) {
  return this.glyphNames.nameToGlyphIndex(e3);
}, gn.prototype.nameToGlyph = function(e3) {
  var t2 = this.nameToGlyphIndex(e3), r2 = this.glyphs.get(t2);
  return r2 || (r2 = this.glyphs.get(0)), r2;
}, gn.prototype.glyphIndexToName = function(e3) {
  return this.glyphNames.glyphIndexToName ? this.glyphNames.glyphIndexToName(e3) : "";
}, gn.prototype.getKerningValue = function(e3, t2) {
  e3 = e3.index || e3, t2 = t2.index || t2;
  var r2 = this.position.defaultKerningTables;
  return r2 ? this.position.getKerningValue(r2, e3, t2) : this.kerningPairs && this.kerningPairs[e3 + "," + t2] || 0;
}, gn.prototype.defaultRenderOptions = { kerning: true, features: [{ script: "arab", tags: ["init", "medi", "fina", "rlig"] }, { script: "latn", tags: ["liga", "rlig"] }] }, gn.prototype.forEachGlyph = function(e3, t2, r2, n2, a2, o2) {
  t2 = void 0 !== t2 ? t2 : 0, r2 = void 0 !== r2 ? r2 : 0, n2 = void 0 !== n2 ? n2 : 72, a2 = Object.assign({}, this.defaultRenderOptions, a2);
  var s2, i2 = 1 / this.unitsPerEm * n2, u2 = this.stringToGlyphs(e3, a2);
  if (a2.kerning) {
    var l2 = a2.script || this.position.getDefaultScriptName();
    s2 = this.position.getKerningTables(l2, a2.language);
  }
  for (var p2 = 0; p2 < u2.length; p2 += 1) {
    var c2 = u2[p2];
    if (o2.call(this, c2, t2, r2, n2, a2), c2.advanceWidth && (t2 += c2.advanceWidth * i2), a2.kerning && p2 < u2.length - 1) t2 += (s2 ? this.position.getKerningValue(s2, c2.index, u2[p2 + 1].index) : this.getKerningValue(c2, u2[p2 + 1])) * i2;
    a2.letterSpacing ? t2 += a2.letterSpacing * n2 : a2.tracking && (t2 += a2.tracking / 1e3 * n2);
  }
  return t2;
}, gn.prototype.getPath = function(e3, t2, r2, n2, a2) {
  var o2 = new E();
  return this.forEachGlyph(e3, t2, r2, n2, a2, function(e4, t3, r3, n3) {
    var s2 = e4.getPath(t3, r3, n3, a2, this);
    o2.extend(s2);
  }), o2;
}, gn.prototype.getPaths = function(e3, t2, r2, n2, a2) {
  var o2 = [];
  return this.forEachGlyph(e3, t2, r2, n2, a2, function(e4, t3, r3, n3) {
    var s2 = e4.getPath(t3, r3, n3, a2, this);
    o2.push(s2);
  }), o2;
}, gn.prototype.getAdvanceWidth = function(e3, t2, r2) {
  return this.forEachGlyph(e3, 0, 0, t2, r2, function() {
  });
}, gn.prototype.draw = function(e3, t2, r2, n2, a2, o2) {
  this.getPath(t2, r2, n2, a2, o2).draw(e3);
}, gn.prototype.drawPoints = function(e3, t2, r2, n2, a2, o2) {
  this.forEachGlyph(t2, r2, n2, a2, o2, function(t3, r3, n3, a3) {
    t3.drawPoints(e3, r3, n3, a3);
  });
}, gn.prototype.drawMetrics = function(e3, t2, r2, n2, a2, o2) {
  this.forEachGlyph(t2, r2, n2, a2, o2, function(t3, r3, n3, a3) {
    t3.drawMetrics(e3, r3, n3, a3);
  });
}, gn.prototype.getEnglishName = function(e3) {
  var t2 = this.names[e3];
  if (t2) return t2.en;
}, gn.prototype.validate = function() {
  var e3 = this;
  function t2(t3) {
    var r2 = e3.getEnglishName(t3);
    r2 && r2.trim().length;
  }
  t2("fontFamily"), t2("weightName"), t2("manufacturer"), t2("copyright"), t2("version"), this.unitsPerEm;
}, gn.prototype.toTables = function() {
  return kt.fontToTable(this);
}, gn.prototype.toBuffer = function() {
  return console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead."), this.toArrayBuffer();
}, gn.prototype.toArrayBuffer = function() {
  for (var e3 = this.toTables().encode(), t2 = new ArrayBuffer(e3.length), r2 = new Uint8Array(t2), n2 = 0; n2 < e3.length; n2++) r2[n2] = e3[n2];
  return t2;
}, gn.prototype.download = function(e3) {
  var t2 = this.getEnglishName("fontFamily"), r2 = this.getEnglishName("fontSubfamily");
  e3 = e3 || t2.replace(/\s/g, "") + "-" + r2 + ".otf";
  var n2 = this.toArrayBuffer();
  if ("undefined" != typeof window) if (window.URL = window.URL || window.webkitURL, window.URL) {
    var a2 = new DataView(n2), o2 = new Blob([a2], { type: "font/opentype" }), s2 = document.createElement("a");
    s2.href = window.URL.createObjectURL(o2), s2.download = e3;
    var i2 = document.createEvent("MouseEvents");
    i2.initEvent("click", true, false), s2.dispatchEvent(i2);
  } else console.warn("Font file could not be downloaded. Try using a different browser.");
  else {
    var u2 = __require("fs"), l2 = function(e4) {
      for (var t3 = Buffer.alloc(e4.byteLength), r3 = new Uint8Array(e4), n3 = 0; n3 < t3.length; ++n3) t3[n3] = r3[n3];
      return t3;
    }(n2);
    u2.writeFileSync(e3, l2);
  }
}, gn.prototype.fsSelectionValues = { ITALIC: 1, UNDERSCORE: 2, NEGATIVE: 4, OUTLINED: 8, STRIKEOUT: 16, BOLD: 32, REGULAR: 64, USER_TYPO_METRICS: 128, WWS: 256, OBLIQUE: 512 }, gn.prototype.usWidthClasses = { ULTRA_CONDENSED: 1, EXTRA_CONDENSED: 2, CONDENSED: 3, SEMI_CONDENSED: 4, MEDIUM: 5, SEMI_EXPANDED: 6, EXPANDED: 7, EXTRA_EXPANDED: 8, ULTRA_EXPANDED: 9 }, gn.prototype.usWeightClasses = { THIN: 100, EXTRA_LIGHT: 200, LIGHT: 300, NORMAL: 400, MEDIUM: 500, SEMI_BOLD: 600, BOLD: 700, EXTRA_BOLD: 800, BLACK: 900 };
var Tn = { make: function(e3, t2) {
  var r2 = new J.Table("fvar", [{ name: "version", type: "ULONG", value: 65536 }, { name: "offsetToData", type: "USHORT", value: 0 }, { name: "countSizePairs", type: "USHORT", value: 2 }, { name: "axisCount", type: "USHORT", value: e3.axes.length }, { name: "axisSize", type: "USHORT", value: 20 }, { name: "instanceCount", type: "USHORT", value: e3.instances.length }, { name: "instanceSize", type: "USHORT", value: 4 + 4 * e3.axes.length }]);
  r2.offsetToData = r2.sizeOf();
  for (var n2 = 0; n2 < e3.axes.length; n2++) r2.fields = r2.fields.concat(yn(n2, e3.axes[n2], t2));
  for (var a2 = 0; a2 < e3.instances.length; a2++) r2.fields = r2.fields.concat(Sn(a2, e3.instances[a2], e3.axes, t2));
  return r2;
}, parse: function(e3, t2, r2) {
  var n2 = new se.Parser(e3, t2), a2 = n2.parseULong();
  w.argument(65536 === a2, "Unsupported fvar table version.");
  var o2 = n2.parseOffset16();
  n2.skip("uShort", 1);
  for (var s2 = n2.parseUShort(), i2 = n2.parseUShort(), u2 = n2.parseUShort(), l2 = n2.parseUShort(), p2 = [], c2 = 0; c2 < s2; c2++) p2.push(bn(e3, t2 + o2 + c2 * i2, r2));
  for (var h2 = [], f2 = t2 + o2 + s2 * i2, d2 = 0; d2 < u2; d2++) h2.push(xn(e3, f2 + d2 * l2, p2, r2));
  return { axes: p2, instances: h2 };
} };
var Un = function() {
  return { coverage: this.parsePointer(ae.coverage), attachPoints: this.parseList(ae.pointer(ae.uShortList)) };
};
var kn = function() {
  var e3 = this.parseUShort();
  return w.argument(1 === e3 || 2 === e3 || 3 === e3, "Unsupported CaretValue table version."), 1 === e3 ? { coordinate: this.parseShort() } : 2 === e3 ? { pointindex: this.parseShort() } : 3 === e3 ? { coordinate: this.parseShort() } : void 0;
};
var On = function() {
  return this.parseList(ae.pointer(kn));
};
var Rn = function() {
  return { coverage: this.parsePointer(ae.coverage), ligGlyphs: this.parseList(ae.pointer(On)) };
};
var En = function() {
  return this.parseUShort(), this.parseList(ae.pointer(ae.coverage));
};
var Ln = { parse: function(e3, t2) {
  var r2 = new ae(e3, t2 = t2 || 0), n2 = r2.parseVersion(1);
  w.argument(1 === n2 || 1.2 === n2 || 1.3 === n2, "Unsupported GDEF table version.");
  var a2 = { version: n2, classDef: r2.parsePointer(ae.classDef), attachList: r2.parsePointer(Un), ligCaretList: r2.parsePointer(Rn), markAttachClassDef: r2.parsePointer(ae.classDef) };
  return n2 >= 1.2 && (a2.markGlyphSets = r2.parsePointer(En)), a2;
} };
var Cn = { parse: function(e3, t2) {
  var r2 = new se.Parser(e3, t2), n2 = r2.parseUShort();
  if (0 === n2) return function(e4) {
    var t3 = {};
    e4.skip("uShort");
    var r3 = e4.parseUShort();
    w.argument(0 === r3, "Unsupported kern sub-table version."), e4.skip("uShort", 2);
    var n3 = e4.parseUShort();
    e4.skip("uShort", 3);
    for (var a2 = 0; a2 < n3; a2 += 1) {
      var o2 = e4.parseUShort(), s2 = e4.parseUShort(), i2 = e4.parseShort();
      t3[o2 + "," + s2] = i2;
    }
    return t3;
  }(r2);
  if (1 === n2) return function(e4) {
    var t3 = {};
    e4.skip("uShort"), e4.parseULong() > 1 && console.warn("Only the first kern subtable is supported."), e4.skip("uLong");
    var r3 = 255 & e4.parseUShort();
    if (e4.skip("uShort"), 0 === r3) {
      var n3 = e4.parseUShort();
      e4.skip("uShort", 3);
      for (var a2 = 0; a2 < n3; a2 += 1) {
        var o2 = e4.parseUShort(), s2 = e4.parseUShort(), i2 = e4.parseShort();
        t3[o2 + "," + s2] = i2;
      }
    }
    return t3;
  }(r2);
  throw new Error("Unsupported kern table version (" + n2 + ").");
} };
var wn = { parse: function(e3, t2, r2, n2) {
  for (var a2 = new se.Parser(e3, t2), o2 = n2 ? a2.parseUShort : a2.parseULong, s2 = [], i2 = 0; i2 < r2 + 1; i2 += 1) {
    var u2 = o2.call(a2);
    n2 && (u2 *= 2), s2.push(u2);
  }
  return s2;
} };
function Dn(e3, t2) {
  __require("fs").readFile(e3, function(e4, r2) {
    if (e4) return t2(e4.message);
    t2(null, Gt(r2));
  });
}
function In(e3, t2) {
  var r2 = new XMLHttpRequest();
  r2.open("get", e3, true), r2.responseType = "arraybuffer", r2.onload = function() {
    return r2.response ? t2(null, r2.response) : t2("Font could not be loaded: " + r2.statusText);
  }, r2.onerror = function() {
    t2("Font could not be loaded");
  }, r2.send();
}
function Gn(e3, t2) {
  for (var r2 = [], n2 = 12, a2 = 0; a2 < t2; a2 += 1) {
    var o2 = se.getTag(e3, n2), s2 = se.getULong(e3, n2 + 4), i2 = se.getULong(e3, n2 + 8), u2 = se.getULong(e3, n2 + 12);
    r2.push({ tag: o2, checksum: s2, offset: i2, length: u2, compression: false }), n2 += 16;
  }
  return r2;
}
function Mn(e3, t2) {
  if ("WOFF" === t2.compression) {
    var r2 = new Uint8Array(e3.buffer, t2.offset + 2, t2.compressedLength - 2), n2 = new Uint8Array(t2.length);
    if (k(r2, n2), n2.byteLength !== t2.length) throw new Error("Decompression error: " + t2.tag + " decompressed length doesn't match recorded length");
    return { data: new DataView(n2.buffer, 0), offset: 0 };
  }
  return { data: e3, offset: t2.offset };
}
function Bn(e3, t2) {
  var r2, n2;
  t2 = null == t2 ? {} : t2;
  var a2, o2, s2, i2, u2, l2, p2, c2, h2, f2, d2, v2, g2, m2 = new gn({ empty: true }), y2 = new DataView(e3, 0), b2 = [], S2 = se.getTag(y2, 0);
  if (S2 === String.fromCharCode(0, 1, 0, 0) || "true" === S2 || "typ1" === S2) m2.outlinesFormat = "truetype", b2 = Gn(y2, a2 = se.getUShort(y2, 4));
  else if ("OTTO" === S2) m2.outlinesFormat = "cff", b2 = Gn(y2, a2 = se.getUShort(y2, 4));
  else {
    if ("wOFF" !== S2) throw new Error("Unsupported OpenType signature " + S2);
    var x2 = se.getTag(y2, 4);
    if (x2 === String.fromCharCode(0, 1, 0, 0)) m2.outlinesFormat = "truetype";
    else {
      if ("OTTO" !== x2) throw new Error("Unsupported OpenType flavor " + S2);
      m2.outlinesFormat = "cff";
    }
    b2 = function(e4, t3) {
      for (var r3 = [], n3 = 44, a3 = 0; a3 < t3; a3 += 1) {
        var o3 = se.getTag(e4, n3), s3 = se.getULong(e4, n3 + 4), i3 = se.getULong(e4, n3 + 8), u3 = se.getULong(e4, n3 + 12), l3 = void 0;
        l3 = i3 < u3 && "WOFF", r3.push({ tag: o3, offset: s3, compression: l3, compressedLength: i3, length: u3 }), n3 += 20;
      }
      return r3;
    }(y2, a2 = se.getUShort(y2, 12));
  }
  for (var T2 = 0; T2 < a2; T2 += 1) {
    var U2 = b2[T2], k2 = void 0;
    switch (U2.tag) {
      case "cmap":
        k2 = Mn(y2, U2), m2.tables.cmap = xe.parse(k2.data, k2.offset), m2.encoding = new Ee(m2.tables.cmap);
        break;
      case "cvt ":
        k2 = Mn(y2, U2), g2 = new se.Parser(k2.data, k2.offset), m2.tables.cvt = g2.parseShortList(U2.length / 2);
        break;
      case "fvar":
        s2 = U2;
        break;
      case "fpgm":
        k2 = Mn(y2, U2), g2 = new se.Parser(k2.data, k2.offset), m2.tables.fpgm = g2.parseByteList(U2.length);
        break;
      case "head":
        k2 = Mn(y2, U2), m2.tables.head = tt.parse(k2.data, k2.offset), m2.unitsPerEm = m2.tables.head.unitsPerEm, r2 = m2.tables.head.indexToLocFormat;
        break;
      case "hhea":
        k2 = Mn(y2, U2), m2.tables.hhea = rt.parse(k2.data, k2.offset), m2.ascender = m2.tables.hhea.ascender, m2.descender = m2.tables.hhea.descender, m2.numberOfHMetrics = m2.tables.hhea.numberOfHMetrics;
        break;
      case "hmtx":
        c2 = U2;
        break;
      case "ltag":
        k2 = Mn(y2, U2), n2 = at.parse(k2.data, k2.offset);
        break;
      case "COLR":
        k2 = Mn(y2, U2), m2.tables.colr = gt.parse(k2.data, k2.offset);
        break;
      case "CPAL":
        k2 = Mn(y2, U2), m2.tables.cpal = mt.parse(k2.data, k2.offset);
        break;
      case "maxp":
        k2 = Mn(y2, U2), m2.tables.maxp = ot.parse(k2.data, k2.offset), m2.numGlyphs = m2.tables.maxp.numGlyphs;
        break;
      case "name":
        d2 = U2;
        break;
      case "OS/2":
        k2 = Mn(y2, U2), m2.tables.os2 = it.parse(k2.data, k2.offset);
        break;
      case "post":
        k2 = Mn(y2, U2), m2.tables.post = ut.parse(k2.data, k2.offset), m2.glyphNames = new Ce(m2.tables.post);
        break;
      case "prep":
        k2 = Mn(y2, U2), g2 = new se.Parser(k2.data, k2.offset), m2.tables.prep = g2.parseByteList(U2.length);
        break;
      case "glyf":
        i2 = U2;
        break;
      case "loca":
        f2 = U2;
        break;
      case "CFF ":
        o2 = U2;
        break;
      case "kern":
        h2 = U2;
        break;
      case "GDEF":
        u2 = U2;
        break;
      case "GPOS":
        l2 = U2;
        break;
      case "GSUB":
        p2 = U2;
        break;
      case "meta":
        v2 = U2;
    }
  }
  var O2 = Mn(y2, d2);
  if (m2.tables.name = be.parse(O2.data, O2.offset, n2), m2.names = m2.tables.name, i2 && f2) {
    var R2 = 0 === r2, E2 = Mn(y2, f2), L2 = wn.parse(E2.data, E2.offset, m2.numGlyphs, R2), C2 = Mn(y2, i2);
    m2.glyphs = _t.parse(C2.data, C2.offset, L2, m2, t2);
  } else {
    if (!o2) throw new Error("Font doesn't contain TrueType or CFF outlines.");
    var w2 = Mn(y2, o2);
    et.parse(w2.data, w2.offset, m2, t2);
  }
  var D2 = Mn(y2, c2);
  if (nt.parse(m2, D2.data, D2.offset, m2.numberOfHMetrics, m2.numGlyphs, m2.glyphs, t2), we(m2, t2), h2) {
    var I2 = Mn(y2, h2);
    m2.kerningPairs = Cn.parse(I2.data, I2.offset);
  } else m2.kerningPairs = {};
  if (u2) {
    var G2 = Mn(y2, u2);
    m2.tables.gdef = Ln.parse(G2.data, G2.offset);
  }
  if (l2) {
    var M2 = Mn(y2, l2);
    m2.tables.gpos = dt.parse(M2.data, M2.offset), m2.position.init();
  }
  if (p2) {
    var B2 = Mn(y2, p2);
    m2.tables.gsub = ht.parse(B2.data, B2.offset);
  }
  if (s2) {
    var F2 = Mn(y2, s2);
    m2.tables.fvar = Tn.parse(F2.data, F2.offset, m2.names);
  }
  if (v2) {
    var P2 = Mn(y2, v2);
    m2.tables.meta = vt.parse(P2.data, P2.offset), m2.metas = m2.tables.meta;
  }
  return m2;
}
function Fn(e3, t2, r2) {
  r2 = null == r2 ? {} : r2;
  var n2 = "undefined" == typeof window && !r2.isUrl ? Dn : In;
  return new Promise(function(a2, o2) {
    n2(e3, function(e4, n3) {
      if (e4) {
        if (t2) return t2(e4);
        o2(e4);
      }
      var s2;
      try {
        s2 = Bn(n3, r2);
      } catch (e5) {
        if (t2) return t2(e5, null);
        o2(e5);
      }
      if (t2) return t2(null, s2);
      a2(s2);
    });
  });
}
function Pn(e3, t2) {
  return Bn(Gt(__require("fs").readFileSync(e3)), t2);
}
var An = Object.freeze({ __proto__: null, Font: gn, Glyph: Ie, Path: E, BoundingBox: R, _parse: se, parse: Bn, load: Fn, loadSync: Pn });

// node_modules/scribe.js-ocr/js/containers/fontContainer.js
init_miscUtils();

// node_modules/scribe.js-ocr/js/utils/imageUtils.js
async function loadImageElem(src, elem) {
  return new Promise((resolve, reject) => {
    let urlLoad;
    if (src instanceof Blob) {
      urlLoad = URL.createObjectURL(src);
    } else if (src instanceof ArrayBuffer) {
      const blob = new Blob([src]);
      urlLoad = URL.createObjectURL(blob);
    } else {
      urlLoad = src;
    }
    elem.onload = () => resolve(elem);
    elem.onerror = reject;
    elem.src = urlLoad;
  });
}
function imageStrToBlob(imgStr) {
  const imgData = new Uint8Array(atob(imgStr.split(",")[1]).split("").map((c2) => c2.charCodeAt(0)));
  const imgBlob = new Blob([imgData], { type: "application/octet-stream" });
  return imgBlob;
}
var detectImageFormat = (image) => {
  if (image[0] === 255 && image[1] === 216) {
    return "jpeg";
  }
  if (image[0] === 137 && image[1] === 80) {
    return "png";
  }
  throw new Error("Unsupported image type");
};
var importImageFileToBase64 = async (file) => new Promise((resolve, reject) => {
  if (file instanceof ArrayBuffer) {
    const imageUint8 = new Uint8Array(file);
    const format = detectImageFormat(imageUint8);
    const binary = String.fromCharCode(...imageUint8);
    resolve(`data:image/${format};base64,${btoa(binary)}`);
    return;
  }
  if (typeof process === "undefined" && file instanceof File) {
    const reader = new FileReader();
    reader.onloadend = async () => {
      resolve(
        /** @type {string} */
        reader.result
      );
    };
    reader.onerror = (error) => {
      reject(error);
    };
    reader.readAsDataURL(file);
    return;
  }
  if (typeof process !== "undefined") {
    if (!file?.name) reject(new Error("Invalid input. Must be a FileNode or ArrayBuffer."));
    const format = file.name.match(/jpe?g$/i) ? "jpeg" : "png";
    resolve(`data:image/${format};base64,${file.fileData.toString("base64")}`);
    return;
  }
  reject(new Error("Invalid input. Must be a File or ArrayBuffer."));
});
function base64ToBytes(base64) {
  const commaIndex = base64.slice(0, 100).indexOf(",");
  if (commaIndex > 0) {
    base64 = base64.slice(commaIndex + 1);
  }
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    bytes[i2] = binaryString.charCodeAt(i2);
  }
  return bytes;
}
function getPngIHDRInfo(bytes) {
  const width = bytes[16] << 24 | bytes[17] << 16 | bytes[18] << 8 | bytes[19];
  const height = bytes[20] << 24 | bytes[21] << 16 | bytes[22] << 8 | bytes[23];
  const bitDepth = bytes[24];
  const colorType = bytes[25];
  const compressionMethod = bytes[26];
  const filterMethod = bytes[27];
  const interlaceMethod = bytes[28];
  return {
    width,
    height,
    bitDepth,
    colorType,
    compressionMethod,
    filterMethod,
    interlaceMethod
  };
}
function getPngDimensions(base64) {
  const bytes = base64ToBytes(base64.slice(0, 150).split(",")[1].slice(0, 96));
  const width = bytes[16] << 24 | bytes[17] << 16 | bytes[18] << 8 | bytes[19];
  const height = bytes[20] << 24 | bytes[21] << 16 | bytes[22] << 8 | bytes[23];
  return { width, height };
}
function getJpegDimensions(base64) {
  const bytes = base64ToBytes(base64.split(",")[1]);
  let i2 = 0;
  if (bytes[i2] === 255 && bytes[i2 + 1] === 216) {
    i2 += 2;
  }
  while (i2 < bytes.length) {
    if (bytes[i2] === 255) {
      if ([192, 193, 194, 195, 197, 198, 199, 201, 202, 203, 205, 206, 207].includes(bytes[i2 + 1])) {
        const height = bytes[i2 + 5] << 8 | bytes[i2 + 6];
        const width = bytes[i2 + 7] << 8 | bytes[i2 + 8];
        return { width, height };
      }
      const segmentLength = bytes[i2 + 2] << 8 | bytes[i2 + 3];
      i2 += segmentLength + 2;
      continue;
    }
    i2++;
  }
  throw new Error("Could not find dimensions in the JPEG image.");
}

// node_modules/scribe.js-ocr/js/canvasAdapter.js
var ca = class _ca {
  /** @type {import('canvaskit-wasm').CanvasKit} */
  static CanvasKit;
  static getCanvasKit = async () => {
    if (typeof process === "undefined") {
      throw new Error("getCanvasKit is only available in Node.js");
    } else {
      if (!_ca.CanvasKit) {
        const canvasKitImport = await Promise.resolve().then(() => __toESM(require_canvaskit(), 1));
        const CanvasKitInit = canvasKitImport.default;
        _ca.CanvasKit = await CanvasKitInit();
      }
      return _ca.CanvasKit;
    }
  };
  /**
   *
   * @param {number} width
   * @param {number} height
   */
  static createCanvas = async (width, height) => {
    if (typeof process === "undefined") {
      return new OffscreenCanvas(width, height);
    }
    if (!width || !height || width <= 0 || height <= 0) {
      throw new Error(`Invalid canvas size: ${width}x${height}`);
    }
    const canvasKit = await _ca.getCanvasKit();
    return canvasKit.MakeCanvas(width, height);
  };
  /**
   * Handles various image formats, always returns a ImageBitmap.
   *
   * @param {string|ImageBitmap|Promise<string>|Promise<ImageBitmap>} img
   * @returns {Promise<ImageBitmap>}
   */
  static getImageBitmap = async (img) => {
    img = await img;
    if (img === void 0) throw new Error("Input is undefined");
    if (img === null) throw new Error("Input is null");
    if (typeof img === "string") {
      if (typeof process === "undefined") {
        const imgBlob = imageStrToBlob(img);
        const imgBit2 = await createImageBitmap(imgBlob);
        return imgBit2;
      }
      const imgData = new Uint8Array(atob(img.split(",")[1]).split("").map((c2) => c2.charCodeAt(0)));
      const canvasKit = await _ca.getCanvasKit();
      const imgBit = await canvasKit.MakeImageFromEncoded(imgData);
      return imgBit;
    }
    if (!(typeof process === "undefined") && typeof img !== "string" && typeof img !== "number") return img;
    return img;
  };
  static dummyCanvasPromise = _ca.createCanvas(1, 1);
  /**
   *
   * @param {FontContainerFont} fontObj
   */
  static registerFontObj = async (fontObj) => {
    if (typeof process === "undefined") {
      throw new Error("registerFontObj is only available in Node.js");
    } else {
      const dummyCanvas = await _ca.dummyCanvasPromise;
      const fs3 = await import("node:fs");
      const fontBuffer = typeof fontObj.src === "string" ? fs3.readFileSync(fontObj.src) : fontObj.src;
      dummyCanvas.loadFont(fontBuffer, {
        family: fontObj.fontFaceName,
        style: fontObj.fontFaceStyle,
        weight: fontObj.fontFaceWeight
      });
    }
  };
};

// node_modules/scribe.js-ocr/js/containers/fontContainer.js
if (typeof process === "object") {
  globalThis.self = globalThis;
  const { createRequire } = await import("node:module");
  globalThis.require = createRequire(import.meta.url);
  const { fileURLToPath } = await import("node:url");
  const { dirname } = await import("node:path");
  globalThis.__dirname = dirname(fileURLToPath(import.meta.url));
}
function checkMultiFontMode(charMetricsObj) {
  let defaultFontObs = 0;
  let namedFontObs = 0;
  if (charMetricsObj.Default?.obs) {
    defaultFontObs += charMetricsObj.Default?.obs || 0;
  }
  if (charMetricsObj.SerifDefault?.obs) {
    namedFontObs += charMetricsObj.SerifDefault?.obs || 0;
  }
  if (charMetricsObj.SansDefault?.obs) {
    namedFontObs += charMetricsObj.SansDefault?.obs || 0;
  }
  return namedFontObs > defaultFontObs;
}
async function loadOpentype(src, kerningPairs = null) {
  const font = typeof src === "string" ? await An.load(src) : await An.parse(src, { lowMemory: false });
  font.tables.gsub = null;
  if (kerningPairs) font.kerningPairs = kerningPairs;
  return font;
}
var fontFaceObj = {};
function loadFontFace(fontFamily, fontStyle, fontWeight, src) {
  const src1 = typeof src === "string" ? `url(${src})` : src;
  const fontFace = new FontFace(fontFamily, src1, { style: fontStyle, weight: fontWeight });
  if (fontFace.status === "error") throw new Error(`FontFace failed to load: ${fontFamily} ${fontStyle} ${fontWeight}`);
  const fontSet = globalThis.document ? globalThis.document.fonts : globalThis.fonts;
  if (typeof fontFaceObj[fontFamily] === "undefined") {
    fontFaceObj[fontFamily] = {};
  }
  if (typeof fontFaceObj[fontFamily][fontStyle] === "undefined") {
    fontFaceObj[fontFamily][fontStyle] = {};
  }
  if (typeof fontFaceObj[fontFamily][fontStyle][fontWeight] !== "undefined") {
    fontSet.delete(fontFaceObj[fontFamily][fontStyle][fontWeight]);
  }
  fontFaceObj[fontFamily][fontStyle][fontWeight] = fontFace;
  fontFace.load();
  fontSet.add(fontFace);
  return fontFace;
}
async function loadFont(family, styleLookup, type, src, opt2) {
  const fontObj = await loadOpentype(src);
  return new FontContainerFont(family, styleLookup, src, opt2, fontObj);
}
function FontContainerFont(family, styleLookup, src, opt2, opentypeObj) {
  let fontFaceName = family;
  if (opt2) fontFaceName += " Opt";
  this.family = family;
  this.style = styleLookup;
  this.opt = opt2;
  this.src = src;
  this.opentype = opentypeObj;
  this.fontFaceName = fontFaceName;
  this.fontFaceStyle = ["italic", "boldItalic"].includes(this.style) ? "italic" : "normal";
  this.fontFaceWeight = ["bold", "boldItalic"].includes(this.style) ? "bold" : "normal";
  this.type = determineSansSerif(this.family) === "SansDefault" ? "sans" : "serif";
  this.smallCapsMult = 0.75;
  this.disable = false;
  if (typeof FontFace !== "undefined") {
    loadFontFace(this.fontFaceName, this.fontFaceStyle, this.fontFaceWeight, this.src);
  } else {
    ca.registerFontObj(this);
  }
}
async function loadFontContainerFamily(family, src, opt2 = false) {
  const res = {
    normal: null,
    italic: null,
    bold: null,
    boldItalic: null
  };
  const loadType = (styleLookup) => new Promise((resolve) => {
    const srcType = src[styleLookup];
    if (!srcType) {
      resolve(false);
      return;
    }
    loadOpentype(srcType).then((font) => {
      res[styleLookup] = new FontContainerFont(family, styleLookup, srcType, opt2, font);
      resolve(true);
    });
  });
  Promise.allSettled([loadType("normal"), loadType("italic"), loadType("bold"), loadType("boldItalic")]);
  return res;
}
async function loadFontsFromSource(srcObj, opt2 = false) {
  const fontObjPromise = {};
  for (const [family, src] of Object.entries(srcObj)) {
    fontObjPromise[family] = loadFontContainerFamily(family, src, opt2);
  }
  const fontObj = {};
  for (const [key, value] of Object.entries(fontObjPromise)) {
    fontObj[key] = await value;
  }
  return fontObj;
}
var FontCont = class _FontCont {
  /** @type {?FontContainer} */
  static raw = null;
  /** @type {?FontContainer} */
  static opt = null;
  /** @type {?Object<string, FontContainerFamilyUpload>} */
  static doc = null;
  /** @type {?FontContainer} */
  static export = null;
  static supp = {
    /** @type {?FontContainerFont} */
    chi_sim: null
  };
  /**
   * This object contains all data that is saved and restored from intermediate .scribe files.
   * Anything outside of this object is not saved or restored.
   * @type {FontState}
   */
  static state = {
    /** Optimized fonts will be used when believed to improve quality. */
    enableOpt: false,
    /** Optimized fonts will always be used when they exist, even if believed to reduce quality. */
    forceOpt: false,
    /**
     * If `false`, 'Courier' will not be cleaned to Nimbus Mono.
     * This setting is useful because Tesseract sometimes misidentifies fonts as Courier, and when not the document default, Nimbus Mono is almost always incorrect.
     * Even with this setting `false`, Nimbus Mono will still be used when the font is exactly 'NimbusMono' and Nimbus Mono can still be the document default font.
     */
    enableCleanToNimbusMono: false,
    defaultFontName: "SerifDefault",
    serifDefaultName: "NimbusRoman",
    sansDefaultName: "NimbusSans",
    glyphSet: null,
    /** @type {Object.<string, CharMetricsFamily>} */
    charMetrics: {}
  };
  /** @type {?Awaited<ReturnType<import('../fontEval.js').evaluateFonts>>} */
  static rawMetrics = null;
  /** @type {?Awaited<ReturnType<import('../fontEval.js').evaluateFonts>>} */
  static optMetrics = null;
  /**
   * Load fonts from an ArrayBuffer containing arbitrary font data.
   * Supports .ttf, .otf, and .woff formats.
   * This function should only be used for fonts we do not provide, such as user-uploaded fonts.
   * @param {ArrayBuffer} src
   */
  static addFontFromFile = async (src) => {
    let fontObj;
    let fontData;
    try {
      fontObj = await loadOpentype(src);
      fontData = fontObj.toArrayBuffer();
    } catch (error) {
      console.error("Error loading font.");
      console.error(error);
      return;
    }
    const fontNameEmbedded = fontObj.names.postScriptName.en;
    let styleLookup = (
      /** @type {StyleLookup} */
      "normal"
    );
    if (fontNameEmbedded.match(/boldit|bdit/i)) {
      styleLookup = "boldItalic";
    } else if (fontNameEmbedded.match(/italic/i)) {
      styleLookup = "italic";
    } else if (fontNameEmbedded.match(/bold/i)) {
      styleLookup = "bold";
    }
    const fontName = fontNameEmbedded.replace(/[^+]+\+/g, "").replace(/\s/g, "_");
    if (!_FontCont.doc?.[fontName]?.[styleLookup]) {
      try {
        const fontContainer = new FontContainerFont(fontName, styleLookup, fontData, false, fontObj);
        if (!_FontCont.doc) {
          _FontCont.doc = {};
        }
        if (!_FontCont.doc[fontName]) {
          _FontCont.doc[fontName] = {};
        }
        _FontCont.doc[fontName][styleLookup] = fontContainer;
      } catch (error) {
        console.error(`Error loading font ${fontName} ${styleLookup}.`);
      }
    } else {
      console.warn(`Font ${fontName} ${styleLookup} already exists.`);
    }
  };
  /**
   * Decide whether to use the optimized version of a font family.
   * Note that even when this function returns `true`, optimized versions of every style will not exist.
   * @param {string} family - Font family name.
   */
  static useOptFamily = (family) => {
    const raw = _FontCont.raw?.[family]?.normal;
    if (!raw) return false;
    const opt2 = _FontCont.opt?.[family]?.normal;
    if (opt2 && _FontCont.state.forceOpt) {
      return true;
    }
    if (opt2 && _FontCont.state.enableOpt) {
      const defaultFamily = raw.type === "serif" ? _FontCont.state.serifDefaultName : _FontCont.state.sansDefaultName;
      const rawMetricDefault = _FontCont.rawMetrics?.[defaultFamily];
      const optMetricDefault = _FontCont.optMetrics?.[defaultFamily];
      const rawMetric = _FontCont.rawMetrics?.[family];
      const optMetric = _FontCont.optMetrics?.[family];
      if (rawMetric && optMetric && optMetric < rawMetric && optMetricDefault < rawMetricDefault) {
        return true;
      }
    }
    return false;
  };
  /**
   * Gets a font object.  Unlike accessing the font containers directly,
   * this method allows for special values 'Default', 'SansDefault', and 'SerifDefault' to be used.
   *
   * @param {Partial<Style>} style
   * @param {string} [lang='eng']
   * @returns {FontContainerFont}
   */
  static getFont = (style, lang = "eng") => {
    let family = style.font || _FontCont.state.defaultFontName;
    const styleLookup = getStyleLookup(style);
    if (_FontCont.doc?.[family]?.[styleLookup] && !_FontCont.doc?.[family]?.[styleLookup]?.disable) {
      return _FontCont.doc[family][styleLookup];
    }
    if (lang === "chi_sim") {
      if (!_FontCont.supp.chi_sim) throw new Error("chi_sim font does not exist.");
      return _FontCont.supp.chi_sim;
    }
    if (!_FontCont.raw) throw new Error("Raw fonts not yet initialized.");
    if (!_FontCont.raw?.[family]?.[styleLookup]) {
      if (/NimbusRom/i.test(family)) {
        family = "NimbusRoman";
      } else if (/Times/i.test(family)) {
        family = "NimbusRoman";
      } else if (/NimbusSan/i.test(family)) {
        family = "NimbusSans";
      } else if (/Helvetica/i.test(family)) {
        family = "NimbusSans";
      } else if (/Arial/i.test(family)) {
        family = "NimbusSans";
      } else if (/CenturySch/i.test(family)) {
        family = "Century";
      } else if (/Palatino/i.test(family)) {
        family = "Palatino";
      } else if (/Garamond/i.test(family)) {
        family = "Garamond";
      } else if (/CenturyGothic/i.test(family)) {
        family = "Gothic";
      } else if (/AvantGarde/i.test(family)) {
        family = "Gothic";
      } else if (/Carlito/i.test(family)) {
        family = "Carlito";
      } else if (/Calibri/i.test(family)) {
        family = "Carlito";
      } else if (/Courier/i.test(family) && _FontCont.state.enableCleanToNimbusMono) {
        family = "NimbusMono";
      } else if (/NimbusMono/i.test(family) && _FontCont.state.enableCleanToNimbusMono) {
        family = "NimbusMono";
      }
    }
    if (!_FontCont.raw?.[family]?.[styleLookup]) {
      family = determineSansSerif(family);
    }
    if (family === "Default") family = _FontCont.state.defaultFontName;
    if (family === "SerifDefault") family = _FontCont.state.serifDefaultName;
    if (family === "SansDefault") family = _FontCont.state.sansDefaultName;
    let fontRes = _FontCont.raw?.[family]?.[styleLookup];
    if (!fontRes) throw new Error(`Font container does not contain ${family} (${styleLookup}).`);
    const opt2 = _FontCont.opt?.[family]?.[styleLookup];
    const useOpt = _FontCont.useOptFamily(family);
    if (opt2 && useOpt) fontRes = opt2;
    return fontRes;
  };
  /**
   *
   * @param {OcrWord} word
   */
  static getWordFont = (word) => _FontCont.getFont(word.style, word.lang);
  /**
   * Reset font container to original state but do not unload default resources.
   */
  static clear = () => {
    _FontCont.opt = null;
    _FontCont.rawMetrics = null;
    _FontCont.optMetrics = null;
    _FontCont.state.enableCleanToNimbusMono = false;
    _FontCont.state.defaultFontName = "SerifDefault";
    _FontCont.state.serifDefaultName = "NimbusRoman";
    _FontCont.state.sansDefaultName = "NimbusSans";
    clearObjectProperties(_FontCont.state.charMetrics);
  };
  static terminate = () => {
    _FontCont.clear();
    _FontCont.raw = null;
    _FontCont.state.glyphSet = null;
  };
};

// node_modules/scribe.js-ocr/js/objects/pageMetricsObjects.js
function PageMetrics(dims) {
  this.angle = null;
  this.dims = { ...dims };
  this.left = null;
  this.manAdj = 0;
}

// node_modules/scribe.js-ocr/mupdf/mupdf-async.js
async function initMuPDFWorker() {
  const mupdf = {};
  let worker;
  if (typeof process === "undefined") {
    worker = new Worker(new URL("./mupdf-worker.js", import.meta.url), { type: "module" });
  } else {
    const WorkerNode = (await import("node:worker_threads")).Worker;
    worker = new WorkerNode(new URL("./mupdf-worker.js", import.meta.url));
  }
  const errorHandler = (err3) => {
    console.error(err3);
  };
  if (typeof process === "undefined") {
    worker.onerror = errorHandler;
  } else {
    worker.on("error", errorHandler);
  }
  let readyResolve;
  const readyPromise = new Promise((resolve, reject) => {
    readyResolve = resolve;
  });
  worker.promises = {};
  worker.promiseId = 0;
  const messageHandler = async (data2) => {
    if (typeof data2 === "string" && data2 === "READY") {
      readyResolve();
      return;
    }
    const [type, id, result] = data2;
    if (type === "RESULT") {
      if (["drawPageAsPNG"].includes(worker.promises[id].func)) {
        worker.promises[id].resolve(result);
        delete worker.promises[id];
      } else {
        worker.promises[id].resolve(result);
        delete worker.promises[id];
      }
    } else {
      worker.promises[id].reject(result);
      delete worker.promises[id];
    }
  };
  if (typeof process === "undefined") {
    worker.onmessage = (event) => messageHandler(event.data);
  } else {
    worker.on("message", messageHandler);
  }
  function wrap(func) {
    return function(...args) {
      return new Promise((resolve, reject) => {
        if (!["openDocument", "cleanFile", "freeDocument", "overlayDocuments", "subsetPages"].includes(func)) {
          if (args[0] === void 0) {
            args = [mupdf.pdfDoc];
          } else {
            args = [mupdf.pdfDoc, args[0]];
          }
        }
        const id = worker.promiseId++;
        const page = ["drawPageAsPNG"].includes(func) ? args[1] : null;
        worker.promises[id] = {
          resolve,
          reject,
          func,
          page
        };
        if (args[0] instanceof ArrayBuffer) {
          worker.postMessage([func, args, id], [args[0]]);
        } else {
          worker.postMessage([func, args, id]);
        }
      });
    };
  }
  mupdf.openDocument = wrap("openDocument");
  mupdf.freeDocument = wrap("freeDocument");
  mupdf.documentTitle = wrap("documentTitle");
  mupdf.documentOutline = wrap("documentOutline");
  mupdf.countPages = wrap("countPages");
  mupdf.pageSizes = wrap("pageSizes");
  mupdf.pageWidth = wrap("pageWidth");
  mupdf.pageHeight = wrap("pageHeight");
  mupdf.pageLinks = wrap("pageLinks");
  mupdf.pageText = wrap("pageText");
  mupdf.pageTextHTML = wrap("pageTextHTML");
  mupdf.pageTextXHTML = wrap("pageTextXHTML");
  mupdf.pageTextXML = wrap("pageTextXML");
  mupdf.pageTextJSON = wrap("pageTextJSON");
  mupdf.extractAllFonts = wrap("extractAllFonts");
  mupdf.search = wrap("search");
  mupdf.drawPageAsPNG = wrap("drawPageAsPNG");
  mupdf.convertImageStart = wrap("convertImageStart");
  mupdf.convertImageAddPage = wrap("convertImageAddPage");
  mupdf.convertImageEnd = wrap("convertImageEnd");
  mupdf.checkNativeText = wrap("checkNativeText");
  mupdf.detectExtractText = wrap("detectExtractText");
  mupdf.save = wrap("save");
  mupdf.run = wrap("run");
  mupdf.cleanFile = wrap("cleanFile");
  mupdf.overlayDocuments = wrap("overlayDocuments");
  mupdf.subsetPages = wrap("subsetPages");
  mupdf.terminate = function() {
    worker.terminate();
  };
  await readyPromise;
  return mupdf;
}

// node_modules/scribe.js-ocr/js/generalWorkerMain.js
init_app();
async function initGeneralWorker() {
  const obj = {};
  let worker;
  if (typeof process === "undefined") {
    worker = new Worker(new URL("./worker/generalWorker.js", import.meta.url), { type: "module" });
  } else {
    const WorkerNode = (await import("node:worker_threads")).Worker;
    worker = new WorkerNode(new URL("./worker/generalWorker.js", import.meta.url));
  }
  return new Promise((resolve, reject) => {
    const errorHandler = (err3) => {
      console.error(err3);
    };
    if (typeof process === "undefined") {
      worker.onerror = errorHandler;
    } else {
      worker.on("error", errorHandler);
    }
    const workerPromises = {};
    let promiseId = 0;
    const ready = new Promise((innerResolve, innerReject) => {
      workerPromises["0"] = { resolve: innerResolve, reject: innerReject, func: "ready" };
    });
    const messageHandler = async (data2) => {
      if (workerPromises[data2.id]) {
        if (data2.status === "reject") {
          workerPromises[data2.id].reject(data2.data);
          delete workerPromises[data2.id];
        } else {
          workerPromises[data2.id].resolve(data2.data);
          delete workerPromises[data2.id];
        }
      }
    };
    if (typeof process === "undefined") {
      worker.onmessage = (event) => messageHandler(event.data);
    } else {
      worker.on("message", messageHandler);
    }
    function wrap(func) {
      return function(...args) {
        return new Promise((innerResolve, innerReject) => {
          const id = promiseId++;
          workerPromises[id] = { resolve: innerResolve, reject: innerReject, func };
          worker.postMessage([func, args[0], id]);
        });
      };
    }
    function wrap2(func) {
      return function(...args) {
        const id = promiseId++;
        const promiseB = new Promise((innerResolve, innerReject) => {
          workerPromises[`${id}b`] = { resolve: innerResolve, reject: innerReject, func };
        });
        const promiseA = new Promise((innerResolve, innerReject) => {
          workerPromises[id] = { resolve: innerResolve, reject: innerReject, func };
          worker.postMessage([func, args[0], id]);
        });
        return [promiseA, promiseB];
      };
    }
    obj.convertPageHocr = wrap("convertPageHocr");
    obj.convertPageAbbyy = wrap("convertPageAbbyy");
    obj.convertPageStext = wrap("convertPageStext");
    obj.convertDocTextract = wrap("convertDocTextract");
    obj.convertDocAzureDocIntel = wrap("convertDocAzureDocIntel");
    obj.convertPageGoogleVision = wrap("convertPageGoogleVision");
    obj.convertPageText = wrap("convertPageText");
    obj.optimizeFont = wrap("optimizeFont");
    obj.evalPageFont = wrap("evalPageFont");
    obj.evalPageBase = wrap("evalPageBase");
    obj.evalWords = wrap("evalWords");
    obj.compareOCRPageImp = wrap("compareOCRPageImp");
    obj.nudgePageFontSize = wrap("nudgePageFontSize");
    obj.nudgePageBaseline = wrap("nudgePageBaseline");
    obj.reinitialize = wrap("reinitialize");
    obj.reinitialize2 = wrap("reinitialize2");
    obj.recognize = wrap("recognize");
    obj.recognizeAndConvert = wrap("recognizeAndConvert");
    obj.recognizeAndConvert2 = wrap2("recognizeAndConvert2");
    obj.renderPageStaticImp = wrap("renderPageStaticImp");
    obj.loadFontsWorker = wrap("loadFontsWorker");
    obj.updateFontContWorker = wrap("updateFontContWorker");
    obj.terminate = () => worker.terminate();
    ready.then(() => resolve(obj));
  });
}
var gs = class _gs {
  // Individual promises are used to track the readiness of different components in the scheduler/workers.
  // This is used rather than storing the scheduler in a promise for a couple reasons:
  // (1) The scheduler only loads certain features on an as-needed basis, and we need to be able to track the readiness of these individually.
  //     When initially set up, the scheduler will not have fonts loaded, or the Tesseract worker loaded.
  // (2) The scheduler is accessed directly from this object within in many non-async functions,
  //     so storing as a promise would require a lot of refactoring for little benefit.
  //     The scheduler is a singleton that is only set up once, so there is no need to store it in a promise as long as setup race conditions are avoided.
  /** Whether built-in fonts have been loaded in workers. */
  static loadedBuiltInFontsRawWorker = false;
  /** Whether optimized fonts have been loaded in workers. */
  static loadedBuiltInFontsOptWorker = false;
  static loadedBuiltInFontsDocWorker = false;
  /** @type {?GeneralScheduler} */
  // static scheduler = null;
  /** @type {?import('../tess/tesseract.esm.min.js').default} */
  static schedulerInner = null;
  /** @type {?Promise<void>} */
  static schedulerReady = null;
  /** @type {?Function} */
  static #resReadyTesseract = null;
  /** @type {?Promise<void>} */
  static schedulerReadyTesseract = null;
  /**
   * @param {Parameters<typeof import('./worker/compareOCRModule.js').compareOCRPageImp>[0]} args
   * @returns {ReturnType<typeof import('./worker/compareOCRModule.js').compareOCRPageImp>}
   */
  static compareOCRPageImp = async (args) => await _gs.schedulerInner.addJob("compareOCRPageImp", args);
  /**
   * @param {Parameters<typeof import('./import/convertPageHocr.js').convertPageHocr>[0]} args
   * @returns {ReturnType<typeof import('./import/convertPageHocr.js').convertPageHocr>}
   */
  static convertPageHocr = async (args) => {
    await _gs.getGeneralScheduler();
    return _gs.schedulerInner.addJob("convertPageHocr", args);
  };
  /**
   * @param {Parameters<typeof import('./import/convertPageAbbyy.js').convertPageAbbyy>[0]} args
   * @returns {ReturnType<typeof import('./import/convertPageAbbyy.js').convertPageAbbyy>}
   */
  static convertPageAbbyy = async (args) => {
    await _gs.getGeneralScheduler();
    return _gs.schedulerInner.addJob("convertPageAbbyy", args);
  };
  /**
   * @param {Parameters<typeof import('./import/convertDocTextract.js').convertDocTextract>[0]} args
   * @returns {ReturnType<typeof import('./import/convertDocTextract.js').convertDocTextract>}
   */
  static convertDocTextract = async (args) => {
    await _gs.getGeneralScheduler();
    return _gs.schedulerInner.addJob("convertDocTextract", args);
  };
  /**
   * @param {Parameters<typeof import('./import/convertDocAzureDocIntel.js').convertDocAzureDocIntel>[0]} args
   * @returns {ReturnType<typeof import('./import/convertDocAzureDocIntel.js').convertDocAzureDocIntel>}
   */
  static convertDocAzureDocIntel = async (args) => {
    await _gs.getGeneralScheduler();
    return _gs.schedulerInner.addJob("convertDocAzureDocIntel", args);
  };
  /**
   * @param {Parameters<typeof import('./import/convertPageGoogleVision.js').convertPageGoogleVision>[0]} args
   * @returns {ReturnType<typeof import('./import/convertPageGoogleVision.js').convertPageGoogleVision>}
   */
  static convertPageGoogleVision = async (args) => {
    await _gs.getGeneralScheduler();
    return _gs.schedulerInner.addJob("convertPageGoogleVision", args);
  };
  /**
   * @param {Parameters<typeof import('./import/convertPageStext.js').convertPageStext>[0]} args
   * @returns {ReturnType<typeof import('./import/convertPageStext.js').convertPageStext>}
   */
  static convertPageStext = async (args) => {
    await _gs.getGeneralScheduler();
    return _gs.schedulerInner.addJob("convertPageStext", args);
  };
  /**
   * @param {Parameters<typeof import('./import/convertPageText.js').convertPageText>[0]} args
   * @returns {ReturnType<typeof import('./import/convertPageText.js').convertPageText>}
   */
  static convertPageText = async (args) => {
    await _gs.getGeneralScheduler();
    return _gs.schedulerInner.addJob("convertPageText", args);
  };
  /**
   * @param {Parameters<typeof import('./worker/optimizeFontModule.js').optimizeFont>[0]} args
   * @returns {ReturnType<typeof import('./worker/optimizeFontModule.js').optimizeFont>}
   */
  static optimizeFont = async (args) => {
    await _gs.getGeneralScheduler();
    return _gs.schedulerInner.addJob("optimizeFont", args);
  };
  /**
   * @template {Partial<Tesseract.OutputFormats>} TO
   * @param {Object} args
   * @param {Parameters<Tesseract.Worker['recognize']>[0]} args.image
   * @param {Parameters<Tesseract.Worker['recognize']>[1]} args.options
   * @param {TO} args.output
   * @returns {Promise<Tesseract.Page<TO>>}
   * Exported for type inference purposes, should not be imported anywhere.
   */
  static recognize = async (args) => await _gs.schedulerInner.addJob("recognize", args);
  /**
   * @param {Parameters<typeof import('./worker/generalWorker.js').recognizeAndConvert>[0]} args
   * @returns {ReturnType<typeof import('./worker/generalWorker.js').recognizeAndConvert>}
   */
  static recognizeAndConvert = async (args) => await _gs.schedulerInner.addJob("recognizeAndConvert", args);
  /**
   * @param {Parameters<typeof import('./worker/generalWorker.js').recognizeAndConvert2>[0]} args
   * @returns {Promise<[ReturnType<typeof import('./worker/generalWorker.js').recognizeAndConvert>, ReturnType<typeof import('./worker/generalWorker.js').recognizeAndConvert>]>}
   */
  static recognizeAndConvert2 = async (args) => await _gs.schedulerInner.addJob("recognizeAndConvert2", args);
  /**
   * @param {Parameters<typeof import('./worker/compareOCRModule.js').evalPageBase>[0]} args
   * @returns {ReturnType<typeof import('./worker/compareOCRModule.js').evalPageBase>}
   */
  static evalPageBase = async (args) => await _gs.schedulerInner.addJob("evalPageBase", args);
  /**
   * @param {Parameters<typeof import('./worker/compareOCRModule.js').evalWords>[0]} args
   * @returns {ReturnType<typeof import('./worker/compareOCRModule.js').evalWords>}
   */
  static evalWords = async (args) => await _gs.schedulerInner.addJob("evalWords", args);
  /**
   * @param {Parameters<typeof import('./worker/compareOCRModule.js').evalPageFont>[0]} args
   * @returns {ReturnType<typeof import('./worker/compareOCRModule.js').evalPageFont>}
   */
  static evalPageFont = async (args) => await _gs.schedulerInner.addJob("evalPageFont", args);
  /**
   * @param {Parameters<typeof import('./worker/compareOCRModule.js').renderPageStaticImp>[0]} args
   * @returns {ReturnType<typeof import('./worker/compareOCRModule.js').renderPageStaticImp>}
   */
  static renderPageStaticImp = async (args) => await _gs.schedulerInner.addJob("renderPageStaticImp", args);
  static init = async () => {
    let workerN;
    if (opt.workerN) {
      workerN = opt.workerN;
    } else if (typeof process === "undefined") {
      workerN = Math.min(Math.round((globalThis.navigator.hardwareConcurrency || 8) / 2), 6);
    } else {
      const cpuN = Math.floor((await import("node:os")).cpus().length / 2);
      workerN = Math.max(Math.min(cpuN - 1, 8), 1);
    }
    const Tesseract = typeof process === "undefined" ? (await Promise.resolve().then(() => (init_tesseract_esm_min(), tesseract_esm_min_exports))).default : await Promise.resolve().then(() => __toESM(require_src(), 1));
    _gs.schedulerInner = await Tesseract.createScheduler();
    _gs.schedulerInner.workers = new Array(workerN);
    const addGeneralWorker = async (i2) => {
      const w2 = await initGeneralWorker();
      w2.id = `png-${Math.random().toString(16).slice(3, 8)}`;
      _gs.schedulerInner.addWorker(w2);
      _gs.schedulerInner.workers[i2] = w2;
    };
    await addGeneralWorker(0);
    const resArr = Array.from({ length: workerN }, (v2, k2) => k2).slice(1).map((i2) => addGeneralWorker(i2));
    await Promise.all(resArr);
    return;
  };
  /**
   *
   * @param {Object} params
   * @param {boolean} [params.anyOk=false] - Is any Tesseract worker okay to use?
   *    If `true`, this function returns immediately if Tesseract workers are already loaded,
   *    without checking the particular language/oem settings.
   * @param {boolean} [params.vanillaMode=false] - Use vanilla Tesseract rather than Scribe OCR fork.
   * @param {string[]} [params.langs] - Array of language codes to load. If not provided, all languages are loaded.
   * @param {Object<string, string>} [params.config={}] - Config params to pass to to Tesseract.js.
   * @returns
   */
  static initTesseract = async ({
    anyOk = true,
    vanillaMode = false,
    langs = ["eng"],
    config: config2 = {}
  }) => {
    await _gs.schedulerReady;
    if (anyOk && _gs.schedulerReadyTesseract) return _gs.schedulerReadyTesseract;
    if (_gs.schedulerReadyTesseract) await _gs.schedulerReadyTesseract;
    _gs.schedulerReadyTesseract = new Promise((resolve, reject) => {
      _gs.#resReadyTesseract = resolve;
    });
    const worker0 = _gs.schedulerInner.workers[0];
    await worker0.reinitialize({ langs, vanillaMode, config: config2 });
    if (_gs.schedulerInner.workers.length > 0) {
      const resArr = _gs.schedulerInner.workers.slice(1).map((x2) => x2.reinitialize({ langs, vanillaMode, config: config2 }));
      await Promise.allSettled(resArr);
    }
    _gs.#resReadyTesseract(true);
    return _gs.schedulerReadyTesseract;
  };
  /**
   * Gets the general scheduler if it exists, otherwise creates a new one.
   */
  static getGeneralScheduler = () => {
    if (_gs.schedulerReady) {
      return _gs.schedulerReady;
    }
    _gs.schedulerReady = _gs.init();
    return _gs.schedulerReady;
  };
  static clear = () => {
    _gs.loadedBuiltInFontsOptWorker = false;
  };
  static terminate = async () => {
    _gs.clear();
    await _gs.schedulerReady;
    await _gs.schedulerInner.terminate();
    _gs.schedulerInner = null;
    _gs.schedulerReady = null;
    _gs.#resReadyTesseract = null;
    _gs.schedulerReadyTesseract = null;
    _gs.loadedBuiltInFontsRawWorker = false;
  };
};

// node_modules/scribe.js-ocr/js/fontContainerMain.js
async function loadBuiltInFontsRaw(glyphSet = "latin") {
  if (FontCont.state.glyphSet === glyphSet || FontCont.state.glyphSet === "all" && glyphSet === "latin") return;
  FontCont.state.glyphSet = glyphSet;
  let carlitoNormal;
  let carlitoItalic;
  let carlitoBold;
  let carlitoBoldItalic;
  let centuryNormal;
  let centuryItalic;
  let centuryBold;
  let centuryBoldItalic;
  let garamondNormal;
  let garamondItalic;
  let garamondBold;
  let garamondBoldItalic;
  let palatinoNormal;
  let palatinoItalic;
  let palatinoBold;
  let palatinoBoldItalic;
  let nimbusRomanNormal;
  let nimbusRomanItalic;
  let nimbusRomanBold;
  let nimbusRomanBoldItalic;
  let nimbusSansNormal;
  let nimbusSansItalic;
  let nimbusSansBold;
  let nimbusSansBoldItalic;
  let nimbusMonoNormal;
  let nimbusMonoItalic;
  let nimbusMonoBold;
  let nimbusMonoBoldItalic;
  let gothicNormal;
  let gothicItalic;
  let gothicBold;
  let gothicBoldItalic;
  if (typeof process === "undefined") {
    if (glyphSet === "latin") {
      carlitoNormal = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'Carlito-Regular.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/Carlito-Regular.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      carlitoItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'Carlito-Italic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/Carlito-Italic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      carlitoBold = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'Carlito-Bold.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/Carlito-Bold.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      carlitoBoldItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'Carlito-BoldItalic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/Carlito-BoldItalic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      centuryNormal = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'Century-Regular.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/Century-Regular.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      centuryItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'Century-Italic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/Century-Italic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      centuryBold = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'Century-Bold.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/Century-Bold.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      centuryBoldItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'Century-BoldItalic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/Century-BoldItalic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      garamondNormal = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'Garamond-Regular.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/Garamond-Regular.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      garamondItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'Garamond-Italic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/Garamond-Italic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      garamondBold = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'Garamond-Bold.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/Garamond-Bold.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      garamondBoldItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'Garamond-BoldItalic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/Garamond-BoldItalic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      palatinoNormal = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'Palatino-Regular.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/Palatino-Regular.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      palatinoItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'Palatino-Italic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/Palatino-Italic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      palatinoBold = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'Palatino-Bold.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/Palatino-Bold.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      palatinoBoldItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'Palatino-BoldItalic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/Palatino-BoldItalic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusRomanNormal = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'NimbusRoman-Regular.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/NimbusRoman-Regular.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusRomanItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'NimbusRoman-Italic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/NimbusRoman-Italic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusRomanBold = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'NimbusRoman-Bold.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/NimbusRoman-Bold.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusRomanBoldItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'NimbusRoman-BoldItalic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/NimbusRoman-BoldItalic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusSansNormal = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'NimbusSans-Regular.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/NimbusSans-Regular.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusSansItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'NimbusSans-Italic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/NimbusSans-Italic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusSansBold = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'NimbusSans-Bold.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/NimbusSans-Bold.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusSansBoldItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'NimbusSans-BoldItalic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/NimbusSans-BoldItalic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusMonoNormal = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'NimbusMono-Regular.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/NimbusMono-Regular.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusMonoItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'NimbusMono-Italic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/NimbusMono-Italic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusMonoBold = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'NimbusMono-Bold.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/NimbusMono-Bold.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusMonoBoldItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'NimbusMono-BoldItalic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/NimbusMono-BoldItalic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      gothicNormal = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'URWGothicBook-Regular.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/URWGothicBook-Regular.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      gothicItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'URWGothicBook-Italic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/URWGothicBook-Italic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      gothicBold = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'URWGothicBook-Bold.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/URWGothicBook-Bold.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      gothicBoldItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'latin', 'URWGothicBook-BoldItalic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/latin/URWGothicBook-BoldItalic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
    } else {
      carlitoNormal = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Carlito-Regular.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/Carlito-Regular.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      carlitoItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Carlito-Italic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/Carlito-Italic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      carlitoBold = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Carlito-Bold.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/Carlito-Bold.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      carlitoBoldItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Carlito-BoldItalic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/Carlito-BoldItalic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      centuryNormal = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Century-Regular.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/Century-Regular.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      centuryItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Century-Italic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/Century-Italic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      centuryBold = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Century-Bold.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/Century-Bold.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      centuryBoldItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Century-BoldItalic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/Century-BoldItalic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      garamondNormal = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Garamond-Regular.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/Garamond-Regular.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      garamondItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Garamond-Italic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/Garamond-Italic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      garamondBold = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Garamond-Bold.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/Garamond-Bold.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      garamondBoldItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Garamond-BoldItalic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/Garamond-BoldItalic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      palatinoNormal = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Palatino-Regular.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/Palatino-Regular.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      palatinoItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Palatino-Italic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/Palatino-Italic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      palatinoBold = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Palatino-Bold.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/Palatino-Bold.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      palatinoBoldItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Palatino-BoldItalic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/Palatino-BoldItalic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusRomanNormal = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusRoman-Regular.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/NimbusRoman-Regular.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusRomanItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusRoman-Italic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/NimbusRoman-Italic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusRomanBold = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusRoman-Bold.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/NimbusRoman-Bold.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusRomanBoldItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusRoman-BoldItalic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/NimbusRoman-BoldItalic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusSansNormal = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusSans-Regular.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/NimbusSans-Regular.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusSansItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusSans-Italic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/NimbusSans-Italic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusSansBold = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusSans-Bold.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/NimbusSans-Bold.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusSansBoldItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusSans-BoldItalic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/NimbusSans-BoldItalic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusMonoNormal = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusMono-Regular.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/NimbusMono-Regular.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusMonoItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusMono-Italic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/NimbusMono-Italic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusMonoBold = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusMono-Bold.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/NimbusMono-Bold.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      nimbusMonoBoldItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusMono-BoldItalic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/NimbusMono-BoldItalic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      gothicNormal = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'URWGothicBook-Regular.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/URWGothicBook-Regular.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      gothicItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'URWGothicBook-Italic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/URWGothicBook-Italic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      gothicBold = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'URWGothicBook-Bold.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/URWGothicBook-Bold.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
      gothicBoldItalic = (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR
        ? (async () => {
            const pathMod = await import('path');
            const fsMod = await import('fs/promises');
            const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'URWGothicBook-BoldItalic.woff');
            const data = await fsMod.readFile(localPath);
            return new Response(data);
          })()
        : fetch(new URL("../fonts/all/URWGothicBook-BoldItalic.woff", import.meta.url))
      ).then((res) => res.arrayBuffer());
    }
  } else {
    const { readFile } = await import("node:fs/promises");
    carlitoNormal = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Carlito-Regular.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/Carlito-Regular.woff", import.meta.url));
      })().then((res) => res.buffer);
    carlitoItalic = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Carlito-Italic.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/Carlito-Italic.woff", import.meta.url));
      })().then((res) => res.buffer);
    carlitoBold = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Carlito-Bold.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/Carlito-Bold.woff", import.meta.url));
      })().then((res) => res.buffer);
    carlitoBoldItalic = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Carlito-BoldItalic.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/Carlito-BoldItalic.woff", import.meta.url));
      })().then((res) => res.buffer);
    centuryNormal = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Century-Regular.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/Century-Regular.woff", import.meta.url));
      })().then((res) => res.buffer);
    centuryItalic = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Century-Italic.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/Century-Italic.woff", import.meta.url));
      })().then((res) => res.buffer);
    centuryBold = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Century-Bold.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/Century-Bold.woff", import.meta.url));
      })().then((res) => res.buffer);
    centuryBoldItalic = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Century-BoldItalic.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/Century-BoldItalic.woff", import.meta.url));
      })().then((res) => res.buffer);
    garamondNormal = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Garamond-Regular.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/Garamond-Regular.woff", import.meta.url));
      })().then((res) => res.buffer);
    garamondItalic = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Garamond-Italic.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/Garamond-Italic.woff", import.meta.url));
      })().then((res) => res.buffer);
    garamondBold = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Garamond-Bold.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/Garamond-Bold.woff", import.meta.url));
      })().then((res) => res.buffer);
    garamondBoldItalic = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Garamond-BoldItalic.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/Garamond-BoldItalic.woff", import.meta.url));
      })().then((res) => res.buffer);
    palatinoNormal = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Palatino-Regular.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/Palatino-Regular.woff", import.meta.url));
      })().then((res) => res.buffer);
    palatinoItalic = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Palatino-Italic.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/Palatino-Italic.woff", import.meta.url));
      })().then((res) => res.buffer);
    palatinoBold = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Palatino-Bold.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/Palatino-Bold.woff", import.meta.url));
      })().then((res) => res.buffer);
    palatinoBoldItalic = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'Palatino-BoldItalic.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/Palatino-BoldItalic.woff", import.meta.url));
      })().then((res) => res.buffer);
    nimbusRomanNormal = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusRoman-Regular.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/NimbusRoman-Regular.woff", import.meta.url));
      })().then((res) => res.buffer);
    nimbusRomanItalic = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusRoman-Italic.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/NimbusRoman-Italic.woff", import.meta.url));
      })().then((res) => res.buffer);
    nimbusRomanBold = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusRoman-Bold.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/NimbusRoman-Bold.woff", import.meta.url));
      })().then((res) => res.buffer);
    nimbusRomanBoldItalic = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusRoman-BoldItalic.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/NimbusRoman-BoldItalic.woff", import.meta.url));
      })().then((res) => res.buffer);
    nimbusSansNormal = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusSans-Regular.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/NimbusSans-Regular.woff", import.meta.url));
      })().then((res) => res.buffer);
    nimbusSansItalic = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusSans-Italic.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/NimbusSans-Italic.woff", import.meta.url));
      })().then((res) => res.buffer);
    nimbusSansBold = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusSans-Bold.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/NimbusSans-Bold.woff", import.meta.url));
      })().then((res) => res.buffer);
    nimbusSansBoldItalic = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusSans-BoldItalic.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/NimbusSans-BoldItalic.woff", import.meta.url));
      })().then((res) => res.buffer);
    nimbusMonoNormal = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusMono-Regular.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/NimbusMono-Regular.woff", import.meta.url));
      })().then((res) => res.buffer);
    nimbusMonoItalic = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusMono-Italic.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/NimbusMono-Italic.woff", import.meta.url));
      })().then((res) => res.buffer);
    nimbusMonoBold = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusMono-Bold.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/NimbusMono-Bold.woff", import.meta.url));
      })().then((res) => res.buffer);
    nimbusMonoBoldItalic = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'NimbusMono-BoldItalic.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/NimbusMono-BoldItalic.woff", import.meta.url));
      })().then((res) => res.buffer);
    gothicNormal = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'URWGothicBook-Regular.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/URWGothicBook-Regular.woff", import.meta.url));
      })().then((res) => res.buffer);
    gothicItalic = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'URWGothicBook-Italic.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/URWGothicBook-Italic.woff", import.meta.url));
      })().then((res) => res.buffer);
    gothicBold = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'URWGothicBook-Bold.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/URWGothicBook-Bold.woff", import.meta.url));
      })().then((res) => res.buffer);
    gothicBoldItalic = (async () => {
        if (typeof Bun !== 'undefined' && globalThis.__BUN_SCRIBE_DIR) {
          const pathMod = await import('path');
          const fsMod = await import('fs/promises');
          const localPath = pathMod.join(globalThis.__BUN_SCRIBE_DIR, 'fonts', 'all', 'URWGothicBook-BoldItalic.woff');
          return fsMod.readFile(localPath);
        }
        return readFile(new URL("../fonts/all/URWGothicBook-BoldItalic.woff", import.meta.url));
      })().then((res) => res.buffer);
  }
  const srcObj = {
    Carlito: {
      normal: await carlitoNormal,
      italic: await carlitoItalic,
      bold: await carlitoBold,
      boldItalic: await carlitoBoldItalic
    },
    Century: {
      normal: await centuryNormal,
      italic: await centuryItalic,
      bold: await centuryBold,
      boldItalic: await centuryBoldItalic
    },
    Garamond: {
      normal: await garamondNormal,
      italic: await garamondItalic,
      bold: await garamondBold,
      boldItalic: await garamondBoldItalic
    },
    Gothic: {
      normal: await gothicNormal,
      italic: await gothicItalic,
      bold: await gothicBold,
      boldItalic: await gothicBoldItalic
    },
    Palatino: {
      normal: await palatinoNormal,
      italic: await palatinoItalic,
      bold: await palatinoBold,
      boldItalic: await palatinoBoldItalic
    },
    NimbusRoman: {
      normal: await nimbusRomanNormal,
      italic: await nimbusRomanItalic,
      bold: await nimbusRomanBold,
      boldItalic: await nimbusRomanBoldItalic
    },
    NimbusSans: {
      normal: await nimbusSansNormal,
      italic: await nimbusSansItalic,
      bold: await nimbusSansBold,
      boldItalic: await nimbusSansBoldItalic
    },
    NimbusMono: {
      normal: await nimbusMonoNormal,
      italic: await nimbusMonoItalic,
      bold: await nimbusMonoBold,
      boldItalic: await nimbusMonoBoldItalic
    }
  };
  FontCont.raw = await /** @type {FontContainer} */
  /** @type {any} */
  loadFontsFromSource(srcObj);
  if (gs.schedulerReady === null) console.warn("Failed to load fonts to workers as workers have not been initialized yet.");
  await gs.schedulerReady;
  await updateFontContWorkerMain({ loadRaw: true });
  return;
}
var chiReadyRes;
var chiReady;
async function loadChiSimFont() {
  if (chiReady) return chiReady;
  chiReady = new Promise((resolve, reject) => {
    chiReadyRes = resolve;
  });
  let chiSimSrc;
  if (typeof process === "undefined") {
    chiSimSrc = fetch(new URL("../fonts/NotoSansSC-Regular.ttf", import.meta.url)).then((res) => res.arrayBuffer());
  } else {
    const { readFile } = await import("node:fs/promises");
    chiSimSrc = readFile(new URL("../fonts/NotoSansSC-Regular.ttf", import.meta.url)).then((res) => res.buffer);
  }
  FontCont.supp.chi_sim = await loadFont("NotoSansSC", "normal", "sans", await chiSimSrc, false);
  chiReadyRes();
  return chiReady;
}
async function enableFontOpt(enableOpt, forceOpt) {
  let change = false;
  if (enableOpt === true || enableOpt === false) {
    if (FontCont.state.enableOpt !== enableOpt) {
      change = true;
      FontCont.state.enableOpt = enableOpt;
    }
  }
  if (forceOpt === true || forceOpt === false) {
    if (FontCont.state.forceOpt !== forceOpt) {
      change = true;
      FontCont.state.forceOpt = forceOpt;
    }
  }
  await updateFontContWorkerMain();
}
async function updateFontContWorkerMain(params = {}) {
  const loadRaw = params.loadRaw === true || params.loadRaw !== false && FontCont.raw && !gs.loadedBuiltInFontsRawWorker;
  const loadOpt = params.loadOpt === true || params.loadOpt !== false && FontCont.opt && !gs.loadedBuiltInFontsOptWorker;
  const loadDoc = params.loadDoc === true || params.loadDoc !== false && FontCont.doc && !gs.loadedBuiltInFontsDocWorker;
  for (const [type, load] of [["raw", loadRaw], ["opt", loadOpt], ["doc", loadDoc]]) {
    if (!load) continue;
    const resArr2 = [];
    const input = { opt: type === "opt", src: {} };
    for (const [key, value] of Object.entries(FontCont[type])) {
      if (!value || !value.normal) continue;
      input.src[key] = {
        normal: value.normal.src
      };
      if (value.italic) input.src[key].italic = value.italic.src;
      if (value.bold) input.src[key].bold = value.bold.src;
      if (value.boldItalic) input.src[key].boldItalic = value.boldItalic.src;
    }
    for (let i2 = 0; i2 < gs.schedulerInner.workers.length; i2++) {
      const worker = gs.schedulerInner.workers[i2];
      const res = worker.loadFontsWorker(input);
      resArr2.push(res);
      if (type === "opt") {
        gs.loadedBuiltInFontsOptWorker = true;
      } else if (type === "raw") {
        gs.loadedBuiltInFontsRawWorker = true;
      } else if (type === "doc") {
        gs.loadedBuiltInFontsDocWorker = true;
      }
    }
    await Promise.all(resArr2);
  }
  const resArr = [];
  for (let i2 = 0; i2 < gs.schedulerInner.workers.length; i2++) {
    const worker = gs.schedulerInner.workers[i2];
    const res = worker.updateFontContWorker({
      rawMetrics: FontCont.rawMetrics,
      optMetrics: FontCont.optMetrics,
      sansDefaultName: FontCont.state.sansDefaultName,
      serifDefaultName: FontCont.state.serifDefaultName,
      defaultFontName: FontCont.state.defaultFontName,
      enableOpt: FontCont.state.enableOpt,
      forceOpt: FontCont.state.forceOpt
    });
    resArr.push(res);
  }
  await Promise.all(resArr);
}
function setDefaultFontAuto(charMetricsObj) {
  const multiFontMode = checkMultiFontMode(charMetricsObj);
  if (!multiFontMode) return;
  if ((charMetricsObj.SerifDefault?.obs || 0) > (charMetricsObj.SansDefault?.obs || 0)) {
    FontCont.state.defaultFontName = "SerifDefault";
  } else {
    FontCont.state.defaultFontName = "SansDefault";
  }
  if (gs.schedulerInner) {
    for (let i2 = 0; i2 < gs.schedulerInner.workers.length; i2++) {
      const worker = gs.schedulerInner.workers[i2];
      worker.updateFontContWorker({ defaultFontName: FontCont.state.defaultFontName });
    }
  }
}
async function optimizeFontContainerFamily(fontFamily, charMetricsObj) {
  const multiFontMode = checkMultiFontMode(charMetricsObj);
  let charMetricsType = "Default";
  if (multiFontMode) {
    if (fontFamily.normal.type === "sans") {
      charMetricsType = "SansDefault";
    } else {
      charMetricsType = "SerifDefault";
    }
  }
  if (!charMetricsObj[charMetricsType] || !charMetricsObj[charMetricsType][fontFamily.normal.style] || charMetricsObj[charMetricsType][fontFamily.normal.style].obs < 200) {
    return null;
  }
  const metricsNormal = charMetricsObj[charMetricsType][fontFamily.normal.style];
  const normalOptFont = gs.optimizeFont({ fontData: fontFamily.normal.src, charMetricsObj: metricsNormal, style: fontFamily.normal.style }).then(async (x2) => {
    const font = await loadOpentype(x2.fontData, x2.kerningPairs);
    return new FontContainerFont(fontFamily.normal.family, fontFamily.normal.style, x2.fontData, true, font);
  });
  const metricsItalic = charMetricsObj[charMetricsType][fontFamily.italic.style];
  let italicOptFont = null;
  if (metricsItalic && metricsItalic.obs >= 200) {
    italicOptFont = gs.optimizeFont({ fontData: fontFamily.italic.src, charMetricsObj: metricsItalic, style: fontFamily.italic.style }).then(async (x2) => {
      const font = await loadOpentype(x2.fontData, x2.kerningPairs);
      return new FontContainerFont(fontFamily.italic.family, fontFamily.italic.style, x2.fontData, true, font);
    });
  }
  return {
    normal: await normalOptFont,
    italic: await italicOptFont,
    bold: null
  };
}
async function optimizeFontContainerAll(fontPrivate, charMetricsObj) {
  const carlitoPromise = optimizeFontContainerFamily(fontPrivate.Carlito, charMetricsObj);
  const centuryPromise = optimizeFontContainerFamily(fontPrivate.Century, charMetricsObj);
  const garamondPromise = optimizeFontContainerFamily(fontPrivate.Garamond, charMetricsObj);
  const gothicPromise = optimizeFontContainerFamily(fontPrivate.Gothic, charMetricsObj);
  const palatinoPromise = optimizeFontContainerFamily(fontPrivate.Palatino, charMetricsObj);
  const nimbusRomanPromise = optimizeFontContainerFamily(fontPrivate.NimbusRoman, charMetricsObj);
  const nimbusSansPromise = optimizeFontContainerFamily(fontPrivate.NimbusSans, charMetricsObj);
  const nimbusMonoPromise = optimizeFontContainerFamily(fontPrivate.NimbusMono, charMetricsObj);
  const results = await Promise.all([
    carlitoPromise,
    centuryPromise,
    garamondPromise,
    gothicPromise,
    palatinoPromise,
    nimbusRomanPromise,
    nimbusSansPromise,
    nimbusMonoPromise
  ]);
  if (results.every((x2) => x2 === null)) return null;
  return {
    Carlito: results[0],
    Century: results[1],
    Garamond: results[2],
    Gothic: results[3],
    Palatino: results[4],
    NimbusRoman: results[5],
    NimbusSans: results[6],
    NimbusMono: results[7]
  };
}

// node_modules/scribe.js-ocr/js/containers/imageContainer.js
init_dataContainer();

// node_modules/scribe.js-ocr/js/objects/imageObjects.js
var ImageWrapper = class {
  /**
   * @param {number} n - Page number
   * @param {string} imageStr - Base-64 encoded image string. Should start with "data:image/png" or "data:image/jpeg".
   * @param {string} colorMode - Color mode ("color", "gray", or "binary").
   * @param {boolean} rotated - Whether image has been rotated.
   * @param {boolean} upscaled - Whether image has been upscaled.
   *
   * All properties of this object must be serializable, as ImageWrapper objects are sent between threads.
   * This means that no promises can be used.
   */
  constructor(n2, imageStr, colorMode, rotated = false, upscaled = false) {
    this.n = n2;
    this.src = imageStr;
    const format0 = (
      /** @type {'png'|'jpeg'|undefined} */
      imageStr.match(/^data:image\/(png|jpeg)/)?.[1]
    );
    if (!format0 || !["png", "jpeg"].includes(format0)) throw new Error(`Invalid image format: ${format0}`);
    this.format = format0;
    this._dims = null;
    this.rotated = rotated;
    this.upscaled = upscaled;
    this.colorMode = colorMode;
    this.imageBitmap = null;
  }
};
var getDims = (img) => {
  if (!img._dims) {
    if (img.format === "jpeg") {
      img._dims = getJpegDimensions(img.src);
    } else {
      img._dims = getPngDimensions(img.src);
    }
  }
  return img._dims;
};
var requiresUndo = (img, props) => {
  if (!props) return false;
  if (img.rotated && props.rotated === false) return true;
  if (img.upscaled && props.upscaled === false) return true;
  if (img.colorMode === "color" && props.colorMode === "gray" || img.colorMode === "gray" && props.colorMode === "color") return true;
  return false;
};
var compatible = (img, props, significantRotation) => {
  if (!props) return true;
  if (props.rotated === false && img.rotated === true) {
    return false;
  }
  if (props.rotated === true && img.rotated === false) {
    if (significantRotation) {
      return false;
    }
  }
  if (props.upscaled === true && img.upscaled === false || props.upscaled === false && img.upscaled === true) return false;
  if (props.colorMode && props.colorMode !== img.colorMode && img.colorMode !== "native" && img.colorMode !== "native") return false;
  return true;
};
var imageUtils = {
  getDims,
  requiresUndo,
  compatible
};

// node_modules/scribe.js-ocr/js/containers/imageContainer.js
init_miscUtils();
init_app();
var skipTextMode = false;
var MuPDFScheduler = class {
  constructor(scheduler, workers2) {
    this.scheduler = scheduler;
    this.workers = workers2;
    this.pageText = (args) => this.scheduler.addJob("pageText", args);
    this.extractAllFonts = (args) => this.scheduler.addJob("extractAllFonts", args);
    this.drawPageAsPNG = (args) => this.scheduler.addJob("drawPageAsPNG", args);
  }
};
var ImageCache = class _ImageCache {
  /** @type {Array<ImageWrapper|Promise<ImageWrapper>>} */
  static nativeSrc = [];
  /** @type {Array<ImageWrapper|Promise<ImageWrapper>>} */
  static native = [];
  /** @type {Array<ImageWrapper|Promise<ImageWrapper>>} */
  static binary = [];
  // These arrays store the properties of the images.
  // While they are redundant with the properties stored in the ImageWrapper objects,
  // they still need to exist to determine whether the image needs to be re-rendered.
  // The imagewrappers are stored as promises, and needing to await them would break things without further changes.
  // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await#control_flow_effects_of_await
  /** @type {Array<ImageProperties>} */
  static nativeProps = [];
  /** @type {Array<ImageProperties>} */
  static binaryProps = [];
  /** @type {?ArrayBuffer} */
  static pdfData = null;
  /**
   * @param {ImagePropertiesRequest} props
   * @param {ImageWrapper} inputImage
   * @param {number} n - Page number
   * @param {boolean} [binary=false]
   * @returns {ImageProperties}
   */
  static fillPropsDefault = (props, inputImage, n2, binary = false) => {
    let colorMode = "binary";
    if (!binary) {
      const color = props?.colorMode === "color" || !props?.colorMode && opt.colorMode === "color";
      colorMode = color ? "color" : "gray";
    }
    let pageAngle = pageMetricsAll[n2].angle || 0;
    if (Math.abs(pageAngle) < 0.05) pageAngle = 0;
    const rotate = props?.rotated !== false && inputImage.rotated === false;
    const angleArg = rotate ? pageAngle * (Math.PI / 180) * -1 : 0;
    const upscaleArg = props?.upscaled || false;
    const isRotated = Boolean(angleArg) || inputImage.rotated;
    const isUpscaled = upscaleArg || inputImage.upscaled;
    return {
      rotated: isRotated,
      upscaled: isUpscaled,
      colorMode,
      n: n2
    };
  };
  /** @type {?Promise<MuPDFScheduler>} */
  static muPDFScheduler = null;
  static loadCount = 0;
  static pageCount = 0;
  /**
   * The dimensions that each page would be, if it was rendered at 300 DPI.
   * @type {Array<dims>}
   */
  static pdfDims300 = [];
  static inputModes = {
    pdf: false,
    image: false
  };
  static colorModeDefault = "gray";
  /**
   * Initializes the MuPDF scheduler.
   * This is separate from the function that loads the file (`#loadFileMuPDFScheduler`),
   * as the scheduler starts loading ahead of the file being available for performance reasons.
   * @param {number} [numWorkers]
   */
  static #initMuPDFScheduler = async (numWorkers) => {
    if (!numWorkers) {
      if (typeof process === "undefined") {
        numWorkers = Math.min(Math.round((globalThis.navigator.hardwareConcurrency || 8) / 2), 3);
      } else {
        const cpuN = Math.floor((await import("node:os")).cpus().length / 2);
        numWorkers = Math.max(Math.min(cpuN - 1, 3), 1);
      }
      if (opt.workerN && opt.workerN < numWorkers) {
        numWorkers = opt.workerN;
      }
    }
    const Tesseract = typeof process === "undefined" ? (await Promise.resolve().then(() => (init_tesseract_esm_min(), tesseract_esm_min_exports))).default : await Promise.resolve().then(() => __toESM(require_src(), 1));
    const scheduler = await Tesseract.createScheduler();
    const workersPromiseArr = range(1, numWorkers).map(async () => {
      const w2 = await initMuPDFWorker();
      w2.id = `png-${Math.random().toString(16).slice(3, 8)}`;
      scheduler.addWorker(w2);
      return w2;
    });
    const workers2 = await Promise.all(workersPromiseArr);
    return new MuPDFScheduler(scheduler, workers2);
  };
  /**
   *
   * @param {ArrayBuffer} fileData
   * @returns
   */
  static #loadFileMuPDFScheduler = async (fileData) => {
    const scheduler = await _ImageCache.getMuPDFScheduler();
    const workersPromiseArr = range(0, scheduler.workers.length - 1).map(async (x2) => {
      const w2 = scheduler.workers[x2];
      if (w2.pdfDoc) await w2.freeDocument(w2.pdfDoc);
      const fileDataCopy = fileData.slice(0);
      const pdfDoc = await w2.openDocument(fileDataCopy, "document.pdf");
      w2.pdfDoc = pdfDoc;
    });
    await Promise.all(workersPromiseArr);
  };
  static #renderImage = async (n2, color = false) => {
    if (_ImageCache.inputModes.image) {
      return _ImageCache.nativeSrc[n2];
    }
    if (_ImageCache.inputModes.pdf) {
      const pageMetrics = pageMetricsAll[n2];
      const targetWidth = pageMetrics.dims.width;
      const dpi = 300 * (targetWidth / _ImageCache.pdfDims300[n2].width);
      const muPDFScheduler = await _ImageCache.getMuPDFScheduler();
      return muPDFScheduler.drawPageAsPNG({
        page: n2 + 1,
        dpi,
        color,
        skipText: skipTextMode
      }).then((res) => new ImageWrapper(n2, res, color ? "color" : "gray"));
    }
    throw new Error("Attempted to render image without image input provided.");
  };
  /**
   * @param {ImageWrapper} inputImage
   * @param {number} n - Page number
   * @param {ImagePropertiesRequest} [props] - Image properties needed.
   *  Image properties should only be defined if needed, as they can require the image to be re-rendered.
   * @param {boolean} [saveNativeImage=true] - Whether the native image should be saved.
   */
  static transformImage = async (inputImage, n2, props, saveNativeImage = true) => {
    let pageAngle = pageMetricsAll[n2].angle || 0;
    if (Math.abs(pageAngle) < 0.05) pageAngle = 0;
    const rotate = props?.rotated !== false && inputImage.rotated === false;
    const angleArg = rotate ? pageAngle * (Math.PI / 180) * -1 : 0;
    const upscaleArg = props?.upscaled || false;
    await gs.getGeneralScheduler();
    const resPromise = (async () => {
      await gs.initTesseract({ anyOk: true });
      return gs.recognize({
        image: inputImage.src,
        options: { rotateRadians: angleArg, upscale: upscaleArg },
        output: {
          imageBinary: true,
          imageColor: saveNativeImage,
          debug: true,
          text: false,
          hocr: false,
          tsv: false,
          blocks: false
        }
      });
    })();
    const isRotated = Boolean(angleArg) || inputImage.rotated;
    let native = null;
    if (saveNativeImage) {
      native = resPromise.then(async (res) => new ImageWrapper(
        n2,
        /** @type {string} */
        /** @type {unknown} */
        res.imageColor,
        inputImage.colorMode,
        isRotated,
        upscaleArg
      ));
    }
    const binary = resPromise.then(async (res) => new ImageWrapper(
      n2,
      /** @type {string} */
      /** @type {unknown} */
      res.imageBinary,
      "binary",
      isRotated,
      upscaleArg
    ));
    return { native, binary };
  };
  /**
   * @param {number} n - Page number
   * @param {ImagePropertiesRequest} [props] - Image properties needed.
   *  Image properties should only be defined if needed, as they can require the image to be re-rendered.
   * @param {boolean} [nativeOnly=true]
   */
  static getImages = (n2, props, nativeOnly = true) => {
    if (!_ImageCache.inputModes.image && !_ImageCache.inputModes.pdf) {
      return { native: void 0, binary: void 0 };
    }
    const significantRotation = Math.abs(pageMetricsAll[n2].angle || 0) > 0.05;
    const newNative = !_ImageCache.native[n2] || !imageUtils.compatible(_ImageCache.nativeProps[n2], props, significantRotation);
    const newBinary = !nativeOnly && (!_ImageCache.binary[n2] || !imageUtils.compatible(_ImageCache.binaryProps[n2], props, significantRotation));
    if (newNative || newBinary) {
      const renderRaw = !_ImageCache.native[n2] || imageUtils.requiresUndo(_ImageCache.nativeProps[n2], props);
      const propsRaw = {
        colorMode: opt.colorMode,
        rotated: false,
        upscaled: false,
        n: n2
      };
      const renderTransform = newBinary || !imageUtils.compatible(propsRaw, props, significantRotation);
      const propsNew = renderRaw ? propsRaw : JSON.parse(JSON.stringify(_ImageCache.nativeProps[n2]));
      propsNew.colorMode = props?.colorMode || propsNew.colorMode;
      propsNew.rotated = props?.rotated ?? propsNew.rotated;
      propsNew.upscaled = props?.upscaled ?? propsNew.upscaled;
      const propsNewBinary = JSON.parse(JSON.stringify(propsNew));
      propsNewBinary.colorMode = "binary";
      const inputNative = _ImageCache.native[n2];
      if (newNative) _ImageCache.nativeProps[n2] = propsNew;
      if (newBinary) _ImageCache.binaryProps[n2] = propsNewBinary;
      const res = (async () => {
        let img1;
        if (renderRaw) {
          const color = props?.colorMode === "color" || !props?.colorMode && opt.colorMode === "color";
          img1 = await _ImageCache.#renderImage(n2, color);
        } else {
          img1 = await inputNative;
        }
        if (renderTransform) {
          return _ImageCache.transformImage(img1, n2, props, true);
        }
        return { native: img1, binary: null };
      })();
      if (newNative) _ImageCache.native[n2] = res.then((r2) => r2.native);
      if (newBinary) _ImageCache.binary[n2] = res.then((r2) => r2.binary);
    }
    return { native: _ImageCache.native[n2], binary: _ImageCache.binary[n2] };
  };
  /**
   * @param {number} n
   * @param {ImagePropertiesRequest} [props]
   */
  static getNative = async (n2, props) => _ImageCache.getImages(n2, props, true).native;
  /**
   * @param {number} n
   * @param {ImagePropertiesRequest} [props]
   */
  static getBinary = async (n2, props) => _ImageCache.getImages(n2, props, false).binary;
  /**
   * Pre-render a range of pages.
   * This is generally not required, as individual image are rendered as needed.
   * The primary use case is reducing latency in the UI by rendering images in advance.
   *
   * @param {number} min - Min page to render.
   * @param {number} max - Max page to render.
   * @param {boolean} binary - Whether to render binary images.
   * @param {ImagePropertiesRequest} [props]
   */
  static preRenderRange = async (min, max, binary, props) => {
    const pagesArr = range(min, max);
    if (binary) {
      await Promise.all(pagesArr.map((n2) => _ImageCache.getBinary(n2, props).then(() => {
        opt.progressHandler({ n: n2, type: "render", info: {} });
      })));
    } else {
      await Promise.all(pagesArr.map((n2) => _ImageCache.getNative(n2, props).then(() => {
        opt.progressHandler({ n: n2, type: "render", info: {} });
      })));
    }
  };
  static clear = () => {
    _ImageCache.nativeSrc = [];
    _ImageCache.native = [];
    _ImageCache.binary = [];
    _ImageCache.inputModes.image = false;
    _ImageCache.inputModes.pdf = false;
    _ImageCache.pageCount = 0;
    _ImageCache.pdfDims300.length = 0;
    _ImageCache.loadCount = 0;
    _ImageCache.nativeProps.length = 0;
    _ImageCache.binaryProps.length = 0;
  };
  static terminate = async () => {
    _ImageCache.clear();
    if (_ImageCache.muPDFScheduler) {
      const muPDFScheduler = await _ImageCache.muPDFScheduler;
      await muPDFScheduler.scheduler.terminate();
      _ImageCache.muPDFScheduler = null;
    }
  };
  /**
   * Gets the MuPDF scheduler if it exists, otherwise creates a new one.
   * @param {number} [numWorkers] - Number of workers to create.
   */
  static getMuPDFScheduler = async (numWorkers) => {
    if (_ImageCache.muPDFScheduler) return _ImageCache.muPDFScheduler;
    _ImageCache.muPDFScheduler = _ImageCache.#initMuPDFScheduler(numWorkers);
    return _ImageCache.muPDFScheduler;
  };
  /**
   *
   * @param {ArrayBuffer} fileData
   * @param {Boolean} [skipText=false] - Whether to skip native text when rendering PDF to image.
   */
  static openMainPDF = async (fileData, skipText = false) => {
    const muPDFScheduler = await _ImageCache.getMuPDFScheduler();
    await _ImageCache.#loadFileMuPDFScheduler(fileData);
    _ImageCache.pageCount = await muPDFScheduler.workers[0].countPages();
    const pageDims1 = await muPDFScheduler.workers[0].pageSizes([300]);
    _ImageCache.pdfDims300.length = 0;
    pageDims1.forEach((x2) => {
      _ImageCache.pdfDims300.push({ width: x2[0], height: x2[1] });
    });
    _ImageCache.inputModes.pdf = true;
    skipTextMode = skipText;
    const pageDPI = _ImageCache.pdfDims300.map((x2) => 300 * Math.min(x2.width, 3500) / x2.width);
    _ImageCache.pdfDims300.forEach((x2, i2) => {
      const pageDims = { width: Math.round(x2.width * pageDPI[i2] / 300), height: Math.round(x2.height * pageDPI[i2] / 300) };
      pageMetricsAll[i2] = new PageMetrics(pageDims);
    });
    if (opt.extractPDFFonts) {
      muPDFScheduler.extractAllFonts().then(async (x2) => {
        for (let i2 = 0; i2 < x2.length; i2++) {
          const src = x2[i2].buffer;
          FontCont.addFontFromFile(src);
        }
        await updateFontContWorkerMain();
      });
    }
  };
};

// node_modules/scribe.js-ocr/js/clear.js
init_miscUtils();
function clearData() {
  inputData.clear();
  clearObjectProperties(ocrAll);
  ocrAll.active = [];
  clearObjectProperties(ocrAllRaw);
  ocrAllRaw.active = [];
  layoutRegions.pages.length = 0;
  layoutDataTables.pages.length = 0;
  pageMetricsAll.length = 0;
  convertPageWarn.length = 0;
  ImageCache.clear();
  FontCont.clear();
}

// node_modules/scribe.js-ocr/scribe.js
init_app();
init_dataContainer();

// node_modules/scribe.js-ocr/js/coordinates.js
init_dataContainer();
function rotateBoundingBox(boundingBox, rotateAngle, n2) {
  let angleAdjXRect = 0;
  let angleAdjYRect = 0;
  const pageDims = pageMetricsAll[n2].dims;
  const sinAngle = Math.sin(rotateAngle * (Math.PI / 180));
  const cosAngle = Math.cos(rotateAngle * (Math.PI / 180));
  const shiftX = sinAngle * (pageDims.height * 0.5) * -1 || 0;
  const shiftY = sinAngle * ((pageDims.width - shiftX) * 0.5) || 0;
  const baselineY = boundingBox.top + boundingBox.height - boundingBox.height / 3;
  const angleAdjYInt = (1 - cosAngle) * baselineY - sinAngle * boundingBox.left;
  const angleAdjXInt = sinAngle * (baselineY - angleAdjYInt * 0.5);
  angleAdjXRect = shiftX + angleAdjXInt;
  angleAdjYRect = shiftY + angleAdjYInt;
  return {
    left: boundingBox.left - angleAdjXRect,
    top: boundingBox.top - angleAdjYRect,
    width: boundingBox.width,
    height: boundingBox.height
  };
}
function canvasToImage(canvasCoords, imageRotated, canvasRotated, n2, angle = 0) {
  if (canvasRotated && imageRotated || !canvasRotated && !imageRotated || Math.abs(angle ?? 0) <= 0.05) {
    return {
      left: canvasCoords.left,
      top: canvasCoords.top,
      width: canvasCoords.width,
      height: canvasCoords.height
    };
  }
  const rotateAngle = canvasRotated && !imageRotated ? angle : angle * -1;
  canvasCoords = rotateBoundingBox(canvasCoords, rotateAngle, n2);
  return {
    left: canvasCoords.left,
    top: canvasCoords.top,
    width: canvasCoords.width,
    height: canvasCoords.height
  };
}
async function ocrToImage(ocrCoords, n2, binary = false) {
  const imageN = binary ? await ImageCache.getBinary(n2) : await ImageCache.getNative(n2);
  if (!imageN.rotated && !imageN.upscaled) {
    return ocrCoords;
  }
  if (imageN.upscaled) {
    ocrCoords.left *= 2;
    ocrCoords.top *= 2;
    ocrCoords.width *= 2;
    ocrCoords.height *= 2;
  }
  if (imageN.rotated) {
    const rotateAngle = (pageMetricsAll[n2].angle || 0) * -1;
    rotateBoundingBox(ocrCoords, rotateAngle, n2);
  }
  return ocrCoords;
}
var coords = {
  canvasToImage,
  ocrToImage
};
var coordinates_default = coords;

// node_modules/scribe.js-ocr/js/debug.js
init_app();
init_dataContainer();
async function drawDebugImages(args) {
  let canvas = args.canvas;
  const compDebugArrArr = args.compDebugArrArr;
  const context = args.context;
  let top = 5;
  let canvasHeight = 5;
  let canvasWidth = 200;
  compDebugArrArr.forEach((a2) => {
    a2.forEach((x2) => {
      canvasHeight += x2.dims.height + 25;
      canvasWidth = Math.max(x2.dims.width * 3 + 30, canvasWidth);
    });
  });
  if (!canvas) {
    canvas = await ca.createCanvas(canvasWidth, canvasHeight);
  } else {
    canvas.height = canvasHeight;
    canvas.width = canvasWidth;
  }
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvasWidth, canvasHeight);
  const fontSize = 10;
  ctx.fillStyle = "black";
  ctx.font = `${fontSize}px NimbusSans`;
  for (const compDebugArr of compDebugArrArr) {
    for (const compDebugObj of compDebugArr) {
      let chosen = compDebugObj.errorRawB < compDebugObj.errorRawA;
      if (compDebugObj.errorAdjB && compDebugObj.errorAdjA) {
        chosen = compDebugObj.errorAdjB < compDebugObj.errorAdjA;
      }
      const colWidth = Math.max(compDebugObj.dims.width, 50);
      const rectX = 5 + colWidth + 10 + Number(chosen) * (colWidth + 10) - 3;
      const rectY = top - 3;
      const rectWidth = compDebugObj.dims.width + 6;
      const rectHeight = compDebugObj.dims.height + 6;
      ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
      if (context === "browser" && compDebugObj.context === "browser") {
        const topI = top;
        await [compDebugObj.imageRaw, compDebugObj.imageA, compDebugObj.imageB].forEach(async (image, i2) => {
          if (!image) return;
          const imgElem = document.createElement("img");
          await loadImageElem(image, imgElem);
          ctx.drawImage(imgElem, 5 + i2 * (colWidth + 10), topI);
        });
      } else if (context === "node" && compDebugObj.context === "node") {
        const imgElem0 = await ca.getImageBitmap(compDebugObj.imageRaw);
        const imgElem1 = await ca.getImageBitmap(compDebugObj.imageA);
        const imgElem2 = await ca.getImageBitmap(compDebugObj.imageB);
        ctx.drawImage(imgElem0, 5, top);
        ctx.drawImage(imgElem1, 5 + colWidth + 10, top);
        ctx.drawImage(imgElem2, 5 + 2 * (colWidth + 10), top);
      } else {
        throw new Error("Attempted to draw debug images in wrong context.");
      }
      if (compDebugObj.errorRawA || compDebugObj.errorAdjA) {
        let debugStr1 = "";
        if (compDebugObj.errorAdjA) debugStr1 += `${String(Math.round(compDebugObj.errorAdjA * 1e3) / 1e3)} `;
        if (compDebugObj.errorRawA) debugStr1 += `[${String(Math.round(compDebugObj.errorRawA * 1e3) / 1e3)}]`;
        ctx.fillText(debugStr1, 5 + colWidth + 10, top + compDebugObj.dims.height + fontSize + 3);
      }
      if (compDebugObj.errorRawB || compDebugObj.errorAdjB) {
        let debugStr2 = "";
        if (compDebugObj.errorRawB) debugStr2 += `${String(Math.round(compDebugObj.errorRawB * 1e3) / 1e3)} `;
        if (compDebugObj.errorAdjB) debugStr2 += `[${String(Math.round(compDebugObj.errorAdjB * 1e3) / 1e3)}]`;
        ctx.fillText(debugStr2, 5 + 2 * (colWidth + 10), top + compDebugObj.dims.height + fontSize + 3);
      }
      top += compDebugObj.dims.height + 25;
    }
  }
  return canvas;
}
async function renderPageStatic(page) {
  const image = await ImageCache.getNative(page.n, { rotated: opt.autoRotate, upscaled: false });
  const res = gs.renderPageStaticImp({
    page,
    image,
    angle: pageMetricsAll[page.n].angle
  });
  return res;
}

// node_modules/scribe.js-ocr/js/export/export.js
init_app();
init_dataContainer();

// node_modules/scribe.js-ocr/js/modifyOCR.js
init_ocrObjects();
init_miscUtils();
function combineOCRPage(pageA, pageB, pageMetricsObj, replaceFontSize = false, editWordIds = true) {
  const linesNew = pageA.lines;
  for (let i2 = 0; i2 < linesNew.length; i2++) {
    const lineNew = linesNew[i2];
    if (lineNew.words.length === 0) continue;
    const lineNewRot = ocrObjects_default.cloneLine(lineNew);
    if (pageMetricsObj.angle) ocrObjects_default.rotateLine(lineNewRot, pageMetricsObj.angle * -1, pageMetricsObj.dims);
    let lineI = -1;
    let match;
    let matchXOverlap = 0;
    let matchXDist = 1e6;
    let closestI = 0;
    let closestMetric = 1e6;
    let afterClosest = true;
    let yDistMin = 1e6;
    for (lineI = 0; lineI < pageB.lines.length; lineI++) {
      const line = pageB.lines[lineI];
      if (line.words.length === 0 || line.orientation !== 0) continue;
      const lineRot = ocrObjects_default.cloneLine(line);
      if (pageMetricsObj.angle) ocrObjects_default.rotateLine(lineRot, pageMetricsObj.angle * -1, pageMetricsObj.dims);
      const left = Math.max(lineRot.bbox.left, lineNewRot.bbox.left);
      const top = Math.max(lineRot.bbox.top, lineNewRot.bbox.top);
      const right = Math.min(lineRot.bbox.right, lineNewRot.bbox.right);
      const bottom = Math.min(lineRot.bbox.bottom, lineNewRot.bbox.bottom);
      const width = right - left;
      const height = bottom - top;
      const yOverlap = height < 0 ? 0 : height / (lineNewRot.bbox.bottom - lineNewRot.bbox.top);
      if (yOverlap >= 0.5) {
        const xOverlap = width < 0 ? 0 : width / (lineNewRot.bbox.right - lineNewRot.bbox.left);
        if (xOverlap > matchXOverlap) {
          matchXOverlap = xOverlap;
          match = line;
        } else if (xOverlap === 0 && matchXOverlap === 0) {
          const xDist = Math.min(Math.abs(lineRot.bbox.right - lineNewRot.bbox.left), Math.abs(lineRot.bbox.left - lineNewRot.bbox.right));
          if (xDist < matchXDist) {
            matchXDist = xDist;
            match = line;
          }
        }
      } else if (!match) {
        const xOverlap = width < 0 ? 0 : width / (lineNewRot.bbox.right - lineNewRot.bbox.left);
        const xDist = xOverlap > 0 ? 0 : Math.min(Math.abs(lineRot.bbox.right - lineNewRot.bbox.left), Math.abs(lineRot.bbox.left - lineNewRot.bbox.right));
        const yDist = yOverlap > 0 ? 0 : Math.min(Math.abs(lineRot.bbox.bottom - lineNewRot.bbox.top), Math.abs(lineRot.bbox.top - lineNewRot.bbox.bottom));
        if (yDist < yDistMin) yDistMin = yDist;
        const totalMetric = xDist + yDist * 3;
        if (totalMetric < closestMetric) {
          closestMetric = totalMetric;
          closestI = lineI;
          afterClosest = lineNewRot[3] > lineRot[3];
        }
      }
    }
    if (match && matchXOverlap === 0 && matchXDist > 2 * yDistMin && pageB.dims.width * 0.05 < matchXDist) match = void 0;
    if (match) {
      const { words } = match;
      for (let j2 = 0; j2 < lineNew.words.length; j2++) {
        const wordNew = lineNew.words[j2];
        wordNew.line = match;
        const wordBoxNew = wordNew.bbox;
        let word;
        let wordBox;
        let wordIndex;
        let k2 = 0;
        do {
          wordIndex = k2;
          word = words[k2];
          wordBox = word.bbox;
          k2 += 1;
        } while (wordBox.right < wordBoxNew.left && k2 < words.length);
        if (editWordIds) wordNew.id = word.id + getRandomAlphanum(3);
        if (wordBoxNew[0] > wordBox.left) {
          words.splice(wordIndex + 1, 0, wordNew);
        } else {
          words.splice(wordIndex, 0, wordNew);
        }
      }
      if (match.bbox.right - match.bbox.left < 300) {
        const pageAngleRad = pageB.angle * (Math.PI / 180);
        const pageSlope = Math.tan(pageAngleRad);
        match.baseline[0] = pageSlope;
      }
      ocrObjects_default.updateLineBbox(match);
    } else {
      for (let j2 = 0; j2 < lineNew.words.length; j2++) {
        const wordNew = lineNew.words[j2];
        if (editWordIds) wordNew.id += getRandomAlphanum(3);
      }
      if (replaceFontSize) {
        if (lineI === 0 || lineI + 1 === pageB.lines.length) {
          lineNew.ascHeight = lineNew.bbox.bottom - lineNew.bbox.top;
          lineNew.xHeight = null;
        } else {
          const closestLine = pageB.lines[closestI];
          lineNew.ascHeight = closestLine.ascHeight;
          lineNew.xHeight = closestLine.xHeight;
          const lineHeight = lineNew.bbox.bottom - lineNew.bbox.top;
          if (lineNew.ascHeight > lineHeight * 1.5) {
            lineNew.ascHeight = lineNew.bbox.bottom - lineNew.bbox.top;
            lineNew.xHeight = null;
          }
        }
      }
      lineNew.page = pageB;
      if (afterClosest) {
        pageB.lines.splice(lineI + 1, 0, lineNew);
      } else {
        pageB.lines.splice(lineI, 0, lineNew);
      }
    }
  }
}
function reorderOcrPage(page, layoutObj, applyExclude = true, editInPlace = false) {
  const pageInt = editInPlace ? page : structuredClone(page);
  if (!layoutObj?.boxes || Object.keys(layoutObj?.boxes).length === 0) return pageInt;
  const hocrALines = pageInt.lines;
  const linesNew = [];
  const orderArr = Array(hocrALines.length);
  orderArr.fill(100);
  for (let i2 = 0; i2 < hocrALines.length; i2++) {
    const hocrALine = hocrALines[i2];
    const lineBoxA = hocrALine.bbox;
    for (const [id, obj] of Object.entries(layoutObj.boxes)) {
      const overlap = calcBoxOverlap(lineBoxA, obj.coords);
      if (overlap > 0.5) {
        if (obj.type === "order") {
          orderArr[i2] = obj.order;
        } else if (obj.type === "exclude" && applyExclude) {
          orderArr[i2] = 101;
        }
      }
    }
  }
  for (let i2 = 0; i2 <= 100; i2++) {
    for (let j2 = 0; j2 < orderArr.length; j2++) {
      if (orderArr[j2] === i2) {
        linesNew.push(hocrALines[j2]);
      }
    }
  }
  pageInt.lines = linesNew;
  return pageInt;
}

// node_modules/scribe.js-ocr/js/export/export.js
init_miscUtils();

// node_modules/scribe.js-ocr/fonts/encoding.js
var win1252Chars = [
  " ",
  "!",
  '"',
  "#",
  "$",
  "%",
  "&",
  "'",
  "(",
  ")",
  "*",
  "+",
  ",",
  "-",
  ".",
  "/",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  ":",
  ";",
  "<",
  "=",
  ">",
  "?",
  "@",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "[",
  "",
  "]",
  "^",
  "_",
  "`",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "{",
  "|",
  "}",
  "~",
  "",
  "\u20AC",
  "",
  "\u201A",
  "\u0192",
  "\u201E",
  "\u2026",
  "\u2020",
  "\u2021",
  "\u02C6",
  "\u2030",
  "\u0160",
  "\u2039",
  "\u0152",
  "",
  "\u017D",
  "",
  "",
  "\u2018",
  "\u2019",
  "\u201C",
  "\u201D",
  "\u2022",
  "\u2013",
  "\u2014",
  "\u02DC",
  "\u2122",
  "\u0161",
  "\u203A",
  "\u0153",
  "",
  "\u017E",
  "\u0178",
  "",
  "\xA1",
  "\xA2",
  "\xA3",
  "\xA4",
  "\xA5",
  "\xA6",
  "\xA7",
  "\xA8",
  "\xA9",
  "\xAA",
  "\xAB",
  "\xAC",
  "",
  "\xAE",
  "\xAF",
  "\xB0",
  "\xB1",
  "\xB2",
  "\xB3",
  "\xB4",
  "\xB5",
  "\xB6",
  "\xB7",
  "\xB8",
  "\xB9",
  "\xBA",
  "\xBB",
  "\xBC",
  "\xBD",
  "\xBE",
  "\xBF",
  "\xC0",
  "\xC1",
  "\xC2",
  "\xC3",
  "\xC4",
  "\xC5",
  "\xC6",
  "\xC7",
  "\xC8",
  "\xC9",
  "\xCA",
  "\xCB",
  "\xCC",
  "\xCD",
  "\xCE",
  "\xCF",
  "\xD0",
  "\xD1",
  "\xD2",
  "\xD3",
  "\xD4",
  "\xD5",
  "\xD6",
  "\xD7",
  "\xD8",
  "\xD9",
  "\xDA",
  "\xDB",
  "\xDC",
  "\xDD",
  "\xDE",
  "\xDF",
  "\xE0",
  "\xE1",
  "\xE2",
  "\xE3",
  "\xE4",
  "\xE5",
  "\xE6",
  "\xE7",
  "\xE8",
  "\xE9",
  "\xEA",
  "\xEB",
  "\xEC",
  "\xED",
  "\xEE",
  "\xEF",
  "\xF0",
  "\xF1",
  "\xF2",
  "\xF3",
  "\xF4",
  "\xF5",
  "\xF6",
  "\xF7",
  "\xF8",
  "\xF9",
  "\xFA",
  "\xFB",
  "\xFC",
  "\xFD",
  "\xFE",
  "\xFF"
];
var encodingASCII = {
  "A": "A",
  "B": "B",
  "C": "C",
  "D": "D",
  "E": "E",
  "F": "F",
  "G": "G",
  "H": "H",
  "I": "I",
  "J": "J",
  "K": "K",
  "L": "L",
  "M": "M",
  "N": "N",
  "O": "O",
  "P": "P",
  "Q": "Q",
  "R": "R",
  "S": "S",
  "T": "T",
  "U": "U",
  "V": "V",
  "W": "W",
  "X": "X",
  "Y": "Y",
  "Z": "Z",
  "a": "a",
  "&": "&",
  "^": "^",
  "~": "~",
  "*": "*",
  "@": "@",
  "b": "b",
  "\\": "\\\\",
  "|": "|",
  "{": "{",
  "}": "}",
  "[": "[",
  "]": "]",
  "c": "c",
  ":": ":",
  ",": ",",
  "d": "d",
  "$": "$",
  "e": "e",
  "8": "8",
  "=": "=",
  "!": "!",
  "f": "f",
  "5": "5",
  "4": "4",
  "g": "g",
  "`": "`",
  ">": ">",
  "h": "h",
  "-": "-",
  "i": "i",
  "j": "j",
  "k": "k",
  "l": "l",
  "<": "<",
  "m": "m",
  "n": "n",
  "9": "9",
  "#": "#",
  "o": "o",
  "1": "1",
  "p": "p",
  "(": "\\(",
  ")": "\\)",
  "%": "%",
  ".": ".",
  "+": "+",
  "q": "q",
  "?": "?",
  '"': '"',
  "'": "'",
  "r": "r",
  "s": "s",
  ";": ";",
  "7": "7",
  "6": "6",
  "/": "/",
  " ": " ",
  "t": "t",
  "3": "3",
  "2": "2",
  "u": "u",
  "_": "_",
  "v": "v",
  "w": "w",
  "x": "x",
  "y": "y",
  "z": "z",
  "0": "0"
};
var encodingNonASCII = {
  "\xC6": "\\306",
  "\xC1": "\\301",
  "\xC2": "\\302",
  "\xC4": "\\304",
  "\xC0": "\\300",
  "\xC5": "\\305",
  "\xC3": "\\303",
  "\xC7": "\\307",
  "\xC9": "\\311",
  "\xCA": "\\312",
  "\xCB": "\\313",
  "\xC8": "\\310",
  "\xD0": "\\320",
  "\u20AC": "\\200",
  "\xCD": "\\315",
  "\xCE": "\\316",
  "\xCF": "\\317",
  "\xCC": "\\314",
  "\xD1": "\\321",
  "\u0152": "\\214",
  "\xD3": "\\323",
  "\xD4": "\\324",
  "\xD6": "\\326",
  "\xD2": "\\322",
  "\xD8": "\\330",
  "\xD5": "\\325",
  "\u0160": "\\212",
  "\xDE": "\\336",
  "\xDA": "\\332",
  "\xDB": "\\333",
  "\xDC": "\\334",
  "\xD9": "\\331",
  "\xDD": "\\335",
  "\u0178": "\\237",
  "\u017D": "\\216",
  "\xE1": "\\341",
  "\xE2": "\\342",
  "\xB4": "\\264",
  "\xE4": "\\344",
  "\xE6": "\\346",
  "\xE0": "\\340",
  "\xE5": "\\345",
  "\xE3": "\\343",
  "\xA6": "\\246",
  "\u2022": "\\225",
  "\xE7": "\\347",
  "\xB8": "\\270",
  "\xA2": "\\242",
  "\u02C6": "\\210",
  "\xA9": "\\251",
  "\xA4": "\\244",
  "\u2020": "\\206",
  "\u2021": "\\207",
  "\xB0": "\\260",
  "\xA8": "\\250",
  "\xF7": "\\367",
  "\xE9": "\\351",
  "\xEA": "\\352",
  "\xEB": "\\353",
  "\xE8": "\\350",
  "\u2026": "\\205",
  "\u2014": "\\227",
  "\u2013": "\\226",
  "\xF0": "\\360",
  "\xA1": "\\241",
  "\u0192": "\\203",
  "\xDF": "\\337",
  "\xAB": "\\253",
  "\xBB": "\\273",
  "\u2039": "\\213",
  "\u203A": "\\233",
  "\xED": "\\355",
  "\xEE": "\\356",
  "\xEF": "\\357",
  "\xEC": "\\354",
  "\xAC": "\\254",
  "\xAF": "\\257",
  "\u03BC": "\\265",
  "\xD7": "\\327",
  "\xF1": "\\361",
  "\xF3": "\\363",
  "\xF4": "\\364",
  "\xF6": "\\366",
  "\u0153": "\\234",
  "\xF2": "\\362",
  "\xBD": "\\275",
  "\xBC": "\\274",
  "\xB9": "\\271",
  "\xAA": "\\252",
  "\xBA": "\\272",
  "\xF8": "\\370",
  "\xF5": "\\365",
  "\xB6": "\\266",
  "\xB7": "\\267",
  "\u2030": "\\211",
  "\xB1": "\\261",
  "\xBF": "\\277",
  "\u201E": "\\204",
  "\u201C": "\\223",
  "\u201D": "\\224",
  "\u2018": "\\221",
  "\u2019": "\\222",
  "\u201A": "\\202",
  "\xAE": "\\256",
  "\u0161": "\\232",
  "\xA7": "\\247",
  "\xA3": "\\243",
  "\xFE": "\\376",
  "\xBE": "\\276",
  "\xB3": "\\263",
  "\u02DC": "\\230",
  "\u2122": "\\231",
  "\xB2": "\\262",
  "\xFA": "\\372",
  "\xFB": "\\373",
  "\xFC": "\\374",
  "\xF9": "\\371",
  "\xFD": "\\375",
  "\xFF": "\\377",
  "\xA5": "\\245",
  "\u017E": "\\236",
  "(": "\\(",
  ")": "\\)",
  "\\": "\\\\"
};
var winEncodingLookup2 = {
  ...encodingASCII,
  ...encodingNonASCII
};

// node_modules/scribe.js-ocr/js/export/pdf/writePdfFonts.js
init_miscUtils();
var byteToHex = [];
for (let n2 = 0; n2 <= 255; ++n2) {
  const hexOctet = n2.toString(16).padStart(2, "0");
  byteToHex.push(hexOctet);
}
function hex(arrayBuffer) {
  const buff = new Uint8Array(arrayBuffer);
  let hexOctets = "";
  for (let i2 = 0; i2 < buff.length; ++i2) {
    if (i2 % 32 === 0 && i2 !== 0) hexOctets += "\n";
    hexOctets += byteToHex[buff[i2]];
  }
  return hexOctets;
}
function createToUnicode(font) {
  let cmapStr = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo
<< /Registry (Adobe)
   /Ordering (UCS)
   /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000> <FFFF>
endcodespacerange
`;
  const entries = [];
  for (let i2 = 0; i2 < font.glyphs.length; i2++) {
    const glyph = font.glyphs.glyphs[String(i2)];
    if (glyph.unicode !== void 0) {
      const srcHex = i2.toString(16).padStart(4, "0");
      const unicodeHex = glyph.unicode.toString(16).padStart(4, "0");
      entries.push(`<${srcHex}> <${unicodeHex}>`);
    }
  }
  const chunkSize = 100;
  for (let i2 = 0; i2 < entries.length; i2 += chunkSize) {
    const chunk = entries.slice(i2, i2 + chunkSize);
    cmapStr += `${chunk.length} beginbfchar
`;
    cmapStr += chunk.join("\n");
    cmapStr += "\nendbfchar\n";
  }
  cmapStr += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  return cmapStr;
}
var generateFontFlags = (serif, italic, smallcap, symbolic) => {
  let flags = 0;
  if (serif) flags |= 1 << 1;
  if (italic) flags |= 1 << 6;
  if (smallcap) flags |= 1 << 17;
  if (symbolic) {
    flags |= 1 << 2;
  } else {
    flags |= 1 << 5;
  }
  return flags;
};
function createFontDescriptor(font, objIndex, italic, embeddedObjIndex = null) {
  let objOut = `${String(objIndex)} 0 obj
<</Type/FontDescriptor`;
  const namesTable = font.names.windows || font.names;
  objOut += `/FontName/${namesTable.postScriptName.en}`;
  const headTable = font.tables.head;
  if (headTable) {
    objOut += `/FontBBox[${[font.tables.head.xMin, font.tables.head.yMin, font.tables.head.xMax, font.tables.head.yMax].join(" ")}]`;
  } else {
    objOut += "/FontBBox[0, 0, 0, 0]";
  }
  const postTable = font.tables.post;
  if (postTable) {
    objOut += `/ItalicAngle ${String(postTable.italicAngle)}`;
  } else {
    objOut += "/ItalicAngle 0";
  }
  objOut += `/Ascent ${String(font.ascender)}`;
  objOut += `/Descent ${String(font.descender)}`;
  objOut += `/StemV ${String(Math.round(0.08 * font.unitsPerEm))}`;
  const serif = determineSansSerif(namesTable.postScriptName.en) !== "SansDefault";
  objOut += `/Flags ${String(generateFontFlags(serif, italic, false, false))}`;
  if (embeddedObjIndex === null || embeddedObjIndex === void 0) {
    objOut += ">>\nendobj\n\n";
    return objOut;
  }
  objOut += `/FontFile3 ${String(embeddedObjIndex)} 0 R`;
  objOut += ">>\nendobj\n\n";
  return objOut;
}
function createEmbeddedFontType1(font, firstObjIndex, italic = false, isStandardFont = false) {
  let fontDictObjStr = `${String(firstObjIndex)} 0 obj
<</Type/Font/Subtype/Type1`;
  fontDictObjStr += `
/BaseFont/${font.tables.name.postScriptName.en}`;
  fontDictObjStr += "/Encoding/WinAnsiEncoding";
  fontDictObjStr += "/Widths[";
  for (let i2 = 0; i2 < win1252Chars.length; i2++) {
    const advance = font.charToGlyph(win1252Chars[i2]).advanceWidth || font.unitsPerEm;
    const advanceNorm = Math.round(advance * (1e3 / font.unitsPerEm));
    fontDictObjStr += `${String(advanceNorm)} `;
  }
  fontDictObjStr += "]/FirstChar 32/LastChar 255";
  fontDictObjStr += `/FontDescriptor ${String(firstObjIndex + 1)} 0 R>>
endobj

`;
  const fontDescObjStr = createFontDescriptor(font, firstObjIndex + 1, italic, isStandardFont ? null : firstObjIndex + 2);
  const fontBuffer = font.toArrayBuffer();
  const fontHexStr = hex(fontBuffer);
  let fontFileObjStr = `${String(firstObjIndex + 2)} 0 obj
<</Length1 ${String(fontBuffer.byteLength)}/Subtype/OpenType/Length ${String(fontHexStr.length)}/Filter/ASCIIHexDecode>>
stream
`;
  fontFileObjStr += `${fontHexStr}
endstream
endobj

`;
  return [fontDictObjStr, fontDescObjStr, fontFileObjStr];
}
function createEmbeddedFontType0({
  font,
  firstObjIndex,
  italic = false
}) {
  let fontDictObjStr = `${String(firstObjIndex)} 0 obj
<</Type/Font/Subtype/Type0`;
  const namesTable = font.names.windows || font.names;
  fontDictObjStr += `/BaseFont/${namesTable.postScriptName.en}`;
  fontDictObjStr += "/Encoding/Identity-H";
  fontDictObjStr += `/ToUnicode ${String(firstObjIndex + 5)} 0 R`;
  fontDictObjStr += `/DescendantFonts[${String(firstObjIndex + 4)} 0 R]`;
  fontDictObjStr += ">>\nendobj\n\n";
  const toUnicodeStr0 = createToUnicode(font);
  let toUnicodeStr = `${String(firstObjIndex + 5)} 0 obj
`;
  toUnicodeStr += `<</Length ${toUnicodeStr0.length}>>
stream
`;
  toUnicodeStr += toUnicodeStr0;
  toUnicodeStr += "\nendstream\nendobj\n\n";
  const fontDescObjStr = createFontDescriptor(font, firstObjIndex + 1, italic, firstObjIndex + 3);
  let widthsObjStr = `${String(firstObjIndex + 2)} 0 obj
`;
  widthsObjStr += "[ 0 [";
  for (let i2 = 0; i2 < font.glyphs.length; i2++) {
    const advanceNorm = Math.round(font.glyphs.glyphs[String(i2)].advanceWidth * (1e3 / font.unitsPerEm));
    widthsObjStr += `${String(advanceNorm)} `;
  }
  widthsObjStr += "] ]";
  widthsObjStr += "\nendobj\n\n";
  const fontBuffer = font.toArrayBuffer();
  const fontHexStr = hex(fontBuffer);
  let fontFileObjStr = `${String(firstObjIndex + 3)} 0 obj
<</Length1 ${String(fontBuffer.byteLength)}/Subtype/OpenType/Length ${String(fontHexStr.length)}/Filter/ASCIIHexDecode>>
stream
`;
  fontFileObjStr += `${fontHexStr}
endstream
endobj

`;
  let fontObjStr = `${String(firstObjIndex + 4)} 0 obj
`;
  fontObjStr += "<</Type/Font/Subtype/CIDFontType2/CIDSystemInfo<</Registry(Adobe)/Ordering(Identity)/Supplement 0>>";
  fontObjStr += `/BaseFont/${namesTable.postScriptName.en}/FontDescriptor ${String(firstObjIndex + 1)} 0 R`;
  fontObjStr += `/W ${String(firstObjIndex + 2)} 0 R`;
  fontObjStr += ">>\nendobj\n\n";
  return [fontDictObjStr, fontDescObjStr, widthsObjStr, fontFileObjStr, fontObjStr, toUnicodeStr];
}

// node_modules/scribe.js-ocr/js/export/pdf/writePdfImages.js
var formatNum = (x2) => String(Math.round(x2 * 1e6) / 1e6);
function extractPngIdatData(pngBytes) {
  const signature = [137, 80, 78, 71, 13, 10, 26, 10];
  for (let i2 = 0; i2 < 8; i2++) {
    if (pngBytes[i2] !== signature[i2]) {
      throw new Error("Invalid PNG file signature");
    }
  }
  let offset = 8;
  const idatChunks = [];
  while (offset < pngBytes.length) {
    const length = pngBytes[offset] << 24 | pngBytes[offset + 1] << 16 | pngBytes[offset + 2] << 8 | pngBytes[offset + 3];
    offset += 4;
    const type = String.fromCharCode(
      pngBytes[offset],
      pngBytes[offset + 1],
      pngBytes[offset + 2],
      pngBytes[offset + 3]
    );
    offset += 4;
    if (type === "IDAT") {
      idatChunks.push(pngBytes.subarray(offset, offset + length));
    } else if (type === "IEND") {
      break;
    }
    offset += length + 4;
  }
  if (idatChunks.length === 0) {
    throw new Error("No IDAT chunks found in PNG file");
  }
  const totalLength = idatChunks.reduce((acc, chunk) => acc + chunk.length, 0);
  const concatenated = new Uint8Array(totalLength);
  let currentOffset = 0;
  for (const chunk of idatChunks) {
    concatenated.set(chunk, currentOffset);
    currentOffset += chunk.length;
  }
  return concatenated;
}
var createImageXObjectJpeg = (objIndex, imageData, width, height) => {
  const imageBytes = new Uint8Array(imageData);
  let objStr = `${String(objIndex)} 0 obj
`;
  objStr += "<</Type /XObject\n";
  objStr += "/Subtype /Image\n";
  const imageHexStr = hex(imageBytes.buffer);
  objStr += `/Width ${String(width)}
`;
  objStr += `/Height ${String(height)}
`;
  objStr += "/ColorSpace /DeviceRGB\n";
  objStr += "/BitsPerComponent 8\n";
  objStr += "/Filter [ /ASCIIHexDecode /DCTDecode ]\n";
  objStr += `/Length ${String(imageHexStr.length)}
`;
  objStr += ">>\nstream\n";
  objStr += `${imageHexStr}
`;
  objStr += "endstream\nendobj\n\n";
  return objStr;
};
function createDeviceNRGBA(colorSpaceObjIndex) {
  const tintFuncObjIndex = colorSpaceObjIndex + 1;
  const tintTransformFunction = "{ pop }";
  const colorSpaceObj = `${colorSpaceObjIndex} 0 obj
[
  /DeviceN
  [ /Red /Green /Blue /Alpha ]
  /DeviceRGB
  ${tintFuncObjIndex} 0 R
]
endobj
`;
  const tintFuncObj = `${tintFuncObjIndex} 0 obj
<<
  /FunctionType 4
  /Domain [ 0 1 0 1 0 1 0 1 ]
  /Range [ 0 1 0 1 0 1 ]
  /Length ${tintTransformFunction.length}
>>
stream
${tintTransformFunction}
endstream
endobj
`;
  return [colorSpaceObj, tintFuncObj];
}
var createImageXObjectPng = (objIndex, imageData, objDevN) => {
  const imageBytes = new Uint8Array(imageData);
  let objStr = `${String(objIndex)} 0 obj
`;
  objStr += "<</Type /XObject\n";
  objStr += "/Subtype /Image\n";
  const imageDataOutput = extractPngIdatData(imageBytes);
  const imageHexStr = hex(imageDataOutput.buffer);
  const idhr = getPngIHDRInfo(imageBytes);
  const predictor = 15;
  let colors = 3;
  let colorSpace = "/DeviceRGB";
  if (idhr.colorType === 0) {
    colors = 1;
    colorSpace = "/DeviceGray";
  } else if (idhr.colorType === 2) {
    colors = 3;
    colorSpace = "/DeviceRGB";
  } else if (idhr.colorType === 4) {
    colors = 2;
    colorSpace = "/DeviceGray";
  } else if (idhr.colorType === 6) {
    colors = 4;
    if (!objDevN) {
      console.warn("PNG has alpha channel but no DeviceN color space provided. PNG will not be rendered correctly.");
    } else {
      colorSpace = `${objDevN} 0 R`;
    }
  } else {
    console.warn(`Unsupported PNG color type: ${idhr.colorType}, defaulting to RGB`);
  }
  objStr += "/DecodeParms [ null <<";
  objStr += `/Predictor ${predictor} `;
  objStr += `/Colors ${colors} `;
  objStr += `/Columns ${String(idhr.width)} `;
  objStr += " >> ]\n";
  objStr += `/Width ${String(idhr.width)}
`;
  objStr += `/Height ${String(idhr.height)}
`;
  objStr += `/ColorSpace ${colorSpace}
`;
  objStr += `/BitsPerComponent ${idhr.bitDepth}
`;
  objStr += "/Filter [ /ASCIIHexDecode /FlateDecode ]\n";
  objStr += `/Length ${String(imageHexStr.length)}
`;
  objStr += ">>\nstream\n";
  objStr += `${imageHexStr}
`;
  objStr += "endstream\nendobj\n\n";
  return objStr;
};
function createEmbeddedImages(images, firstObjIndex, objDevN) {
  const imageObjArr = [];
  images.forEach((image, index) => {
    const objIndex = firstObjIndex + index;
    const dims = imageUtils.getDims(image);
    const imageBytes = base64ToBytes(image.src);
    let objParts;
    if (image.format === "jpeg") {
      objParts = createImageXObjectJpeg(objIndex, imageBytes.buffer, dims.width, dims.height);
    } else {
      objParts = createImageXObjectPng(objIndex, imageBytes.buffer, objDevN);
    }
    imageObjArr.push(objParts);
  });
  return imageObjArr;
}
function createImageResourceDict(imageObjIndices) {
  if (imageObjIndices.length === 0) return "";
  let resourceStr = "/XObject<<";
  imageObjIndices.forEach((objIndex, i2) => {
    resourceStr += `/Im${String(i2)} ${String(objIndex)} 0 R
`;
  });
  resourceStr += ">>";
  return resourceStr;
}
function drawImageCommands(imageName, x2, y2, width, height, rotation = 0) {
  const angle = rotation * Math.PI / 180;
  const centerX = x2 + width / 2;
  const centerY = y2 + height / 2;
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const a2 = width * cos;
  const b2 = width * sin;
  const c2 = -height * sin;
  const d2 = height * cos;
  const e3 = centerX - (width * cos - height * sin) / 2;
  const f2 = centerY - (width * sin + height * cos) / 2;
  return `q
${formatNum(a2)} ${formatNum(b2)} ${formatNum(c2)} ${formatNum(d2)} ${formatNum(e3)} ${formatNum(f2)} cm
/${imageName} Do
Q
`;
}

// node_modules/scribe.js-ocr/js/export/pdf/writePdf.js
init_app();

// node_modules/scribe.js-ocr/js/export/pdf/writePdfText.js
init_ocrObjects();

// node_modules/scribe.js-ocr/js/utils/fontUtils.js
init_ocrObjects();
init_miscUtils();
init_app();
var getDistinctCharsFont = (ocrPageArr, family, style) => {
  const charsAll = {};
  for (const ocrPage of ocrPageArr) {
    for (const ocrLine of ocrPage.lines) {
      for (const ocrWord of ocrLine.words) {
        if (family || style) {
          const wordFont = FontCont.getWordFont(ocrWord);
          if (!wordFont) continue;
          if (family && wordFont.family !== family) continue;
          if (style && wordFont.style !== style && wordFont.style !== "normal") continue;
        }
        ocrWord.text.split("").forEach((x2) => {
          charsAll[x2] = true;
        });
      }
    }
  }
  return Object.keys(charsAll);
};
async function subsetFont(font, charArr = []) {
  const glyphs = [];
  glyphs.push(font.glyphs.get(0));
  if (!charArr.includes(" ")) glyphs.push(font.charToGlyph(" "));
  charArr.forEach((x2) => {
    const glyph = font.charToGlyph(x2);
    if (glyph) glyphs.push(glyph);
  });
  const namesTable = font.names.windows || font.names;
  const subset = new An.Font({
    familyName: namesTable.postScriptName.en,
    styleName: namesTable.fontSubfamily.en,
    unitsPerEm: font.unitsPerEm,
    ascender: font.ascender,
    descender: font.descender,
    glyphs
  });
  return subset;
}
function getFontSize(fontOpentype, heightActual, text) {
  const textArr = text.split("");
  const charMetricsFirst = fontOpentype.charToGlyph(textArr[0]).getMetrics();
  let yMin = charMetricsFirst.yMin;
  let yMax = charMetricsFirst.yMax;
  for (let i2 = 1; i2 < textArr.length; i2++) {
    const charMetrics = fontOpentype.charToGlyph(textArr[i2]).getMetrics();
    if (charMetrics.yMin < yMin) yMin = charMetrics.yMin;
    if (charMetrics.yMax > yMax) yMax = charMetrics.yMax;
  }
  const textHeight = (yMax - yMin) * (1 / fontOpentype.unitsPerEm);
  return Math.round(heightActual / textHeight);
}
function calcWordFontSizePrecise(wordArr, fontOpentype, nonLatin = false) {
  if (wordArr[0].chars && wordArr[0].chars.length > 0) {
    const charArr = wordArr.map((x2) => x2.chars).flat();
    const charArrFiltered = nonLatin ? charArr.filter((x2) => x2 && x2.bbox.bottom - x2.bbox.top > 5) : charArr.filter((x2) => x2 && /[A-Za-z0-9]/.test(x2.text));
    const fontSizeCharArr = charArrFiltered.map((x2) => getFontSize(fontOpentype, x2.bbox.bottom - x2.bbox.top, x2.text));
    const fontSizeCharMedian = quantile(fontSizeCharArr, 0.5);
    return fontSizeCharMedian;
  }
  const wordArrFiltered = nonLatin ? wordArr.filter((x2) => x2 && x2.bbox.bottom - x2.bbox.top > 5) : wordArr.filter((x2) => x2 && /[A-Za-z0-9]/.test(x2.text));
  const fontSizeWordArr = wordArrFiltered.map((x2) => getFontSize(fontOpentype, x2.bbox.bottom - x2.bbox.top, x2.text));
  const fontSizeWordMedian = quantile(fontSizeWordArr, 0.5);
  return fontSizeWordMedian;
}
function addLigatures(word) {
  if (word.style.smallCaps || !opt.ligatures) return word.text.split("");
  const fontI = FontCont.getWordFont(word);
  const fontOpentype = fontI.opentype;
  return addLigaturesText(word.text, fontOpentype);
}
function addLigaturesText(wordText, fontOpentype) {
  const wordTextArr = typeof wordText === "string" ? wordText.split("") : wordText;
  const wordCharArrOut = [];
  for (let i2 = 0; i2 < wordTextArr.length; i2++) {
    const charI = wordTextArr[i2];
    const charJ = wordTextArr[i2 + 1];
    if (charI === "f" && charJ) {
      let charLig;
      if (charJ === "f") {
        charLig = String.fromCharCode(64256);
      } else if (charJ === "i") {
        charLig = String.fromCharCode(64257);
      } else if (charJ === "l") {
        charLig = String.fromCharCode(64258);
      }
      if (charLig) {
        const glyphLig = fontOpentype.charToGlyph(charLig);
        if (glyphLig && glyphLig.index > 0 && glyphLig.name !== ".notdef" && glyphLig.path.commands.length > 0) {
          wordCharArrOut.push(charLig);
          i2++;
          continue;
        }
      }
    }
    wordCharArrOut.push(charI);
  }
  return wordCharArrOut;
}
var missingGlyphs = {};
function calcWordCharMetrics(wordText, fontOpentype) {
  const wordTextArr = typeof wordText === "string" ? wordText.split("") : wordText;
  const advanceArr = [];
  const kerningArr = [];
  for (let i2 = 0; i2 < wordTextArr.length; i2++) {
    const charI = wordTextArr[i2];
    const charJ = wordTextArr[i2 + 1];
    const glyphI = fontOpentype.charToGlyph(charI);
    const fontName = fontOpentype.tables.name.postScriptName.en;
    if (!glyphI || glyphI.name === ".notdef") {
      if (!missingGlyphs[fontName]) missingGlyphs[fontName] = /* @__PURE__ */ new Set();
      missingGlyphs[fontName].add(charI);
      console.log(`Character ${charI} is not defined in font ${fontName}`);
    }
    advanceArr.push(glyphI.advanceWidth);
    if (charJ) {
      if (opt.kerning) {
        const glyphJ = fontOpentype.charToGlyph(charJ);
        const kerning = fontOpentype.getKerningValue(glyphI, glyphJ);
        kerningArr.push(kerning);
      } else {
        kerningArr.push(0);
      }
    }
  }
  return { advanceArr, kerningArr };
}
function calcWordMetrics(word, angle = 0) {
  const fontI = FontCont.getWordFont(word);
  const fontOpentype = fontI.opentype;
  const fontSize = calcWordFontSize(word);
  const charArr = addLigatures(word);
  const charArr2 = word.style.smallCaps ? charArr.map((x2) => x2.toUpperCase()) : charArr;
  const { advanceArr, kerningArr } = calcWordCharMetrics(charArr2, fontOpentype);
  if (word.style.smallCaps) {
    for (let i2 = 0; i2 < charArr2.length; i2++) {
      if (charArr2[i2] !== charArr[i2]) {
        advanceArr[i2] *= fontI.smallCapsMult;
        if (kerningArr[i2]) kerningArr[i2] *= fontI.smallCapsMult;
      }
    }
  }
  const advanceTotal = advanceArr.reduce((a2, b2) => a2 + b2, 0);
  const kerningTotal = kerningArr.reduce((a2, b2) => a2 + b2, 0);
  const wordWidth1 = advanceTotal + kerningTotal;
  const wordLastGlyphMetrics = fontOpentype.charToGlyph(charArr2.at(-1)).getMetrics();
  const wordFirstGlyphMetrics = fontOpentype.charToGlyph(charArr2[0]).getMetrics();
  let wordLeftBearing = wordFirstGlyphMetrics.xMin || 0;
  let lastGlyphMax = wordLastGlyphMetrics.xMax || 0;
  if (word.style.smallCaps && charArr2[charArr2.length - 1] !== charArr[charArr2.length - 1]) lastGlyphMax *= fontI.smallCapsMult;
  let wordRightBearing = advanceArr[advanceArr.length - 1] - lastGlyphMax;
  if (word.style.smallCaps && charArr2[0] !== charArr[0]) wordLeftBearing *= fontI.smallCapsMult;
  if (word.style.smallCaps && charArr2[charArr2.length - 1] !== charArr[charArr2.length - 1]) wordRightBearing *= fontI.smallCapsMult;
  const wordWidth = word.visualCoords ? wordWidth1 - wordRightBearing - wordLeftBearing : wordWidth1;
  const wordWidthPx = wordWidth * (fontSize / fontOpentype.unitsPerEm);
  const wordLeftBearingPx = wordLeftBearing * (fontSize / fontOpentype.unitsPerEm);
  const wordRightBearingPx = wordRightBearing * (fontSize / fontOpentype.unitsPerEm);
  const advanceArrPx = advanceArr.map((x2) => x2 * (fontSize / fontOpentype.unitsPerEm));
  const kerningArrPx = kerningArr.map((x2) => x2 * (fontSize / fontOpentype.unitsPerEm));
  let charSpacing = 0;
  if (charArr2.length > 1) {
    const cosAngle = Math.cos(angle * (Math.PI / 180));
    const actualWidth = (word.bbox.right - word.bbox.left) / cosAngle;
    charSpacing = Math.round((actualWidth - wordWidthPx) / (charArr2.length - 1) * 1e6) / 1e6;
  }
  return {
    visualWidth: wordWidthPx,
    leftSideBearing: wordLeftBearingPx,
    rightSideBearing: wordRightBearingPx,
    advanceArr: advanceArrPx,
    kerningArr: kerningArrPx,
    charSpacing,
    font: fontI,
    fontSize,
    charArr
  };
}
var calcWordFontSize = (word) => {
  const font = FontCont.getWordFont(word);
  const fontOpentype = font.opentype;
  if (word.style.sup || word.style.dropcap) {
    if (word.visualCoords) {
      return getFontSize(fontOpentype, word.bbox.bottom - word.bbox.top, word.text);
    }
    if (word.style.size) {
      const mult = FontProps.sizeMult[font.family] || 1;
      return word.style.size / mult;
    }
    return (word.bbox.bottom - word.bbox.top) * (fontOpentype.unitsPerEm / (fontOpentype.ascender - fontOpentype.descender));
  }
  if (word.style.size) {
    const mult = FontProps.sizeMult[font.family] || 1;
    return word.style.size / mult;
  }
  const lineFontSize = calcLineFontSize(word.line);
  if (lineFontSize) return lineFontSize;
  return 12;
};
var calcLineFontSize = (line) => {
  if (line._size) return line._size;
  const nonLatin = line.words[0]?.lang === "chi_sim";
  const font = FontCont.getWordFont(line.words[0]);
  if (!font) {
    const linePrev = getPrevLine(line);
    if (linePrev) {
      line._sizeCalc = calcLineFontSize(linePrev);
    } else {
      line._sizeCalc = 15;
    }
    return line._sizeCalc;
  }
  const fontOpentype = font.opentype;
  if (line.words.length <= 3 && line.words[0].chars && line.words[0].chars.length > 0 || nonLatin) {
    const fontSizeCalc = calcWordFontSizePrecise(line.words, fontOpentype, nonLatin);
    if (fontSizeCalc && fontSizeCalc > 0) {
      line._sizeCalc = fontSizeCalc;
      return line._sizeCalc;
    }
  }
  if (line.ascHeight && line.xHeight) {
    const size1 = getFontSize(fontOpentype, line.ascHeight, "A");
    const size2 = getFontSize(fontOpentype, line.xHeight, "o");
    let sizeFinal = Math.floor((size1 + size2) / 2);
    if (Math.max(size1, size2) / Math.min(size1, size2) > 1.2) {
      const linePrev = getPrevLine(line);
      if (linePrev) {
        const sizeLast = calcLineFontSize(linePrev);
        if (sizeLast && (Math.max(size1, sizeLast) / Math.min(size1, sizeLast) <= 1.2 || Math.max(sizeLast, size2) / Math.min(sizeLast, size2) <= 1.2)) {
          if (Math.abs(sizeLast - size2) < Math.abs(sizeLast - size1)) {
            sizeFinal = Math.floor((sizeLast + size2) / 2);
          } else {
            sizeFinal = Math.floor((sizeLast + size1) / 2);
          }
        }
      }
    }
    line._sizeCalc = sizeFinal;
  } else if (!line.ascHeight && line.xHeight) {
    line._sizeCalc = getFontSize(fontOpentype, line.xHeight, "o");
  } else if (line.ascHeight && !line.xHeight) {
    line._sizeCalc = getFontSize(fontOpentype, line.ascHeight, "A");
  } else {
    const linePrev = getPrevLine(line);
    if (linePrev) {
      line._sizeCalc = calcLineFontSize(linePrev);
    } else {
      line._sizeCalc = 15;
    }
  }
  return line._sizeCalc;
};

// node_modules/scribe.js-ocr/js/export/pdf/writePdfText.js
init_miscUtils();
var formatNum2 = (x2) => String(Math.round(x2 * 1e6) / 1e6);
async function ocrPageToPDFStream(pageObj, outputDims, pdfFonts, textMode, angle, rotateText = false, rotateBackground = false, confThreshHigh = 85, confThreshMed = 75) {
  if (!pageObj || pageObj.lines.length === 0) {
    return { textContentObjStr: "", pdfFontsUsed: /* @__PURE__ */ new Set() };
  }
  const cosAnglePage = Math.cos(angle * (Math.PI / 180));
  const pdfFontsUsed = /* @__PURE__ */ new Set();
  const underlines = (
    /** @type {Array<{left: number, right: number, top: number, height: number, fontSize: number, bold: boolean}>} */
    []
  );
  let textContentObjStr = "";
  if (textMode === "invis") {
    textContentObjStr += "/GSO0 gs\n";
  } else if (["proof", "eval"].includes(textMode)) {
    textContentObjStr += "/GSO1 gs\n";
  }
  textContentObjStr += "BT\n";
  textContentObjStr += `1 0 0 1 0 ${String(outputDims.height)} Tm
`;
  let pdfFontNameCurrent = "";
  let pdfFontTypeCurrent = 0;
  for (let i2 = 0; i2 < pageObj.lines.length; i2++) {
    const lineObj = pageObj.lines[i2];
    const { words } = lineObj;
    if (words.length === 0) continue;
    let wordJ = words[0];
    let fillColor = "0 0 0 rg";
    if (textMode === "proof") {
      if (wordJ.conf > confThreshHigh) {
        fillColor = "0 1 0.5 rg";
      } else if (wordJ.conf > confThreshMed) {
        fillColor = "1 0.8 0 rg";
      } else {
        fillColor = "1 0 0 rg";
      }
    }
    const angleAdjLine = rotateBackground && Math.abs(angle ?? 0) > 0.05 ? ocrObjects_default.calcLineStartAngleAdj(lineObj) : { x: 0, y: 0 };
    let fillColorCurrent = fillColor;
    textContentObjStr += `${fillColor}
`;
    let wordFont = FontCont.getWordFont(wordJ);
    const word0Metrics = calcWordMetrics(wordJ, angle);
    let wordFontSize = word0Metrics.fontSize;
    const pdfFontCurrent = wordJ.lang === "chi_sim" ? pdfFonts.NotoSansSC.normal : pdfFonts[wordFont.family][getStyleLookup(wordJ.style)];
    pdfFontNameCurrent = pdfFontCurrent.name;
    pdfFontTypeCurrent = pdfFontCurrent.type;
    pdfFontsUsed.add(pdfFontCurrent);
    textContentObjStr += `${pdfFontNameCurrent} ${String(wordFontSize)} Tf
`;
    textContentObjStr += "0 Ts\n";
    const word0LeftBearing = wordJ.visualCoords ? word0Metrics.leftSideBearing : 0;
    let tz = 100;
    if (wordJ.style.dropcap) {
      const wordWidthActual = wordJ.bbox.right - wordJ.bbox.left;
      tz = wordWidthActual / word0Metrics.visualWidth * 100;
    }
    const lineLeftAdj = wordJ.bbox.left - word0LeftBearing * (tz / 100) + angleAdjLine.x;
    const lineTopAdj = lineObj.bbox.bottom + lineObj.baseline[1] + angleAdjLine.y;
    const lineAngleDeg = Number(rotateText) * angle + 90 * lineObj.orientation;
    const sinAngleTm = Math.sin(lineAngleDeg * (Math.PI / 180));
    const cosAngleTm = Math.cos(lineAngleDeg * (Math.PI / 180));
    if (lineObj.orientation === 1) {
      textContentObjStr += `${formatNum2(cosAngleTm)} ${formatNum2(-sinAngleTm)} ${formatNum2(sinAngleTm)} ${formatNum2(cosAngleTm)} ${formatNum2(outputDims.width - lineTopAdj + 1)} ${formatNum2(outputDims.height - lineLeftAdj)} Tm
`;
    } else if (lineObj.orientation === 2) {
      textContentObjStr += `${formatNum2(cosAngleTm)} ${formatNum2(-sinAngleTm)} ${formatNum2(sinAngleTm)} ${formatNum2(cosAngleTm)} ${formatNum2(outputDims.width - lineLeftAdj + 1)} ${formatNum2(lineTopAdj)} Tm
`;
    } else if (lineObj.orientation === 3) {
      textContentObjStr += `${formatNum2(cosAngleTm)} ${formatNum2(-sinAngleTm)} ${formatNum2(sinAngleTm)} ${formatNum2(cosAngleTm)} ${formatNum2(lineTopAdj)} ${formatNum2(lineLeftAdj)} Tm
`;
    } else {
      textContentObjStr += `${formatNum2(cosAngleTm)} ${formatNum2(-sinAngleTm)} ${formatNum2(sinAngleTm)} ${formatNum2(cosAngleTm)} ${formatNum2(lineLeftAdj)} ${formatNum2(outputDims.height - lineTopAdj + 1)} Tm
`;
    }
    textContentObjStr += "[ ";
    let wordBoxLast = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    let wordRightBearingLast = 0;
    let charSpacingLast = 0;
    let spacingAdj = 0;
    let kernSpacing = false;
    let wordLast = wordJ;
    let underlineLeft = (
      /** @type {?number} */
      null
    );
    let underlineRight = (
      /** @type {?number} */
      null
    );
    let wordFontOpentypeLast = wordFont.opentype;
    let fontSizeLast = wordFontSize;
    let tsCurrent = 0;
    let tzCurrent = 100;
    let charLig = false;
    for (let j2 = 0; j2 < words.length; j2++) {
      wordJ = words[j2];
      const wordMetrics = calcWordMetrics(wordJ, angle);
      wordFontSize = wordMetrics.fontSize;
      const charSpacing = wordMetrics.charSpacing;
      const charArr = wordMetrics.charArr;
      const wordLeftBearing = wordJ.visualCoords ? wordMetrics.leftSideBearing : 0;
      const kerningArr = wordMetrics.kerningArr;
      wordFont = FontCont.getWordFont(wordJ);
      fillColor = "0 0 0 rg";
      if (textMode === "proof") {
        const wordConf = wordJ.conf;
        if (wordConf > confThreshHigh) {
          fillColor = "0 1 0.5 rg";
        } else if (wordConf > confThreshMed) {
          fillColor = "1 0.8 0 rg";
        } else {
          fillColor = "1 0 0 rg";
        }
      } else if (textMode === "eval") {
        fillColor = wordJ.matchTruth ? "0 1 0.5 rg" : "1 0 0 rg";
      }
      const angleAdjWord = wordJ.style.sup ? ocrObjects_default.calcWordAngleAdj(wordJ) : { x: 0, y: 0 };
      const angleAdjWordX = rotateBackground && Math.abs(angle ?? 0) > 0.05 ? angleAdjWord.x : 0;
      let ts = 0;
      if (wordJ.style.sup || wordJ.style.dropcap) {
        ts = lineObj.bbox.bottom + lineObj.baseline[1] + angleAdjLine.y - (wordJ.bbox.bottom + angleAdjLine.y + angleAdjWord.y);
        if (!wordJ.visualCoords) {
          const fontDesc = wordFont.opentype.descender / wordFont.opentype.unitsPerEm * wordMetrics.fontSize;
          ts -= fontDesc;
        }
      } else {
        ts = 0;
      }
      tz = 100;
      if (wordJ.style.dropcap) {
        const wordWidthActual = wordJ.bbox.right - wordJ.bbox.left;
        tz = wordWidthActual / wordMetrics.visualWidth * 100;
      }
      const pdfFont = wordJ.lang === "chi_sim" ? pdfFonts.NotoSansSC.normal : pdfFonts[wordFont.family][getStyleLookup(wordJ.style)];
      const pdfFontName = pdfFont.name;
      const pdfFontType = pdfFont.type;
      pdfFontsUsed.add(pdfFont);
      const wordWidthAdj = (wordJ.bbox.right - wordJ.bbox.left) / cosAnglePage;
      const wordSpaceAdj = (wordJ.bbox.left - wordBoxLast.right) / cosAnglePage;
      if (j2 > 0 && !kernSpacing) {
        const spaceAdvance = wordFontOpentypeLast.charToGlyph(" ").advanceWidth || wordFontOpentypeLast.unitsPerEm / 2;
        const spaceWidthGlyph = spaceAdvance * (fontSizeLast / wordFontOpentypeLast.unitsPerEm);
        const wordSpaceExpectedPx = spaceWidthGlyph + charSpacingLast * 2 + wordRightBearingLast + wordLeftBearing;
        const wordSpaceExtraPx = (wordSpaceAdj - wordSpaceExpectedPx + spacingAdj + angleAdjWordX) * (100 / tzCurrent);
        if (pdfFontTypeCurrent === 0) {
          const spaceChar = wordFont.opentype.charToGlyphIndex(" ").toString(16).padStart(4, "0");
          textContentObjStr += `<${spaceChar}> ${String(Math.round(wordSpaceExtraPx * (-1e3 / fontSizeLast) * 1e6) / 1e6)}`;
        } else {
          textContentObjStr += `( ) ${String(Math.round(wordSpaceExtraPx * (-1e3 / fontSizeLast) * 1e6) / 1e6)}`;
        }
      }
      kernSpacing = false;
      wordBoxLast = wordJ.bbox;
      if (charArr.length === 1 && !wordJ.style.dropcap) {
        const wordLastGlyph = wordFont.opentype.charToGlyph(charArr.at(-1));
        const wordLastGlyphMetrics = wordLastGlyph.getMetrics();
        const lastCharAdvance = wordLast.visualCoords ? wordLastGlyphMetrics.xMax - wordLastGlyphMetrics.xMin : wordLastGlyph.advanceWidth || wordFont.opentype.unitsPerEm / 2;
        const lastCharWidth = lastCharAdvance * (wordFontSize / wordFont.opentype.unitsPerEm);
        spacingAdj = wordWidthAdj - lastCharWidth - angleAdjWordX;
      } else {
        spacingAdj = 0 - angleAdjWordX;
      }
      textContentObjStr += " ] TJ\n";
      const fontSize = wordJ.style.smallCaps && wordJ.text[0] && wordJ.text[0] !== wordJ.text[0].toUpperCase() ? wordFontSize * wordFont.smallCapsMult : wordFontSize;
      if (pdfFontName !== pdfFontNameCurrent || fontSize !== fontSizeLast) {
        textContentObjStr += `${pdfFontName} ${String(fontSize)} Tf
`;
        pdfFontNameCurrent = pdfFontName;
        pdfFontTypeCurrent = pdfFontType;
        fontSizeLast = fontSize;
      }
      if (fillColor !== fillColorCurrent) {
        textContentObjStr += `${fillColor}
`;
        fillColorCurrent = fillColor;
      }
      if (ts !== tsCurrent) {
        textContentObjStr += `${String(ts)} Ts
`;
        tsCurrent = ts;
      }
      if (tz !== tzCurrent) {
        textContentObjStr += `${String(tz)} Tz
`;
        tzCurrent = tz;
      }
      textContentObjStr += `${String(Math.round(charSpacing * 1e6) / 1e6)} Tc
`;
      textContentObjStr += "[ ";
      for (let k2 = 0; k2 < charArr.length; k2++) {
        const letterSrc = charArr[k2];
        const letter = wordJ.style.smallCaps ? charArr[k2].toUpperCase() : charArr[k2];
        const fontSizeLetter = wordJ.style.smallCaps && letterSrc !== letter ? wordFontSize * wordFont.smallCapsMult : wordFontSize;
        const letterEnc = pdfFontTypeCurrent === 0 ? pdfFont.opentype.charToGlyphIndex(letter)?.toString(16).padStart(4, "0") : winEncodingLookup[letter];
        if (letterEnc) {
          let kern = (kerningArr[k2] || 0) * (-1e3 / fontSizeLetter);
          if (wordJ.lang === "chi_sim" && j2 + 1 < words.length && words[j2 + 1].lang === "chi_sim") {
            kernSpacing = true;
            const wordNext = words[j2 + 1];
            const wordSpaceNextAdj = (wordNext.bbox.left - wordJ.bbox.right) / cosAngleTm;
            const wordGlyph = wordFont.opentype.charToGlyph(charArr.at(-1));
            const wordGlyphMetrics = wordGlyph.getMetrics();
            const wordNextGlyphMetrics = wordFont.opentype.charToGlyph(wordNext.text.substr(0, 1)).getMetrics();
            const wordRightBearing = wordJ.visualCoords ? (wordGlyph.advanceWidth - wordGlyphMetrics.xMax) * (wordFontSize / wordFont.opentype.unitsPerEm) : 0;
            const wordNextLeftBearing = wordNext.visualCoords ? wordNextGlyphMetrics.xMin * (wordFontSize / wordFont.opentype.unitsPerEm) : 0;
            const wordSpaceExpected = charSpacing + wordRightBearing + wordNextLeftBearing;
            kern = Math.round((wordSpaceNextAdj - wordSpaceExpected + spacingAdj + angleAdjWordX) * (-1e3 / wordFontSize));
          }
          const charAdvance = wordFont.opentype.charToGlyph(letter).advanceWidth;
          const charWidthPdfPrecise = charAdvance * (1e3 / wordFont.opentype.unitsPerEm);
          const charWidthPdfRound = Math.floor(charWidthPdfPrecise);
          const charWidthError = charWidthPdfRound - charWidthPdfPrecise;
          const charAdj = kern + charWidthError;
          if (pdfFontName !== pdfFontNameCurrent || fontSizeLetter !== fontSizeLast) {
            textContentObjStr += " ] TJ\n";
            textContentObjStr += `${pdfFontName} ${String(fontSizeLetter)} Tf
`;
            fontSizeLast = fontSizeLetter;
            textContentObjStr += `${String(Math.round(charSpacing * 1e6) / 1e6)} Tc
`;
            textContentObjStr += "[ ";
          }
          if (pdfFontTypeCurrent === 0) {
            textContentObjStr += `<${letterEnc}> ${String(Math.round(charAdj * 1e6) / 1e6)} `;
          } else {
            textContentObjStr += `(${letterEnc}) ${String(Math.round(kern * 1e6) / 1e6)} `;
          }
          if (charLig) {
            k2++;
            charLig = false;
          }
        } else {
          const kern = (wordFont.opentype.charToGlyph(letter).advanceWidth - wordFont.opentype.charToGlyph(" ").advanceWidth) * (-1e3 / wordFont.opentype.unitsPerEm) || 0;
          if (pdfFontTypeCurrent === 0) {
            const spaceChar = wordFont.opentype.charToGlyphIndex(" ").toString(16).padStart(4, "0");
            textContentObjStr += `<${spaceChar}> ${String(Math.round(kern * 1e6) / 1e6)} `;
          } else {
            textContentObjStr += `( ) ${String(Math.round(kern * 1e6) / 1e6)} `;
          }
        }
      }
      if (wordJ.style.underline && underlineLeft === null) {
        underlineLeft = wordJ.bbox.left;
      }
      if (wordJ.style.underline) {
        underlineRight = wordJ.bbox.right;
      }
      if (underlineLeft !== null && (!wordJ.style.underline || j2 === words.length - 1)) {
        underlines.push({
          left: underlineLeft,
          right: underlineRight,
          top: lineTopAdj,
          height: lineObj.bbox.bottom - lineObj.bbox.top,
          fontSize: wordFontSize,
          bold: wordJ.style.bold
        });
        underlineLeft = null;
        underlineRight = null;
      }
      wordLast = wordJ;
      wordRightBearingLast = wordLast.visualCoords ? wordMetrics.rightSideBearing : 0;
      wordFontOpentypeLast = wordFont.opentype;
      charSpacingLast = charSpacing;
    }
    textContentObjStr += " ] TJ\n";
  }
  textContentObjStr += "ET";
  underlines.forEach((underline) => {
    const underlineThickness = underline.bold ? Math.ceil(underline.fontSize / 12) : Math.ceil(underline.fontSize / 24);
    const underlineOffset = Math.ceil(underline.fontSize / 12) + underlineThickness;
    textContentObjStr += `
${String(underline.left)} ${String(outputDims.height - underline.top - underlineOffset)} ${String(underline.right - underline.left)} ${underlineThickness} re
f
`;
  });
  return { textContentObjStr, pdfFontsUsed };
}

// node_modules/scribe.js-ocr/js/export/pdf/writePdf.js
var createPdfFontRefs = async (objectIStart, ocrArr) => {
  if (!FontCont.raw) throw new Error("No fonts loaded.");
  let objectI = objectIStart;
  let fontI = 0;
  const pdfFonts = {};
  const pdfFontRefs = [];
  const pdfFontObjStrArr = [];
  const addFontFamilyRef = async (familyKey, familyObj) => {
    pdfFonts[familyKey] = {};
    for (const [key, value] of Object.entries(familyObj)) {
      const isStandardFont = false;
      if (isStandardFont) {
        pdfFonts[familyKey][key] = {
          type: 1,
          index: fontI,
          name: `/FO${String(fontI)}`,
          objN: objectI,
          opentype: value.opentype
        };
        pdfFontRefs.push({ familyKey, key });
        pdfFontObjStrArr.push(null);
        objectI += 3;
      } else {
        pdfFonts[familyKey][key] = {
          type: 0,
          index: fontI,
          name: `/FO${String(fontI)}`,
          objN: objectI,
          opentype: value.opentype
        };
        pdfFontRefs.push({ familyKey, key });
        pdfFontObjStrArr.push(null);
        objectI += 6;
      }
      fontI++;
    }
  };
  for (const familyKeyI of Object.keys(FontCont.raw)) {
    const useOpt = FontCont.useOptFamily(familyKeyI);
    const familyObjI = {
      normal: useOpt && FontCont.opt?.[familyKeyI]?.normal ? FontCont.opt[familyKeyI].normal : FontCont.raw[familyKeyI].normal,
      italic: useOpt && FontCont.opt?.[familyKeyI]?.italic ? FontCont.opt[familyKeyI].italic : FontCont.raw[familyKeyI].italic,
      bold: useOpt && FontCont.opt?.[familyKeyI]?.bold ? FontCont.opt[familyKeyI].bold : FontCont.raw[familyKeyI].bold,
      boldItalic: useOpt && FontCont.opt?.[familyKeyI]?.boldItalic ? FontCont.opt[familyKeyI].boldItalic : FontCont.raw[familyKeyI].boldItalic
    };
    await addFontFamilyRef(familyKeyI, familyObjI);
  }
  if (FontCont.doc) {
    for (const familyKeyI of Object.keys(FontCont.doc)) {
      await addFontFamilyRef(familyKeyI, FontCont.doc[familyKeyI]);
    }
  }
  if (FontCont.supp.chi_sim && ocrArr) {
    const charArr = getDistinctCharsFont(ocrArr, FontCont.supp.chi_sim.family);
    if (charArr.length > 0) {
      const fontExport = await subsetFont(FontCont.supp.chi_sim.opentype, charArr);
      pdfFonts.NotoSansSC = {};
      pdfFonts.NotoSansSC.normal = {
        type: 0,
        index: fontI,
        name: `/FO${String(fontI)}`,
        objN: objectI,
        opentype: fontExport
      };
      pdfFontRefs.push({ familyKey: "NotoSansSC", key: "normal" });
      pdfFontObjStrArr.push(null);
      objectI += 6;
      fontI++;
    }
  } else if (FontCont.supp.chi_sim) {
    console.warn("Chinese font loaded but no OCR data available to determine if it is needed. Font will not be included in PDF.");
  }
  return {
    pdfFonts,
    pdfFontRefs,
    pdfFontObjStrArr,
    objectI
  };
};
async function writePdf({
  pageMetricsArr,
  ocrArr = null,
  minpage = 0,
  maxpage = -1,
  textMode = "ebook",
  rotateText = false,
  rotateBackground = false,
  rotateOrientation = false,
  dimsLimit = { width: -1, height: -1 },
  confThreshHigh = 85,
  confThreshMed = 75,
  proofOpacity = 0.8,
  images = null,
  includeImages = false
}) {
  if (!FontCont.raw) throw new Error("No fonts loaded.");
  if (maxpage === -1) {
    maxpage = pageMetricsArr.length - 1;
  }
  if (maxpage < 0) throw new Error("PDF with negative page count requested.");
  let objectI = 3;
  let pdfFonts = {};
  let pdfFontRefs = [];
  let pdfFontObjStrArr = [];
  if (ocrArr && ocrArr.length > 0) {
    const fontRefs = await createPdfFontRefs(objectI, ocrArr);
    pdfFonts = fontRefs.pdfFonts;
    pdfFontRefs = fontRefs.pdfFontRefs;
    pdfFontObjStrArr = fontRefs.pdfFontObjStrArr;
    objectI = fontRefs.objectI;
  }
  const pdfFontsUsed = /* @__PURE__ */ new Set();
  const pdfImageObjStrArr = [];
  const imageObjIndices = [];
  if (includeImages && images && images.length > 0) {
    const objectIDeviceN = objectI;
    const colorDevObjects = await createDeviceNRGBA(objectI);
    for (let i2 = 0; i2 < colorDevObjects.length; i2++) {
      pdfImageObjStrArr.push(colorDevObjects[i2]);
      objectI++;
    }
    const imageObjects = createEmbeddedImages(images, objectI, objectIDeviceN);
    for (let i2 = 0; i2 < imageObjects.length; i2++) {
      pdfImageObjStrArr.push(imageObjects[i2]);
      imageObjIndices.push(objectI + i2);
    }
    objectI += imageObjects.length;
  }
  const pdfPageObjStrArr = [];
  const pageIndexArr = [];
  for (let i2 = minpage; i2 <= maxpage; i2++) {
    const angle = pageMetricsArr[i2].angle || 0;
    const { dims } = pageMetricsArr[i2];
    const imageName = includeImages && images && images.length > 0 ? `Im${String(i2 % images.length)}` : null;
    const { pdfObj, pdfFontsUsed: pdfFontsUsedI } = await ocrPageToPDF({
      pageObj: ocrArr?.[i2],
      inputDims: dims,
      outputDims: dimsLimit,
      firstObjIndex: objectI,
      parentIndex: 2,
      proofOpacity,
      pdfFonts,
      textMode,
      angle,
      rotateOrientation,
      rotateText,
      rotateBackground,
      confThreshHigh,
      confThreshMed,
      imageObjIndices,
      imageName
    });
    for (const font of pdfFontsUsedI) {
      pdfFontsUsed.add(font);
    }
    for (let j2 = 0; j2 < pdfObj.length; j2++) {
      pdfPageObjStrArr.push(pdfObj[j2]);
    }
    pageIndexArr.push(objectI);
    objectI += pdfObj.length;
    opt.progressHandler({ n: i2, type: "export", info: {} });
  }
  for (const pdfFont of pdfFontsUsed) {
    if (pdfFont.opentype?.names?.postScriptName?.en === "NotoSansSC-Regular") continue;
    const isStandardFont = false;
    if (isStandardFont) {
      pdfFontObjStrArr[pdfFont.index] = createEmbeddedFontType1(pdfFont.opentype, pdfFont.objN);
    } else {
      pdfFontObjStrArr[pdfFont.index] = createEmbeddedFontType0({ font: pdfFont.opentype, firstObjIndex: pdfFont.objN });
    }
  }
  const pdfObjStrArr = [];
  let pdfOut = "%PDF-1.7\n%\xB5\xB6n\n";
  pdfObjStrArr.push("1 0 obj\n<</Type /Catalog\n/Pages 2 0 R>>\nendobj\n\n");
  let pagesObjStr = "2 0 obj\n<</Type /Pages\n/Kids [";
  for (let i2 = 0; i2 < maxpage - minpage + 1; i2++) {
    pagesObjStr += `${String(pageIndexArr[i2])} 0 R
`;
  }
  pagesObjStr += `]
/Count ${String(maxpage - minpage + 1)}>>
endobj

`;
  pdfObjStrArr.push(pagesObjStr);
  const xrefArr = [];
  for (let i2 = 0; i2 < pdfObjStrArr.length; i2++) {
    xrefArr.push({ type: "obj", offset: pdfOut.length + 2 });
    pdfOut += pdfObjStrArr[i2];
  }
  for (let i2 = 0; i2 < pdfFontRefs.length; i2++) {
    if (pdfFontObjStrArr[i2]) {
      for (let j2 = 0; j2 < pdfFontObjStrArr[i2].length; j2++) {
        xrefArr.push({ type: "obj", offset: pdfOut.length + 2 });
        pdfOut += pdfFontObjStrArr[i2][j2];
      }
    } else {
      xrefArr.push({ type: "free", offset: 0 });
      xrefArr.push({ type: "free", offset: 0 });
      xrefArr.push({ type: "free", offset: 0 });
      xrefArr.push({ type: "free", offset: 0 });
      xrefArr.push({ type: "free", offset: 0 });
      xrefArr.push({ type: "free", offset: 0 });
    }
  }
  for (let i2 = 0; i2 < pdfImageObjStrArr.length; i2++) {
    xrefArr.push({ type: "obj", offset: pdfOut.length + 2 });
    pdfOut += pdfImageObjStrArr[i2];
  }
  for (let i2 = 0; i2 < pdfPageObjStrArr.length; i2++) {
    xrefArr.push({ type: "obj", offset: pdfOut.length + 2 });
    pdfOut += pdfPageObjStrArr[i2];
  }
  const objCount = pdfObjStrArr.length + pdfFontRefs.length * 6 + pdfImageObjStrArr.length + pdfPageObjStrArr.length + 1;
  const xrefOffset = pdfOut.length + 2;
  let xrefStr = `xref
0 ${objCount}
`;
  xrefStr += "0000000000 65535 f\n";
  for (let i2 = 0; i2 < xrefArr.length; i2++) {
    if (xrefArr[i2].type === "obj") {
      xrefStr += `${String(xrefArr[i2].offset).padStart(10, "0")} 00000 n
`;
    } else {
      xrefStr += "0000000000 65535 f\n";
    }
  }
  xrefStr += `trailer
  <<  /Root 1 0 R
      /Size ${objCount}
  >>
startxref
${xrefOffset}
%%EOF`;
  pdfOut += xrefStr;
  return pdfOut;
}
async function ocrPageToPDF({
  pageObj,
  inputDims,
  outputDims,
  firstObjIndex,
  parentIndex,
  proofOpacity,
  pdfFonts,
  textMode,
  angle,
  rotateOrientation = false,
  rotateText = false,
  rotateBackground = false,
  confThreshHigh = 85,
  confThreshMed = 75,
  imageObjIndices = [],
  imageName = null
}) {
  if (outputDims.width < 1) {
    outputDims = inputDims;
  }
  const noTextContent = !pageObj || pageObj.lines.length === 0;
  const noImageContent = !imageName || !imageObjIndices || imageObjIndices.length === 0;
  const pageIndex = firstObjIndex;
  let pageObjStr = `${String(pageIndex)} 0 obj
<</Type/Page/MediaBox[0 0 ${String(outputDims.width)} ${String(outputDims.height)}]`;
  if (rotateOrientation && (angle > 45 && angle < 135 || angle > 225 && angle < 315)) {
    pageObjStr = `${String(pageIndex)} 0 obj
<</Type/Page/MediaBox[0 0 ${String(outputDims.height)} ${String(outputDims.width)}]`;
  }
  pageObjStr += `/Parent ${parentIndex} 0 R`;
  if (noTextContent && noImageContent) {
    pageObjStr += "/Resources<<>>";
    pageObjStr += ">>\nendobj\n\n";
    return { pdfObj: [pageObjStr], pdfFontsUsed: (
      /** @type {Set<PdfFontInfo>} */
      /* @__PURE__ */ new Set()
    ) };
  }
  let resourceDictObjStr = `${String(firstObjIndex + 1)} 0 obj
<<`;
  pageObjStr += `/Contents ${String(firstObjIndex + 2)} 0 R`;
  pageObjStr += `/Resources ${String(firstObjIndex + 1)} 0 R`;
  pageObjStr += ">>\nendobj\n\n";
  let imageResourceStr = "";
  let imageContentObjStr = "";
  if (imageName && imageObjIndices.length > 0) {
    imageResourceStr = createImageResourceDict(imageObjIndices);
    let rotation = 0;
    if (rotateBackground && Math.abs(angle ?? 0) > 0.05) {
      rotation = angle;
    }
    let x2 = 0;
    let y2 = 0;
    if (rotateOrientation && (rotation > 45 && rotation < 135 || rotation > 225 && rotation < 315)) {
      x2 = (outputDims.height - outputDims.width) / 2;
      y2 = (outputDims.width - outputDims.height) / 2;
    }
    imageContentObjStr += drawImageCommands(imageName, x2, y2, outputDims.width, outputDims.height, rotation);
  }
  if (noTextContent) {
    resourceDictObjStr += imageResourceStr;
    resourceDictObjStr += ">>\nendobj\n\n";
    const pageContentObjStr2 = `${String(firstObjIndex + 2)} 0 obj
<</Length ${String(imageContentObjStr.length)} >>
stream
${imageContentObjStr}
endstream
endobj

`;
    return { pdfObj: [pageObjStr, resourceDictObjStr, pageContentObjStr2], pdfFontsUsed: (
      /** @type {Set<PdfFontInfo>} */
      /* @__PURE__ */ new Set()
    ) };
  }
  const { textContentObjStr, pdfFontsUsed } = await ocrPageToPDFStream(
    pageObj,
    outputDims,
    pdfFonts,
    textMode,
    angle,
    rotateText,
    rotateBackground,
    confThreshHigh,
    confThreshMed
  );
  let pdfFontsStr = "";
  for (const font of pdfFontsUsed) {
    pdfFontsStr += `${String(font.name)} ${String(font.objN)} 0 R
`;
  }
  resourceDictObjStr += `/Font<<${pdfFontsStr}>>`;
  resourceDictObjStr += imageResourceStr;
  resourceDictObjStr += "/ExtGState<<";
  resourceDictObjStr += "/GSO0 <</ca 0.0>>";
  resourceDictObjStr += `/GSO1 <</ca ${proofOpacity}>>`;
  resourceDictObjStr += ">>";
  resourceDictObjStr += ">>\nendobj\n\n";
  const pageContentObjStr = `${String(firstObjIndex + 2)} 0 obj
<</Length ${String(imageContentObjStr.length + textContentObjStr.length)} >>
stream
${imageContentObjStr}${textContentObjStr}
endstream
endobj

`;
  return {
    pdfObj: [pageObjStr, resourceDictObjStr, pageContentObjStr],
    pdfFontsUsed
  };
}

// node_modules/scribe.js-ocr/js/export/writeHocr.js
init_app();
init_dataContainer();
init_ocrObjects();
init_miscUtils();
function writeHocr({ ocrData, minValue, maxValue }) {
  if (minValue === null || minValue === void 0) minValue = 0;
  if (maxValue === null || maxValue === void 0 || maxValue < 0) maxValue = ocrData.length - 1;
  const meta = {
    "font-metrics": FontCont.state.charMetrics,
    "default-font": FontCont.state.defaultFontName,
    "sans-font": FontCont.state.sansDefaultName,
    "serif-font": FontCont.state.serifDefaultName,
    "enable-opt": opt.enableOpt,
    layout: layoutRegions.pages,
    "layout-data-table": layoutDataTables.serialize()
  };
  let hocrOut = String.raw`<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">`;
  hocrOut += "<head>";
  hocrOut += "\n	<title></title>";
  for (const [key, value] of Object.entries(meta)) {
    const valueStr = typeof value === "object" ? JSON.stringify(value) : value;
    hocrOut += `
	<meta name='${key}' content='${valueStr}'></meta>`;
  }
  hocrOut += '\n	<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>';
  hocrOut += "\n	<meta name='ocr-system' content='scribeocr' />";
  hocrOut += "\n	<meta name='ocr-capabilities' content='ocr_page ocr_carea ocr_par ocr_line ocrx_word ocrp_wconf ocrp_lang ocrp_dir ocrp_font ocrp_fsize'/>";
  hocrOut += "\n</head>";
  hocrOut += "\n<body>";
  for (let i2 = minValue; i2 <= maxValue; i2++) {
    const pageObj = ocrData[i2];
    if (!pageObj) {
      hocrOut += `
	<div class='ocr_page' title='bbox 0 0 ${pageMetricsAll[i2].dims.width} ${pageMetricsAll[i2].dims.height}'>`;
      hocrOut += "\n	</div>";
      continue;
    }
    hocrOut += `
	<div class='ocr_page' title='bbox 0 0 ${pageObj.dims.width} ${pageObj.dims.height}'>`;
    for (const lineObj of pageObj.lines) {
      hocrOut += `
		<span class='ocr_line' title="bbox ${lineObj.bbox.left} ${lineObj.bbox.top} ${lineObj.bbox.right} ${lineObj.bbox.bottom}`;
      hocrOut += `; baseline ${round6(lineObj.baseline[0])} ${Math.round(lineObj.baseline[1])}`;
      if (lineObj.xHeight) hocrOut += `; x_x_height ${lineObj.xHeight}`;
      if (lineObj.ascHeight) hocrOut += `; x_asc_height ${lineObj.ascHeight}`;
      hocrOut += '">';
      for (const wordObj of lineObj.words) {
        hocrOut += `
			<span class='ocrx_word' id='${wordObj.id}' title='`;
        hocrOut += `bbox ${Math.round(wordObj.bbox.left)} ${Math.round(wordObj.bbox.top)} ${Math.round(wordObj.bbox.right)} ${Math.round(wordObj.bbox.bottom)}`;
        hocrOut += `;x_wconf ${wordObj.conf}`;
        if (wordObj.style.font && wordObj.style.font !== "Default") {
          hocrOut += `;x_font ${wordObj.style.font}`;
        }
        if (wordObj.style.size) {
          hocrOut += `;x_fsize ${wordObj.style.size}`;
        }
        hocrOut += "'";
        if (wordObj.lang) hocrOut += ` lang='${wordObj.lang}'`;
        if (wordObj.style.bold || wordObj.style.italic || wordObj.style.smallCaps || wordObj.style.font && wordObj.style.font !== "Default") {
          hocrOut += " style='";
          if (wordObj.style.italic) {
            hocrOut += "font-style:italic;";
          }
          if (wordObj.style.bold) {
            hocrOut += "font-weight:bold;";
          }
          if (wordObj.style.smallCaps) {
            hocrOut += "font-variant:small-caps;";
          }
          if (wordObj.style.font && wordObj.style.font !== "Default") {
            hocrOut += `font-family:${wordObj.style.font}`;
          }
          hocrOut += "'>";
        } else {
          hocrOut += ">";
        }
        if (wordObj.style.sup) {
          hocrOut += `<sup>${ocrObjects_default.escapeXml(wordObj.text)}</sup>`;
        } else if (wordObj.style.dropcap) {
          hocrOut += `<span class='ocr_dropcap'>${ocrObjects_default.escapeXml(wordObj.text)}</span>`;
        } else {
          hocrOut += ocrObjects_default.escapeXml(wordObj.text);
        }
        hocrOut += "</span>";
      }
      hocrOut += "\n		</span>";
    }
    hocrOut += "\n	</div>";
    opt.progressHandler({ n: i2, type: "export", info: {} });
  }
  hocrOut += "\n</body>\n</html>";
  return hocrOut;
}

// node_modules/scribe.js-ocr/js/export/writeText.js
init_app();
init_dataContainer();
init_reflowPars();
function writeText({
  ocrCurrent,
  minpage = 0,
  maxpage = -1,
  reflowText = false,
  wordIds = null
}) {
  let textStr = "";
  if (maxpage === -1) maxpage = ocrCurrent.length - 1;
  let newLine = false;
  for (let g2 = minpage; g2 <= maxpage; g2++) {
    if (!ocrCurrent[g2] || ocrCurrent[g2].lines.length === 0) continue;
    const pageObj = ocrCurrent[g2];
    if (reflowText && (!pageObj.textSource || !["textract", "abbyy"].includes(pageObj.textSource))) {
      const angle = pageMetricsAll[g2].angle || 0;
      assignParagraphs(pageObj, angle);
    }
    let parCurrent = pageObj.lines[0].par;
    for (let h2 = 0; h2 < pageObj.lines.length; h2++) {
      const lineObj = pageObj.lines[h2];
      if (reflowText) {
        if (g2 > 0 && h2 === 0 || lineObj.par !== parCurrent) newLine = true;
        parCurrent = lineObj.par;
      } else {
        newLine = true;
      }
      for (let i2 = 0; i2 < lineObj.words.length; i2++) {
        const wordObj = lineObj.words[i2];
        if (!wordObj) continue;
        if (wordIds && !wordIds.includes(wordObj.id)) continue;
        if (newLine) {
          textStr = `${textStr}
`;
        } else if (h2 > 0 || g2 > 0 || i2 > 0) {
          textStr = `${textStr} `;
        }
        newLine = false;
        textStr += wordObj.text;
      }
    }
    opt.progressHandler({ n: g2, type: "export", info: {} });
  }
  return textStr;
}

// node_modules/scribe.js-ocr/js/export/writeHtml.js
init_app();
init_reflowPars();
init_dataContainer();
init_ocrObjects();
var formatNum3 = (num) => num.toFixed(5).replace(/\.?0+$/, "");
var calcFontMetrics = (fontI, fontSize) => {
  const os2 = fontI.opentype.tables.os2;
  const unitsPerEm = fontI.opentype.unitsPerEm;
  if (os2.fsSelection >> 7 & 1) {
    return {
      fontBoundingBoxAscent: Math.round(os2.sTypoAscender * (fontSize / unitsPerEm)),
      fontBoundingBoxDescent: Math.abs(Math.round(os2.sTypoDescender * (fontSize / unitsPerEm)))
    };
  }
  return {
    fontBoundingBoxAscent: Math.round(os2.usWinAscent * (fontSize / unitsPerEm)),
    fontBoundingBoxDescent: Math.round(os2.usWinDescent * (fontSize / unitsPerEm))
  };
};
var makeSmallCapsDivs = (text, fontSizeHTMLSmallCaps) => {
  const textDivs0 = text.match(/([a-z]+)|([^a-z]+)/g);
  if (!textDivs0) return "";
  const textDivs = textDivs0.map((x2) => {
    const lower = /[a-z]/.test(x2);
    const styleStr = lower ? `style="font-size:${fontSizeHTMLSmallCaps}px"` : "";
    return `<span class="input-sub" ${styleStr}>${x2}</span>`;
  });
  return textDivs.join("");
};
function writeHtml({
  ocrPages,
  images,
  minpage = 0,
  maxpage = -1,
  reflowText = false,
  removeMargins = false,
  wordIds = null
}) {
  const fontsUsed = /* @__PURE__ */ new Set();
  const enableOptSaved = FontCont.state.enableOpt;
  FontCont.state.enableOpt = false;
  if (images && images.length === 0) images = void 0;
  reflowText = false;
  let bodyStr = "<body>\n";
  if (maxpage === -1) maxpage = ocrPages.length - 1;
  let newLine = false;
  const activeLine = {
    left: 0,
    y1: 0,
    maxFontBoundingBoxAscentLine: 0,
    bodyWordsStr: ""
  };
  const addLine = () => {
    if (activeLine.bodyWordsStr !== "") {
      const topHTML = Math.round((activeLine.y1 - activeLine.maxFontBoundingBoxAscentLine) * 1e3) / 1e3;
      bodyStr += `    <div class="scribe-line" style="left:${activeLine.left}px;top:${topHTML}px;">
`;
      bodyStr += "        ";
      bodyStr += activeLine.bodyWordsStr;
      bodyStr += "<br>\n";
      bodyStr += "    </div>\n";
    }
    activeLine.bodyWordsStr = "";
    activeLine.maxFontBoundingBoxAscentLine = 0;
    activeLine.y1 = 0;
    activeLine.left = 0;
  };
  let top = 0;
  for (let g2 = minpage; g2 <= maxpage; g2++) {
    if (!ocrPages[g2] || ocrPages[g2].lines.length === 0) continue;
    const pageObj = ocrPages[g2];
    let minLeft = 0;
    let minTop = 0;
    let maxBottom = 0;
    if (removeMargins) {
      const wordArr = ocrObjects_default.getPageWords(pageObj);
      for (let h2 = 0; h2 < wordArr.length; h2++) {
        const wordObj = wordArr[h2];
        if (wordIds && !wordIds.includes(wordObj.id)) continue;
        if (minLeft === 0 || wordObj.bbox.left < minLeft) minLeft = wordObj.bbox.left;
        if (minTop === 0 || wordObj.bbox.top < minTop) minTop = wordObj.bbox.top;
        if (wordObj.bbox.bottom > maxBottom) maxBottom = wordObj.bbox.bottom;
      }
    }
    bodyStr += `  <div class="scribe-page" id="page${g2}" style="position:absolute;top:${top}px;">
`;
    const imageObj = images ? images[g2] : null;
    if (imageObj) {
      bodyStr += `  <img class="scribe-image" src="${imageObj.src}">
`;
    }
    if (removeMargins) {
      top += Math.min(maxBottom - minTop + 200, pageMetricsAll[g2].dims.height + 10);
    } else {
      top += pageMetricsAll[g2].dims.height + 10;
    }
    if (reflowText && (!pageObj.textSource || !["textract", "abbyy"].includes(pageObj.textSource))) {
      const angle = pageMetricsAll[g2].angle || 0;
      assignParagraphs(pageObj, angle);
    }
    let parCurrent = pageObj.lines[0].par;
    let wordObjPrev = (
      /** @type {?OcrWord} */
      null
    );
    let advanceDiffPrev = 0;
    let rightSideBearingPrev = 0;
    let charSpacingHTMLPrev = 0;
    for (let h2 = 0; h2 < pageObj.lines.length; h2++) {
      const lineObj = pageObj.lines[h2];
      if (reflowText) {
        if (h2 === 0 || lineObj.par !== parCurrent) newLine = true;
        parCurrent = lineObj.par;
      } else {
        newLine = true;
      }
      let underlinePrev = false;
      for (let i2 = 0; i2 < lineObj.words.length; i2++) {
        const wordObj = lineObj.words[i2];
        if (!wordObj) continue;
        if (wordIds && !wordIds.includes(wordObj.id)) continue;
        if (newLine) {
          wordObjPrev = null;
          addLine();
          const scale2 = 1;
          const {
            charSpacing: charSpacing2,
            leftSideBearing: leftSideBearing2,
            rightSideBearing: rightSideBearing2,
            fontSize: fontSize2,
            charArr: charArr2,
            advanceArr: advanceArr2,
            kerningArr: kerningArr2,
            font: font2
          } = calcWordMetrics(wordObj);
          activeLine.y1 = wordObj.line.bbox.bottom + wordObj.line.baseline[1] - minTop;
          activeLine.left = wordObj.bbox.left - minLeft;
          if (wordObj.visualCoords) activeLine.left -= leftSideBearing2 * scale2;
        }
        newLine = false;
        const scale = 1;
        const angle = 0;
        const {
          charSpacing,
          leftSideBearing,
          rightSideBearing,
          fontSize,
          charArr,
          advanceArr,
          kerningArr,
          font
        } = calcWordMetrics(wordObj);
        fontsUsed.add(font);
        const wordStr = charArr.join("");
        const charSpacingHTML = charSpacing * scale;
        const y1 = wordObj.line.bbox.bottom + wordObj.line.baseline[1] - minTop;
        const fontSizeHTML = fontSize * scale;
        const metrics = calcFontMetrics(font, fontSizeHTML);
        const fontSizeHTMLSmallCaps = fontSize * scale * font.smallCapsMult;
        if (metrics.fontBoundingBoxAscent > activeLine.maxFontBoundingBoxAscentLine) {
          activeLine.maxFontBoundingBoxAscentLine = metrics.fontBoundingBoxAscent;
        }
        const topHTML = Math.round((y1 - metrics.fontBoundingBoxAscent) * 1e3) / 1e3;
        let styleStr2 = "";
        styleStr2 += `font-size:${fontSizeHTML}px;`;
        styleStr2 += `font-family:${font.fontFaceName};`;
        if (Math.abs(angle ?? 0) > 0.05) {
          styleStr2 += `transform-origin:left ${y1 - topHTML}px;`;
          styleStr2 += `transform:rotate(${angle}deg);`;
        }
        const { fill, opacity } = ocrObjects_default.getWordFillOpacity(
          wordObj,
          opt.displayMode,
          opt.confThreshMed,
          opt.confThreshHigh,
          opt.overlayOpacity
        );
        if (opacity === 0) {
          styleStr2 += "color:transparent;";
          styleStr2 += "opacity:1;";
        } else {
          styleStr2 += `color:${fill};`;
          styleStr2 += `opacity:${opacity};`;
        }
        let innerHTML;
        if (wordObj.style.smallCaps) {
          styleStr2 += "text-transform:uppercase;";
          innerHTML = makeSmallCapsDivs(wordStr, fontSizeHTMLSmallCaps);
        } else {
          innerHTML = wordStr;
        }
        let leftPad = 0;
        if (wordObjPrev) {
          let spaceAdj = 0;
          if (wordObj.visualCoords) {
            spaceAdj = leftSideBearing + rightSideBearingPrev;
          } else {
            spaceAdj = advanceDiffPrev;
          }
          leftPad = (wordObj.bbox.left - wordObjPrev.bbox.right - spaceAdj - charSpacingHTMLPrev) / Math.cos(angle);
        }
        styleStr2 += `letter-spacing:${formatNum3(charSpacingHTML)}px;`;
        styleStr2 += `font-weight:${font.fontFaceWeight};`;
        styleStr2 += `font-style:${font.fontFaceStyle};`;
        styleStr2 += `line-height:${metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent}px;`;
        if (wordObj.style.sup) {
          const supOffset = Math.round(wordObj.line.bbox.bottom + wordObj.line.baseline[1] - wordObj.bbox.bottom);
          styleStr2 += `vertical-align:${supOffset}px;`;
        }
        if (wordObj.style.underline) {
          styleStr2 += "text-decoration:underline;";
          styleStr2 += `text-decoration-color:${fill};`;
          styleStr2 += `text-decoration-thickness:${Math.ceil(fontSizeHTML / 12)}px;`;
          styleStr2 += `text-underline-offset:${Math.ceil(fontSizeHTML / 12) + Math.ceil(fontSizeHTML / 24)}px;`;
        }
        if (i2 > 0) {
          let styleStrSpace = "";
          const spaceAdvance = font.opentype.charToGlyph(" ").advanceWidth || font.opentype.unitsPerEm * 0.35;
          const spaceAdvancePx = spaceAdvance / font.opentype.unitsPerEm;
          const fontSizeHTMLSpace = leftPad / spaceAdvancePx;
          if (fontSizeHTMLSpace > fontSizeHTML * 3) {
            styleStrSpace += `font-size:${fontSizeHTML}px;`;
            const leftPadFinal = leftPad - spaceAdvancePx * fontSizeHTML;
            styleStrSpace += `padding-left:${leftPadFinal}px;`;
          } else {
            styleStrSpace += `font-size:${fontSizeHTML}px;`;
            const leftPadFinal = leftPad - spaceAdvancePx * fontSizeHTML;
            styleStrSpace += `word-spacing:${formatNum3(leftPadFinal)}px;`;
          }
          styleStrSpace += `font-family:${font.fontFaceName};`;
          styleStrSpace += `font-style:${font.fontFaceStyle};`;
          styleStrSpace += `font-weight:${font.fontFaceWeight};`;
          if (underlinePrev) {
            styleStrSpace += `color:${fill};`;
            styleStrSpace += `opacity:${opacity};`;
            styleStrSpace += "text-decoration:underline;";
            styleStrSpace += `text-decoration-color:${fill};`;
            styleStrSpace += `text-decoration-thickness:${Math.ceil(fontSizeHTML / 12)}px;`;
            styleStrSpace += `text-underline-offset:${Math.ceil(fontSizeHTML / 12) + Math.ceil(fontSizeHTML / 24)}px;`;
          }
          activeLine.bodyWordsStr += `<span class="scribe-space" style=${styleStrSpace}> </span>`;
        }
        activeLine.bodyWordsStr += `<span class="scribe-word" id="${wordObj.id}" style="${styleStr2}">${innerHTML}</span>`;
        underlinePrev = wordObj.style.underline;
        const advanceTotalHTML = advanceArr.reduce((a2, b2) => a2 + b2, 0) + kerningArr.reduce((a2, b2) => a2 + b2, 0) + charSpacingHTML * (charArr.length - 1);
        advanceDiffPrev = advanceTotalHTML - (wordObj.bbox.right - wordObj.bbox.left);
        wordObjPrev = wordObj;
        rightSideBearingPrev = rightSideBearing;
        charSpacingHTMLPrev = charSpacingHTML;
      }
    }
    addLine();
    bodyStr += "  </div>\n";
    opt.progressHandler({ n: g2, type: "export", info: {} });
  }
  let styleStr = "<style>\n  .scribe-word {\n";
  styleStr += "    z-index:1;\n";
  styleStr += "    white-space:nowrap;\n";
  if (opt.kerning) {
    styleStr += "    font-kerning:normal;\n";
  } else {
    styleStr += "    font-kerning:none;\n";
  }
  styleStr += "  }\n";
  styleStr += "  .scribe-line {\n";
  styleStr += "    position:absolute;\n";
  styleStr += "    white-space:nowrap;\n";
  styleStr += "  }\n";
  styleStr += "  .scribe-page {\n";
  styleStr += "    text-decoration-skip-ink:none;\n";
  styleStr += "  }\n";
  styleStr += "  .scribe-image {\n";
  styleStr += "    position:absolute;\n";
  styleStr += "    user-select:none;\n";
  styleStr += "    pointer-events:none;\n";
  styleStr += "  }\n";
  for (const fontI of fontsUsed) {
    const cdnPath = "https://cdn.jsdelivr.net/npm/scribe.js-ocr@0.8.0/fonts/all/";
    let styleTitleCase = "Regular";
    if (fontI.style === "italic") {
      styleTitleCase = "Italic";
    } else if (fontI.style === "bold") {
      styleTitleCase = "Bold";
    } else if (fontI.style === "boldItalic") {
      styleTitleCase = "BoldItalic";
    }
    const fontName = `${fontI.family}-${styleTitleCase}.woff`;
    const fontPath = cdnPath + fontName;
    styleStr += `  @font-face {
    font-family: '${fontI.fontFaceName}';
    font-style: ${fontI.fontFaceStyle};
    font-weight: ${fontI.fontFaceWeight};
    src: url('${fontPath}');
  }
`;
  }
  styleStr += "</style>\n";
  bodyStr += "</body>\n";
  const metaStr = '<meta charset="UTF-8">\n';
  const htmlStr = `<!doctype html>
<html>
<head>
${metaStr}${styleStr}</head>
${bodyStr}</html>`;
  FontCont.state.enableOpt = enableOptSaved;
  return htmlStr;
}

// node_modules/scribe.js-ocr/js/export/export.js
init_ocrObjects();

// node_modules/scribe.js-ocr/js/objects/layoutObjects.js
init_miscUtils();
var LayoutBoxBase = class {
  /**
   * Create a layout box.
   * @param {bbox} coords - The coordinates of the layout box.
   */
  constructor(coords2) {
    this.id = getRandomAlphanum(10);
    this.coords = coords2;
    this.inclusionRule = "majority";
    this.inclusionLevel = "word";
  }
};
var LayoutDataColumn = class extends LayoutBoxBase {
  /**
   * Create a layout data column.
   * @param {bbox} coords - The coordinates of the layout data column.
   * @param {LayoutDataTable} table - The layout data table to which the column belongs.
   */
  constructor(coords2, table3) {
    super(coords2);
    this.type = "dataColumn";
    this.table = table3;
  }
};
var LayoutRegion = class extends LayoutBoxBase {
  /**
   * Create a layout data column.
   * @param {LayoutPage} page
   * @param {number} priority - The priority of the layout data column.
   * @param {bbox} coords - The coordinates of the layout data column.
   * @param {('order'|'exclude')} type - The type of the layout region.
   */
  constructor(page, priority, coords2, type) {
    super(coords2);
    this.page = page;
    this.type = type;
    this.order = priority;
  }
};
function LayoutPage(n2) {
  this.n = n2;
  this.default = true;
  this.boxes = {};
}
var calcTableBbox = (table3) => {
  const boxesBboxArr = table3.boxes.map((box) => box.coords);
  return calcBboxUnion(boxesBboxArr);
};
var LayoutDataTable = class {
  /**
   * Create a layout data table.
   * @param {LayoutDataTablePage} page - The layout data table page to which the table belongs.
   */
  constructor(page) {
    this.page = page;
    this.id = getRandomAlphanum(10);
    this.boxes = [];
  }
};
function LayoutDataTablePage(n2) {
  this.n = n2;
  this.default = true;
  this.tables = [];
}
var removeCircularRefsDataTables = (pages) => {
  const pagesClone = structuredClone(pages);
  pagesClone.forEach((page) => {
    page.tables.forEach((table3) => {
      delete table3.page;
      table3.boxes.forEach((box) => {
        delete box.table;
      });
    });
  });
};
var addCircularRefsDataTables = (pages) => {
  pages.forEach((page) => {
    page.tables.forEach((table3) => {
      table3.page = page;
      table3.boxes.forEach((box) => {
        box.table = table3;
      });
    });
  });
  return pages;
};
var layout = {
  LayoutDataColumn,
  LayoutDataTable,
  LayoutRegion
};
var layoutObjects_default = layout;

// node_modules/scribe.js-ocr/js/export/export.js
async function exportData(format = "txt", minPage = 0, maxPage = -1) {
  if (format === "text") format = "txt";
  if (maxPage === -1) maxPage = inputData.pageCount - 1;
  let ocrDownload = [];
  if (format !== "hocr" && opt.enableLayout) {
    for (let i2 = 0; i2 < ocrAll.active.length; i2++) {
      ocrDownload.push(reorderOcrPage(ocrAll.active[i2], layoutRegions.pages[i2]));
    }
  } else {
    ocrDownload = ocrAll.active;
  }
  let content;
  if (format === "pdf") {
    const dimsLimit = { width: -1, height: -1 };
    if (opt.standardizePageSize) {
      for (let i2 = minPage; i2 <= maxPage; i2++) {
        dimsLimit.height = Math.max(dimsLimit.height, pageMetricsAll[i2].dims.height);
        dimsLimit.width = Math.max(dimsLimit.width, pageMetricsAll[i2].dims.width);
      }
    }
    if (opt.displayMode !== "ebook") {
      const insertInputPDF = inputData.pdfMode && opt.addOverlay;
      const rotateBackground = !insertInputPDF && opt.autoRotate;
      const rotateText = !rotateBackground;
      const includeImages = false;
      let images = [];
      if (includeImages) {
        images = await Promise.all(ImageCache.nativeSrc);
      }
      const pdfStr = await writePdf({
        ocrArr: ocrDownload,
        pageMetricsArr: pageMetricsAll,
        minpage: minPage,
        maxpage: maxPage,
        textMode: opt.displayMode,
        rotateText,
        rotateBackground,
        dimsLimit: { width: -1, height: -1 },
        confThreshHigh: opt.confThreshHigh,
        confThreshMed: opt.confThreshMed,
        proofOpacity: opt.overlayOpacity / 100,
        images,
        includeImages
      });
      const enc = new TextEncoder();
      const pdfEnc = enc.encode(pdfStr);
      if (opt.intermediatePDF) return pdfEnc;
      const muPDFScheduler = await ImageCache.getMuPDFScheduler(1);
      const w2 = muPDFScheduler.workers[0];
      const pdfOverlay = await w2.openDocument(pdfEnc.buffer, "document.pdf");
      let insertInputFailed = false;
      if (insertInputPDF) {
        try {
          const basePdfDataCopy = structuredClone(ImageCache.pdfData);
          const basePdf = await w2.openDocument(basePdfDataCopy, "document.pdf");
          const basePdfNoInvisData = await w2.save({
            doc1: basePdf,
            minpage: minPage,
            maxpage: maxPage,
            pagewidth: dimsLimit.width,
            pageheight: dimsLimit.height,
            humanReadable: opt.humanReadablePDF,
            skipTextInvis: true
          });
          const basePdfNoInvis = await w2.openDocument(basePdfNoInvisData, "document.pdf");
          if (minPage > 0 || maxPage < inputData.pageCount - 1) {
            await w2.subsetPages(basePdfNoInvis, minPage, maxPage);
          }
          await w2.overlayDocuments(basePdfNoInvis, pdfOverlay);
          content = await w2.save({
            doc1: basePdfNoInvis,
            minpage: minPage,
            maxpage: maxPage,
            pagewidth: dimsLimit.width,
            pageheight: dimsLimit.height,
            humanReadable: opt.humanReadablePDF
          });
          w2.freeDocument(basePdf);
          w2.freeDocument(basePdfNoInvis);
        } catch (error) {
          console.error("Failed to insert contents into input PDF, creating new PDF from rendered images instead.");
          console.error(error);
          insertInputFailed = true;
        }
      }
      if (!insertInputPDF && (inputData.pdfMode || inputData.imageMode) || insertInputFailed) {
        const props = { rotated: rotateBackground, upscaled: false, colorMode: opt.colorMode };
        const binary = opt.colorMode === "binary";
        const renderImage = binary || inputData.pdfMode;
        if (renderImage) await ImageCache.preRenderRange(minPage, maxPage, binary, props);
        await w2.convertImageStart({ humanReadable: opt.humanReadablePDF });
        for (let i2 = minPage; i2 < maxPage + 1; i2++) {
          let image;
          if (binary) {
            image = await ImageCache.getBinary(i2, props);
          } else if (inputData.pdfMode) {
            image = await ImageCache.getNative(i2, props);
          } else {
            image = await ImageCache.nativeSrc[i2];
          }
          const angleImagePdf = rotateBackground && !renderImage ? (pageMetricsAll[i2].angle || 0) * -1 : 0;
          await w2.convertImageAddPage({
            image: image.src,
            i: i2,
            pagewidth: dimsLimit.width,
            pageheight: dimsLimit.height,
            angle: angleImagePdf
          });
          opt.progressHandler({ n: i2, type: "export", info: {} });
        }
        const contentImage = await w2.convertImageEnd();
        const pdfBase = await w2.openDocument(contentImage, "document.pdf");
        await w2.overlayDocuments(pdfBase, pdfOverlay);
        content = await w2.save({
          doc1: pdfBase,
          minpage: minPage,
          maxpage: maxPage,
          pagewidth: dimsLimit.width,
          pageheight: dimsLimit.height,
          humanReadable: opt.humanReadablePDF
        });
        w2.freeDocument(pdfBase);
      } else if (!insertInputPDF) {
        content = await w2.save({
          doc1: pdfOverlay,
          minpage: minPage,
          maxpage: maxPage,
          pagewidth: dimsLimit.width,
          pageheight: dimsLimit.height,
          humanReadable: opt.humanReadablePDF
        });
      }
      w2.freeDocument(pdfOverlay);
    } else {
      const pdfStr = await writePdf({
        ocrArr: ocrDownload,
        pageMetricsArr: pageMetricsAll,
        minpage: minPage,
        maxpage: maxPage,
        textMode: opt.displayMode,
        rotateText: false,
        rotateBackground: true,
        dimsLimit,
        confThreshHigh: opt.confThreshHigh,
        confThreshMed: opt.confThreshMed,
        proofOpacity: opt.overlayOpacity / 100
      });
      const enc = new TextEncoder();
      const pdfEnc = enc.encode(pdfStr);
      if (opt.intermediatePDF) return pdfEnc;
      const muPDFScheduler = await ImageCache.getMuPDFScheduler(1);
      const w2 = muPDFScheduler.workers[0];
      const pdf = await w2.openDocument(pdfEnc.buffer, "document.pdf");
      content = await w2.save({
        doc1: pdf,
        minpage: minPage,
        maxpage: maxPage,
        pagewidth: dimsLimit.width,
        pageheight: dimsLimit.height,
        humanReadable: opt.humanReadablePDF
      });
      w2.freeDocument(pdf);
    }
  } else if (format === "hocr") {
    content = writeHocr({ ocrData: ocrDownload, minValue: minPage, maxValue: maxPage });
  } else if (format === "html") {
    const images = (
      /** @type {Array<ImageWrapper>} */
      []
    );
    if (opt.includeImages) {
      const props = { rotated: opt.autoRotate, upscaled: false, colorMode: opt.colorMode };
      const binary = opt.colorMode === "binary";
      const renderImage = binary || inputData.pdfMode;
      if (renderImage) await ImageCache.preRenderRange(minPage, maxPage, binary, props);
      for (let i2 = minPage; i2 < maxPage + 1; i2++) {
        let image;
        if (binary) {
          image = await ImageCache.getBinary(i2, props);
        } else if (inputData.pdfMode) {
          image = await ImageCache.getNative(i2, props);
        } else {
          image = await ImageCache.nativeSrc[i2];
        }
        images.push(image);
      }
    }
    content = writeHtml({
      ocrPages: ocrDownload,
      images,
      minpage: minPage,
      maxpage: maxPage,
      reflowText: opt.reflow,
      removeMargins: opt.removeMargins
    });
  } else if (format === "txt") {
    content = writeText({
      ocrCurrent: ocrDownload,
      minpage: minPage,
      maxpage: maxPage,
      reflowText: opt.reflow
    });
  } else if (typeof DISABLE_DOCX_XLSX === "undefined" && format === "docx") {
    const writeDocx2 = (await Promise.resolve().then(() => (init_writeDocx(), writeDocx_exports))).writeDocx;
    content = await writeDocx2({ hocrCurrent: ocrDownload, minpage: minPage, maxpage: maxPage });
  } else if (typeof DISABLE_DOCX_XLSX === "undefined" && format === "xlsx") {
    const writeXlsx2 = (await Promise.resolve().then(() => (init_writeTabular(), writeTabular_exports))).writeXlsx;
    content = await writeXlsx2({
      ocrPageArr: ocrDownload,
      layoutPageArr: layoutDataTables.pages,
      minpage: minPage,
      maxpage: maxPage
    });
  } else if (format === "scribe") {
    const data2 = {
      ocr: removeCircularRefsOcr(ocrDownload),
      fontState: FontCont.state,
      layoutRegions: layoutRegions.pages,
      layoutDataTables: removeCircularRefsDataTables(layoutDataTables.pages)
    };
    const contentStr = JSON.stringify(data2);
    const pako3 = await Promise.resolve().then(() => (init_pako_esm(), pako_esm_exports));
    const enc = new TextEncoder();
    content = pako3.gzip(enc.encode(contentStr))?.buffer;
  }
  return content;
}
async function download(format, fileName, minPage = 0, maxPage = -1) {
  if (format === "text") format = "txt";
  fileName = fileName.replace(/\.\w{1,6}$/, `.${format}`);
  const content = await exportData(format, minPage, maxPage);
  await saveAs(content, fileName);
}

// node_modules/scribe.js-ocr/js/export/exportDebugCsv.js
init_ocrObjects();
init_miscUtils();
var escapeCsvField = (field) => {
  if (typeof field === "object") {
    return `"${JSON.stringify(field).replace(/"/g, '""')}"`;
  }
  if (typeof field === "string") {
    return `"${field.replace(/"/g, '""')}"`;
  }
  return field;
};
var convertToCsv = (data2) => {
  if (data2.length === 0) {
    return "";
  }
  const headers = Object.keys(data2[0]);
  const rows = data2.map((item) => headers.map((header) => escapeCsvField(item[header])).join(","));
  return [headers.join(","), ...rows].join("\n");
};
var writeDebugCsv = ({ pages, fileName }) => {
  let csvStr = "";
  for (let i2 = 0; i2 < pages.length; i2++) {
    const words = ocrObjects_default.getPageWords(pages[i2]).map((word) => {
      word = ocrObjects_default.cloneWord(word);
      delete word.line;
      return word;
    });
    let csvStrI = convertToCsv(words);
    if (i2 > 0) {
      const firstNewlineIndex = csvStrI.indexOf("\n");
      if (firstNewlineIndex !== -1) csvStrI = csvStrI.slice(firstNewlineIndex);
    }
    csvStr += csvStrI;
  }
  saveAs(csvStr, fileName);
};

// node_modules/scribe.js-ocr/js/extractPDFText.js
init_app();
init_dataContainer();

// node_modules/scribe.js-ocr/js/recognizeConvert.js
init_app();
init_dataContainer();

// node_modules/scribe.js-ocr/js/fontEval.js
init_dataContainer();
async function evalPagesFont(font, pageArr, opt2, n2 = 500) {
  let metricTotal = 0;
  let wordsTotal = 0;
  for (let i2 = 0; i2 < pageArr.length; i2++) {
    if (wordsTotal > n2) break;
    const imageI = await ImageCache.getBinary(i2);
    const res = await gs.evalPageFont({
      font,
      page: pageArr[i2],
      binaryImage: imageI,
      pageMetricsObj: pageMetricsAll[i2],
      opt: opt2
    });
    metricTotal += res.metricTotal;
    wordsTotal += res.wordsTotal;
  }
  return { wordsTotal, metricTotal };
}
async function evaluateFonts(pageArr, opt2) {
  const evalCarlito = !!(opt2 ? FontCont.opt?.Carlito : FontCont.raw?.Carlito);
  const evalNimbusSans = !!(opt2 ? FontCont.opt?.NimbusSans : FontCont.raw?.NimbusSans);
  const evalCentury = !!(opt2 ? FontCont.opt?.Century : FontCont.raw?.Century);
  const evalPalatino = !!(opt2 ? FontCont.opt?.Palatino : FontCont.raw?.Palatino);
  const evalGaramond = !!(opt2 ? FontCont.opt?.Garamond : FontCont.raw?.Garamond);
  const evalGothic = !!(opt2 ? FontCont.opt?.Gothic : FontCont.raw?.Gothic);
  const evalNimbusRoman = !!(opt2 ? FontCont.opt?.NimbusRoman : FontCont.raw?.NimbusRoman);
  const evalNimbusMono = !!(opt2 ? FontCont.opt?.NimbusMono : FontCont.raw?.NimbusMono);
  const fontMetricsPromises = {
    carlito: evalCarlito ? evalPagesFont("Carlito", pageArr, opt2) : null,
    nimbusSans: evalNimbusSans ? evalPagesFont("NimbusSans", pageArr, opt2) : null,
    century: evalCentury ? evalPagesFont("Century", pageArr, opt2) : null,
    palatino: evalPalatino ? evalPagesFont("Palatino", pageArr, opt2) : null,
    garamond: evalGaramond ? evalPagesFont("Garamond", pageArr, opt2) : null,
    gothic: evalGothic ? evalPagesFont("Gothic", pageArr, opt2) : null,
    nimbusRoman: evalNimbusRoman ? evalPagesFont("NimbusRoman", pageArr, opt2) : null,
    nimbusMono: evalNimbusMono ? evalPagesFont("NimbusMono", pageArr, opt2) : null
  };
  const fontMetricsTmp = {
    carlito: await fontMetricsPromises.carlito,
    nimbusSans: await fontMetricsPromises.nimbusSans,
    century: await fontMetricsPromises.century,
    palatino: await fontMetricsPromises.palatino,
    garamond: await fontMetricsPromises.garamond,
    gothic: await fontMetricsPromises.gothic,
    nimbusRoman: await fontMetricsPromises.nimbusRoman,
    nimbusMono: await fontMetricsPromises.nimbusMono
  };
  const fontMetrics = {
    Carlito: fontMetricsTmp.carlito ? fontMetricsTmp.carlito.metricTotal / fontMetricsTmp.carlito.wordsTotal : null,
    NimbusSans: fontMetricsTmp.nimbusSans ? fontMetricsTmp.nimbusSans.metricTotal / fontMetricsTmp.nimbusSans.wordsTotal : null,
    Century: fontMetricsTmp.century ? fontMetricsTmp.century.metricTotal / fontMetricsTmp.century.wordsTotal : null,
    Palatino: fontMetricsTmp.palatino ? fontMetricsTmp.palatino.metricTotal / fontMetricsTmp.palatino.wordsTotal : null,
    Garamond: fontMetricsTmp.garamond ? fontMetricsTmp.garamond.metricTotal / fontMetricsTmp.garamond.wordsTotal : null,
    Gothic: fontMetricsTmp.gothic ? fontMetricsTmp.gothic.metricTotal / fontMetricsTmp.gothic.wordsTotal : null,
    NimbusRoman: fontMetricsTmp.nimbusRoman ? fontMetricsTmp.nimbusRoman.metricTotal / fontMetricsTmp.nimbusRoman.wordsTotal : null,
    NimbusMono: fontMetricsTmp.nimbusMono ? fontMetricsTmp.nimbusMono.metricTotal / fontMetricsTmp.nimbusMono.wordsTotal : null
  };
  return fontMetrics;
}
var calcBestFonts = (fontMetrics) => {
  let minKeySans = "NimbusSans";
  let minValueSans = Number.MAX_VALUE;
  for (const [key, value] of Object.entries(fontMetrics)) {
    if (!["Carlito", "Gothic", "NimbusSans"].includes(key)) continue;
    if (value && value < minValueSans) {
      minValueSans = value;
      minKeySans = key;
    }
  }
  let minKeySerif = "NimbusRoman";
  let minValueSerif = Number.MAX_VALUE;
  for (const [key, value] of Object.entries(fontMetrics)) {
    if (!["Century", "Palatino", "Garamond", "NimbusRoman", "NimbusMono"].includes(key)) continue;
    if (value && value < minValueSerif) {
      minValueSerif = value;
      minKeySerif = key;
    }
  }
  return {
    minKeySans,
    minKeySerif
  };
};
async function runFontOptimization(ocrArr) {
  await loadBuiltInFontsRaw();
  const calculateOpt = FontCont.state.charMetrics && Object.keys(FontCont.state.charMetrics).length > 0;
  let enableOptSerif = false;
  let enableOptSans = false;
  let optimizeFontContainerAllPromise;
  if (calculateOpt) {
    setDefaultFontAuto(FontCont.state.charMetrics);
    optimizeFontContainerAllPromise = optimizeFontContainerAll(FontCont.raw, FontCont.state.charMetrics).then((res) => {
      FontCont.opt = res;
    });
  }
  if (ImageCache.inputModes.image || ImageCache.inputModes.pdf) {
    const pageNum = Math.min(ImageCache.pageCount, 5);
    FontCont.rawMetrics = await evaluateFonts(ocrArr.slice(0, pageNum), false);
    const bestMetricsRaw = calcBestFonts(FontCont.rawMetrics);
    await optimizeFontContainerAllPromise;
    if (FontCont.opt && Object.keys(FontCont.opt).length > 0) {
      await updateFontContWorkerMain();
      FontCont.optMetrics = await evaluateFonts(ocrArr.slice(0, pageNum), true);
      const bestMetricsOpt = calcBestFonts(FontCont.optMetrics);
      if (FontCont.optMetrics[bestMetricsOpt.minKeySans] < FontCont.rawMetrics[bestMetricsRaw.minKeySans]) {
        enableOptSans = true;
        FontCont.state.sansDefaultName = bestMetricsOpt.minKeySans;
      } else {
        FontCont.state.sansDefaultName = bestMetricsRaw.minKeySans;
      }
      if (FontCont.optMetrics[bestMetricsOpt.minKeySerif] < FontCont.rawMetrics[bestMetricsRaw.minKeySerif]) {
        enableOptSerif = true;
        FontCont.state.serifDefaultName = bestMetricsOpt.minKeySerif;
      } else {
        FontCont.state.serifDefaultName = bestMetricsRaw.minKeySerif;
      }
    } else {
      FontCont.state.sansDefaultName = bestMetricsRaw.minKeySans;
      FontCont.state.serifDefaultName = bestMetricsRaw.minKeySerif;
    }
    FontCont.state.enableOpt = enableOptSerif || enableOptSans;
    await updateFontContWorkerMain();
  }
  return FontCont.state.enableOpt;
}

// node_modules/scribe.js-ocr/js/fontStatistics.js
init_miscUtils();

// node_modules/scribe.js-ocr/js/objects/charMetricsObjects.js
function CharMetricsFont() {
  this.width = {};
  this.height = {};
  this.kerning = {};
  this.kerning2 = {};
  this.variants = {};
  this.heightCaps = 1.3;
  this.obs = 0;
  this.obsCaps = 0;
}
function CharMetricsFamily() {
  this.normal = new CharMetricsFont();
  this.italic = new CharMetricsFont();
  this.smallCaps = new CharMetricsFont();
  this.bold = new CharMetricsFont();
  this.obs = 0;
}
function CharMetricsRawFont() {
  this.width = {};
  this.height = {};
  this.kerning = {};
  this.kerning2 = {};
  this.obs = 0;
}
function CharMetricsRawFamily() {
  this.normal = new CharMetricsRawFont();
  this.italic = new CharMetricsRawFont();
  this.smallCaps = new CharMetricsRawFont();
  this.bold = new CharMetricsRawFont();
}

// node_modules/scribe.js-ocr/js/fontStatistics.js
function calcCharMetricsFromPages(pageArr) {
  if (!pageArr || pageArr.length === 0) return {};
  const pageCharMetricsArr = pageArr.map((x2) => calcCharMetricsPage(x2));
  if (pageCharMetricsArr.length === 0) return {};
  const charMetricsRawObj = pageCharMetricsArr.reduce((x2, y2) => unionCharMetricsRawObj(x2, y2));
  const charMetricsOut = {};
  for (const [family, obj] of Object.entries(charMetricsRawObj)) {
    charMetricsOut[family] = new CharMetricsFamily();
    for (const [style, obj2] of Object.entries(obj)) {
      charMetricsOut[family][style] = calculateCharMetrics(obj2);
      charMetricsOut[family].obs += charMetricsOut[family][style].obs;
    }
  }
  return charMetricsOut;
}
function unionCharMetricsFont(charMetricsRawFontA, charMetricsRawFontB, xHeight = null) {
  if (!charMetricsRawFontA) {
    if (!charMetricsRawFontB) return null;
    charMetricsRawFontA = structuredClone(charMetricsRawFontB);
    return charMetricsRawFontA;
  }
  if (!charMetricsRawFontB) {
    return charMetricsRawFontA;
  }
  if (charMetricsRawFontB?.obs) charMetricsRawFontA.obs += charMetricsRawFontB.obs;
  for (const [prop, obj] of Object.entries(charMetricsRawFontB)) {
    for (const [key, value] of Object.entries(obj)) {
      if (!charMetricsRawFontA[prop][key]) {
        charMetricsRawFontA[prop][key] = [];
      }
      if (xHeight) {
        const valueNorm = value.map((x2) => x2 / xHeight).filter((x2) => x2);
        Array.prototype.push.apply(charMetricsRawFontA[prop][key], valueNorm);
      } else {
        Array.prototype.push.apply(charMetricsRawFontA[prop][key], value);
      }
    }
  }
  return charMetricsRawFontA;
}
function unionCharMetricsRawObj(charMetricsRawObjA, charMetricsRawObjB) {
  for (const [family, obj] of Object.entries(charMetricsRawObjB)) {
    for (const [style, obj2] of Object.entries(obj)) {
      if (Object.keys(obj2.width).length === 0) continue;
      if (!charMetricsRawObjA[family]) {
        charMetricsRawObjA[family] = new CharMetricsRawFamily();
      }
    }
  }
  for (const [family, obj] of Object.entries(charMetricsRawObjA)) {
    for (const [style, obj2] of Object.entries(obj)) {
      unionCharMetricsFont(charMetricsRawObjA?.[family]?.[style], charMetricsRawObjB?.[family]?.[style]);
    }
  }
  return charMetricsRawObjA;
}
function calculateCharMetrics(charMetricsRawFontObj) {
  const fontMetricOut = new CharMetricsFont();
  for (const prop of ["width", "height", "kerning", "kerning2"]) {
    for (const [key, value] of Object.entries(charMetricsRawFontObj[prop])) {
      if (value.length > 0) {
        fontMetricOut[prop][key] = round6(quantile(value, 0.5));
      }
    }
  }
  const heightCapsArr = [];
  for (const [key, value] of Object.entries(charMetricsRawFontObj.height)) {
    if (/[A-Z]/.test(String.fromCharCode(parseInt(key)))) {
      Array.prototype.push.apply(heightCapsArr, value);
    }
  }
  fontMetricOut.heightCaps = round6(quantile(heightCapsArr, 0.5));
  fontMetricOut.obsCaps = heightCapsArr.length;
  fontMetricOut.obs = charMetricsRawFontObj.obs;
  for (const prop of ["width", "height", "kerning", "kerning2"]) {
    for (const [key, value] of Object.entries(charMetricsRawFontObj[prop])) {
      const nameFirst = key.match(/\w+/)[0];
      const charFirst = String.fromCharCode(parseInt(nameFirst));
      if (/\d/.test(charFirst)) {
        fontMetricOut[prop][key] *= fontMetricOut.heightCaps;
      }
    }
  }
  for (const prop of ["kerning2"]) {
    for (const [key, value] of Object.entries(charMetricsRawFontObj[prop])) {
      if (value.length > 0) {
        const nameSecond = key.match(/\w+$/)[0];
        const widthSecond = fontMetricOut.width[nameSecond];
        fontMetricOut[prop][key] -= widthSecond;
      }
    }
  }
  return fontMetricOut;
}
var base1Arr = ["Calibri", "Comic", "Franklin", "Tahoma", "Verdana", "Baskerville", "Book", "Cambria", "Century_Schoolbook", "Courier", "Garamond", "Georgia", "Times"];
var base1Regex = new RegExp(base1Arr.reduce((x2, y2) => `${x2}|${y2}`), "i");
var singleGArr = ["Arial", "Comic", "DejaVu", "Helvetica", "Impact", "Tahoma", "Verdana"];
var singleGRegex = new RegExp(singleGArr.reduce((x2, y2) => `${x2}|${y2}`), "i");
var minYArr = ["Bookman", "Georgia"];
var minYRegex = new RegExp(minYArr.reduce((x2, y2) => `${x2}|${y2}`), "i");
var closedKArr = ["Century_Schoolbook"];
var closedKRegex = new RegExp(closedKArr.reduce((x2, y2) => `${x2}|${y2}`), "i");
var roundedVWArr = ["Bookman", "Century_Schoolbook", "Georgia"];
var roundedVWRegex = new RegExp(roundedVWArr.reduce((x2, y2) => `${x2}|${y2}`), "i");
var serifStemSerifPQArr = ["Bookman", "Century_Schoolbook", "Courier", "Georgia", "Times"];
var serifStemSerifPQRegex = new RegExp(serifStemSerifPQArr.reduce((x2, y2) => `${x2}|${y2}`), "i");
function calcCharMetricsPage(pageObj) {
  const charMetricsRawPage = {};
  for (const lineObj of pageObj.lines) {
    for (const wordObj of lineObj.words) {
      const wordFontFamily = determineSansSerif(wordObj.style.font) || "Default";
      if (wordObj.chars && wordObj.chars.length !== wordObj.text.length) continue;
      if (wordObj.conf < 80 || wordObj.lang === "chi_sim" || wordObj.style.sup || wordObj.style.smallCaps) continue;
      const charMetricsRawLine = {};
      if (wordObj.chars) {
        for (let k2 = 0; k2 < wordObj.chars.length; k2++) {
          const charObj = wordObj.chars[k2];
          const charHeight = charObj.bbox.bottom - charObj.bbox.top;
          const charWidth = charObj.bbox.right - charObj.bbox.left;
          const charNorm = /\d/.test(charObj.text) ? lineObj.ascHeight : lineObj.xHeight;
          if (!charNorm) continue;
          const charUnicode = String(charObj.text.charCodeAt(0));
          if (!charMetricsRawLine[wordFontFamily]) {
            charMetricsRawLine[wordFontFamily] = new CharMetricsRawFamily();
          }
          const styleLookup = getStyleLookup(wordObj.style);
          if (!["normal", "italic", "bold"].includes(styleLookup)) continue;
          if (!charMetricsRawLine[wordFontFamily][styleLookup].width[charUnicode]) {
            charMetricsRawLine[wordFontFamily][styleLookup].width[charUnicode] = [];
            charMetricsRawLine[wordFontFamily][styleLookup].height[charUnicode] = [];
          }
          charMetricsRawLine[wordFontFamily][styleLookup].width[charUnicode].push(charWidth / charNorm);
          charMetricsRawLine[wordFontFamily][styleLookup].height[charUnicode].push(charHeight / charNorm);
          charMetricsRawLine[wordFontFamily][styleLookup].obs += 1;
          if (k2 + 1 < wordObj.chars.length) {
            const charObjNext = wordObj.chars[k2 + 1];
            const trailingSpace = charObjNext.bbox.left - charObj.bbox.right;
            const charWidthNext = charObjNext.bbox.right - charObjNext.bbox.left;
            if (trailingSpace + charWidthNext > 0) {
              const bigramUnicode = `${charUnicode},${wordObj.chars[k2 + 1].text.charCodeAt(0)}`;
              if (!charMetricsRawLine[wordFontFamily][styleLookup].kerning[bigramUnicode]) {
                charMetricsRawLine[wordFontFamily][styleLookup].kerning[bigramUnicode] = [];
                charMetricsRawLine[wordFontFamily][styleLookup].kerning2[bigramUnicode] = [];
              }
              charMetricsRawLine[wordFontFamily][styleLookup].kerning[bigramUnicode].push(trailingSpace / charNorm);
              charMetricsRawLine[wordFontFamily][styleLookup].kerning2[bigramUnicode].push((trailingSpace + charWidthNext) / charNorm);
            }
          }
        }
      }
      for (const [family, obj] of Object.entries(charMetricsRawLine)) {
        for (const [style, obj2] of Object.entries(obj)) {
          if (Object.keys(obj2.width).length === 0) continue;
          if (!charMetricsRawPage[family]) {
            charMetricsRawPage[family] = new CharMetricsRawFamily();
          }
        }
      }
      for (const [family, obj] of Object.entries(charMetricsRawPage)) {
        for (const [style, obj2] of Object.entries(obj)) {
          unionCharMetricsFont(charMetricsRawPage?.[family]?.[style], charMetricsRawLine?.[family]?.[style]);
        }
      }
    }
  }
  return charMetricsRawPage;
}

// node_modules/scribe.js-ocr/js/recognizeConvert.js
init_miscUtils();
var compareOCRPage = async (pageA, pageB, options) => {
  const mode2 = options?.mode || "stats";
  const evalConflicts = options?.evalConflicts ?? true;
  const supplementComp = options?.supplementComp ?? false;
  const skipImage = mode2 === "stats" && !supplementComp || mode2 === "comb" && !evalConflicts && !supplementComp;
  const binaryImage = skipImage ? null : await ImageCache.getBinary(pageA.n);
  const pageMetricsObj = pageMetricsAll[pageA.n];
  return gs.compareOCRPageImp({
    pageA,
    pageB,
    binaryImage,
    pageMetricsObj,
    options
  });
};
var evalOCRPage = async (params) => {
  const n2 = "page" in params.page ? params.page.page.n : params.page.n;
  const binaryImage = await ImageCache.getBinary(n2);
  const pageMetricsObj = pageMetricsAll[n2];
  return gs.evalPageBase({
    page: params.page,
    binaryImage,
    pageMetricsObj,
    func: params.func,
    view: params.view
  });
};
var compareOCR = async (ocrA, ocrB, options) => {
  const compOptions = {
    ignorePunct: opt.ignorePunct,
    ignoreCap: opt.ignoreCap,
    confThreshHigh: opt.confThreshHigh,
    confThreshMed: opt.confThreshMed
  };
  if (options) Object.assign(compOptions, options);
  const ocrArr = [];
  const metricsArr = [];
  const debugImageArr = [];
  const comparePageI = async (i2) => {
    const res = await compareOCRPage(ocrA[i2], ocrB[i2], compOptions);
    ocrArr[i2] = res.page;
    metricsArr[i2] = res.metrics;
    if (res.debugImg) debugImageArr[i2] = res.debugImg;
  };
  const indices = [...Array(ocrA.length).keys()];
  const compPromises = indices.map(async (i2) => comparePageI(i2));
  await Promise.allSettled(compPromises);
  return { ocr: ocrArr, metrics: metricsArr, debug: debugImageArr };
};
var calcRecognizeRotateArgs = async (n2, areaMode) => {
  const rotate = true;
  const autoRotate = true;
  const angleThresh = 8726646e-10;
  const angle = pageMetricsAll[n2]?.angle;
  const angleKnown = typeof angle === "number";
  const nativeN = await ImageCache.getNative(n2);
  const rotateDegrees = rotate && angle && Math.abs(angle || 0) > 0.05 && !nativeN.rotated ? angle * -1 : 0;
  const rotateRadians = rotateDegrees * (Math.PI / 180);
  let saveNativeImage = false;
  let saveBinaryImageArg = false;
  if (!areaMode) {
    const binaryN = await ImageCache.binary[n2];
    if (autoRotate && !nativeN.rotated[n2] && (!angleKnown || Math.abs(rotateRadians) > angleThresh)) saveNativeImage = true;
    if (!binaryN || autoRotate && !binaryN.rotated && (!angleKnown || Math.abs(rotateRadians) > angleThresh)) saveBinaryImageArg = true;
  }
  return {
    angleThresh,
    angleKnown,
    rotateRadians,
    saveNativeImage,
    saveBinaryImageArg
  };
};
var recognizePageImp = async (n2, legacy, lstm, areaMode, tessOptions = {}, debugVis = false) => {
  const {
    angleThresh,
    angleKnown,
    rotateRadians,
    saveNativeImage,
    saveBinaryImageArg
  } = await calcRecognizeRotateArgs(n2, areaMode);
  const nativeN = await ImageCache.getNative(n2);
  if (!nativeN) throw new Error(`No image source found for page ${n2}`);
  const config2 = {
    ...{
      rotateRadians,
      rotateAuto: !angleKnown,
      legacy,
      lstm
    },
    ...tessOptions
  };
  const pageDims = pageMetricsAll[n2].dims;
  const runRecognition = legacy || lstm;
  const resArr = await gs.recognizeAndConvert2({
    image: nativeN.src,
    options: config2,
    output: {
      // text, blocks, hocr, and tsv must all be `false` to disable recognition
      text: runRecognition,
      blocks: runRecognition,
      hocr: runRecognition,
      tsv: runRecognition,
      layoutBlocks: !runRecognition,
      imageBinary: saveBinaryImageArg,
      imageColor: saveNativeImage,
      debug: true,
      debugVis
    },
    n: n2,
    knownAngle: pageMetricsAll[n2].angle,
    pageDims
  });
  const res0 = await resArr[0];
  if (!angleKnown) pageMetricsAll[n2].angle = (res0.recognize.rotateRadians || 0) * (180 / Math.PI) * -1;
  const isRotated = Boolean(res0.recognize.rotateRadians || 0) || nativeN.rotated;
  const significantRotation = Math.abs(res0.recognize.rotateRadians || 0) > angleThresh;
  const upscale = res0.recognize.upscale || false;
  if (saveBinaryImageArg && res0.recognize.imageBinary && (significantRotation || !ImageCache.binary[n2])) {
    ImageCache.binaryProps[n2] = { rotated: isRotated, upscaled: upscale, colorMode: "binary" };
    ImageCache.binary[n2] = new ImageWrapper(n2, res0.recognize.imageBinary, "binary", isRotated, upscale);
  }
  if (saveNativeImage && res0.recognize.imageColor && significantRotation) {
    ImageCache.nativeProps[n2] = { rotated: isRotated, upscaled: upscale, colorMode: opt.colorMode };
    ImageCache.native[n2] = new ImageWrapper(n2, res0.recognize.imageColor, "native", isRotated, upscale);
  }
  return resArr;
};
function checkCharWarn(warnArr) {
  const charErrorCt = warnArr.filter((x2) => x2?.char === "char_error").length;
  const charWarnCt = warnArr.filter((x2) => x2?.char === "char_warning").length;
  const charGoodCt = warnArr.length - charErrorCt - charWarnCt;
  if (charGoodCt === 0 && charErrorCt > 0) {
    if (typeof process === "undefined") {
      const errorHTML = `No character-level OCR data detected. Abbyy XML is only supported with character-level data. 
        <a href="https://docs.scribeocr.com/faq.html#is-character-level-ocr-data-required--why" target="_blank" class="alert-link">Learn more.</a>`;
      opt.errorHandler(errorHTML);
    } else {
      const errorText = `No character-level OCR data detected. Abbyy XML is only supported with character-level data. 
        See: https://docs.scribeocr.com/faq.html#is-character-level-ocr-data-required--why`;
      opt.errorHandler(errorText);
    }
  }
  if (charGoodCt === 0 && charWarnCt > 0) {
    if (typeof process === "undefined") {
      const warningHTML = `No character-level OCR data detected. Font optimization features will be disabled. 
        <a href="https://docs.scribeocr.com/faq.html#is-character-level-ocr-data-required--why" target="_blank" class="alert-link">Learn more.</a>`;
      opt.warningHandler(warningHTML);
    } else {
      const errorText = `No character-level OCR data detected. Font optimization features will be disabled. 
        See: https://docs.scribeocr.com/faq.html#is-character-level-ocr-data-required--why`;
      opt.warningHandler(errorText);
    }
  }
}
async function convertOCRPage(ocrRaw, n2, mainData, format, engineName, scribeMode = false) {
  await gs.getGeneralScheduler();
  let res;
  if (format === "hocr") {
    res = await gs.convertPageHocr({ ocrStr: ocrRaw, n: n2, scribeMode });
  } else if (format === "abbyy") {
    res = await gs.convertPageAbbyy({ ocrStr: ocrRaw, n: n2 });
  } else if (format === "textract") {
  } else if (format === "azure_doc_intel") {
  } else if (format === "google_vision") {
    res = await gs.convertPageGoogleVision({ ocrStr: ocrRaw, n: n2 });
  } else if (format === "stext") {
    res = await gs.convertPageStext({ ocrStr: ocrRaw, n: n2 });
  } else if (format === "text") {
    res = await gs.convertPageText({ textStr: ocrRaw });
  } else {
    throw new Error(`Invalid format: ${format}`);
  }
  await convertPageCallback(res, n2, mainData, engineName);
}
async function convertPageCallback({
  pageObj,
  dataTables,
  warn,
  langSet,
  fontSet
}, n2, mainData, engineName) {
  const fontPromiseArr = [];
  if (langSet && langSet.has("chi_sim")) fontPromiseArr.push(loadChiSimFont());
  if (langSet && (langSet.has("rus") || langSet.has("ukr") || langSet.has("ell"))) {
    fontPromiseArr.push(loadBuiltInFontsRaw("all"));
  } else {
    fontPromiseArr.push(loadBuiltInFontsRaw());
  }
  await Promise.all(fontPromiseArr);
  if (["Tesseract Legacy", "Tesseract LSTM"].includes(engineName)) ocrAll["Tesseract Latest"][n2] = pageObj;
  if (engineName) ocrAll[engineName][n2] = pageObj;
  if (mainData) {
    convertPageWarn[n2] = warn;
    if (pageObj.dims.height && pageObj.dims.width) pageMetricsAll[n2] = new PageMetrics(pageObj.dims);
    pageMetricsAll[n2].angle = pageObj.angle;
  }
  inputData.xmlMode[n2] = true;
  if (Object.keys(layoutDataTables.pages[n2].tables).length === 0) layoutDataTables.pages[n2] = dataTables;
  opt.progressHandler({ n: n2, type: "convert", info: { engineName } });
}
async function convertOCR(ocrRawArr, mainData, format, engineName, scribeMode, pageMetrics = null) {
  const promiseArr = [];
  if (format === "textract") {
    if (!pageMetrics || !pageMetrics[0]?.dims) throw new Error("Page metrics must be provided for Textract data.");
    const pageDims = pageMetrics.map((metrics) => metrics.dims);
    const res = await gs.convertDocTextract({ ocrStr: ocrRawArr, pageDims });
    for (let n2 = 0; n2 < res.length; n2++) {
      await convertPageCallback(res[n2], n2, mainData, engineName);
    }
    return;
  }
  if (format === "azure_doc_intel") {
    if (!pageMetrics || !pageMetrics[0]?.dims) throw new Error("Page metrics must be provided for Azure Document Intelligence data.");
    const pageDims = pageMetrics.map((metrics) => metrics.dims);
    const res = await gs.convertDocAzureDocIntel({ ocrStr: ocrRawArr, pageDims });
    for (let n2 = 0; n2 < res.length; n2++) {
      await convertPageCallback(res[n2], n2, mainData, engineName);
    }
    return;
  }
  if (format === "text") {
    const res = await gs.convertPageText({ textStr: ocrRawArr[0] });
    if (res.length > inputData.pageCount) inputData.pageCount = res.length;
    for (let i2 = 0; i2 < res.length; i2++) {
      if (!layoutRegions.pages[i2]) layoutRegions.pages[i2] = new LayoutPage(i2);
    }
    for (let i2 = 0; i2 < res.length; i2++) {
      if (!layoutDataTables.pages[i2]) layoutDataTables.pages[i2] = new LayoutDataTablePage(i2);
    }
    for (let n2 = 0; n2 < res.length; n2++) {
      await convertPageCallback(res[n2], n2, mainData, engineName);
    }
    return;
  }
  for (let n2 = 0; n2 < ocrRawArr.length; n2++) {
    promiseArr.push(convertOCRPage(ocrRawArr[n2], n2, mainData, format, engineName, scribeMode));
  }
  await Promise.all(promiseArr);
}
async function recognizeAllPages(legacy = true, lstm = true, mainData = false, langs = ["eng"], vanillaMode = false, config2 = {}) {
  if (inputData.pdfMode) await ImageCache.preRenderRange(0, ImageCache.pageCount - 1, false);
  if (legacy) {
    const oemText = "Tesseract Legacy";
    if (!ocrAll[oemText]) ocrAll[oemText] = Array(inputData.pageCount);
    ocrAll.active = ocrAll[oemText];
  }
  if (lstm) {
    const oemText = "Tesseract LSTM";
    if (!ocrAll[oemText]) ocrAll[oemText] = Array(inputData.pageCount);
    ocrAll.active = ocrAll[oemText];
  }
  {
    const oemText = "Tesseract Latest";
    if (!ocrAll[oemText]) ocrAll[oemText] = Array(inputData.pageCount);
    ocrAll.active = ocrAll[oemText];
  }
  await gs.initTesseract({
    anyOk: false,
    vanillaMode,
    langs,
    config: config2
  });
  const inputPages = [...Array(ImageCache.pageCount).keys()];
  const promisesA = [];
  const resolvesA = [];
  const promisesB = [];
  const resolvesB = [];
  for (let i2 = 0; i2 < inputPages.length; i2++) {
    promisesA.push(new Promise((resolve, reject) => {
      resolvesA[i2] = { resolve, reject };
    }));
    promisesB.push(new Promise((resolve, reject) => {
      resolvesB[i2] = { resolve, reject };
    }));
  }
  const upscale = inputData.imageMode && opt.enableUpscale;
  const configPage = { upscale };
  for (const x2 of inputPages) {
    recognizePageImp(x2, legacy, lstm, false, configPage, opt.debugVis).then(async (resArr) => {
      const res0 = await resArr[0];
      if (res0.recognize.debugVis) {
        const { ScrollView: ScrollView2 } = await Promise.resolve().then(() => (init_ScrollView(), ScrollView_exports));
        const sv = new ScrollView2({
          lightTheme: true,
          CanvasKit: ca.CanvasKit
        });
        await sv.processVisStr(res0.recognize.debugVis);
        visInstructions[x2] = await sv.getAll(true);
      }
      if (legacy) {
        await convertPageCallback(res0.convert.legacy, x2, mainData, "Tesseract Legacy");
        resolvesA[x2].resolve();
      } else if (lstm) {
        await convertPageCallback(res0.convert.lstm, x2, false, "Tesseract LSTM");
        resolvesA[x2].resolve();
      }
      if (legacy && lstm) {
        (async () => {
          const res1 = await resArr[1];
          await convertPageCallback(res1.convert.lstm, x2, false, "Tesseract LSTM");
          resolvesB[x2].resolve();
        })();
      }
    });
  }
  await Promise.all(promisesA);
  if (mainData) {
    await checkCharWarn(convertPageWarn);
  }
  if (legacy && lstm) await Promise.all(promisesB);
  if (lstm) {
    const oemText = "Tesseract LSTM";
    ocrAll.active = ocrAll[oemText];
  } else {
    const oemText = "Tesseract Legacy";
    ocrAll.active = ocrAll[oemText];
  }
}
async function recognize(options = {}) {
  if (!inputData.pdfMode && !inputData.imageMode) throw new Error("No PDF or image data found to recognize.");
  await gs.getGeneralScheduler();
  const combineMode = options && options.combineMode ? options.combineMode : "data";
  const vanillaMode = options && options.vanillaMode !== void 0 ? options.vanillaMode : false;
  const config2 = options && options.config ? options.config : {};
  const langs = options && options.langs ? options.langs : ["eng"];
  let oemMode = "combined";
  if (options && options.modeAdv) {
    oemMode = options.modeAdv;
  } else if (options && options.mode) {
    oemMode = options.mode === "speed" ? "lstm" : "legacy";
  }
  const fontPromiseArr = [];
  if (langs.includes("chi_sim")) fontPromiseArr.push(loadChiSimFont());
  if (langs.includes("rus") || langs.includes("ukr") || langs.includes("ell")) fontPromiseArr.push(loadBuiltInFontsRaw("all"));
  await Promise.all(fontPromiseArr);
  let forceMainData = false;
  let existingOCR;
  if (ocrAll["User Upload"]) {
    existingOCR = ocrAll["User Upload"];
  } else if (ocrAll.pdf && (inputData.pdfType === "text" && opt.usePDFText.native.supp || inputData.pdfType === "ocr" && opt.usePDFText.ocr.supp)) {
    existingOCR = ocrAll.pdf;
    forceMainData = ocrAll.pdf !== ocrAll.active;
  }
  if (oemMode === "legacy" || oemMode === "lstm") {
    await recognizeAllPages(oemMode === "legacy", oemMode === "lstm", !existingOCR, langs, vanillaMode, config2);
    if (oemMode === "legacy") {
      const charMetrics = calcCharMetricsFromPages(ocrAll["Tesseract Legacy"]);
      if (Object.keys(charMetrics).length > 0) {
        clearObjectProperties(FontCont.state.charMetrics);
        Object.assign(FontCont.state.charMetrics, charMetrics);
      }
      await runFontOptimization(ocrAll["Tesseract Legacy"]);
    }
  } else if (oemMode === "combined") {
    await recognizeAllPages(true, true, !existingOCR, langs, vanillaMode, config2);
    if (opt.saveDebugImages) {
      DebugData.debugImg.Combined = new Array(ImageCache.pageCount);
      for (let i2 = 0; i2 < ImageCache.pageCount; i2++) {
        DebugData.debugImg.Combined[i2] = [];
      }
    }
    if (existingOCR) {
      const oemText2 = "Tesseract Combined";
      if (!ocrAll[oemText2]) ocrAll[oemText2] = Array(inputData.pageCount);
      ocrAll.active = ocrAll[oemText2];
      if (opt.saveDebugImages) {
        DebugData.debugImg["Tesseract Combined"] = new Array(ImageCache.pageCount);
        for (let i2 = 0; i2 < ImageCache.pageCount; i2++) {
          DebugData.debugImg["Tesseract Combined"][i2] = [];
        }
      }
    }
    if (!ocrAll["Tesseract Combined Temp"]) ocrAll["Tesseract Combined Temp"] = Array(inputData.pageCount);
    {
      const compOptions = {
        mode: "comb",
        evalConflicts: false,
        legacyLSTMComb: true
      };
      const res = await compareOCR(ocrAll["Tesseract Legacy"], ocrAll["Tesseract LSTM"], compOptions);
      clearObjectProperties(ocrAll["Tesseract Combined Temp"]);
      Object.assign(ocrAll["Tesseract Combined Temp"], res.ocr);
    }
    const pageNum = Math.min(ImageCache.pageCount - 1, 5);
    await ImageCache.preRenderRange(0, pageNum, true);
    const charMetrics = calcCharMetricsFromPages(ocrAll["Tesseract Combined Temp"]);
    if (Object.keys(charMetrics).length > 0) {
      clearObjectProperties(FontCont.state.charMetrics);
      Object.assign(FontCont.state.charMetrics, charMetrics);
    }
    await runFontOptimization(ocrAll["Tesseract Combined Temp"]);
    const oemText = "Combined";
    if (!ocrAll[oemText]) ocrAll[oemText] = Array(inputData.pageCount);
    ocrAll.active = ocrAll[oemText];
    {
      const tessCombinedLabel = existingOCR ? "Tesseract Combined" : "Combined";
      const compOptions = {
        mode: "comb",
        debugLabel: opt.saveDebugImages ? tessCombinedLabel : void 0,
        ignoreCap: opt.ignoreCap,
        ignorePunct: opt.ignorePunct,
        confThreshHigh: opt.confThreshHigh,
        confThreshMed: opt.confThreshMed,
        legacyLSTMComb: true
      };
      const res = await compareOCR(ocrAll["Tesseract Legacy"], ocrAll["Tesseract LSTM"], compOptions);
      if (DebugData.debugImg[tessCombinedLabel]) DebugData.debugImg[tessCombinedLabel] = res.debug;
      clearObjectProperties(ocrAll[tessCombinedLabel]);
      Object.assign(ocrAll[tessCombinedLabel], res.ocr);
    }
    if (existingOCR) {
      if (combineMode === "conf") {
        const compOptions = {
          debugLabel: opt.saveDebugImages ? "Combined" : void 0,
          supplementComp: true,
          ignoreCap: opt.ignoreCap,
          ignorePunct: opt.ignorePunct,
          confThreshHigh: opt.confThreshHigh,
          confThreshMed: opt.confThreshMed,
          editConf: true
        };
        const res = await compareOCR(existingOCR, ocrAll["Tesseract Combined"], compOptions);
        if (DebugData.debugImg.Combined) DebugData.debugImg.Combined = res.debug;
        clearObjectProperties(ocrAll.Combined);
        Object.assign(ocrAll.Combined, res.ocr);
      } else if (combineMode === "data") {
        const compOptions = {
          mode: "comb",
          debugLabel: "Combined",
          ignoreCap: opt.ignoreCap,
          ignorePunct: opt.ignorePunct,
          confThreshHigh: opt.confThreshHigh,
          confThreshMed: opt.confThreshMed,
          // If the existing data was invisible OCR text extracted from a PDF, it is assumed to not have accurate bounding boxes.
          useBboxB: !forceMainData && existingOCR === ocrAll.pdf && inputData.pdfMode && !!inputData.pdfType && ["image", "ocr"].includes(inputData.pdfType)
        };
        let res;
        if (forceMainData) {
          res = await compareOCR(ocrAll["Tesseract Combined"], existingOCR, compOptions);
        } else {
          res = await compareOCR(existingOCR, ocrAll["Tesseract Combined"], compOptions);
        }
        if (DebugData.debugImg.Combined) DebugData.debugImg.Combined = res.debug;
        clearObjectProperties(ocrAll.Combined);
        Object.assign(ocrAll.Combined, res.ocr);
      }
    }
  }
  return ocrAll.active;
}
var calcEvalStatsDoc = (evalStatsArr) => {
  const evalStatsDoc = {
    total: 0,
    correct: 0,
    incorrect: 0,
    missed: 0,
    extra: 0,
    correctLowConf: 0,
    incorrectHighConf: 0
  };
  for (let i2 = 0; i2 < evalStatsArr.length; i2++) {
    evalStatsDoc.total += evalStatsArr[i2].total;
    evalStatsDoc.correct += evalStatsArr[i2].correct;
    evalStatsDoc.incorrect += evalStatsArr[i2].incorrect;
    evalStatsDoc.missed += evalStatsArr[i2].missed;
    evalStatsDoc.extra += evalStatsArr[i2].extra;
    evalStatsDoc.correctLowConf += evalStatsArr[i2].correctLowConf;
    evalStatsDoc.incorrectHighConf += evalStatsArr[i2].incorrectHighConf;
  }
  return evalStatsDoc;
};

// node_modules/scribe.js-ocr/js/extractPDFText.js
var extractInternalPDFTextRaw = async () => {
  const muPDFScheduler = await ImageCache.getMuPDFScheduler();
  const pdfContentStats = {
    /** Total number of letters in the source PDF. */
    letterCountTotal: 0,
    /** Total number of visible letters in the source PDF. */
    letterCountVis: 0,
    /** Total number of pages with 100+ letters in the source PDF. */
    pageCountTotalText: 0,
    /** Total number of pages with 100+ visible letters in the source PDF. */
    pageCountVisText: 0
  };
  const stextArr = (
    /** @type {Array<string>} */
    []
  );
  const pageDPI = ImageCache.pdfDims300.map((x2) => 300 * Math.min(x2.width, 3500) / x2.width);
  const resArr = pageDPI.map(async (x2, i2) => {
    const res = await muPDFScheduler.pageText({
      page: i2 + 1,
      dpi: x2,
      format: "xml",
      calcStats: true
    });
    pdfContentStats.letterCountTotal += res.letterCountTotal;
    pdfContentStats.letterCountVis += res.letterCountVis;
    if (res.letterCountTotal >= 100) pdfContentStats.pageCountTotalText++;
    if (res.letterCountVis >= 100) pdfContentStats.pageCountVisText++;
    stextArr[i2] = res.content;
  });
  await Promise.all(resArr);
  let type = "image";
  {
    if (pdfContentStats.letterCountTotal >= ImageCache.pageCount * 100 && pdfContentStats.letterCountVis >= pdfContentStats.letterCountTotal * 0.9 && pdfContentStats.pageCountVisText >= ImageCache.pageCount / 2) {
      type = "text";
    } else if (pdfContentStats.letterCountTotal >= ImageCache.pageCount * 100 && pdfContentStats.pageCountTotalText >= ImageCache.pageCount / 2) {
      type = "ocr";
    } else {
      type = "image";
    }
  }
  return { contentRaw: stextArr, content: (
    /** @type {?Array<OcrPage>} */
    null
  ), type };
};
var extractInternalPDFText = async () => {
  const extractPDFTextNative = opt.usePDFText.native.main || opt.usePDFText.native.supp;
  const extractPDFTextOCR = opt.usePDFText.ocr.main || opt.usePDFText.ocr.supp;
  const res = await extractInternalPDFTextRaw();
  inputData.pdfType = res.type;
  ocrAllRaw.pdf = res.contentRaw;
  if (!opt.keepPDFTextAlways) {
    if (!extractPDFTextOCR && res.type === "ocr") return res;
    if (!extractPDFTextNative && res.type === "text") return res;
  }
  ocrAll.pdf = Array(ImageCache.pageCount);
  if (inputData.pdfType === "text" && opt.usePDFText.native.main || inputData.pdfType === "ocr" && opt.usePDFText.ocr.main) {
    ocrAllRaw.active = ocrAllRaw.pdf;
    ocrAll.active = ocrAll.pdf;
  }
  const format = "stext";
  await convertOCR(ocrAllRaw.pdf, true, format, "pdf", false);
  res.content = ocrAll.pdf;
  return res;
};

// node_modules/scribe.js-ocr/scribe.js
init_extractTables();

// node_modules/scribe.js-ocr/js/import/import.js
init_app();
init_dataContainer();

// node_modules/scribe.js-ocr/js/fontSupp.js
init_ocrObjects();
init_miscUtils();
var calcSuppFontInfoForWords = async (words) => {
  let sansVotes = 0;
  let serifVotes = 0;
  let fontSizeMult = null;
  const rect0 = calcBboxUnion(words.map((word) => word.bbox));
  const rect = {
    left: rect0.left,
    top: rect0.top,
    width: rect0.right - rect0.left,
    height: rect0.bottom - rect0.top
  };
  if (rect.width < 5 || rect.height < 5) return { sansVotes, serifVotes, fontSizeMult };
  const legacy = true;
  const lstm = false;
  let pageNew;
  try {
    const res0 = await recognizePageImp(words[0].line.page.n, legacy, lstm, true, { rectangle: rect, tessedit_pageseg_mode: "6" });
    const resLegacy = await res0[0];
    pageNew = resLegacy.convert.legacy.pageObj;
  } catch {
    return { sansVotes, serifVotes, fontSizeMult };
  }
  const wordsRes = ocrObjects_default.getPageWords(pageNew);
  const fontSizeArr = [];
  for (const word of wordsRes) {
    fontSizeArr.push(calcWordFontSize(word));
    const sansSerif = determineSansSerif(word.style.font);
    if (sansSerif !== "Default") {
      if (sansSerif === "SansDefault") {
        sansVotes++;
      } else {
        serifVotes++;
      }
    }
  }
  if (words[0].style.size) {
    fontSizeMult = quantile(fontSizeArr, 0.5) / words[0].style.size;
  }
  return { sansVotes, serifVotes, fontSizeMult };
};
var calcSuppFontInfo = async (ocrArr) => {
  if (!ocrArr) return;
  await gs.initTesseract({ anyOk: true, langs: ["eng"] });
  const calcFonts = /* @__PURE__ */ new Set();
  const skipFonts = /* @__PURE__ */ new Set();
  const fontExamples = {};
  for (const page of ocrArr) {
    for (const line of page.lines) {
      let wordFontLast;
      let wordFontSizeLast;
      for (const word of line.words) {
        if (word.style.font) {
          if (skipFonts.has(word.style.font)) {
            continue;
          } else if (word.bbox.left < 0 || word.bbox.top < 0 || word.bbox.right > page.dims.width || word.bbox.bottom > page.dims.height) {
            continue;
          } else if (!calcFonts.has(word.style.font)) {
            const sansSerifUnknown = determineSansSerif(word.style.font) === "Default";
            if (sansSerifUnknown || !word.visualCoords) {
              calcFonts.add(word.style.font);
            } else {
              skipFonts.add(word.style.font);
              continue;
            }
          }
          if (!fontExamples[word.style.font]) {
            fontExamples[word.style.font] = [];
          } else if (fontExamples[word.style.font].length > 3) {
            continue;
          }
          if (word.style.font !== wordFontLast || word.style.size !== wordFontSizeLast) {
            fontExamples[word.style.font].push([word]);
          } else {
            fontExamples[word.style.font][fontExamples[word.style.font].length - 1].push(word);
          }
          wordFontLast = word.style.font;
          wordFontSizeLast = word.style.size;
        }
      }
    }
  }
  const resPromises = {};
  for (const [key, value] of Object.entries(fontExamples)) {
    if (value.length < 3) continue;
    resPromises[key] = [];
    for (let i2 = 0; i2 < value.length; i2++) {
      resPromises[key].push(calcSuppFontInfoForWords(value[i2]));
    }
  }
  for (const [key, value] of Object.entries(resPromises)) {
    const resArr = await Promise.all(value);
    let sansVotes = 0;
    let serifVotes = 0;
    const fontSizeMultArr = [];
    for (const res of resArr) {
      if (res.sansVotes) sansVotes += res.sansVotes;
      if (res.serifVotes) serifVotes += res.serifVotes;
      if (res.fontSizeMult) {
        fontSizeMultArr.push(res.fontSizeMult);
      }
    }
    if (fontSizeMultArr.length >= 3) {
      const fontSizeMult = quantile(fontSizeMultArr, 0.5);
      if (fontSizeMult && fontSizeMult > 0.9 && fontSizeMult < 1.5) FontProps.sizeMult[key] = fontSizeMult;
    }
    if (serifVotes > sansVotes) {
      FontProps.serifFontsDoc.add(key);
    } else {
      FontProps.sansFontsDoc.add(key);
    }
  }
  if (Object.keys(FontProps.sizeMult).length === 0) return;
  for (const page of ocrArr) {
    for (const line of page.lines) {
      for (const word of line.words) {
        if (word.style.font && word.style.size && FontProps.sizeMult[word.style.font]) {
          word.style.size = Math.round(word.style.size * FontProps.sizeMult[word.style.font] * 1e3) / 1e3;
        }
      }
    }
  }
};

// node_modules/scribe.js-ocr/js/import/import.js
init_ocrObjects();
init_miscUtils();

// node_modules/scribe.js-ocr/js/import/importOCR.js
init_miscUtils();
var splitHOCRStr = (hocrStrAll) => hocrStrAll.replace(/[\s\S]*?<body>/, "").replace(/<\/body>[\s\S]*$/, "").replace(/<\/body>[\s\S]*$/, "").trim().split(/(?=<div class=['"]ocr_page['"])/);
var detectOcrFormat = (ocrStr, ext) => {
  if (ext) {
    ext = ext.replace(/^\./, "").toLowerCase();
    if (ext === "hocr") {
      return "hocr";
    }
    if (ext === "stext") {
      return "stext";
    }
  }
  const node2 = ocrStr.match(/>([^>]+)/)?.[1];
  if (!!node2 && !!/abbyy/i.test(node2)) {
    return "abbyy";
  }
  if (!!node2 && !!/<document name/.test(node2)) {
    return "stext";
  }
  if (!node2 && !!/"DetectDocumentTextModelVersion"/i.test(ocrStr)) {
    return "textract";
  }
  if (!node2 && !!/"AnalyzeDocumentModelVersion"/i.test(ocrStr)) {
    return "textract";
  }
  if (!node2 && !!/"pages"/i.test(ocrStr) && !!/"fullTextAnnotation"/i.test(ocrStr)) {
    return "google_vision";
  }
  if (/"createdDateTime"/i.test(ocrStr) && /"analyzeResult"/i.test(ocrStr) && /"modelId"/i.test(ocrStr)) {
    return "azure_doc_intel";
  }
  if (!!node2 && !!/class=['"]ocr_page['"]/i.test(ocrStr) || !!/<\?xml version/i.test(ocrStr)) {
    return "hocr";
  }
  if (ext && ext.toLowerCase() === "txt") {
    return "text";
  }
  return null;
};
async function importOCRFiles(ocrFilesAll) {
  const singleHOCRMode = ocrFilesAll.length === 1;
  let hocrStrStart = null;
  let format = null;
  let reimportHocrMode = false;
  let pageCountHOCR;
  let hocrRaw;
  let charMetricsObj;
  let layoutObj = null;
  let layoutDataTableObj = null;
  let defaultFont;
  let enableOpt;
  let sansFont;
  let serifFont;
  if (singleHOCRMode) {
    const hocrStrAll = await readOcrFile(ocrFilesAll[0]);
    format = detectOcrFormat(hocrStrAll, ocrFilesAll[0]?.name?.split(".").pop());
    if (!format) {
      console.error(ocrFilesAll[0]);
      throw new Error("No supported OCR format detected.");
    }
    if (format === "textract") {
      hocrRaw = [hocrStrAll];
    } else if (format === "google_vision") {
      hocrRaw = [hocrStrAll];
      if (hocrStrAll.substring(0, 500).includes('"responses"')) {
        const responses = JSON.parse(hocrStrAll).responses;
        hocrRaw = responses.sort((a2, b2) => a2.context.pageNumber - b2.context.pageNumber).map((resp) => JSON.stringify(resp));
      }
    } else if (format === "azure_doc_intel") {
      hocrRaw = [hocrStrAll];
    } else if (format === "abbyy") {
      hocrRaw = hocrStrAll.split(/(?=<page)/).slice(1);
    } else if (format === "stext") {
      hocrRaw = hocrStrAll.split(/(?=<page)/).slice(1);
    } else if (format === "text") {
      hocrRaw = [hocrStrAll];
    } else if (format === "hocr") {
      hocrStrStart = hocrStrAll.match(/[\s\S]*?<body>/)?.[0];
      hocrRaw = splitHOCRStr(hocrStrAll);
    }
    pageCountHOCR = hocrRaw.length;
  } else {
    pageCountHOCR = ocrFilesAll.length;
    hocrRaw = Array(pageCountHOCR);
    const hocrStrFirst = await readOcrFile(ocrFilesAll[0]);
    format = detectOcrFormat(hocrStrFirst, ocrFilesAll[0]?.name?.split(".").pop());
    if (!format) {
      console.error(ocrFilesAll[0]);
      throw new Error("No supported OCR format detected.");
    }
    for (let i2 = 0; i2 < pageCountHOCR; i2++) {
      const hocrFile = ocrFilesAll[i2];
      hocrRaw[i2] = await readOcrFile(hocrFile);
    }
  }
  if (format === "hocr" && hocrStrStart) {
    const getMeta = (name) => {
      const regex = new RegExp(`<meta name=["']${name}["'][^<]+`, "i");
      const nodeStr = hocrStrStart.match(regex)?.[0];
      if (!nodeStr) return null;
      const contentStr = nodeStr.match(/content=["']([\s\S]+?)(?=["']\s{0,5}\/?>)/i)?.[1];
      if (!contentStr) return null;
      return contentStr.replace(/&quot;/g, '"');
    };
    const ocrSystem = getMeta("ocr-system");
    reimportHocrMode = ocrSystem === "scribeocr";
    if (singleHOCRMode) {
      const charMetricsStr = getMeta("font-metrics");
      if (charMetricsStr) {
        charMetricsObj = /** @type  {Object.<string, CharMetricsFamily>} */
        JSON.parse(charMetricsStr);
        for (const key in charMetricsObj) {
          if (charMetricsObj[key]["small-caps"] && !charMetricsObj[key].smallCaps) charMetricsObj[key].smallCaps = charMetricsObj[key]["small-caps"];
        }
      }
      const layoutStr = getMeta("layout");
      if (layoutStr) layoutObj = /** @type {LayoutPage} */
      JSON.parse(layoutStr);
      const layoutDataTableStr = getMeta("layout-data-table");
      if (layoutDataTableStr) {
        layoutDataTableObj = JSON.parse(layoutDataTableStr);
        addCircularRefsDataTables(layoutDataTableObj);
      }
      const enableOptStr = getMeta("enable-opt");
      if (enableOptStr) enableOpt = enableOptStr;
    }
    const defaultFontStr = getMeta("default-font");
    if (defaultFontStr) defaultFont = defaultFontStr;
    const sansFontStr = getMeta("sans-font");
    if (sansFontStr) sansFont = sansFontStr;
    let serifFontStr = getMeta("serif-font");
    if (serifFontStr && serifFontStr === "NimbusRomNo9L") serifFontStr = "NimbusRoman";
    if (serifFontStr) serifFont = serifFontStr;
  }
  const fontState = {
    enableOpt: enableOpt !== void 0 ? enableOpt === "true" || enableOpt === "1" : void 0,
    serifDefaultName: serifFont,
    sansDefaultName: sansFont,
    defaultFontName: defaultFont,
    charMetrics: charMetricsObj
  };
  return {
    hocrRaw,
    layoutObj,
    fontState,
    layoutDataTableObj,
    format,
    reimportHocrMode
  };
}

// node_modules/scribe.js-ocr/js/import/import.js
async function standardizeFiles(files) {
  if (typeof files[0] === "string") {
    if (typeof process !== "undefined") {
      const { wrapFilesNode: wrapFilesNode2 } = await Promise.resolve().then(() => (init_nodeAdapter(), nodeAdapter_exports));
      return wrapFilesNode2(
        /** @type {Array<string>} */
        files
      );
    }
    const blobPromises = files.map((url) => fetch(url).then((response) => {
      if (!response.ok) {
        console.log(response);
        throw new Error(`Failed to fetch ${url}: ${response.statusText}`);
      }
      return response.blob().then((blob) => ({ blob, url }));
    }));
    const blobsAndUrls = await Promise.all(blobPromises);
    return blobsAndUrls.map(({ blob, url }) => {
      const fileName = url.split("/").pop();
      if (!fileName) throw new Error(`Failed to extract file name from URL: ${url}`);
      return new File([blob], fileName, { type: blob.type });
    });
  }
  if (globalThis.FileList && files instanceof FileList) {
    return Array.from(files);
  }
  return (
    /** @type {Array<File>} */
    files
  );
}
async function sortInputFiles(files) {
  const imageFilesAll = [];
  const ocrFilesAll = [];
  const pdfFilesAll = [];
  const scribeFilesAll = [];
  const unsupportedFilesAll = [];
  const unsupportedExt = {};
  for (let i2 = 0; i2 < files.length; i2++) {
    const file = files[i2];
    const fileExt = file.name.match(/\.([^.]+)$/)?.[1].toLowerCase() || "";
    if (["png", "jpeg", "jpg"].includes(fileExt)) {
      imageFilesAll.push(file);
    } else if (["hocr", "xml", "html", "gz", "stext", "json", "txt"].includes(fileExt)) {
      ocrFilesAll.push(file);
    } else if (["scribe"].includes(fileExt)) {
      scribeFilesAll.push(file);
    } else if (["pdf"].includes(fileExt)) {
      pdfFilesAll.push(file);
    } else {
      if ([""].includes(fileExt)) {
        try {
          const content = await readOcrFile(file);
          if (/"AnalyzeDocumentModelVersion"/i.test(content)) {
            ocrFilesAll.push(file);
            continue;
          }
        } catch (error) {
        }
      }
      unsupportedFilesAll.push(file);
      unsupportedExt[fileExt] = true;
    }
  }
  if (unsupportedFilesAll.length > 0) {
    const errorText = `Import includes unsupported file types: ${Object.keys(unsupportedExt).join(", ")}`;
    opt.warningHandler(errorText);
  }
  imageFilesAll.sort((a2, b2) => a2.name > b2.name ? 1 : b2.name > a2.name ? -1 : 0);
  ocrFilesAll.sort((a2, b2) => a2.name > b2.name ? 1 : b2.name > a2.name ? -1 : 0);
  return {
    pdfFiles: pdfFilesAll,
    imageFiles: imageFilesAll,
    ocrFiles: ocrFilesAll,
    scribeFiles: scribeFilesAll
  };
}
async function importFiles(files) {
  if (!files) throw new Error("No files provided.");
  clearData();
  gs.getGeneralScheduler();
  let pdfFiles = [];
  let imageFiles = [];
  let ocrFiles = [];
  let scribeFiles = [];
  if ("pdfFiles" in files || "imageFiles" in files || "ocrFiles" in files || "scribeFiles" in files) {
    if (files.pdfFiles && files.pdfFiles[0] instanceof ArrayBuffer) {
      pdfFiles = files.pdfFiles;
    } else if (files.pdfFiles) {
      pdfFiles = await standardizeFiles(files.pdfFiles);
    }
    if (files.imageFiles && files.imageFiles[0] instanceof ArrayBuffer) {
      imageFiles = files.imageFiles;
    } else if (files.imageFiles) {
      imageFiles = await standardizeFiles(files.imageFiles);
    }
    if (files.ocrFiles && files.ocrFiles[0] instanceof ArrayBuffer) {
      ocrFiles = files.ocrFiles;
    } else if (files.ocrFiles) {
      ocrFiles = await standardizeFiles(files.ocrFiles);
    }
    if (files.scribeFiles && files.scribeFiles[0] instanceof ArrayBuffer) {
      scribeFiles = files.scribeFiles;
    } else if (files.scribeFiles) {
      scribeFiles = await standardizeFiles(files.scribeFiles);
    }
  } else {
    const filesStand = await standardizeFiles(files);
    if (files[0] instanceof ArrayBuffer) throw new Error("ArrayBuffer inputs must be sorted by file type.");
    ({
      pdfFiles,
      imageFiles,
      ocrFiles,
      scribeFiles
    } = await sortInputFiles(filesStand));
  }
  if (pdfFiles.length === 0 && imageFiles.length === 0 && ocrFiles.length === 0 && scribeFiles.length === 0) {
    const errorText = "No supported files found.";
    opt.errorHandler(errorText);
    return;
  }
  if (pdfFiles.length > 0 && imageFiles.length > 0) {
    const errorText = "PDF and image files cannot be imported together. Only first PDF file will be imported.";
    opt.warningHandler(errorText);
    pdfFiles.length = 1;
    imageFiles.length = 0;
  } else if (pdfFiles.length > 1) {
    const errorText = "Multiple PDF files are not supported. Only first PDF file will be imported.";
    opt.warningHandler(errorText);
    pdfFiles.length = 1;
    imageFiles.length = 0;
  }
  if (pdfFiles[0] && !(pdfFiles[0] instanceof ArrayBuffer)) {
    inputData.inputFileNames = [pdfFiles[0].name];
  } else if (imageFiles[0] && !(imageFiles[0] instanceof ArrayBuffer)) {
    inputData.inputFileNames = imageFiles.map((x2) => x2.name);
  }
  if (pdfFiles.length > 0 && "name" in pdfFiles[0]) {
    inputData.defaultDownloadFileName = `${pdfFiles[0].name.replace(/\.\w{1,6}$/, "")}.pdf`;
  } else if (imageFiles.length > 0 && "name" in imageFiles[0]) {
    inputData.defaultDownloadFileName = `${imageFiles[0].name.replace(/\.\w{1,6}$/, "")}.pdf`;
  } else if (ocrFiles.length > 0 && "name" in ocrFiles[0]) {
    inputData.defaultDownloadFileName = `${ocrFiles[0].name.replace(/\.\w{1,6}$/, "")}.pdf`;
  } else if (scribeFiles.length > 0 && "name" in scribeFiles[0]) {
    inputData.defaultDownloadFileName = `${scribeFiles[0].name.replace(/\.\w{1,6}$/, "")}.pdf`;
  }
  let existingLayout = false;
  let existingLayoutDataTable = false;
  inputData.pdfMode = pdfFiles.length === 1;
  inputData.imageMode = !!(imageFiles.length > 0 && !inputData.pdfMode);
  ImageCache.inputModes.image = !!(imageFiles.length > 0 && !inputData.pdfMode);
  if (scribeFiles.length > 0) {
    const scribeRestoreStr = await readOcrFile(scribeFiles[0]);
    const scribeRestoreObj = JSON.parse(scribeRestoreStr);
    if (scribeRestoreObj.fontState) {
      objectAssignDefined(FontCont.state, scribeRestoreObj.fontState);
      await runFontOptimization(ocrAll.active);
    }
    if (scribeRestoreObj.layoutRegions) {
      existingLayout = true;
      layoutRegions.pages = scribeRestoreObj.layoutRegions;
    }
    if (scribeRestoreObj.layoutDataTables) {
      existingLayoutDataTable = true;
      addCircularRefsDataTables(scribeRestoreObj.layoutDataTables);
      layoutDataTables.pages = scribeRestoreObj.layoutDataTables;
    }
    const oemName2 = "User Upload";
    if (!ocrAll[oemName2]) ocrAll[oemName2] = Array(inputData.pageCount);
    addCircularRefsOcr(scribeRestoreObj.ocr);
    ocrAll[oemName2] = scribeRestoreObj.ocr;
    ocrAll.active = ocrAll[oemName2];
    for (let i2 = 0; i2 < ocrAll[oemName2].length; i2++) {
      inputData.xmlMode[i2] = true;
      if (ocrAll[oemName2][i2].dims.height && ocrAll[oemName2][i2].dims.width) {
        pageMetricsAll[i2] = new PageMetrics(ocrAll[oemName2][i2].dims);
      }
      pageMetricsAll[i2].angle = ocrAll[oemName2][i2].angle;
    }
  }
  const xmlModeImport = ocrFiles.length > 0;
  let pageCount;
  let pageCountImage;
  let format;
  let reimportHocrMode = false;
  if (inputData.pdfMode) {
    const pdfFile = pdfFiles[0];
    ImageCache.getMuPDFScheduler();
    ImageCache.pdfData = pdfFile instanceof ArrayBuffer ? pdfFile : await pdfFile.arrayBuffer();
    await ImageCache.openMainPDF(ImageCache.pdfData, opt.omitNativeText);
    pageCountImage = ImageCache.pageCount;
    ImageCache.loadCount = ImageCache.pageCount;
  } else if (inputData.imageMode) {
    pageCountImage = imageFiles.length;
  }
  let existingOpt = false;
  const oemName = "User Upload";
  if (xmlModeImport) {
    if (!ocrAll[oemName]) ocrAll[oemName] = Array(inputData.pageCount);
    ocrAll.active = ocrAll[oemName];
    const ocrData = await importOCRFiles(Array.from(ocrFiles));
    format = /** @type {("hocr" | "abbyy" | "stext" | "textract" | "text")} */
    ocrData.format;
    if (format === "text") {
      await loadBuiltInFontsRaw();
    }
    ocrAllRaw.active = ocrData.hocrRaw;
    if (pageCountImage && ocrAllRaw.active.length > pageCountImage && ocrData.format !== "textract") {
      console.log(`Identified ${ocrAllRaw.active.length} pages of OCR data but ${pageCountImage} pages of image/pdf data. Only first ${pageCountImage} pages will be used.`);
      ocrAllRaw.active = ocrAllRaw.active.slice(0, pageCountImage);
    }
    objectAssignDefined(FontCont.state, ocrData.fontState);
    if (ocrData.fontState.charMetrics && Object.keys(ocrData.fontState.charMetrics).length > 0) {
      const fontPromise = loadBuiltInFontsRaw();
      existingOpt = true;
      await gs.schedulerReady;
      setDefaultFontAuto(FontCont.state.charMetrics);
      if (ocrData.enableOpt === "false") {
        FontCont.state.enableOpt = false;
      } else {
        await fontPromise;
        if (!FontCont.raw) throw new Error("Raw font data not found.");
        FontCont.opt = await optimizeFontContainerAll(FontCont.raw, FontCont.state.charMetrics);
        FontCont.state.enableOpt = true;
        await enableFontOpt(true);
      }
    }
    if (ocrData.layoutObj) {
      for (let i2 = 0; i2 < ocrData.layoutObj.length; i2++) {
        layoutRegions.pages[i2] = ocrData.layoutObj[i2];
      }
      existingLayout = true;
    }
    if (ocrData.layoutDataTableObj) {
      for (let i2 = 0; i2 < ocrData.layoutDataTableObj.length; i2++) {
        layoutDataTables.pages[i2] = ocrData.layoutDataTableObj[i2];
      }
      existingLayoutDataTable = true;
    }
    format = /** @type {("hocr" | "abbyy" | "stext" | "textract" | "text")} */
    ocrData.format;
    reimportHocrMode = ocrData.reimportHocrMode;
  }
  let pageCountOcr = ocrAllRaw.active?.length || ocrAll.active?.length || 0;
  if (format === "textract" && ocrAllRaw.active?.length) {
    pageCountOcr = ocrAllRaw.active[0].match(/"BLOCKTYPE":\s*"PAGE"/ig)?.length || pageCountOcr;
  }
  if (xmlModeImport && (inputData.imageMode || inputData.pdfMode)) {
    if (pageCountImage !== pageCountOcr) {
      const warningHTML = `Page mismatch detected. Image data has ${pageCountImage} pages while OCR data has ${pageCountOcr} pages.`;
      opt.warningHandler(warningHTML);
    }
  }
  inputData.pageCount = pageCountImage ?? pageCountOcr;
  ocrAllRaw.active = ocrAllRaw.active || Array(pageCount);
  if (!existingLayout) {
    for (let i2 = 0; i2 < inputData.pageCount; i2++) {
      layoutRegions.pages[i2] = new LayoutPage(i2);
    }
  }
  if (!existingLayoutDataTable) {
    for (let i2 = 0; i2 < inputData.pageCount; i2++) {
      layoutDataTables.pages[i2] = new LayoutDataTablePage(i2);
    }
  }
  if (inputData.pdfMode && !xmlModeImport) {
    opt.progressHandler({ n: 0, type: "importPDF", info: {} });
  }
  if (inputData.imageMode) {
    ImageCache.pageCount = inputData.pageCount;
    for (let i2 = 0; i2 < inputData.pageCount; i2++) {
      ImageCache.nativeSrc[i2] = await importImageFileToBase64(imageFiles[i2]).then(async (imgStr) => {
        const imgWrapper = new ImageWrapper(i2, imgStr, "native", false, false);
        const imageDims = await imageUtils.getDims(imgWrapper);
        pageMetricsAll[i2] = new PageMetrics(imageDims);
        return imgWrapper;
      });
      ImageCache.loadCount++;
      opt.progressHandler({ n: i2, type: "importImage", info: {} });
    }
  }
  if (xmlModeImport) {
    await convertOCR(ocrAllRaw.active, true, format, oemName, reimportHocrMode, pageMetricsAll).then(async () => {
      if (!existingOpt && !["stext", "textract", "google_vision", "azure_doc_intel"].includes(format)) {
        await checkCharWarn(convertPageWarn);
        const charMetrics = calcCharMetricsFromPages(ocrAll.active);
        if (Object.keys(charMetrics).length > 0) {
          clearObjectProperties(FontCont.state.charMetrics);
          Object.assign(FontCont.state.charMetrics, charMetrics);
        }
        await runFontOptimization(ocrAll.active);
      }
    });
  } else if (inputData.pdfMode && (opt.usePDFText.native.main || opt.usePDFText.native.supp || opt.usePDFText.ocr.main || opt.usePDFText.ocr.supp || opt.keepPDFTextAlways)) {
    await extractInternalPDFText();
    if (inputData.pdfType === "text" && opt.usePDFText.native.main || inputData.pdfType === "ocr" && opt.usePDFText.ocr.main) {
      if (inputData.pdfType === "text") FontCont.state.enableCleanToNimbusMono = true;
      if (opt.calcSuppFontInfo) await calcSuppFontInfo(ocrAll.pdf);
    }
  }
}
async function importFilesSupp(files, ocrName) {
  if (!files || files.length === 0) return;
  if (!ocrAll[ocrName]) ocrAll[ocrName] = Array(inputData.pageCount);
  const curFiles = await standardizeFiles(files);
  const ocrFilesAll = [];
  for (let i2 = 0; i2 < curFiles.length; i2++) ocrFilesAll.push(curFiles[i2]);
  ocrFilesAll.sort((a2, b2) => a2.name > b2.name ? 1 : b2.name > a2.name ? -1 : 0);
  const ocrData = await importOCRFiles(ocrFilesAll);
  const pageCountHOCR = ocrData.hocrRaw.length;
  if (ImageCache.pageCount > 0 && ImageCache.pageCount !== pageCountHOCR) {
    const warningHTML = `Page mismatch detected. Image data has ${ImageCache.pageCount} pages while OCR data has ${pageCountHOCR} pages.`;
    opt.warningHandler(warningHTML);
  }
  const format = (
    /** @type {("hocr" | "abbyy" | "stext" | "textract" | "text")} */
    ocrData.format
  );
  await convertOCR(ocrData.hocrRaw, false, format, ocrName, ocrData.reimportHocrMode);
}

// node_modules/scribe.js-ocr/scribe.js
init_miscUtils();
init_ocrObjects();

// node_modules/scribe.js-ocr/js/utils/ocrUtils.js
init_app();
init_ocrObjects();
init_miscUtils();
var calcConf = (pages) => {
  let wordsTotal = 0;
  let wordsHighConf = 0;
  for (let i2 = 0; i2 < pages.length; i2++) {
    const words = ocrObjects_default.getPageWords(pages[i2]);
    for (let j2 = 0; j2 < words.length; j2++) {
      const word = words[j2];
      wordsTotal += 1;
      if (word.conf > opt.confThreshHigh) wordsHighConf += 1;
    }
  }
  return { total: wordsTotal, highConf: wordsHighConf };
};
function splitOcrWord(word, splitIndex) {
  const wordA = ocrObjects_default.cloneWord(word);
  const wordB = ocrObjects_default.cloneWord(word);
  const validCharData = word.chars && word.chars.map((x2) => x2.text).join("") === word.text;
  if (wordA.chars && wordB.chars) {
    wordA.chars.splice(splitIndex);
    wordB.chars.splice(0, splitIndex);
    if (validCharData) {
      wordA.bbox = calcBboxUnion(wordA.chars.map((x2) => x2.bbox));
      wordB.bbox = calcBboxUnion(wordB.chars.map((x2) => x2.bbox));
    }
  }
  if (!validCharData) {
    const metrics = calcWordMetrics(wordA);
    wordA.bbox.right -= metrics.advanceArr.slice(splitIndex).reduce((a2, b2) => a2 + b2, 0);
    wordB.bbox.left = wordA.bbox.right;
  }
  wordA.text = wordA.text.split("").slice(0, splitIndex).join("");
  wordB.text = wordB.text.split("").slice(splitIndex).join("");
  wordA.id = `${word.id}a`;
  wordB.id = `${word.id}b`;
  return { wordA, wordB };
}
function mergeOcrWords(words) {
  words.sort((a2, b2) => a2.bbox.left - b2.bbox.left);
  const wordA = ocrObjects_default.cloneWord(words[0]);
  wordA.bbox.right = words[words.length - 1].bbox.right;
  wordA.text = words.map((x2) => x2.text).join("");
  if (wordA.chars) wordA.chars = words.flatMap((x2) => x2.chars || []);
  return wordA;
}
var checkOcrWordsAdjacent = (words) => {
  const sortedWords = words.slice().sort((a2, b2) => a2.bbox.left - b2.bbox.left);
  const lineWords = words[0].line.words;
  lineWords.sort((a2, b2) => a2.bbox.left - b2.bbox.left);
  const firstIndex = lineWords.findIndex((x2) => x2.id === sortedWords[0].id);
  const lastIndex = lineWords.findIndex((x2) => x2.id === sortedWords[sortedWords.length - 1].id);
  return lastIndex - firstIndex === sortedWords.length - 1;
};
var splitLineAgressively = (line) => {
  const linesOut = [];
  const lineHeight = line.bbox.bottom - line.bbox.top;
  let wordPrev = line.words[0];
  let lineCurrent = ocrObjects_default.cloneLine(line);
  lineCurrent.words = [line.words[0]];
  for (let i2 = 1; i2 < line.words.length; i2++) {
    const word = ocrObjects_default.cloneWord(line.words[i2]);
    if (word.bbox.left - wordPrev.bbox.right > lineHeight) {
      linesOut.push(lineCurrent);
      lineCurrent = ocrObjects_default.cloneLine(line);
      word.line = lineCurrent;
      lineCurrent.words = [word];
    } else {
      word.line = lineCurrent;
      lineCurrent.words.push(word);
    }
    wordPrev = word;
  }
  linesOut.push(lineCurrent);
  linesOut.forEach((x2) => {
    ocrObjects_default.updateLineBbox(x2);
  });
  return linesOut;
};

// node_modules/scribe.js-ocr/scribe.js
init_reflowPars();
init_writeTabular();

// node_modules/scribe.js-ocr/js/utils/detectTables.js
init_ocrObjects();
init_miscUtils();
function calcColumnBounds(boundingBoxes) {
  const tolerance = 5;
  const columnBounds = [];
  boundingBoxes.sort((a2, b2) => a2.left - b2.left);
  boundingBoxes.forEach((box) => {
    let addedToColumn = false;
    for (const column of columnBounds) {
      if (box.left <= column.right + tolerance && box.right >= column.left - tolerance) {
        column.left = Math.min(column.left, box.left);
        column.right = Math.max(column.right, box.right);
        addedToColumn = true;
        break;
      }
    }
    if (!addedToColumn) {
      columnBounds.push({
        left: box.left,
        right: box.right
      });
    }
  });
  for (let i2 = 0; i2 < columnBounds.length - 1; i2++) {
    const boundRight = (columnBounds[i2].right + columnBounds[i2 + 1].left) / 2;
    columnBounds[i2].right = boundRight;
    columnBounds[i2 + 1].left = boundRight;
  }
  return columnBounds;
}
function detectTablesInPage(ocrPage) {
  const lines = ocrObjects_default.clonePage(ocrPage).lines;
  lines.sort((a2, b2) => a2.bbox.top - b2.bbox.top);
  const rows = [];
  const rowThreshold = 10;
  lines.forEach((item) => {
    let addedToRow = false;
    for (const row of rows) {
      if (Math.abs(item.bbox.top - row.avgTop) <= rowThreshold) {
        row.items.push(item);
        row.avgTop = row.items.reduce((sum, itm) => sum + itm.bbox.top, 0) / row.items.length;
        addedToRow = true;
        break;
      }
    }
    if (!addedToRow) {
      rows.push({ avgTop: item.bbox.top, items: [item] });
    }
  });
  rows.forEach((row) => {
    row.items.sort((a2, b2) => a2.bbox.left - b2.bbox.left);
  });
  const containsNumbers = (row) => {
    let wordsNumN = 0;
    row.items.forEach((line) => {
      line.words.forEach((word) => {
        if (/[0-9]/.test(word.text)) wordsNumN++;
      });
    });
    if (wordsNumN < 4) return false;
    return true;
  };
  const splitRowLinesAgressively = (row) => {
    const row2 = { avgTop: row.avgTop, items: (
      /** @type {Array<OcrLine>} */
      []
    ) };
    row.items.forEach((line) => {
      row2.items.push(...splitLineAgressively(line));
    });
    return row2;
  };
  const hasWordOverlap = (linesA, linesB) => {
    for (let i2 = 0; i2 < linesA.length; i2++) {
      const lineI = linesA[i2];
      const lineJOverlapArr = [];
      for (let j2 = 0; j2 < linesB.length; j2++) {
        const lineJ = linesB[j2];
        if (lineI.bbox.right < lineJ.bbox.left) break;
        if (calcHorizontalOverlap(lineI.bbox, lineJ.bbox) > 0) {
          lineJOverlapArr.push(lineJ);
        }
      }
      if (lineJOverlapArr.length > 1) {
        const wordsI = lineI.words;
        const wordsJ = lineJOverlapArr.map((line) => line.words).flat();
        for (const wordI of wordsI) {
          let overlapCount = 0;
          for (const wordJ of wordsJ) {
            if (calcHorizontalOverlap(wordI.bbox, wordJ.bbox) > 0) {
              overlapCount++;
              if (overlapCount >= 2) {
                return true;
              }
            }
          }
        }
      }
    }
    return false;
  };
  const isCompat = (tableRows, row) => {
    if (!tableRows || tableRows.length === 0) return false;
    const expectedColumns = mean50(tableRows.map((x2) => x2.items.length));
    const existingLines = tableRows.map((x2) => x2.items).flat();
    if (Math.abs(expectedColumns - row.items.length) <= 1) {
      return true;
    }
    if (globalThis.testControl) return false;
    if (hasWordOverlap(existingLines, row.items) || hasWordOverlap(row.items, existingLines)) {
      return false;
    }
    return true;
  };
  const minRows = 4;
  const tables = [];
  let currentTable = [];
  let currentTableCompat = [];
  let currentTableStartIndex = 0;
  const rowsSplit = rows.map((row) => splitRowLinesAgressively(row));
  for (let i2 = 0; i2 < rowsSplit.length; i2++) {
    const rowSplit = rowsSplit[i2];
    if (containsNumbers(rowsSplit[i2])) {
      if (currentTable.length > 0) {
        if (isCompat(currentTableCompat, rowSplit)) {
          currentTable.push(rowSplit);
          currentTableCompat.push(rowSplit);
        } else if (currentTable.length >= minRows) {
          const headerRows = [];
          if (rowsSplit[currentTableStartIndex - 1] && (tables.length === 0 || !tables[tables.length - 1].includes(rowsSplit[currentTableStartIndex - 1])) && isCompat(currentTableCompat, rowsSplit[currentTableStartIndex - 1])) {
            headerRows.push(rowsSplit[currentTableStartIndex - 1]);
            if (rowsSplit[currentTableStartIndex - 2] && (tables.length === 0 || !tables[tables.length - 1].includes(rowsSplit[currentTableStartIndex - 2])) && isCompat(currentTableCompat, rowsSplit[currentTableStartIndex - 2])) {
              headerRows.push(rowsSplit[currentTableStartIndex - 2]);
            }
          }
          tables.push([...headerRows, ...currentTable]);
          currentTable = [rowSplit];
          currentTableCompat = [rowSplit];
          currentTableStartIndex = i2;
        } else {
          currentTable = [rowSplit];
          currentTableCompat = [rowSplit];
          currentTableStartIndex = i2;
        }
      } else {
        currentTable.push(rowSplit);
        currentTableCompat.push(rowSplit);
        currentTableStartIndex = i2;
      }
    } else if (currentTable.length > 0) {
      const nextRowSplit = rowsSplit[i2 + 1];
      const nextRowSplit2 = rowsSplit[i2 + 2];
      if (nextRowSplit && nextRowSplit2 && containsNumbers(nextRowSplit) && containsNumbers(nextRowSplit2) && isCompat(currentTableCompat, nextRowSplit) && isCompat(currentTableCompat, nextRowSplit2)) {
        currentTable.push(rowSplit);
        continue;
      }
      if (currentTable.length >= minRows) {
        const headerRows = [];
        if (rowsSplit[currentTableStartIndex - 1] && (tables.length === 0 || !tables[tables.length - 1].includes(rowsSplit[currentTableStartIndex - 1])) && isCompat(currentTableCompat, rowsSplit[currentTableStartIndex - 1])) {
          headerRows.push(rowsSplit[currentTableStartIndex - 1]);
          if (rowsSplit[currentTableStartIndex - 2] && (tables.length === 0 || !tables[tables.length - 1].includes(rowsSplit[currentTableStartIndex - 2])) && isCompat(currentTableCompat, rowsSplit[currentTableStartIndex - 2])) {
            headerRows.push(rowsSplit[currentTableStartIndex - 2]);
          }
        }
        tables.push([...headerRows, ...currentTable]);
      }
      currentTable = [];
      currentTableCompat = [];
    }
  }
  if (currentTable.length >= minRows) {
    tables.push(currentTable);
  }
  const tableLineBboxes = tables.map((table3) => calcBboxUnion(table3.map((row) => calcBboxUnion(row.items.map((item) => item.bbox)))));
  return tableLineBboxes;
}
var makeTableFromBbox = (page, bbox) => {
  const lines = page.lines.filter((line) => calcBoxOverlap(line.bbox, bbox) > 0.5);
  let columnBboxArr;
  if (lines.length > 0) {
    const lineBoxes = lines.map((line) => line.bbox);
    const columnBoundArr = calcColumnBounds(lineBoxes);
    columnBboxArr = columnBoundArr.map((column) => ({
      left: column.left,
      top: bbox.top,
      right: column.right,
      bottom: bbox.bottom
    }));
    columnBboxArr[0].left = bbox.left;
    columnBboxArr[columnBboxArr.length - 1].right = bbox.right;
    for (let i2 = 0; i2 < columnBboxArr.length - 1; i2++) {
      const boundRight = (columnBboxArr[i2].right + columnBboxArr[i2 + 1].left) / 2;
      columnBboxArr[i2].right = boundRight;
      columnBboxArr[i2 + 1].left = boundRight;
    }
  } else {
    columnBboxArr = [{ ...bbox }];
  }
  const dataTable = new LayoutDataTable();
  columnBboxArr.forEach((columnBbox) => {
    const layoutBox = new LayoutDataColumn(columnBbox, dataTable);
    dataTable.boxes.push(layoutBox);
  });
  return dataTable;
};

// node_modules/scribe.js-ocr/scribe.js
var init = async (params) => {
  const initPdf = params && params.pdf ? params.pdf : false;
  const initOcr = params && params.ocr ? params.ocr : false;
  const initFont = params && params.font ? params.font : false;
  const promiseArr = [];
  promiseArr.push(initPdf ? ImageCache.getMuPDFScheduler() : Promise.resolve());
  promiseArr.push(gs.getGeneralScheduler());
  if (initOcr) {
    const ocrParams = params && params.ocrParams ? params.ocrParams : {};
    promiseArr.push(gs.initTesseract(ocrParams));
  }
  if (initFont) {
    promiseArr.push(loadBuiltInFontsRaw());
  }
  await Promise.all(promiseArr);
};
var extractText = async (files, langs = ["eng"], outputFormat = "txt", options = {}) => {
  const skipRecPDFTextNative = options?.skipRecPDFTextNative ?? true;
  const skipRecPDFTextOCR = options?.skipRecPDFTextOCR ?? false;
  init({ ocr: true, font: true });
  await importFiles(files);
  if (!inputData.xmlMode[0] && !inputData.imageMode && !inputData.pdfMode) throw new Error("No relevant files to process.");
  const skipRecPDF = inputData.pdfMode && (inputData.pdfType === "text" && skipRecPDFTextNative || inputData.pdfType === "ocr" && skipRecPDFTextOCR);
  const skipRecOCR = inputData.xmlMode[0] && !inputData.imageMode && !inputData.pdfMode;
  if (!skipRecPDF && !skipRecOCR) await recognize({ langs });
  return exportData(outputFormat);
};
async function writeDebugImages(canvas, compDebugArrArr, filePath) {
  if (typeof process === "undefined") {
    throw new Error("This function is only available in Node.js.");
  } else {
    const canvas2 = await drawDebugImages({ compDebugArrArr, context: "node" });
    const imgURL = canvas2.toDataURL();
    const imgData = new Uint8Array(atob(imgURL.split(",")[1]).split("").map((c2) => c2.charCodeAt(0)));
    const fs3 = await import("node:fs");
    fs3.writeFileSync(filePath, imgData);
  }
}
async function dumpDebugImages(dir) {
  if (typeof process === "undefined") {
    throw new Error("This function is only available in Node.js.");
  } else {
    if (!DebugData.debugImg.Combined || DebugData.debugImg.Combined.length === 0) {
      console.log("No debug images to dump.");
      return;
    }
    const canvasAlt = await ca.createCanvas(200, 200);
    const ctxDebug = canvasAlt.getContext("2d");
    for (const [name, imgArr] of Object.entries(DebugData.debugImg)) {
      if (!imgArr || imgArr.length === 0) continue;
      for (let i2 = 0; i2 < imgArr.length; i2++) {
        const filePath = `${dir}/${name}_${i2}.png`;
        await writeDebugImages(canvasAlt, [imgArr[i2]], filePath);
      }
    }
  }
}
async function dumpHOCR(dir) {
  if (typeof process === "undefined") {
    throw new Error("This function is only available in Node.js.");
  } else {
    const activeCurrent = ocrAll.active;
    const fs3 = await import("node:fs");
    for (const [name, pages] of Object.entries(ocrAll)) {
      ocrAll.active = pages;
      const hocrStr = await exportData("hocr");
      fs3.writeFileSync(`${dir}/${name}.hocr`, hocrStr);
    }
    ocrAll.active = activeCurrent;
  }
}
var data = class {
  // TODO: Modify such that debugging data is not calculated by default.
  static debug = DebugData;
  static font = FontCont;
  static image = ImageCache;
  static layoutRegions = layoutRegions;
  static layoutDataTables = layoutDataTables;
  static ocr = ocrAll;
  static pageMetrics = pageMetricsAll;
  static vis = visInstructions;
};
var utils = class {
  // OCR utils
  static assignParagraphs = assignParagraphs;
  static calcConf = calcConf;
  static calcEvalStatsDoc = calcEvalStatsDoc;
  static mergeOcrWords = mergeOcrWords;
  static checkOcrWordsAdjacent = checkOcrWordsAdjacent;
  static splitOcrWord = splitOcrWord;
  static ocr = ocrObjects_default;
  // Layout utils
  static calcColumnBounds = calcColumnBounds;
  static calcTableBbox = calcTableBbox;
  static extractSingleTableContent = extractSingleTableContent;
  static detectTablesInPage = detectTablesInPage;
  static makeTableFromBbox = makeTableFromBbox;
  // Font utils
  static calcWordMetrics = calcWordMetrics;
  // Export functions
  static writePdf = writePdf;
  static writeHocr = writeHocr;
  static writeText = writeText;
  static writeXlsx = writeXlsx;
  // Misc utils
  static calcBoxOverlap = calcBoxOverlap;
  static convertToCSV = convertToCsv;
  static replaceSmartQuotes = replaceSmartQuotes;
  static getRandomAlphanum = getRandomAlphanum;
  static countSubstringOccurrences = countSubstringOccurrences;
  static coords = coordinates_default;
  static imageStrToBlob = imageStrToBlob;
  static writeDebugCsv = writeDebugCsv;
  static drawDebugImages = drawDebugImages;
  static dumpDebugImages = dumpDebugImages;
  static dumpHOCR = dumpHOCR;
  static renderPageStatic = renderPageStatic;
  static saveAs = saveAs;
};
var clear = async () => {
  clearData();
};
var terminate = async () => {
  clearData();
  await Promise.allSettled([gs.terminate(), ImageCache.terminate(), FontCont.terminate()]);
};
var scribe_default = {
  clear,
  combineOCRPage,
  compareOCR,
  convertOCRPage,
  data,
  enableFontOpt,
  evalOCRPage,
  exportData,
  download,
  importFiles,
  importFilesSupp,
  inputData,
  init,
  layout: layoutObjects_default,
  opt,
  recognize,
  recognizePageImp,
  extractText,
  extractInternalPDFText,
  terminate,
  utils
};
export {
  scribe_default as default
};
/*! Bundled license information:

scribe.js-ocr/lib/pako.esm.min.js:
scribe.js-ocr/lib/pako.esm.mjs:
  (*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) *)

scribe.js-ocr/tess/tesseract.esm.min.js:
  (*! For license information please see tesseract.min.js.LICENSE.txt *)

scribe.js-ocr/lib/opentype.module.js:
  (*! https://mths.be/codepointat v0.2.0 by @mathias *)
*/
